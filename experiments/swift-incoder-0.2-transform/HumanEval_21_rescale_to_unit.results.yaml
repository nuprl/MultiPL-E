language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfyelce19.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpfyelce19.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpfyelce19.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppw9iocf5.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppw9iocf5.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmppw9iocf5.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / largest\n        rescaled.append(rescaled)\n\
    \        largest = max(largest, number)\n        smallest = min(smallest, number)\n\
    \    }\n    for number in numbers {\n        let rescaled = number - smallest\
    \ / largest\n        rescaled.append(rescaled)\n    }\n    return rescaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpki5p5qyk.swift:9:34: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n                    \
    \      ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpki5p5qyk.swift:12:18: error: value\
    \ of type 'Double' has no member 'append'\n        rescaled.append(rescaled)\n\
    \        ~~~~~~~~ ^~~~~~\n/tmp/tmpki5p5qyk.swift:18:18: error: value of type 'Double'\
    \ has no member 'append'\n        rescaled.append(rescaled)\n        ~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = number\
    \ / max(max - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmptk3tmxm2.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmptk3tmxm2.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmptk3tmxm2.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmptk3tmxm2.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmptk3tmxm2.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmptk3tmxm2.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        largest = number\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / smallest)\n\
    \        smallest = number\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnx0e638r.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf_5zi_f_.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpf_5zi_f_.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(min + ((max\
    \ - min) * (number - min) / (max - min)))\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5rrhiool.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5rrhiool.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp5rrhiool.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_c81a7vg.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_c81a7vg.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp_c81a7vg.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfyelce19.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpfyelce19.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpfyelce19.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = (number - min) / (max - min)\n        scaledNumbers.append(scaledNumber)\n\
    \        min = min(number, min)\n        max = max(number, max)\n    }\n    return\
    \ scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6k51kux8.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6k51kux8.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(number, min)\n            \
    \  ^\n/tmp/tmp6k51kux8.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(number, max)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphh82bcf7/tmphh82bcf7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1f3543c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1f323ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1f323a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1f32397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphh82bcf7                        0x0000560737e07703 <unavailable> + 5891

    5    libc.so.6                          0x00002ab1f372f460 __libc_start_main +
    245

    6    tmphh82bcf7                        0x0000560737e07309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_t0go6n.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6_t0go6n.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6_t0go6n.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmptje0vl9m/tmptje0vl9m.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3aa3669c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3aa3360b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3aa3360988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3aa335f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptje0vl9m                        0x000055bce9ce4603 <unavailable> + 5635

    5    libc.so.6                          0x00002b3aa3855460 __libc_start_main +
    245

    6    tmptje0vl9m                        0x000055bce9ce4209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpik8s5tnm.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpik8s5tnm.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpik8s5tnm.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmptucxx7gl.swift:12:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmptucxx7gl.swift:13:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append((number - min) / (max - min))\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbmx3zt83.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbmx3zt83.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \     scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp22bmxhip.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / largest\n        rescaled.append(rescaled)\n\
    \        largest = number\n        if smallest > number {\n            smallest\
    \ = number\n        }\n    }\n    for number in rescaled {\n        if number\
    \ < smallest {\n            number = smallest\n        }\n        if number >\
    \ largest {\n            number = largest\n        }\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6vdul95u.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6vdul95u.swift:12:18: error: value\
    \ of type 'Double' has no member 'append'\n        rescaled.append(rescaled)\n\
    \        ~~~~~~~~ ^~~~~~\n/tmp/tmp6vdul95u.swift:20:13: error: cannot assign to\
    \ value: 'number' is a 'let' constant\n            number = smallest\n       \
    \     ^~~~~~\n/tmp/tmp6vdul95u.swift:23:13: error: cannot assign to value: 'number'\
    \ is a 'let' constant\n            number = largest\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmptje0vl9m/tmptje0vl9m.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3aa3669c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3aa3360b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3aa3360988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3aa335f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptje0vl9m                        0x000055bce9ce4603 <unavailable> + 5635

    5    libc.so.6                          0x00002b3aa3855460 __libc_start_main +
    245

    6    tmptje0vl9m                        0x000055bce9ce4209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number / max(min, 1.0))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplkjfpwp_.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplkjfpwp_.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmplkjfpwp_.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmplkjfpwp_.swift:15:34:\
    \ error: cannot call value of non-function type 'Double'\n        rescaled.append(number\
    \ / max(min, 1.0))\n                                 ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfyelce19.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpfyelce19.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpfyelce19.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        scaled.append(number / max - min)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi_mvaswy.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpi_mvaswy.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccq3dzv7.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccq3dzv7.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpllksdjww.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpllksdjww.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpllksdjww.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgxwg1a88.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgxwg1a88.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpgxwg1a88.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphh82bcf7/tmphh82bcf7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1f3543c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1f323ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1f323a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1f32397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphh82bcf7                        0x0000560737e07703 <unavailable> + 5891

    5    libc.so.6                          0x00002ab1f372f460 __libc_start_main +
    245

    6    tmphh82bcf7                        0x0000560737e07309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4ivl9fgm.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps6gl91rh.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmps6gl91rh.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    scaled.append(1.0)\n    scaled.append(max\
    \ - min)\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_58ffjhk.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_58ffjhk.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in numbers {\n        scaled.append(number / max - min)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxu83pu7k.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxu83pu7k.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpxu83pu7k.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number - min\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwdfn4b1f.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = number - min\n    \
    \                   ^\n/tmp/tmpwdfn4b1f.swift:19:24: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                 ?? <#default value#>\n/tmp/tmpwdfn4b1f.swift:19:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                !\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        let\
    \ scaledNumber = number / max\n        scaled.append(scaledNumber)\n        if\
    \ scaledNumber < min {\n            min = scaledNumber\n        }\n        if\
    \ scaledNumber > max {\n            max = scaledNumber\n        }\n    }\n   \
    \ return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpzrrfjih1/tmpzrrfjih1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3d6660c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3d6357b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3d6357988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3d63567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzrrfjih1                        0x00005637a64c7603 <unavailable> + 5635

    5    libc.so.6                          0x00002ab3d684c460 __libc_start_main +
    245

    6    tmpzrrfjih1                        0x00005637a64c7209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0x5gph_m.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number))\n    }\n    return rescaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbsv2wpl0.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_c81a7vg.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_c81a7vg.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp_c81a7vg.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf70s3shq.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpf70s3shq.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = (number - min) / (max - min)\n        scaled.append(scaledNumber)\n\
    \        min = min(number, min)\n        max = max(number, max)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp85hmcfdi.swift:10:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp85hmcfdi.swift:14:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(number, min)\n            \
    \  ^\n/tmp/tmp85hmcfdi.swift:15:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(number, max)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpxa_4te_m/tmpxa_4te_m.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b7012bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b6fe22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b6fe22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b6fe217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxa_4te_m                        0x000055ab31bea6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b0b70317460 __libc_start_main +
    245

    6    tmpxa_4te_m                        0x000055ab31bea2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number /= max - min\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_krqwmpj.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_krqwmpj.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp_krqwmpj.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number / max - min)\n   \
    \ }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb08zjwkk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb08zjwkk.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpb08zjwkk.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var scaled: [Double] = []\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in scaled\
    \ {\n        number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkpxt00zt.swift:22:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number > max {\n            max = number\n        }\n        if number\
    \ < min {\n            min = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n    var scale: Double = max - min\n    for number in scaled {\n        number\
    \ *= scale\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpt12onlaf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt12onlaf.swift:23:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number *= scale\n\
    \        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_t0go6n.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6_t0go6n.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6_t0go6n.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        smallest = min(smallest, number)\n        largest = max(largest,\
    \ number)\n    }\n    for number in numbers {\n        rescaled.append(number\
    \ / largest - number / smallest + 1.0)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcmd41w2n.swift:9:34: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n                    \
    \      ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7sesu4nr.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013897
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n    var range\
    \ = max - min\n    var scale = 1.0 / range\n    return numbers.map { $0 * scale\
    \ + min }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp8_y0aoyk/tmp8_y0aoyk.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7106ff0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7106ce7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7106ce7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7106ce67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_y0aoyk                        0x000055ad9c23f723 <unavailable> + 5923

    5    libc.so.6                          0x00002b71071dc460 __libc_start_main +
    245

    6    tmp8_y0aoyk                        0x000055ad9c23f329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / (Double(Int.max) - Double(Int.min))\n\
    \    var scaledNumbers = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        scaledNumbers[numbers.index(min)] = number * scale\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpco0tcld6.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpco0tcld6.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpco0tcld6.swift:16:31: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        scaledNumbers[numbers.index(min)]\
    \ = number * scale\n                              ^\n/tmp/tmpco0tcld6.swift:16:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        scaledNumbers[numbers.index(min)] = number * scale\n        \
    \                      ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpco0tcld6.swift:16:31: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        scaledNumbers[numbers.index(min)]\
    \ = number * scale\n                              ^\n                        \
    \                !\n/tmp/tmpco0tcld6.swift:16:37: error: missing argument label\
    \ 'of:' in call\n        scaledNumbers[numbers.index(min)] = number * scale\n\
    \                                    ^\n                                    of:\
    \ \n/tmp/tmpco0tcld6.swift:17:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpco0tcld6.swift:18:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp1ikvuhyc/tmp1ikvuhyc.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b054e33bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b054e032b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b054e032988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b054e0317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ikvuhyc                        0x000055cdf9cda693 <unavailable> + 5779

    5    libc.so.6                          0x00002b054e527460 __libc_start_main +
    245

    6    tmp1ikvuhyc                        0x000055cdf9cda299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0x5gph_m.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        if number < min {\n  \
    \          min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmptje0vl9m/tmptje0vl9m.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3aa3669c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3aa3360b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3aa3360988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3aa335f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptje0vl9m                        0x000055bce9ce4603 <unavailable> + 5635

    5    libc.so.6                          0x00002b3aa3855460 __libc_start_main +
    245

    6    tmptje0vl9m                        0x000055bce9ce4209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n    var scale:\
    \ Double = 1.0\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n        scale /= max(abs(min), abs(max))\n  \
    \  }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ * scale)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdi83xn8y.swift:12:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpdi83xn8y.swift:13:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpdi83xn8y.swift:14:18: error: cannot call value\
    \ of non-function type 'Double'\n        scale /= max(abs(min), abs(max))\n  \
    \               ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7sesu4nr.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013897
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpllksdjww.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpllksdjww.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpllksdjww.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkik6fcii.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkik6fcii.swift:12:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpkik6fcii.swift:13:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    var min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgbj_6yl6.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpgbj_6yl6.swift:14:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpgbj_6yl6.swift:21:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_t0go6n.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6_t0go6n.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6_t0go6n.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_c81a7vg.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_c81a7vg.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp_c81a7vg.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpykw_xsqi.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf70s3shq.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpf70s3shq.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpgah1agm2/tmpgah1agm2.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86fb052c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86fad49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86fad49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86fad487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgah1agm2                        0x00005565ec4f7703 <unavailable> + 5891

    5    libc.so.6                          0x00002b86fb23e460 __libc_start_main +
    245

    6    tmpgah1agm2                        0x00005565ec4f7309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append(number - min)\n    }\n    for number\
    \ in scaled {\n        number /= max - min\n    }\n    return scaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_krqwmpj.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_krqwmpj.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp_krqwmpj.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    var range = max - min\n    var newMin = min / range\n    var newMax = max\
    \ / range\n    var newRange = newMax - newMin\n    var newNumbers = [Double]()\n\
    \    for number in numbers {\n        newNumbers.append(Double(number) * newRange\
    \ + newMin)\n    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_jqjuuo9/tmp_jqjuuo9.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fb685bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3fb6552b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3fb6552988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3fb65517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_jqjuuo9                        0x00005557b606a833 <unavailable> + 6195

    5    libc.so.6                          0x00002b3fb6a47460 __libc_start_main +
    245

    6    tmp_jqjuuo9                        0x00005557b606a439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpapag_q6v.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpapag_q6v.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpapag_q6v.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        scaled.append(numbers[i] - min)\n \
    \   }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i] / max -\
    \ min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvatqktuq.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpvatqktuq.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpguyki1q1.swift:9:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpguyki1q1.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpguyki1q1.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpgah1agm2/tmpgah1agm2.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86fb052c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86fad49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86fad49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86fad487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgah1agm2                        0x00005565ec4f7703 <unavailable> + 5891

    5    libc.so.6                          0x00002b86fb23e460 __libc_start_main +
    245

    6    tmpgah1agm2                        0x00005565ec4f7309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / min(number, 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp1ikvuhyc/tmp1ikvuhyc.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b054e33bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b054e032b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b054e032988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b054e0317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ikvuhyc                        0x000055cdf9cda693 <unavailable> + 5779

    5    libc.so.6                          0x00002b054e527460 __libc_start_main +
    245

    6    tmp1ikvuhyc                        0x000055cdf9cda299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    let range = max - min\n\
    \    let scaled: [Double] = numbers.map { $0 - min / range }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpiv05fsth.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpiv05fsth.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpiv05fsth.swift:11:51: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n    let scaled: [Double]\
    \ = numbers.map { $0 - min / range }\n                                       \
    \           ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplh0xf8mj.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplh0xf8mj.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmplh0xf8mj.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnoarxxb_.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpnoarxxb_.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        scaled.append(number / max - min)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi_mvaswy.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpi_mvaswy.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0x5gph_m.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / 2.0\n    var scaledNumbers = [Double]()\n\
    \    for number in numbers {\n        scaledNumbers.append(number * scale)\n \
    \   }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6dkph631.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6dkph631.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphel3c140.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmphel3c140.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmphel3c140.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number / max - min)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpistmi067.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / 2.0\n    var scaledNumbers = [Double]()\n\
    \    for number in numbers {\n        scaledNumbers.append(number * scale)\n \
    \   }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6dkph631.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6dkph631.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpr7trc5b6.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    var minValue = Double(numbers.first!)\n\
    \    var maxValue = Double(numbers.last!)\n    for number in numbers {\n     \
    \   let scaledNumber = (number - minValue) / (maxValue - minValue)\n        scaledNumbers.append(scaledNumber)\n\
    \        minValue = min(minValue, number)\n        maxValue = max(maxValue, number)\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmprkq_vz9c/tmprkq_vz9c.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab18c18ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab18be81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab18be81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab18be807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprkq_vz9c                        0x0000557236ca3a39 <unavailable> + 6713

    5    libc.so.6                          0x00002ab18c376460 __libc_start_main +
    245

    6    tmprkq_vz9c                        0x0000557236ca3519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var result: [Double]\
    \ = []\n    for number in numbers {\n        result.append(number - min)\n   \
    \     result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpr7trc5b6.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number / max - min)\n   \
    \ }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb08zjwkk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb08zjwkk.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpb08zjwkk.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var scaled: [Double] = []\n    for\
    \ number in numbers {\n        scaled.append((number - min) / (max - min))\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbmx3zt83.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbmx3zt83.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7sesu4nr.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013897
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number - max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_c81a7vg.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_c81a7vg.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp_c81a7vg.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double]()\n    for number in numbers {\n \
    \       result.append(number - min)\n        result.append(number - max)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0s22c_go.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0s22c_go.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number - min)\n        rescaled.append(number - max)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpug8qoz7a.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpug8qoz7a.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpug8qoz7a.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / (Double(Int.max) - Double(Int.min))\n\
    \    var scaledNumbers = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        scaledNumbers[numbers.index(of: number)] = number\
    \ * scale\n    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoiwzihmw.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpoiwzihmw.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpoiwzihmw.swift:16:31: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        scaledNumbers[numbers.index(of:\
    \ number)] = number * scale\n                              ^\n/tmp/tmpoiwzihmw.swift:16:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        scaledNumbers[numbers.index(of: number)] = number * scale\n \
    \                             ^\n                                            \
    \    ?? <#default value#>\n/tmp/tmpoiwzihmw.swift:16:31: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        scaledNumbers[numbers.index(of:\
    \ number)] = number * scale\n                              ^\n               \
    \                                !\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / max - min\n        min = min(min, rescaled)\n\
    \        max = max(max, rescaled)\n        rescaled.append(rescaled)\n    }\n\
    \    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpykagzy93.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpykagzy93.swift:12:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, rescaled)\n          \
    \    ^\n/tmp/tmpykagzy93.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, rescaled)\n              ^\n/tmp/tmpykagzy93.swift:14:18:\
    \ error: value of type 'Double' has no member 'append'\n        rescaled.append(rescaled)\n\
    \        ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for number in\
    \ numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    var min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        let scaled = (number - min) / (max - min)\n        result.append(scaled)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpha_krw1c.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpha_krw1c.swift:14:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1e6s0ydf.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp1e6s0ydf.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / 2.0\n    var scaledNumbers = [Double]()\n\
    \    for number in numbers {\n        scaledNumbers.append(number * scale)\n \
    \   }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6dkph631.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp6dkph631.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplh0xf8mj.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplh0xf8mj.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmplh0xf8mj.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccq3dzv7.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccq3dzv7.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for number in numbers {\n  \
    \      min = min(min, number)\n        max = max(max, number)\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpapag_q6v.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpapag_q6v.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpapag_q6v.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number / max - min)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwfusn4yz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwfusn4yz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdh03pio6.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdh03pio6.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpdh03pio6.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_t0go6n.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6_t0go6n.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6_t0go6n.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbrygsfhb.swift:9:34: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n                    \
    \      ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number - min)\n\
    \        result.append(number / max - min)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6_t0go6n.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6_t0go6n.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6_t0go6n.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / max\n        rescaled.append(rescaled)\n\
    \        if rescaled < min {\n            min = rescaled\n        }\n        if\
    \ rescaled > max {\n            max = rescaled\n        }\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbiw9umd6.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbiw9umd6.swift:12:18: error: value of type 'Double'\
    \ has no member 'append'\n        rescaled.append(rescaled)\n        ~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double]()\n    for number in numbers {\n \
    \       result.append(number - min)\n        result.append(number - max)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0s22c_go.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0s22c_go.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpllksdjww.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpllksdjww.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpllksdjww.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = ((number\
    \ - min) / (max - min)) * 1.0\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpcx7qfi4i.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpcx7qfi4i.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpcx7qfi4i.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    /tmp/tmpcx7qfi4i.swift:15:24: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        result[numbers.index(of: number)]\
    \ = ((number - min) / (max - min)) * 1.0\n                       ^\n         \
    \                                ?? <#default value#>\n/tmp/tmpcx7qfi4i.swift:15:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = ((number - min) / (max -\
    \ min)) * 1.0\n                       ^\n                                    \
    \    !\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for n in numbers {\n        scaled.append((n - min)\
    \ / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplbidgz37.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmplbidgz37.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl8v_r7vm.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpl8v_r7vm.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpl8v_r7vm.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var scaled:\
    \ [Double] = []\n    for number in numbers {\n        scaled.append(number - min)\n\
    \        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpllksdjww.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpllksdjww.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpllksdjww.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        largest = Double(max(largest,\
    \ number))\n        smallest = Double(min(smallest, number))\n    }\n    for number\
    \ in numbers {\n        rescaled.append(number / smallest)\n    }\n    return\
    \ rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2559s_ww.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps6gl91rh.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmps6gl91rh.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphh82bcf7/tmphh82bcf7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1f3543c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1f323ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1f323a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1f32397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphh82bcf7                        0x0000560737e07703 <unavailable> + 5891

    5    libc.so.6                          0x00002ab1f372f460 __libc_start_main +
    245

    6    tmphh82bcf7                        0x0000560737e07309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.min())\n    var max = Double(numbers.max())\n\
    \    var range = max - min\n    var newMin = min / range\n    var newMax = max\
    \ / range\n    var newRange = newMax - newMin\n    var newNumbers = [Double]()\n\
    \    for number in numbers {\n        newNumbers.append(number * newRange + newMin)\n\
    \    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpeppuue1w.swift:7:30: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    var min = Double(numbers.min())\n\
    \                             ^\n/tmp/tmpeppuue1w.swift:7:30: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    var min\
    \ = Double(numbers.min())\n                             ^\n                  \
    \                 ?? <#default value#>\n/tmp/tmpeppuue1w.swift:7:30: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    var min\
    \ = Double(numbers.min())\n                             ^\n                  \
    \                !\n/tmp/tmpeppuue1w.swift:8:30: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n    var max = Double(numbers.max())\n\
    \                             ^\n/tmp/tmpeppuue1w.swift:8:30: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    var max\
    \ = Double(numbers.max())\n                             ^\n                  \
    \                 ?? <#default value#>\n/tmp/tmpeppuue1w.swift:8:30: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    var max\
    \ = Double(numbers.max())\n                             ^\n                  \
    \                !\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in numbers {\n        scaled.append(number / max - min)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxu83pu7k.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxu83pu7k.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpxu83pu7k.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        guard number >= smallest && number <= largest else { continue }\n\
    \        scaled.append(number - smallest)\n        smallest = Double.greatestFiniteMagnitude\n\
    \        largest = Double.leastFiniteMagnitude\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnfyrjbmj.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnfyrjbmj.swift:14:26: error: type 'Double'\
    \ has no member 'leastFiniteMagnitude'\n        largest = Double.leastFiniteMagnitude\n\
    \                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw8iwz9qs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw8iwz9qs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpw8iwz9qs.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number /= max - min\n   \
    \ }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnpxl9d79.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpnpxl9d79.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpnpxl9d79.swift:14:23: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n        number /= max\
    \ - min\n                      ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0x5gph_m.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpfyelce19.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpfyelce19.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpfyelce19.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccq3dzv7.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccq3dzv7.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    var smallestNumber =\
    \ Double(Int.max)\n    var largestNumber = Double(Int.min)\n    for number in\
    \ numbers {\n        scaledNumbers.append(number / largestNumber)\n        largestNumber\
    \ = max(largestNumber, number)\n        smallestNumber = min(smallestNumber, number)\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp3tvo7rkc/tmp3tvo7rkc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01a8e9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01a8b95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01a8b95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01a8b947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3tvo7rkc                        0x000055a871499743 <unavailable> + 5955

    5    libc.so.6                          0x00002b01a908a460 __libc_start_main +
    245

    6    tmp3tvo7rkc                        0x000055a871499349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n    for number in scaled {\n        if number > 1.0 {\n            number\
    \ /= max\n        } else {\n            number *= max\n        }\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprswo9mt5.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmprswo9mt5.swift:23:20: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n            number /=\
    \ max\n            ~~~~~~ ^\n/tmp/tmprswo9mt5.swift:25:20: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n            number\
    \ *= max\n            ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7jcw0sb5.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp7jcw0sb5.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min(numbers)) / (max(numbers) - min(numbers)))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7sesu4nr.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013897
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx6xj7qqh.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx6xj7qqh.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    var scale: Double = 1.0\n    for number in numbers {\n        let delta =\
    \ number - min\n        min = min + delta\n        max = max + delta\n       \
    \ scale *= delta\n    }\n    return [min/scale, max/scale]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_6mfy7hy/tmp_6mfy7hy.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7794cbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77949b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77949b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77949b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_6mfy7hy                        0x000055d50d4ae7d3 <unavailable> + 6099

    5    libc.so.6                          0x00002b7794ea6460 __libc_start_main +
    245

    6    tmp_6mfy7hy                        0x000055d50d4ae3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scale = (max - min) / 2.0\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append((number - min) / scale)\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkkcf7oi2.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkkcf7oi2.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(numbers.first!)\n    var max: Double\
    \ = Double(numbers.last!)\n    var scale: Double = 1.0 / (max - min)\n    for\
    \ number in numbers {\n        number -= min\n        number *= scale\n    }\n\
    \    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbbdcd6cf.swift:11:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number -= min\n        ~~~~~~\
    \ ^\n/tmp/tmpbbdcd6cf.swift:12:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number *= scale\n        ~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(min(max(0.0, number), 1.0))\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpetcq0a8t/tmpetcq0a8t.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0da3e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0da0dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0da0db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0da0da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpetcq0a8t                        0x000055a1d617e6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002ac0da5d0460 __libc_start_main +
    245

    6    tmpetcq0a8t                        0x000055a1d617e2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnt1jcb3k.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnt1jcb3k.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8y2athfq.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp8y2athfq.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpgah1agm2/tmpgah1agm2.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86fb052c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86fad49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86fad49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86fad487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgah1agm2                        0x00005565ec4f7703 <unavailable> + 5891

    5    libc.so.6                          0x00002b86fb23e460 __libc_start_main +
    245

    6    tmpgah1agm2                        0x00005565ec4f7309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = numbers.min()\n    let max = numbers.max()\n    var scaled: [Double] =\
    \ []\n    for i in 0..<numbers.count {\n        scaled.append(numbers[i] / max\
    \ - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpza48vgq3.swift:12:42: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        scaled.append(numbers[i] /\
    \ max - min)\n                                         ^\n/tmp/tmpza48vgq3.swift:8:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let min = numbers.min()\n        ^\n    guard    \
    \               else { return <#default value#> }\n/tmp/tmpza48vgq3.swift:8:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let min = numbers.min()\n                      ^\n              \
    \              ?? <#default value#>\n/tmp/tmpza48vgq3.swift:8:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let min\
    \ = numbers.min()\n                      ^\n                           !\n/tmp/tmpza48vgq3.swift:12:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        scaled.append(numbers[i] / max - min)\n                     \
    \                    ^\n                                         (   ?? <#default\
    \ value#>)\n/tmp/tmpza48vgq3.swift:12:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        scaled.append(numbers[i]\
    \ / max - min)\n                                         ^\n                 \
    \                           !\n/tmp/tmpza48vgq3.swift:12:36: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        scaled.append(numbers[i]\
    \ / max - min)\n                                   ^\n/tmp/tmpza48vgq3.swift:9:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let max = numbers.max()\n        ^\n    guard    \
    \               else { return <#default value#> }\n/tmp/tmpza48vgq3.swift:9:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max = numbers.max()\n                      ^\n              \
    \              ?? <#default value#>\n/tmp/tmpza48vgq3.swift:9:23: note: force-"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \     scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd0mp0j5k.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(min + ((max - min) * (number - min) / (max - min)))\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9ku3k_y3.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9ku3k_y3.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for number in numbers {\n        result.append(number / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphel3c140.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmphel3c140.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmphel3c140.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        scaled.append(numbers[i] - min)\n \
    \   }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i] / max -\
    \ min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvatqktuq.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpvatqktuq.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(Int.max)\n    var max: Double =\
    \ Double(Int.min)\n    for number in numbers {\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    var result: [Double] = []\n    for\
    \ number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpccv4eqnr.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpccv4eqnr.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013861
