language: swift
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if prefix != \"\" {\n \
    \           prefixes.append(prefix)\n            prefix = \"\"\n        }\n  \
    \      prefix += c\n    }\n    prefixes.append(prefix)\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3mas2m9t.swift:13:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpce7srfcf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current += String(c)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        for p in prefixes {\n            if c == p {\n\
    \                break\n            }\n        }\n        if p != nil {\n    \
    \        prefixes.append(p)\n        }\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjxpbxa43.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmpjxpbxa43.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmpjxpbxa43.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmpjxpbxa43.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        }\n        currentPrefix = String(character) + currentPrefix\n    }\n\
    \    prefixes.append(currentPrefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp7tq2e0_u/tmp7tq2e0_u.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6923a0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6923705b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6923705988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69237047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7tq2e0_u                        0x0000564c689a778e <unavailable> + 6030

    5    libc.so.6                          0x00002b6923bfa460 __libc_start_main +
    245

    6    tmp7tq2e0_u                        0x0000564c689a73d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw8uexarj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpw8uexarj.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for character in string {\n        prefixes.append(String(character))\n \
    \   }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpqkpnlmrc/tmpqkpnlmrc.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab84b388c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab84b07fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab84b07f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab84b07e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkpnlmrc                        0x0000561ab53e9828 <unavailable> + 6184

    5    libc.so.6                          0x00002ab84b574460 __libc_start_main +
    245

    6    tmpqkpnlmrc                        0x0000561ab53e9289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8b2pqbxt.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.characters {\n        prefixes.append(String(s))\n    }\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe748wnk2.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var currentPrefix = \"\"\n    while current !=\
    \ \"\" {\n        currentPrefix = current\n        current = current.prefix(string:\
    \ currentPrefix)\n        prefixes.append(currentPrefix)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5jhg1vrn.swift:11:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        current = current.prefix(string: currentPrefix)\n \
    \                         ^\n/tmp/tmp5jhg1vrn.swift:11:27: note: found candidate\
    \ with type '(Int) -> PrefixSequence<String>'\n        current = current.prefix(string:\
    \ currentPrefix)\n                          ^\n/tmp/tmp5jhg1vrn.swift:11:27: note:\
    \ found candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        current = current.prefix(string: currentPrefix)\n                   \
    \       ^\n/tmp/tmp5jhg1vrn.swift:11:27: error: no 'prefix' candidates produce\
    \ the expected contextual result type 'String'\n        current = current.prefix(string:\
    \ currentPrefix)\n                          ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<String>', not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'String.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014272
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var prefix: String = \"\"\n    while current !=\
    \ \"\" {\n        prefix = current + prefix\n        current = prefixes.last!\n\
    \        prefixes.append(prefix)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpq5f507_0/tmpq5f507_0.swift:11: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b61cfc10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61cf907561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b61cf907286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b61cf90713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b61cf906bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpq5f507_0                        0x000055c60427fdcf <unavailable> + 7631

    6    tmpq5f507_0                        0x000055c60427f737 <unavailable> + 5943

    7    libc.so.6                          0x00002b61cfdfc460 __libc_start_main +
    245

    8    tmpq5f507_0                        0x000055c60427f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7t0zvzeg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7t0zvzeg.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n                                         ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    while current != \"\"\
    \ {\n        current = current.prefix(string)\n        if current == \"\" {\n\
    \            break\n        }\n        prefixes.append(current)\n        longest\
    \ = longest.prefix(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp99d2di5u.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmp99d2di5u.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmp99d2di5u.swift:15:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        longest = longest.prefix(current)\n\
    \                                 ^\n/tmp/tmp99d2di5u.swift:15:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        longest\
    \ = longest.prefix(current)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        if\
    \ prefixes.contains(prefix) {\n            prefixes.append(prefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp17x3ix96.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdgpf9xz3.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdgpf9xz3.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpdgpf9xz3.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfdq_v67x.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpfdq_v67x.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpfdq_v67x.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = currentPrefix + character\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl2chpe19.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpl2chpe19.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n/tmp/tmpl2chpe19.swift:12:45: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            currentPrefix\
    \ = currentPrefix + character\n                                            ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current += String(c)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkul7wxtm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpkul7wxtm.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current.characters.count > 0 {\n        prefixes.append(current)\n\
    \        current = current.prefix(by: 1)\n    }\n    return prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp366bckn_.swift:8:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    while current.characters.count > 0 {\n            \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp366bckn_.swift:10:27:\
    \ error: no exact matches in call to instance method 'prefix'\n        current\
    \ = current.prefix(by: 1)\n                          ^\n/tmp/tmp366bckn_.swift:10:27:\
    \ note: found candidate with type '(Int) -> PrefixSequence<String>'\n        current\
    \ = current.prefix(by: 1)\n                          ^\n/tmp/tmp366bckn_.swift:10:27:\
    \ note: found candidate with type '(Int) -> String.SubSequence' (aka '(Int) ->\
    \ Substring')\n        current = current.prefix(by: 1)\n                     \
    \     ^\n/tmp/tmp366bckn_.swift:10:27: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        current = current.prefix(by:\
    \ 1)\n                          ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<String>', not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'String.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8b2pqbxt.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxwgrwlhg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxwgrwlhg.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpxwgrwlhg.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        if currentPrefix.hasPrefix(string) {\n          \
    \  prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprg02rsw7.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014272
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var i = 0\n    while i < current.count {\n    \
    \    prefixes.append(String(current[i...]))\n        current = String(current.suffix(from:\
    \ i))\n        i += 1\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5xqls_jj.swift:10:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(String(current[i...]))\n                            \
    \   ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp5xqls_jj.swift:11:47:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        current = String(current.suffix(from: i))\n                         \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkul7wxtm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpkul7wxtm.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qtszin.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8b2pqbxt.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8b2pqbxt.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current = current + c\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzhsfwg7m.swift:9:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        current = current + c\n        \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string.characters {\n        if let prefix = prefixes.first {\n\
    \            if c == prefix {\n                continue\n            }\n     \
    \       prefixes.append(prefix)\n        } else {\n            prefixes.append(String(c))\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3z226_2g.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3z226_2g.swift:9:18:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            if c == prefix {\n               ~ ^  ~~~~~~\n/tmp/tmp3z226_2g.swift:9:18:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if c == prefix {\n   \
    \              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(startIndex, offsetBy: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuvv7qfhi.swift:10:39: error: cannot find 'startIndex' in scope\n\
    \        current = string[string.index(startIndex, offsetBy: 1)]\n           \
    \                           ^~~~~~~~~~\n/tmp/tmpuvv7qfhi.swift:10:25: error: cannot\
    \ assign value of type 'Character' to type 'String'\n        current = string[string.index(startIndex,\
    \ offsetBy: 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkul7wxtm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpkul7wxtm.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpkul7wxtm.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpkul7wxtm.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014272
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(current, startIndex: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxamropbh.swift:10:33: error: no exact matches in call to instance\
    \ method 'index'\n        current = string[string.index(current, startIndex: 1)]\n\
    \                                ^\n/tmp/tmpxamropbh.swift:10:33: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        current =\
    \ string[string.index(current, startIndex: 1)]\n                             \
    \   ^\n/tmp/tmpxamropbh.swift:10:25: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        current = string[string.index(current, startIndex:\
    \ 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var prefix: String = \"\"\n    while current !=\
    \ \"\" {\n        prefix = current + prefix\n        current = prefixes.last!\n\
    \        prefixes.append(prefix)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpq5f507_0/tmpq5f507_0.swift:11: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b61cfc10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61cf907561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b61cf907286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b61cf90713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b61cf906bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpq5f507_0                        0x000055c60427fdcf <unavailable> + 7631

    6    tmpq5f507_0                        0x000055c60427f737 <unavailable> + 5943

    7    libc.so.6                          0x00002b61cfdfc460 __libc_start_main +
    245

    8    tmpq5f507_0                        0x000055c60427f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp3iovh0w.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpp3iovh0w.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpp3iovh0w.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        if\
    \ prefixes.contains(prefix) {\n            prefixes.append(prefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp17x3ix96.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for character in string {\n        prefixes.append(String(character))\n \
    \   }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpqkpnlmrc/tmpqkpnlmrc.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab84b388c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab84b07fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab84b07f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab84b07e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkpnlmrc                        0x0000561ab53e9828 <unavailable> + 6184

    5    libc.so.6                          0x00002ab84b574460 __libc_start_main +
    245

    6    tmpqkpnlmrc                        0x0000561ab53e9289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = 0\n    while current != \"\" {\n\
    \        current = current.prefix(string: longest)\n        longest = longest.successor()\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkb9avadj.swift:10:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        current = current.prefix(string: longest)\n       \
    \                   ^\n/tmp/tmpkb9avadj.swift:10:27: note: found candidate with\
    \ type '(Int) -> PrefixSequence<String>'\n        current = current.prefix(string:\
    \ longest)\n                          ^\n/tmp/tmpkb9avadj.swift:10:27: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        current = current.prefix(string: longest)\n                         \
    \ ^\n/tmp/tmpkb9avadj.swift:10:27: error: no 'prefix' candidates produce the expected\
    \ contextual result type 'String'\n        current = current.prefix(string: longest)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\n/tmp/tmpkb9avadj.swift:11:27: error: value\
    \ of type 'Int' has no member 'successor'\n        longest = longest.successor()\n\
    \                  ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        prefixes.append(s)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppsmh90m6.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmppsmh90m6.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    var shortest = \"\"\n\
    \    while current != \"\" {\n        shortest = current\n        current = longest\n\
    \        for c in current {\n            if c != longest[0] {\n              \
    \  longest = longest.substringToIndex(longest.startIndex.successor())\n      \
    \      }\n        }\n        prefixes.append(longest)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp20ujv1g8.swift:14:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if c\
    \ != longest[0] {\n                    ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp20ujv1g8.swift:15:35: error: value\
    \ of type 'String' has no member 'substringToIndex'\n                longest =\
    \ longest.substringToIndex(longest.startIndex.successor())\n                 \
    \         ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp20ujv1g8.swift:15:71: error: value\
    \ of type 'String.Index' has no member 'successor'\n                longest =\
    \ longest.substringToIndex(longest.startIndex.successor())\n                 \
    \                                  ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)] + c)\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpykyqigwd.swift:8:62: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefixes.append(string[..<string.index(before:\
    \ c)] + c)\n                                                             ^\n/tmp/tmpykyqigwd.swift:8:56:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)] + c)\n           \
    \                                            ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(longest:\
    \ 1)\n        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmph2qmm9pq.swift:9:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        current = current.prefix(longest: 1)\n            \
    \              ^\n/tmp/tmph2qmm9pq.swift:9:27: note: found candidate with type\
    \ '(Int) -> PrefixSequence<String>'\n        current = current.prefix(longest:\
    \ 1)\n                          ^\n/tmp/tmph2qmm9pq.swift:9:27: note: found candidate\
    \ with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n       \
    \ current = current.prefix(longest: 1)\n                          ^\n/tmp/tmph2qmm9pq.swift:9:27:\
    \ error: no 'prefix' candidates produce the expected contextual result type 'String'\n\
    \        current = current.prefix(longest: 1)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx0iwpyjo.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx0iwpyjo.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        for p in prefixes {\n            if c == p {\n\
    \                break\n            }\n        }\n        if p != nil {\n    \
    \        prefixes.append(p)\n        }\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjxpbxa43.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmpjxpbxa43.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmpjxpbxa43.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmpjxpbxa43.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxwgrwlhg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxwgrwlhg.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpxwgrwlhg.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxwgrwlhg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxwgrwlhg.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpxwgrwlhg.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        prefixes.append(s)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppsmh90m6.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmppsmh90m6.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014272
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        for p in prefixes {\n            if c == p {\n\
    \                break\n            }\n        }\n        if p != nil {\n    \
    \        prefixes.append(p)\n        }\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjxpbxa43.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmpjxpbxa43.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmpjxpbxa43.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmpjxpbxa43.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp69qtszin.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4kp1g9pj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4kp1g9pj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpce7srfcf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        if currentPrefix.hasPrefix(string) {\n          \
    \  prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprg02rsw7.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string.characters {\n        prefixes.append(String(string[c...]))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpij5j348u.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpij5j348u.swift:8:38:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Character'\
    \ be equivalent\n        prefixes.append(String(string[c...]))\n             \
    \                        ^\nSwift.Collection:2:23: note: where 'Self.Index' =\
    \ 'String.Index', 'R.Bound' = 'Character'\n    @inlinable public subscript<R>(r:\
    \ R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get\
    \ }\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    while current != \"\"\
    \ {\n        current = current.prefix(longest)\n        prefixes.append(current)\n\
    \        longest = longest.prefix(longest)\n    }\n    return prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpczh4r74e.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(longest)\n\
    \                                 ^\n/tmp/tmpczh4r74e.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(longest)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmpczh4r74e.swift:12:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        longest = longest.prefix(longest)\n\
    \                                 ^\n/tmp/tmpczh4r74e.swift:12:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        longest\
    \ = longest.prefix(longest)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var index = 0\n    while index < current.count\
    \ {\n        prefixes.append(String(current[index...]))\n        current = String(current[index...]).prefix(current)\n\
    \        index++\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvdnuydlg.swift:10:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(String(current[index...]))\n                        \
    \       ^~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpvdnuydlg.swift:11:45:\
    \ error: cannot assign value of type 'String.SubSequence' (aka 'Substring') to\
    \ type 'String'\n        current = String(current[index...]).prefix(current)\n\
    \                  ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n               \
    \   String(                                  )\n/tmp/tmpvdnuydlg.swift:11:52:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        current = String(current[index...]).prefix(current)\n               \
    \                                    ^\n/tmp/tmpvdnuydlg.swift:12:14: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        index++\n       \
    \      ^~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    while current != \"\"\
    \ {\n        current = current.prefix(string)\n        if current != \"\" {\n\
    \            prefixes.append(current)\n            if current > longest {\n  \
    \              longest = current\n            }\n        }\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqtu3oe55.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpqtu3oe55.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpce7srfcf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current += String(c)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        prefixes.append(s)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppsmh90m6.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmppsmh90m6.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        if\
    \ prefixes.contains(prefix) {\n            prefixes.append(prefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp17x3ix96.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfdq_v67x.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpfdq_v67x.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpfdq_v67x.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7t0zvzeg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7t0zvzeg.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n                                         ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current = current + c\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzhsfwg7m.swift:9:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        current = current + c\n        \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = currentPrefix + character\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl2chpe19.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpl2chpe19.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n/tmp/tmpl2chpe19.swift:12:45: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            currentPrefix\
    \ = currentPrefix + character\n                                            ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        if\
    \ prefixes.contains(prefix) {\n            prefixes.append(prefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp17x3ix96.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8b2pqbxt.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp3iovh0w.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpp3iovh0w.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpp3iovh0w.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current += c\n       \
    \ prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprhaibprm.swift:9:20: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        current += c\n                 \
    \  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt3ommqj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpzt3ommqj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpzt3ommqj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.characters {\n        for p in prefixes {\n            if\
    \ s.hasPrefix(p) {\n                break\n            }\n        }\n        if\
    \ s.hasPrefix(\"\") {\n            prefixes.append(\"\")\n        }\n    }\n \
    \   return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo6w2z4tq.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo6w2z4tq.swift:9:18:\
    \ error: value of type 'Character' has no member 'hasPrefix'\n            if s.hasPrefix(p)\
    \ {\n               ~ ^~~~~~~~~\n/tmp/tmpo6w2z4tq.swift:13:14: error: value of\
    \ type 'Character' has no member 'hasPrefix'\n        if s.hasPrefix(\"\") {\n\
    \           ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(current, offsetBy: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxeogaa7f.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        current = string[string.index(current,\
    \ offsetBy: 1)]\n                                      ^\n/tmp/tmpxeogaa7f.swift:10:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        current\
    \ = string[string.index(current, offsetBy: 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.characters {\n        for prefix in prefixes {\n        \
    \    if prefix == \"\" {\n                prefixes.append(String(s))\n       \
    \     } else {\n                prefixes.append(String(prefix) + String(s))\n\
    \            }\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwcj7nmxd.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpty4048gu.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppew16bx1.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmppew16bx1.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmppew16bx1.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = currentPrefix + character\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl2chpe19.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpl2chpe19.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n/tmp/tmpl2chpe19.swift:12:45: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            currentPrefix\
    \ = currentPrefix + character\n                                            ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx0iwpyjo.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx0iwpyjo.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp3iovh0w.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpp3iovh0w.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpp3iovh0w.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_dslkycw.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp3iovh0w.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpp3iovh0w.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpp3iovh0w.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3im9tiba.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp3im9tiba.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        for p in prefixes {\n            if p.hasPrefix(string[c])\
    \ {\n                prefixes.append(p)\n                break\n            }\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpptb30rq4.swift:9:34: error: no exact matches in call to subscript\
    \ \n            if p.hasPrefix(string[c]) {\n                                \
    \ ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Character')\n    public subscript(r: Range<String.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaeicx8cj.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(current, offsetBy: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxeogaa7f.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        current = string[string.index(current,\
    \ offsetBy: 1)]\n                                      ^\n/tmp/tmpxeogaa7f.swift:10:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        current\
    \ = string[string.index(current, offsetBy: 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93go4zu_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp93go4zu_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp93go4zu_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1znzrz2.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpe1znzrz2.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp011p1jcr.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp011p1jcr.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014272
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxwgrwlhg.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxwgrwlhg.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpxwgrwlhg.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(current, startIndex: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxamropbh.swift:10:33: error: no exact matches in call to instance\
    \ method 'index'\n        current = string[string.index(current, startIndex: 1)]\n\
    \                                ^\n/tmp/tmpxamropbh.swift:10:33: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        current =\
    \ string[string.index(current, startIndex: 1)]\n                             \
    \   ^\n/tmp/tmpxamropbh.swift:10:25: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        current = string[string.index(current, startIndex:\
    \ 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprd8j7h0j.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmprd8j7h0j.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014267
