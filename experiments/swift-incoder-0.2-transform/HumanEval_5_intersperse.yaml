name: HumanEval_5_intersperse
language: swift
prompt: "\n/// Insert a number 'delimeter' between every two consecutive elements\
  \ of input list `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
  \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n///\
  \ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter:\
  \ 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
  \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) ==\
  \ [2, 2, 2, 2, 2])"
completions: ["    var result = [Int]()\n    var i = 0\n    for number in numbers\
    \ {\n        result.append(number)\n        if i != numbers.count - 1 {\n    \
    \        result.append(delimeter)\n        }\n        i += 1\n    }\n    return\
    \ result", "    var result = numbers\n    for index in 0..<numbers.count {\n \
    \       result[index] = result[index] + delimeter\n    }\n    return result",
  "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", '    return numbers.reduce([])
    { $0 + [$1, $2, $3, delimeter] }', "    return numbers.reduce(into: [Int](), {\
    \ result, number in\n        result.append(number)\n        result.insert(result.count,\
    \ delimeter)\n    })", "    var result = [Int]()\n    var i = 0\n    for n in\
    \ numbers {\n        result.append(n)\n        if i != numbers.count - 1 {\n \
    \           result.append(delimeter)\n        }\n        i += 1\n    }\n    return\
    \ result", "    return numbers.reduce(into: []) {\n        $0.append(contentsOf:\
    \ $1)\n        $0.append(contentsOf: [delimeter])\n    }", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        result\
    \ += [number]\n        result += [delimeter]\n        return result\n    }", " \
    \   var result = [Int]()\n    var last = 0\n    for number in numbers {\n    \
    \    result.append(number)\n        last = number\n    }\n    for number in numbers\
    \ {\n        result.append(delimeter)\n        result.append(number)\n       \
    \ last = number\n    }\n    return result", "    return numbers.reduce(into: [Int](),\
    \ { $0.append($1).append($2) })\n        .enumerated().map { $0.element + 1 }\n\
    \        .map { numbers[$0] + delimeter }", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        result.append(number)\n\
    \        if result.count > 2 {\n            result.append(delimeter)\n       \
    \ }\n        return result\n    }", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        result += [number]\n\
    \        result += [delimeter]\n        return result\n    }", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if number\
    \ != nil {\n            result.append(number)\n            result.append(delimeter)\n\
    \        }\n        return result\n    }", "    var result = numbers[0..<numbers.count]\n\
    \    for i in numbers.indices {\n        result[i] += delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    var last = 0\n    for number in numbers\
    \ {\n        last = number\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.append(last)\n    return result", "    return numbers.reduce(into:\
    \ []) {\n        $0.append($1)\n        $0.append($2)\n    }", "    var result\
    \ = numbers\n    for index in stride(from: 0, to: numbers.count, by: 1) {\n  \
    \      result[index] = delimeter\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!\
    \ + delimeter, number)\n    })", "    var numbers = numbers\n    var delimeter\
    \ = delimeter\n    if numbers.count < 2 {\n        return numbers\n    }\n   \
    \ var result = [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        i += 1\n        if i == delimeter {\n            i = 0\n        }\n \
    \   }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", '    return numbers.reduce([]) { $0 + [$1, $2, delimeter]
    }', "    var result = [Int]()\n    var i = 0\n    for number in numbers {\n  \
    \      result.append(number)\n        if i != numbers.count - 1 {\n          \
    \  result.append(delimeter)\n        }\n        i += 1\n    }\n    return result",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last!, delimeter)\n    })", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { $0.append($1).append($2)\
    \ })\n        .prefix(numbers.count / delimeter)\n        .reduce(into: [Int](),\
    \ { $0.append($1).append($2) })\n        .suffix(numbers.count % delimeter)\n\
    \        .reduce(into: [Int](), { $0.append($1).append($2) })", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if result.count\
    \ < 2 {\n            result = result + [number]\n        } else {\n          \
    \  result = result + [number] + delimeter\n        }\n        return result\n\
    \    }", "    var result = numbers.slice()\n    for index in stride(from: 0, to:\
    \ numbers.count, by: 1) {\n        result[index] = result[index].predecessor()\n\
    \        result[index] = delimeter.predecessor()\n    }\n    return result", " \
    \   var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = numbers\n    for index in stride(from: 0, to: numbers.count, by: 1) {\n  \
    \      result[index] = delimeter\n    }\n    return result", "    var result =\
    \ [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        i += 1\n        if i == delimeter {\n            i = 0\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        if number != delimeter {\n            result.append(delimeter)\n    \
    \    }\n    }\n    return result", "    var result = numbers\n    for index in\
    \ stride(from: 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n\
    \    }\n    return result", "    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int]()) {\n        (result,\
    \ number) in result.append(number)\n        if result.last == nil {\n        \
    \    result.append([])\n        }\n        result[result.count - 1].append(delimeter)\n\
    \    }", "    var numbersInOrder = numbers\n    var interspersedNumbers = [Int]()\n\
    \    for number in numbersInOrder {\n        interspersedNumbers.append(number)\n\
    \        interspersedNumbers.append(delimeter)\n    }\n    return interspersedNumbers",
  "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { $0.append($1) })\n        .enumerated().map { i, number in\n    \
    \        number.count > 1 ? $0[i - 1] + delimeter : $0[i - 1]\n        }\n   \
    \     .reduce(into: [Int](), { $0.append($1) })", "    var numbers_ = numbers\n\
    \    var delimeter_ = delimeter\n    if numbers_.count < delimeter_ {\n      \
    \  numbers_ = Array(numbers_.prefix(delimeter_))\n    }\n    var result = numbers_\n\
    \    for i in 0..<(numbers_.count - 1) {\n        result.append(delimeter_)\n\
    \        result.append(numbers_[i])\n    }\n    return result", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        result\
    \ += [number]\n        result += [delimeter]\n        return result\n    }", " \
    \   return numbers.reduce(into: [Int](), { $0.append($1).append($2) })\n     \
    \   .enumerated().map { $0.element + 1 }\n        .map { numbers[$0] + delimeter\
    \ }\n        .reduce(into: []) { $0.append($1) }", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = [Int]()\n    var i = 0\n    for\
    \ n in numbers {\n        result.append(n)\n        if i != numbers.count - 1\
    \ {\n            result.append(delimeter)\n        }\n        i += 1\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result[result.count-1] += number\n        result[result.count-1]\
    \ += delimeter\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.count, delimeter)\n\
    \    })", "    var numbers = numbers\n    var delimeter = delimeter\n    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { $0.append($1).append($2) })\n        .enumerated().map { $0.element\
    \ + $0.offset + delimeter }\n        .reversed()\n        .map { numbers[$0] }",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last! + delimeter, number)\n    })", "    var result\
    \ = [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n        i += 1\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int]()) { (result, number) in\n        result.append(number)\n        if result.count\
    \ > 2 {\n            result[result.count - 2] = delimeter\n        }\n    }",
  "    return numbers.reduce([]) { (result, number) -> [Int] in\n        var result\
    \ = result\n        if number != 0 {\n            result = result.insert(result.endIndex,\
    \ number)\n        }\n        result = result.insert(result.endIndex, delimeter)\n\
    \        return result\n    }", "    return numbers.reduce(into: [Int](), { $0.append($1).append($2)\
    \ })\n        .enumerated().map { $0.element.insert($0.offset, $0.offset + $0.stride\
    \ - 1) }\n        .reduce(into: [Int](), { $0.append($1).append($2) })\n     \
    \   .enumerated().map { $0.element.insert($0.offset, $0.offset + $0.stride - 1)\
    \ }", "    var result: [Int] = []\n    var i = 0\n    for number in numbers {\n\
    \        result.append(number)\n        if i != numbers.count - 1 {\n        \
    \    result.append(delimeter)\n        }\n        i += 1\n    }\n    return result",
  "    var result = numbers\n    for index in 0..<numbers.count {\n        result[index]\
    \ = result[index] + delimeter\n    }\n    return result", '    return numbers.reduce([])
    { $0 + [$1, $2, delimeter] }', "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.append(delimeter)\n\
    \    })", "    return numbers.reduce([]) { (result, number) -> [Int] in\n    \
    \    var result = result\n        if result.count < 2 {\n            result.append(number)\n\
    \        } else {\n            result[result.count - 1] = result[result.count\
    \ - 1] + delimeter + number\n        }\n        return result\n    }", "    return\
    \ numbers.reduce([]) { (result, number) -> [Int] in\n        var result = result\n\
    \        if result.count < 2 {\n            result = result + [number]\n     \
    \   } else {\n            result = result + [number] + delimeter\n        }\n\
    \        return result\n    }", '    return numbers.reduce([]) { $0 + [$1] + [$2]
    + [$3] + [$4] }', "    var result = [Int]()\n    var i = 0\n    for n in numbers\
    \ {\n        result.append(n)\n        i += 1\n        if i == delimeter {\n \
    \           result.append(delimeter)\n            i = 0\n        }\n    }\n  \
    \  return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!\
    \ + delimeter, number)\n    })", "    var result = numbers.slice()\n    for index\
    \ in stride(from: 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n\
    \    }\n    return result", "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        if number != nil {\n     \
    \       result.append(number)\n        }\n        if result.count > 0 {\n    \
    \        result.append(delimeter)\n        }\n        return result\n    }", " \
    \   return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.count, delimeter)\n    })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.append(delimeter)\n\
    \    })", "    var result = numbers.slice()\n    for index in stride(from: 0,\
    \ to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(result.last!, delimeter)\n \
    \   })", "    var result = [Int]()\n    var i = 0\n    for number in numbers {\n\
    \        result.append(number)\n        i += 1\n        if i == delimeter {\n\
    \            result.append(number)\n            i = 0\n        }\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.count, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int]()) {\n        (result, number)\
    \ in result.appending(number)\n        if result.last == nil {\n            result.append([])\n\
    \        }\n        result[result.count - 1].append(delimeter)\n    }", "    var\
    \ result = numbers\n    for index in 0..<numbers.count {\n        result[index]\
    \ = result[index] + delimeter\n    }\n    return result", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int]()) {\n    \
    \    (accumulator, number) -> in\n        accumulator.insert(accumulator.count\
    \ + 1, number)\n        accumulator.insert(accumulator.count, delimeter)\n   \
    \ }", "    var numbers_ = numbers\n    var delimeter_ = delimeter\n    if numbers_.isEmpty\
    \ {\n        return numbers_\n    }\n    var result = [Int]()\n    var i = 0\n\
    \    while i < numbers_.count {\n        result.append(numbers_[i])\n        if\
    \ delimeter_ > 0 {\n            result.append(delimeter_)\n        }\n       \
    \ i += 1\n    }\n    return result", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        if result.count <\
    \ 2 {\n            result.append(number)\n        } else {\n            result[result.count\
    \ - 1] = result[result.count - 1].prefix(delimeter) + String(number)\n       \
    \ }\n        return result\n    }", "    var result = [Int]()\n    for number\
    \ in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    var result = numbers\n    for index in stride(from:\
    \ 0, to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n \
    \   return result", '    return numbers.reduce([]) { $0 + [$1, $2, delimeter]
    }', "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.count, delimeter)\n    })", '    return numbers.reduce([])
    { $0.insert($1, at: $0.endIndex, at: delimeter) }', "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.offset % 2 == 0 ? $0.element + delimeter\
    \ : $0.element }", "    var result = [Int]()\n    var i = 0\n    for number in\
    \ numbers {\n        result.append(number)\n        if i < numbers.count - 1 {\n\
    \            result.append(delimeter)\n        }\n        i += 1\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    var numbers = numbers\n    var delimeter = delimeter\n    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var lastNumber: Int? = nil\n    for number in numbers {\n   \
    \     if lastNumber != nil {\n            result.append(lastNumber!)\n       \
    \ }\n        result.append(number)\n        lastNumber = number\n    }\n    if\
    \ lastNumber != nil {\n        result.append(lastNumber!)\n    }\n    return result",
  "    return numbers.reduce([]) { (result, number) -> [Int] in\n        var result\
    \ = result\n        result += [number]\n        result += [delimeter]\n      \
    \  return result\n    }", "    var result = [Int]()\n    var index = 0\n    for\
    \ number in numbers {\n        result[index] = number\n        index++\n     \
    \   if index == delimeter {\n            index = 0\n            result.append(number)\n\
    \        }\n    }\n    return result", "    return numbers.reduce(into: [Int]())\
    \ { (result, number) -> [Int] in\n        result.append(number)\n        if result.count\
    \ > 0 {\n            result.append(delimeter)\n        }\n        return result\n\
    \    }", '    return numbers.reduce([]) { $0 + [$1] + [$2] + [$3] + [$4] }', " \
    \   return numbers.reduce([]) { (result, number) -> [Int] in\n        var result\
    \ = result\n        result += [number]\n        result += [delimeter]\n      \
    \  return result\n    }", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element.insert($0.offset, $0.offset + $0.stride\
    \ + delimeter) }\n        .reduce(into: [Int](), { $0.append($1) })", "    return\
    \ numbers.reduce(into: [Int](), { $0.append($1) })\n        .enumerated().map\
    \ { $0.element + $0.offset + delimeter }\n        .reduce(into: [Int](), { $0.append($1)\
    \ })", "    return numbers.reduce([]) { (result, number) -> [Int] in\n       \
    \ var result = result\n        if result.count < 2 {\n            result.append(number)\n\
    \        } else {\n            result[result.count - 1] = result[result.count\
    \ - 1].prefix(delimeter) + String(number)\n        }\n        return result\n\
    \    }", "    return numbers.reduce(into: [Int](), { result, number in\n     \
    \   result.append(number)\n        result.insert(result.last! + delimeter, number)\n\
    \    })", "    return numbers.reduce([]) { (result, number) -> [Int] in\n    \
    \    var result = result\n        if number != 0 {\n            result = result\
    \ + [number]\n        }\n        result = result + [delimeter]\n        return\
    \ result\n    }", "    var result = numbers\n    for index in stride(from: 0,\
    \ to: numbers.count, by: 1) {\n        result[index] = delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    var i = 0\n    for n in numbers {\n\
    \        result.append(n)\n        if i != numbers.count - 1 {\n            result.append(delimeter)\n\
    \        }\n        i += 1\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { $0.append($1) })\n     \
    \   .enumerated().map { index, number in\n            guard index < numbers.count\
    \ else { return }\n            let start = index * delimeter\n            let\
    \ end = start + delimeter\n            let result = numbers[start..<end]\n   \
    \         result.append(number)\n            result\n        }\n        .reduce(into:\
    \ [Int](), { $0.append($1) })", "    var result = [Int]()\n    var i = 0\n   \
    \ for n in numbers {\n        result.append(n)\n        if i < numbers.count -\
    \ 1 {\n            result.append(delimeter)\n        }\n        i += 1\n    }\n\
    \    return result", '    return numbers.reduce(into: [Int](), { $0.append($1).append($2);
    $0.append(delimeter) })', "    var result = numbers[0..<numbers.count]\n    for\
    \ i in numbers.indices {\n        result[i] += delimeter\n    }\n    return result",
  "    return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last! + delimeter, number)\n    })", "    var result\
    \ = numbers\n    for index in 0..<numbers.count {\n        result[index] = result[index]\
    \ % delimeter\n        result[index] = result[index] + delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    var lastNumber = 0\n    for number in\
    \ numbers {\n        result.append(number)\n        lastNumber = number\n    }\n\
    \    for number in result {\n        result[result.index(lastNumber)] = delimeter\n\
    \    }\n    return result", "    var result = [Int]()\n    var last = 0\n    for\
    \ number in numbers {\n        last = number\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    result.append(last)\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    var numbers = numbers\n    var delimeter = delimeter\n    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if result.count\
    \ < 2 {\n            result.append(number)\n        } else {\n            result.append(delimeter)\n\
    \            result.append(number)\n        }\n        return result\n    }",
  "    var result = numbers\n    for index in stride(from: 0, to: numbers.count, by:\
    \ 1) {\n        result[index] = delimeter\n    }\n    return result", "    return\
    \ numbers.reduce([]) { (result, number) -> [Int] in\n        var result = result\n\
    \        result += [number]\n        result += [delimeter]\n        return result\n\
    \    }", "    return numbers.reduce(into: [Int](), { result, number in\n     \
    \   result.append(number)\n        result.insert(result.last! + delimeter, number)\n\
    \    })", "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var numbers\
    \ = numbers\n    var delimeter = delimeter\n    var result = [Int]()\n    for\
    \ number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce([]) { (result, number) -> [Int]\
    \ in\n        var result = result\n        result.append(number)\n        result.append(delimeter)\n\
    \        return result\n    }", "    return numbers.reduce(into: []) {\n     \
    \   if $0.count < 2 {\n            $0.append($1)\n        } else {\n         \
    \   $0.insert($0.count - 1, $1)\n        }\n    }.map { $0 + [$delimeter] }",
  "    var result = numbers\n    for index in stride(from: 0, to: numbers.count, by:\
    \ 1) {\n        result[index] = delimeter\n    }\n    return result", "    var\
    \ result = numbers\n    for index in stride(from: 0, to: numbers.count, by: 1)\
    \ {\n        result[index] = delimeter\n    }\n    return result", "    return\
    \ numbers.reduce([]) { (result, number) -> [Int] in\n        var result = result\n\
    \        if result.count < 2 {\n            result.append(number)\n        } else\
    \ {\n            result[result.count - 1] = result[result.count - 1].prefix(delimeter)\
    \ + String(number)\n        }\n        return result\n    }", "    var result\
    \ = [Int]()\n    var index = 0\n    for number in numbers {\n        result[index]\
    \ = number\n        index++\n        if index == delimeter {\n            index\
    \ = 0\n            result.append(number)\n        }\n    }\n    return result",
  "    return numbers.reduce([]) { (result, number) -> [Int] in\n        var result\
    \ = result\n        if result.count < 2 {\n            result.append(number)\n\
    \        } else {\n            result[result.count - 1] = result[result.count\
    \ - 1] + delimeter + number\n        }\n        return result\n    }", "    return\
    \ numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last!, delimeter)\n    })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", '    return numbers.reduce([]) { $0 + [$1, $2, $3, delimeter]
    }', "    var result = numbers\n    for index in stride(from: 0, to: numbers.count,\
    \ by: 1) {\n        result[index] = delimeter\n    }\n    return result", "  \
    \  return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last!, delimeter)\n    })", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.append(delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(result.last!, delimeter)\n \
    \   })", "    var result = numbers\n    for index in stride(from: 0, to: numbers.count,\
    \ by: 1) {\n        result[index] = delimeter\n    }\n    return result", "  \
    \  var result = numbers\n    for index in stride(from: 0, to: numbers.count, by:\
    \ 1) {\n        result[index] = delimeter\n    }\n    return result", "    var\
    \ numbers = numbers\n    var delimeter = delimeter\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = numbers.slice()\n    for index in\
    \ 0..<numbers.count {\n        result[index] = result[index].predecessor()\n \
    \       result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].predecessor()\n        result[index] =\
    \ result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor()\n        result[index] = result[index].successor()\n\
    \        result[index] = result[index].successor", "    var result = [Int]()\n\
    \    var i = 0\n    for number in numbers {\n        result.append(number)\n \
    \       if i != numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n        i += 1\n    }\n    return result", "    var result = numbers\n\
    \    for index in stride(from: 0, to: numbers.count, by: 1) {\n        result[index]\
    \ = delimeter\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for number in numbers {\n        result.append(number)\n    \
    \    result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { $0.append($1) })\n        .enumerated().map { index, number in\n\
    \            guard index < numbers.count else { return }\n            let start\
    \ = index == 0\n            let end = index == numbers.count - 1\n           \
    \ let interspersed = number + delimeter * (end - start)\n            guard interspersed\
    \ < 0 else { return }\n            return interspersed\n        }\n        .reduce(into:\
    \ [Int](), { $0.append($1) })", "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        if result.count < 2 {\n  \
    \          result = result + [number]\n        } else {\n            result =\
    \ result + [number] + delimeter\n        }\n        return result\n    }", " \
    \   return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.count, delimeter)\n    })", "    return numbers.reduce(into:\
    \ []) {\n        $0.append(contentsOf: $1)\n        $0.append(contentsOf: [delimeter])\n\
    \    }", "    return numbers.reduce(into: [Int]()) { (result, number) in\n   \
    \     result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    }", "    return numbers.reduce(into: [Int](), { result, number in\n     \
    \   result.append(number)\n        result.insert(result.last! + delimeter, number)\n\
    \    })", "    var result = numbers\n    for index in stride(from: 0, to: numbers.count,\
    \ by: 1) {\n        result[index] = delimeter\n    }\n    return result", "  \
    \  return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        result.insert(result.last!, delimeter)\n    })", "    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    return numbers.reduce([]) { (result, number) -> [Int]\
    \ in\n        var result = result\n        result += [number]\n        result\
    \ += [delimeter]\n        return result\n    }", "    var result = [Int]()\n \
    \   var i = 0\n    for n in numbers {\n        result.append(n)\n        if i\
    \ != 0 {\n            result.append(delimeter)\n        }\n        i += 1\n  \
    \  }\n    return result", "    var result = [Int]()\n    var last = 0\n    for\
    \ number in numbers {\n        last = number\n        result.append(last)\n  \
    \      result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.count,\
    \ delimeter)\n    })", "    var result = [Int]()\n    for number in numbers {\n\
    \        result.append(number)\n        result.append(delimeter)\n    }\n    return\
    \ result", "    return numbers.reduce(into: [Int](), { result, number in\n   \
    \     result.append(number)\n        result.insert(result.count, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(result.last!, delimeter)\n \
    \   })", "    var result = numbers\n    for i in 0..<numbers.count {\n       \
    \ result.append(delimeter)\n        result.append(numbers[i])\n    }\n    return\
    \ result", "    var numbers = numbers\n    var delimeter = delimeter\n    var\
    \ result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { $0.append($1).append($2) })\n        .enumerated().map { $0.element\
    \ + delimeter * $0.offset + $0.element }\n        .reduce(into: [Int](), { $0.append($1)\
    \ })", "    var result = [Int]()\n    var index = 0\n    for number in numbers\
    \ {\n        result[index] = number\n        index++\n        if index == delimeter\
    \ {\n            index = 0\n            result.append(number)\n        }\n   \
    \ }\n    return result", "    var result: [Int] = []\n    for number in numbers\
    \ {\n        result.append(number)\n        result.append(delimeter)\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.append(delimeter)\n    })",
  "    return numbers.reduce(into: []) {\n        $0.append(contentsOf: $1)\n    \
    \    $0.append(contentsOf: [delimeter])\n    }", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result[result.count] = number\n        result.insert(result.count,\
    \ delimeter)\n    })", "    var numbers = numbers\n    var delimeter = delimeter\n\
    \    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        result\
    \ += [number]\n        result += [delimeter]\n        return result\n    }", " \
    \   return numbers.reduce(into: [Int](), { result, number in\n        result.append(number)\n\
    \        if result.count > 0 {\n            result[result.count - 1] = delimeter\n\
    \        }\n    })", "    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        result.append(number)\n        result.insert(result.last!, delimeter)\n\
    \    })", "    return numbers.reduce(into: [Int](), { result, number in\n    \
    \    result.append(number)\n        result.insert(result.last!, delimeter)\n \
    \   })", "    var result = numbers\n    for index in stride(from: 0, to: numbers.count,\
    \ by: 1) {\n        result[index] = delimeter\n    }\n    return result", "  \
    \  return numbers.reduce(into: [Int](), { $0.append($1).append($2) })\n      \
    \  .enumerated().map { $0.element + delimeter * $0.offset + $0.element }\n   \
    \     .reduce(into: [Int](), { $0.append($1) })", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if result.count\
    \ < 2 {\n            result.append(number)\n        } else {\n            result.append(delimeter)\n\
    \            result.append(number)\n        }\n        return result\n    }",
  "    var result = numbers\n    for index in 0..<numbers.count {\n        result[index]\
    \ = result[index] as! Int\n        result[index] = result[index] + delimeter\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!\
    \ + delimeter, number)\n    })", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element + 1 }\n        .map { numbers[$0]\
    \ + delimeter }\n        .reduce(into: [Int](), { $0.append($1) })", "    var\
    \ numbers_ = [Int]()\n    for number in numbers {\n        numbers_.append(number)\n\
    \    }\n    var delimeter_ = delimeter\n    for number in numbers_ {\n       \
    \ numbers_.append(delimeter_)\n    }\n    return numbers_", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if result.count\
    \ < 2 {\n            result = result + [number]\n        } else {\n          \
    \  result[result.count - 1] = result[result.count - 1] + delimeter + number\n\
    \        }\n        return result\n    }", "    var result: [Int] = []\n    var\
    \ i = 0\n    for n in numbers {\n        result.append(n)\n        i += 1\n  \
    \      if i == delimeter {\n            i = 0\n            result.append(delimeter)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    return numbers.reduce(into: [Int](), { $0.append($1)\
    \ })\n        .enumerated().map { $0.element.insert($0.offset, $0.offset + $0.count\
    \ - 1) }\n        .reduce(into: [Int](), { $0.append($1) })\n        .enumerated().map\
    \ { $0.element.insert($0.offset, $0.offset + $0.count - 1) }\n        .map { $0.map\
    \ { $0 + delimeter } }\n        .joined()", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })", "    var result = [Int]()\n    var i = 0\n    for number\
    \ in numbers {\n        result.append(number)\n        if i != numbers.count -\
    \ 1 {\n            result.append(delimeter)\n        }\n        i += 1\n    }\n\
    \    return result", "    return numbers.reduce(into: [Int](), { $0.append($1).append($2)\
    \ })\n        .enumerated().map { $0.element + delimeter * $0.offset + $0.element\
    \ }\n        .reversed()\n        .reduce(into: [Int](), { $0.append($1) })",
  "    var result = numbers\n    for index in stride(from: 0, to: numbers.count, by:\
    \ 1) {\n        result[index] = delimeter\n    }\n    return result", "    return\
    \ numbers.reduce([]) { (result, number) -> [Int] in\n        var result = result\n\
    \        result += [number]\n        result += [delimeter]\n        result +=\
    \ [number]\n        return result\n    }", "    return numbers.reduce(into: [Int](),\
    \ { result, number in\n        result.append(number)\n        result.append(delimeter)\n\
    \    })", "    var result = [Int]()\n    var last = 0\n    for number in numbers\
    \ {\n        result.append(number)\n        last = number\n    }\n    for number\
    \ in numbers {\n        result.append(delimeter)\n        result.append(number)\n\
    \        last = number\n    }\n    return result", "    var result = numbers\n\
    \    for index in stride(from: 0, to: numbers.count, by: 1) {\n        result[index]\
    \ = delimeter\n    }\n    return result", '    return numbers.reduce([]) { $0
    + [$1] + [$2] + [$3] + [$4] }', "    return numbers.reduce([]) { (result, number)\
    \ -> [Int] in\n        var result = result\n        result += [number]\n     \
    \   result += [delimeter]\n        return result\n    }", "    var result = numbers\n\
    \    for index in stride(from: 0, to: numbers.count, by: 1) {\n        result[index]\
    \ = delimeter\n    }\n    return result"]
stop_tokens:
- "\n}"
