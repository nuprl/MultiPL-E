name: HumanEval_5_intersperse
language: swift
prompt: "\n/// Insert a number 'delimeter' between every two consecutive elements\
  \ of input list `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
  \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n///\
  \ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter:\
  \ 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
  \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) ==\
  \ [2, 2, 2, 2, 2])"
completions: ["    var result = [Int]()\n    var i = 0\n    for number in numbers\
    \ {\n        result.append(number)\n        if i != numbers.count - 1 {\n    \
    \        result.append(delimeter)\n        }\n        i += 1\n    }\n    return\
    \ result", "    var result = numbers\n    for index in 0..<numbers.count {\n \
    \       result[index] = result[index] + delimeter\n    }\n    return result",
  "    var result = [Int]()\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    return result", '    return numbers.reduce([])
    { $0 + [$1, $2, $3, delimeter] }', "    return numbers.reduce(into: [Int](), {\
    \ result, number in\n        result.append(number)\n        result.insert(result.count,\
    \ delimeter)\n    })", "    var result = [Int]()\n    var i = 0\n    for n in\
    \ numbers {\n        result.append(n)\n        if i != numbers.count - 1 {\n \
    \           result.append(delimeter)\n        }\n        i += 1\n    }\n    return\
    \ result", "    return numbers.reduce(into: []) {\n        $0.append(contentsOf:\
    \ $1)\n        $0.append(contentsOf: [delimeter])\n    }", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        result\
    \ += [number]\n        result += [delimeter]\n        return result\n    }", " \
    \   var result = [Int]()\n    var last = 0\n    for number in numbers {\n    \
    \    result.append(number)\n        last = number\n    }\n    for number in numbers\
    \ {\n        result.append(delimeter)\n        result.append(number)\n       \
    \ last = number\n    }\n    return result", "    return numbers.reduce(into: [Int](),\
    \ { $0.append($1).append($2) })\n        .enumerated().map { $0.element + 1 }\n\
    \        .map { numbers[$0] + delimeter }", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        result.append(number)\n\
    \        if result.count > 2 {\n            result.append(delimeter)\n       \
    \ }\n        return result\n    }", "    return numbers.reduce([]) { (result,\
    \ number) -> [Int] in\n        var result = result\n        result += [number]\n\
    \        result += [delimeter]\n        return result\n    }", "    return numbers.reduce([])\
    \ { (result, number) -> [Int] in\n        var result = result\n        if number\
    \ != nil {\n            result.append(number)\n            result.append(delimeter)\n\
    \        }\n        return result\n    }", "    var result = numbers[0..<numbers.count]\n\
    \    for i in numbers.indices {\n        result[i] += delimeter\n    }\n    return\
    \ result", "    var result = [Int]()\n    var last = 0\n    for number in numbers\
    \ {\n        last = number\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.append(last)\n    return result", "    return numbers.reduce(into:\
    \ []) {\n        $0.append($1)\n        $0.append($2)\n    }", "    var result\
    \ = numbers\n    for index in stride(from: 0, to: numbers.count, by: 1) {\n  \
    \      result[index] = delimeter\n    }\n    return result", "    return numbers.reduce(into:\
    \ [Int](), { result, number in\n        result.append(number)\n        result.insert(result.last!\
    \ + delimeter, number)\n    })", "    var numbers = numbers\n    var delimeter\
    \ = delimeter\n    if numbers.count < 2 {\n        return numbers\n    }\n   \
    \ var result = [Int]()\n    var i = 0\n    for number in numbers {\n        result.append(number)\n\
    \        i += 1\n        if i == delimeter {\n            i = 0\n        }\n \
    \   }\n    return result", "    return numbers.reduce(into: [Int](), { result,\
    \ number in\n        result.append(number)\n        result.insert(result.last!,\
    \ delimeter)\n    })"]
stop_tokens:
- "\n}"
