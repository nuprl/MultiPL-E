language: swift
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeljrmmsy.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.isEmpty {\n                return \"Yes\"\n            }\n      \
    \  }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmph4iqclyy.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0dlksbs.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxynt8tlf.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  } else {\n                stack.pop()\n            }\n        } else {\n  \
    \          if stack.isEmpty {\n                result = \"Yes\"\n            \
    \    break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjll5tara.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpjll5tara.swift:26:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.count < 1 {\n                return \"No\"\n            }\n     \
    \   }\n    }\n    if stack.count != 0 {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9a72_7ny.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbh15uy7v/tmpbh15uy7v.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d0d18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d0a0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d0a0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d0a0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh15uy7v                        0x000056261bac8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b61d0f04460 __libc_start_main +
    245

    6    tmpbh15uy7v                        0x000056261bac83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] += s\n            } else {\n\
    \                result = \"Yes\"\n                break\n            }\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpntf_o9z8.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpntf_o9z8.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmpntf_o9z8.swift:28:22: error: cannot find 'len'\
    \ in scope\n            if stack[len(stack)-1] == \"(\" {\n                  \
    \   ^~~\n/tmp/tmpntf_o9z8.swift:29:23: error: cannot find 'len' in scope\n   \
    \             stack[len(stack)-1] += s\n                      ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpo4mq8bc8/tmpo4mq8bc8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba50e67bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba50e372b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba50e372988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba50e3717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4mq8bc8                        0x0000559fd657d960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba50e867460 __libc_start_main +
    245

    6    tmpo4mq8bc8                        0x0000559fd657d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.isEmpty {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvgbcbpvk.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpvgbcbpvk.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.push(s)\n        } else if s == \")\" {\n            if stack.len()\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7lrcwk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        } else if stack.isEmpty {\n          \
    \  result = \"Yes\"\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp49trg0xx/tmp49trg0xx.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b196dc53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b196d94ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b196d94a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b196d9497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp49trg0xx                        0x000055813ce73aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b196de3f460 __libc_start_main +
    245

    6    tmp49trg0xx                        0x000055813ce733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack[len(stack)-1]\
    \ != s {\n                result = \"No\"\n                break\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpna0h7l36.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpna0h7l36.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmpna0h7l36.swift:28:22: error: cannot find 'len'\
    \ in scope\n            if stack[len(stack)-1] != s {\n                     ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbh15uy7v/tmpbh15uy7v.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d0d18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d0a0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d0a0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d0a0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh15uy7v                        0x000056261bac8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b61d0f04460 __libc_start_main +
    245

    6    tmpbh15uy7v                        0x000056261bac83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                let last\
    \ = stack.removeLast()\n                if last == s {\n                    result\
    \ = \"Yes\"\n                    break\n                }\n            }\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp27l2pkwf/tmp27l2pkwf.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5949a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5946a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5946a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af59469f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp27l2pkwf                        0x000055ebd8ca7976 <unavailable> + 6518

    5    libc.so.6                          0x00002af594b95460 __libc_start_main +
    245

    6    tmp27l2pkwf                        0x000055ebd8ca7559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.len() == 0 {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.len() == 0 {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpom5kxefv.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4w7ywhox/tmp4w7ywhox.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1b602dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1b5d24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1b5d24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1b5d237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4w7ywhox                        0x00005614340767f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ba1b6219460 __libc_start_main +
    245

    6    tmp4w7ywhox                        0x00005614340763d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4mtxn_s3/tmp4mtxn_s3.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b547ff72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b547fc69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b547fc69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b547fc687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4mtxn_s3                        0x0000560d0d9ba960 <unavailable> + 6496

    5    libc.so.6                          0x00002b548015e460 __libc_start_main +
    245

    6    tmp4mtxn_s3                        0x0000560d0d9ba3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxynt8tlf.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.pop()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9shk69qy.swift:26:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if !stack.isEmpty {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp19yx2_in.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyf1rkm4q/tmpyf1rkm4q.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ada2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ad723b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ad723988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ad7227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyf1rkm4q                        0x000056303cdc27f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab3adc18460 __libc_start_main +
    245

    6    tmpyf1rkm4q                        0x000056303cdc23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjylwbhyi/tmpjylwbhyi.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b796e555c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b796e24cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b796e24c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b796e24b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjylwbhyi                        0x0000561cec3a2960 <unavailable> + 6496

    5    libc.so.6                          0x00002b796e741460 __libc_start_main +
    245

    6    tmpjylwbhyi                        0x0000561cec3a23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjylwbhyi/tmpjylwbhyi.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b796e555c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b796e24cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b796e24c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b796e24b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjylwbhyi                        0x0000561cec3a2960 <unavailable> + 6496

    5    libc.so.6                          0x00002b796e741460 __libc_start_main +
    245

    6    tmpjylwbhyi                        0x0000561cec3a23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpywjqg4nd.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var stackSize\
    \ = 0\n    var lastStackSize = 0\n    var lastStackIndex = 0\n    var lastStackElement\
    \ = \"\"\n    for index, element in enumerate(lst) {\n        if element == \"\
    (\" {\n            stack[stackSize] = element\n            stackSize += 1\n  \
    \      } else if element == \")\" {\n            if stackSize == 0 {\n       \
    \         return \"No\"\n            }\n            stackSize -= 1\n         \
    \   if stackSize == 0 {\n                stack[lastStackIndex] = lastStackElement\n\
    \                lastStackIndex += 1\n                lastStackElement = \"\"\n\
    \            }\n        } else {\n            lastStackElement = element\n   \
    \         lastStackIndex = stackSize\n        }\n    }\n    if stackSize == 0\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeyxls28c.swift:24:14: error: expected 'in' after for-each pattern\n\
    \    for index, element in enumerate(lst) {\n             ^\n/tmp/tmpeyxls28c.swift:24:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, element\
    \ in enumerate(lst) {\n             ^\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.count < 1 {\n                return \"No\"\n            }\n     \
    \   }\n    }\n    if stack.count != 0 {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9a72_7ny.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"Yes\"\n            \
    \        break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf14bi33m/tmpf14bi33m.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c0c292c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c0bf89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c0bf89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c0bf887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf14bi33m                        0x0000561b7b1629c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b1c0c47e460 __libc_start_main +
    245

    6    tmpf14bi33m                        0x0000561b7b162439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6oj5w4h7.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp6oj5w4h7.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp6oj5w4h7.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp6oj5w4h7.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \")\" {\n            if stack.isEmpty {\n\
    \                return \"No\"\n            }\n            stack.removeLast()\n\
    \        } else if s == \"(\" {\n            stack.append(s)\n        }\n    }\n\
    \    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf9bs8f4l/tmpf9bs8f4l.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab98ed4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab98ea42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab98ea42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab98ea417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9bs8f4l                        0x00005568ee2fd7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ab98ef37460 __libc_start_main +
    245

    6    tmpf9bs8f4l                        0x00005568ee2fd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"No\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h9flmt0.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9172wjei/tmp9172wjei.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92e6df3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92e6aeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92e6aea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92e6ae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9172wjei                        0x0000558b11b7aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b92e6fdf460 __libc_start_main +
    245

    6    tmp9172wjei                        0x0000558b11b7a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(\"(\")\n  \
    \      } else if s == ')' {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return stack.top() == \"(\" ? \"Yes\"\
    \ : \"No\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpk7188onj.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpk7188onj.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpk7188onj.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"No\"\n        }\n    }\n    if stack.isEmpty {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpu0lxztby.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \")\" {\n            if stack.len() == 0\
    \ {\n                return \"No\"\n            }\n            stack.pop()\n \
    \       } else if s == \"(\" {\n            stack.push(s)\n        }\n    }\n\
    \    if stack.len() == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpkeqif6k8.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.pop()\n  \
    \              stack.append(s)\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ngi7zmu.swift:25:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmp3ngi7zmu.swift:31:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n        }\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsmqqneg9/tmpsmqqneg9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b354446dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3544164b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3544164988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35441637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmqqneg9                        0x000056266c756aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b3544659460 __libc_start_main +
    245

    6    tmpsmqqneg9                        0x000056266c7563d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var res = \"\"\n    for s in lst {\n        if s == \"(\" {\n           \
    \ stack.push(s)\n        } else if s == \")\" {\n            if stack.len() ==\
    \ 0 {\n                return \"No\"\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                return \"\
    No\"\n            }\n            res += s\n        }\n    }\n    if stack.len()\
    \ != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpx58okob0.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0mjgd905/tmp0mjgd905.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad221be3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2218dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2218da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2218d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0mjgd905                        0x000055ccaf40aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ad221dcf460 __libc_start_main +
    245

    6    tmp0mjgd905                        0x000055ccaf40a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \")\" {\n            if stack.isEmpty {\n\
    \                return \"No\"\n            }\n            stack.pop()\n     \
    \   } else if s == \"(\" {\n            stack.push(s)\n        }\n    }\n    if\
    \ stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3dz917n.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count < 1 {\n          \
    \      result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.count < 1 {\n                result =\
    \ \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    if result == \"No\" {\n  \
    \      result = \"Yes\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmploljni8f/tmploljni8f.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b758378bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7583482b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7583482988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75834817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmploljni8f                        0x000055bbf123a960 <unavailable> + 6496

    5    libc.so.6                          0x00002b7583977460 __libc_start_main +
    245

    6    tmploljni8f                        0x000055bbf123a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \")\" {\n            if stack.empty() {\n\
    \                return \"No\"\n            }\n            stack.pop()\n     \
    \   } else if s == \"(\" {\n            stack.push(s)\n        } else {\n    \
    \        return \"No\"\n        }\n    }\n    if stack.empty() {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2g4o5qfn.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    if stack.count > 0 {\n        return \"\
    No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphdxnodmc/tmphdxnodmc.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b861e160c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b861de57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b861de57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b861de567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphdxnodmc                        0x000055820b19eae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b861e34c460 __libc_start_main +
    245

    6    tmphdxnodmc                        0x000055820b19e559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpw25yyosy/tmpw25yyosy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae930351c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae930048b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae930048988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9300477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw25yyosy                        0x0000558d21218960 <unavailable> + 6496

    5    libc.so.6                          0x00002ae93053d460 __libc_start_main +
    245

    6    tmpw25yyosy                        0x0000558d212183d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.isEmpty {\n\
    \                result = \"Yes\"\n                break\n            }\n    \
    \        stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpdypcc6w2.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpdypcc6w2.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbh15uy7v/tmpbh15uy7v.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d0d18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d0a0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d0a0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d0a0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh15uy7v                        0x000056261bac8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b61d0f04460 __libc_start_main +
    245

    6    tmpbh15uy7v                        0x000056261bac83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpemyuq31u.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpemyuq31u.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        stack.pop()\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmplmzefkl_.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \")\" {\n            if stack.isEmpty {\n\
    \                return \"No\"\n            }\n            stack.pop()\n     \
    \   } else if s == \"(\" {\n            stack.push(s)\n        }\n    }\n    if\
    \ stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3dz917n.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp552qanzv/tmp552qanzv.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b672f855c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b672f54cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b672f54c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b672f54b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp552qanzv                        0x0000556ac1167aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b672fa41460 __libc_start_main +
    245

    6    tmp552qanzv                        0x0000556ac11673d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.isEmpty {\n\
    \                result = \"No\"\n                break\n            }\n     \
    \       stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2prugz9_.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmp2prugz9_.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpfjxliklb/tmpfjxliklb.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b870b66dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b870b364b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b870b364988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b870b3637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfjxliklb                        0x000055e5b099c960 <unavailable> + 6496

    5    libc.so.6                          0x00002b870b859460 __libc_start_main +
    245

    6    tmpfjxliklb                        0x000055e5b099c3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            if stack.count != 0 {\n                return \"No\"\n          \
    \  }\n        }\n    }\n    if stack.count != 0 {\n        return \"No\"\n   \
    \ }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpy_zaiink.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6oj5w4h7.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp6oj5w4h7.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp6oj5w4h7.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp6oj5w4h7.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return stack.contains(s) == \"Yes\" ? \"Yes\" : \"No\"\n        }\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmppawqhj9x.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"\"\n    for s in lst {\n        if s == \"(\" {\n        \
    \    stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                return \"Yes\"\
    \n            }\n            stack.removeLast()\n            stack.append(s)\n\
    \        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsurwo6ts/tmpsurwo6ts.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2efdefec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2efdbf5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2efdbf5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2efdbf47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsurwo6ts                        0x00005573facf9aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b2efe0ea460 __libc_start_main +
    245

    6    tmpsurwo6ts                        0x00005573facf93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmplaq_aenq/tmplaq_aenq.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb872b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb86fadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb86fad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb86fac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplaq_aenq                        0x000056217d645aeb <unavailable> + 6891

    5    libc.so.6                          0x00002afb874a2460 __libc_start_main +
    245

    6    tmplaq_aenq                        0x000056217d6453d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return stack.top() == \"(\" ? \"\
    Yes\" : \"No\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpfl3ygw35.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.pop()\n        } else if stack.isEmpty {\n            result\
    \ = \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqx6x_3xe.swift:26:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.len() == 0 {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        }\n    }\n\
    \    if stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9cw03k0l.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9172wjei/tmp9172wjei.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92e6df3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92e6aeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92e6aea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92e6ae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9172wjei                        0x0000558b11b7aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b92e6fdf460 __libc_start_main +
    245

    6    tmp9172wjei                        0x0000558b11b7a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if !stack.isEmpty {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp0k_n0suo.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeljrmmsy.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            if stack.count != 0 {\n                return \"No\"\n          \
    \  }\n            stack.push(s)\n        }\n    }\n    if stack.count != 0 {\n\
    \        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpuilh_knn.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n        }\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsmqqneg9/tmpsmqqneg9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b354446dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3544164b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3544164988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35441637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmqqneg9                        0x000056266c756aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b3544659460 __libc_start_main +
    245

    6    tmpsmqqneg9                        0x000056266c7563d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.len() == 0 {\n         \
    \       return \"No\"\n            }\n            stack.pop()\n        } else\
    \ {\n            if stack.len() != 0 {\n                return \"No\"\n      \
    \      }\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\n\
    \    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ph3a4gk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.pop()\n        } else {\n            if stack.isEmpty {\n \
    \               result = \"Yes\"\n                break\n            }\n     \
    \       stack.pop()\n            stack.append(s)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcihg377t.swift:26:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmpcihg377t.swift:32:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\") {\n                result = \"Yes\"\n                break\n            }\
    \ else {\n                result = \"No\"\n                break\n           \
    \ }\n        } else {\n            result = \"No\"\n            break\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpagzqn70q/tmpagzqn70q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b413148bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4131182b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4131182988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41311817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpagzqn70q                        0x000055eb551efa7b <unavailable> + 6779

    5    libc.so.6                          0x00002b4131677460 __libc_start_main +
    245

    6    tmpagzqn70q                        0x000055eb551ef369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \")\" {\n            if !stack.isEmpty {\n\
    \                stack.pop()\n            } else {\n                return \"\
    No\"\n            }\n        } else if s == \"(\" {\n            stack.push(s)\n\
    \        } else {\n            return \"No\"\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpfkvkaakc.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if stack.top() != \"\" {\n        return \"No\"\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxywji5hw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9172wjei/tmp9172wjei.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92e6df3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92e6aeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92e6aea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92e6ae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9172wjei                        0x0000558b11b7aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b92e6fdf460 __libc_start_main +
    245

    6    tmp9172wjei                        0x0000558b11b7a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.len() == 0 {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.len() == 0 {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpom5kxefv.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 {\n        return \"No\"\n    }\n    var stack = [String]()\n    var stack2\
    \ = [String]()\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack2.count > 0 {\n         \
    \       stack2.removeLast()\n            }\n            if stack2.count == 0 {\n\
    \                stack.append(s)\n            }\n        }\n    }\n    if stack2.count\
    \ > 0 {\n        return \"No\"\n    }\n    if stack.count > 0 {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmplzubr56f/tmplzubr56f.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba59a8a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba59a5a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba59a5a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba59a59f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplzubr56f                        0x0000559c7cf01960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba59aa95460 __libc_start_main +
    245

    6    tmplzubr56f                        0x0000559c7cf013d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.push(s)\n        } else if s == \")\" {\n            if stack.len()\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7lrcwk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    guard lst[0] != \"(\" && lst[0] != \")\" else\
    \ { return \"No\" }\n    guard lst[1] != \"(\" && lst[1] != \")\" else { return\
    \ \"No\" }\n    guard lst[0] != \"(\" && lst[1] != \"(\" else { return \"No\"\
    \ }\n    guard lst[1] != \")\" && lst[1] != \"(\" else { return \"No\" }\n   \
    \ guard lst[0] != \"(\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[1]\
    \ != \")\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[0] != \"(\"\
    \ && lst[1] != \"(\" else { return \"No\" }\n    guard lst[1] != \")\" && lst[1]\
    \ != \"(\" else { return \"No\" }\n    guard lst[0] != \"(\" && lst[1] != \"(\"\
    \ else { return \"No\" }\n    guard lst[1] != \")\" && lst[1] != \"(\" else {\
    \ return \"No\" }\n    guard lst[0] != \"(\" && lst[1] != \"(\" else { return\
    \ \"No\" }\n    guard lst[1] != \")\" && lst[1] != \"(\" else { return \"No\"\
    \ }\n    guard lst[0] != \"(\" && lst[1] != \"(\" else { return \"No\" }\n   \
    \ guard lst[1] != \")\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[0]\
    \ != \"(\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[1] != \")\"\
    \ && lst[1] != \"(\" else { return \"No\" }\n    guard lst[0] != \"(\" && lst[1]\
    \ != \"(\" else { return \"No\" }\n    guard lst[1] != \")\" && lst[1] != \"(\"\
    \ else { return \"No\" }\n    guard lst[0] != \"(\" && lst[1] != \"(\" else {\
    \ return \"No\" }\n    guard lst[1] != \")\" && lst[1] != \"(\" else { return\
    \ \"No\" }\n    guard lst[0] != \"(\" && lst[1] != \"(\" else { return \"No\"\
    \ }\n    guard lst[1] != \")\" && lst[1] != \"(\" else { return \"No\" }\n   \
    \ guard lst[0] != \"(\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[1]\
    \ != \")\" && lst[1] != \"(\" else { return \"No\" }\n    guard lst[0] != \"(\"\
    \ && lst[1] != \"(\" else { return \"No\" }\n    guard lst[1] != \")\" && lst[1]\
    \ != \"(\" else { return \"No\" }\n    guard lst[0] != \"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpannvjq12.swift:43:21: error: unterminated string literal\n    guard\
    \ lst[0] != \"\n                    ^\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            result += \"Yes\"\
    \n        } else {\n            result += \"No\"\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpghmsaegm/tmpghmsaegm.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f5ac88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f5a97fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f5a97f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f5a97e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpghmsaegm                        0x0000560a9a6a2666 <unavailable> + 5734

    5    libc.so.6                          0x00002b6f5ae74460 __libc_start_main +
    245

    6    tmpghmsaegm                        0x0000560a9a6a2249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var result = \"\"\n    for s in lst {\n        if s == \"(\" {\n        \
    \    stack.push(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            result += \"(\"\
    \ + stack.pop() + \")\"\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpo6vcxf5n.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.isEmpty {\n                return \"Yes\"\n            }\n      \
    \  }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpgy8qwhbe.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpgy8qwhbe.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpgy8qwhbe.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count ==\
    \ 0 {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"Yes\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    No\"\n                break\n            }\n            stack.pop()\n        \
    \    stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmphkf2878j.swift:29:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmphkf2878j.swift:35:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpu837gm8w/tmpu837gm8w.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b890c784c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b890c47bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b890c47b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b890c47a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu837gm8w                        0x000055f03b91e7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b890c970460 __libc_start_main +
    245

    6    tmpu837gm8w                        0x000055f03b91e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmps49rsa9i/tmps49rsa9i.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcecf44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcecc3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcecc3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcecc3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps49rsa9i                        0x0000564b0c744960 <unavailable> + 6496

    5    libc.so.6                          0x00002abced130460 __libc_start_main +
    245

    6    tmps49rsa9i                        0x0000564b0c7443d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.isEmpty {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvgbcbpvk.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpvgbcbpvk.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if !stack.isEmpty {\n                return \"No\"\n            }\n      \
    \  }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2q902oif.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ if stack.isEmpty {\n            return \"Yes\"\n        }\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmps_qweml6/tmps_qweml6.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abbfa430c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abbfa127b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abbfa127988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abbfa1267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_qweml6                        0x000055f57d711aeb <unavailable> + 6891

    5    libc.so.6                          0x00002abbfa61c460 __libc_start_main +
    245

    6    tmps_qweml6                        0x000055f57d7113d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxynt8tlf.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.pop()\n        } else {\n            if stack.isEmpty {\n \
    \               result = \"No\"\n                break\n            }\n      \
    \      stack.pop()\n            stack.append(s)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpy9s_0m4t.swift:26:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmpy9s_0m4t.swift:32:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.pop()\n        } else {\n \
    \           if stack.isEmpty {\n                return \"Yes\"\n            }\n\
    \            stack.pop()\n            stack.append(s)\n        }\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp0iljzoic.swift:24:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmp0iljzoic.swift:29:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpfjxliklb/tmpfjxliklb.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b870b66dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b870b364b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b870b364988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b870b3637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfjxliklb                        0x000055e5b099c960 <unavailable> + 6496

    5    libc.so.6                          0x00002b870b859460 __libc_start_main +
    245

    6    tmpfjxliklb                        0x000055e5b099c3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return stack.contains(s) ? \"Yes\" : \"No\"\n        }\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqskk7x0.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\")\n                result = \"Yes\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmphfncfiko.swift:19:31: error: expected '{' after 'if' condition\n\
    \            if s.contains(\")\")\n                              ^\n/tmp/tmphfncfiko.swift:16:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = \"No\"\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return stack.top()\n        }\n\
    \    }\n    if stack.top() == \"(\" {\n        stack.pop()\n    } else {\n   \
    \     return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9i69sw36.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpu837gm8w/tmpu837gm8w.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b890c784c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b890c47bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b890c47b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b890c47a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu837gm8w                        0x000055f03b91e7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b890c970460 __libc_start_main +
    245

    6    tmpu837gm8w                        0x000055f03b91e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push((s, 0))\n \
    \       } else if s == ')' {\n            if stack.isEmpty {\n               \
    \ return \"No\"\n            }\n            s, _ := stack.pop()\n            if\
    \ s != ')' {\n                return \"No\"\n            }\n        }\n    }\n\
    \    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6tnns8_x.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp6tnns8_x.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp6tnns8_x.swift:24:14: error: consecutive statements on\
    \ a line must be separated by ';'\n            s, _ := stack.pop()\n         \
    \    ^\n             ;\n/tmp/tmp6tnns8_x.swift:24:14: error: expected expression\n\
    \            s, _ := stack.pop()\n             ^\n/tmp/tmp6tnns8_x.swift:25:21:\
    \ error: single-quoted string literal found, use '\"'\n            if s != ')'\
    \ {\n                    ^~~\n                    \")\"\n/tmp/tmp6tnns8_x.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n/tmp/tmp6tnns8_x.swift:24:13: warning: expression of type 'String'\
    \ is unused\n            s, _ := stack.pop()\n            ^\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"Yes\"\n            \
    \        break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf14bi33m/tmpf14bi33m.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c0c292c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c0bf89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c0bf89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c0bf887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf14bi33m                        0x0000561b7b1629c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b1c0c47e460 __libc_start_main +
    245

    6    tmpf14bi33m                        0x0000561b7b162439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpch2w7ln9.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    \n    var result\
    \ = \"No\"\n    var stack = [String]()\n    \n    for s in lst {\n        if s\
    \ == \"(\" {\n            stack.append(s)\n        } else if s == \")\" {\n  \
    \          if stack.count > 0 {\n                stack.removeLast()\n        \
    \    } else {\n                result = \"Yes\"\n            }\n        }\n  \
    \  }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpu6eb65o0/tmpu6eb65o0.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32d3661c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32d3358b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32d3358988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32d33577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu6eb65o0                        0x000055cdb050a960 <unavailable> + 6496

    5    libc.so.6                          0x00002b32d384d460 __libc_start_main +
    245

    6    tmpu6eb65o0                        0x000055cdb050a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.len() == 0 {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        }\n    }\n    if stack.len()\
    \ != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpi1mmmtp2.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpi1mmmtp2.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpi1mmmtp2.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n        }\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsmqqneg9/tmpsmqqneg9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b354446dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3544164b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3544164988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35441637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmqqneg9                        0x000056266c756aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b3544659460 __libc_start_main +
    245

    6    tmpsmqqneg9                        0x000056266c7563d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9172wjei/tmp9172wjei.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92e6df3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92e6aeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92e6aea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92e6ae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9172wjei                        0x0000558b11b7aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b92e6fdf460 __libc_start_main +
    245

    6    tmp9172wjei                        0x0000558b11b7a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4w7ywhox/tmp4w7ywhox.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1b602dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1b5d24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1b5d24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1b5d237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4w7ywhox                        0x00005614340767f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ba1b6219460 __libc_start_main +
    245

    6    tmp4w7ywhox                        0x00005614340763d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\") {\n                result = \"Yes\"\n                break\n            }\
    \ else {\n                result = \"No\"\n            }\n        } else {\n \
    \           result = \"No\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpxump6pe5/tmpxump6pe5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba860d8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba860a82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba860a82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba860a817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxump6pe5                        0x000055937c7dfa7b <unavailable> + 6779

    5    libc.so.6                          0x00002ba860f77460 __libc_start_main +
    245

    6    tmpxump6pe5                        0x000055937c7df369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.count != 0 {\n    \
    \    return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxti9jy7y.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpxti9jy7y.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.pop()\n        } else {\n \
    \           if stack.isEmpty {\n                return \"Yes\"\n            }\n\
    \            if stack[stack.count - 1] != \"(\" {\n                return \"No\"\
    \n            }\n            stack.pop()\n        }\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp8vw7bw19.swift:24:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmp8vw7bw19.swift:32:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpemyuq31u.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpemyuq31u.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"No\"\n        }\n    }\n    if stack.isEmpty {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeveirbx1.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpeveirbx1.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpeveirbx1.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcz8drffg.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeljrmmsy.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpp23kgs6o/tmpp23kgs6o.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc74d3cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc74a33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc74a33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc74a327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp23kgs6o                        0x0000564d87316960 <unavailable> + 6496

    5    libc.so.6                          0x00002abc74f28460 __libc_start_main +
    245

    6    tmpp23kgs6o                        0x0000564d873163d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54187fyw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = Stack()\n    for s in lst {\n\
    \        if s == \"(\" {\n            stack.push(\"(\")\n        } else if s ==\
    \ \")\" {\n            if stack.count > 0 {\n                stack.pop()\n   \
    \         } else {\n                return \"No\"\n            }\n        } else\
    \ {\n            return stack.count > 0 ? \"No\" : \"Yes\"\n        }\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjy9r12wd.swift:19:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return stack.stackIsEmpty() ? \"No\" : \"Yes\"\n        }\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeogw70i6.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpeogw70i6.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpeogw70i6.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjylwbhyi/tmpjylwbhyi.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b796e555c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b796e24cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b796e24c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b796e24b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjylwbhyi                        0x0000561cec3a2960 <unavailable> + 6496

    5    libc.so.6                          0x00002b796e741460 __libc_start_main +
    245

    6    tmpjylwbhyi                        0x0000561cec3a23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\") {\n                result = \"Yes\"\n                break\n            }\
    \ else {\n                result = \"No\"\n                break\n           \
    \ }\n        } else {\n            result = \"No\"\n            break\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpagzqn70q/tmpagzqn70q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b413148bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4131182b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4131182988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41311817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpagzqn70q                        0x000055eb551efa7b <unavailable> + 6779

    5    libc.so.6                          0x00002b4131677460 __libc_start_main +
    245

    6    tmpagzqn70q                        0x000055eb551ef369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.isEmpty {\n                return \"Yes\"\n            }\n      \
    \      stack.pop()\n            stack.push(s)\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp7awqa6rx.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\") {\n                result = \"Yes\"\n                break\n            }\
    \ else {\n                result = \"No\"\n                break\n           \
    \ }\n        } else {\n            result = \"No\"\n            break\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpagzqn70q/tmpagzqn70q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b413148bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4131182b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4131182988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41311817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpagzqn70q                        0x000055eb551efa7b <unavailable> + 6779

    5    libc.so.6                          0x00002b4131677460 __libc_start_main +
    245

    6    tmpagzqn70q                        0x000055eb551ef369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54187fyw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4mtxn_s3/tmp4mtxn_s3.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b547ff72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b547fc69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b547fc69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b547fc687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4mtxn_s3                        0x0000560d0d9ba960 <unavailable> + 6496

    5    libc.so.6                          0x00002b548015e460 __libc_start_main +
    245

    6    tmp4mtxn_s3                        0x0000560d0d9ba3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.isEmpty\
    \ == false else { return \"No\" }\n    var stack = Stack()\n    for s in lst {\n\
    \        if s == \"(\" {\n            stack.push(s)\n        } else if s == \"\
    )\" {\n            if stack.peek() == \"(\" {\n                stack.pop()\n \
    \           } else {\n                return \"No\"\n            }\n        }\
    \ else {\n            return \"No\"\n        }\n    }\n    if stack.peek() ==\
    \ \"(\" {\n        stack.pop()\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjgqys4g5.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_99docv4/tmp_99docv4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a81ccfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a819c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a819c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a819c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_99docv4                        0x00005607d37b5aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b1a81ebb460 __libc_start_main +
    245

    6    tmp_99docv4                        0x00005607d37b53d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54187fyw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if stack.top() == \"(\" {\n        stack.pop()\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpztenf1v9.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n            stack.append(s)\n        }\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_srlcg4/tmpi_srlcg4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f648ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f6181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f6181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f61807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_srlcg4                        0x000055c05a3ddaeb <unavailable> + 6891

    5    libc.so.6                          0x00002b59f6676460 __libc_start_main +
    245

    6    tmpi_srlcg4                        0x000055c05a3dd3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmplaq_aenq/tmplaq_aenq.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb872b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb86fadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb86fad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb86fac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplaq_aenq                        0x000056217d645aeb <unavailable> + 6891

    5    libc.so.6                          0x00002afb874a2460 __libc_start_main +
    245

    6    tmplaq_aenq                        0x000056217d6453d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            if len(stack) != 0 {\n                return \"No\"\n           \
    \ }\n        }\n    }\n    if stack.count != 0 {\n        return \"No\"\n    }\n\
    \    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw7jiwe24.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpw7jiwe24.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmpw7jiwe24.swift:26:16: error: cannot find 'len'\
    \ in scope\n            if len(stack) != 0 {\n               ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.pop()\n        } else {\n \
    \           if stack.isEmpty {\n                return \"Yes\"\n            }\n\
    \            stack.append(s)\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprb88_0mi.swift:24:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmps49rsa9i/tmps49rsa9i.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcecf44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcecc3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcecc3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcecc3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps49rsa9i                        0x0000564b0c744960 <unavailable> + 6496

    5    libc.so.6                          0x00002abced130460 __libc_start_main +
    245

    6    tmps49rsa9i                        0x0000564b0c7443d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpfjxliklb/tmpfjxliklb.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b870b66dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b870b364b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b870b364988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b870b3637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfjxliklb                        0x000055e5b099c960 <unavailable> + 6496

    5    libc.so.6                          0x00002b870b859460 __libc_start_main +
    245

    6    tmpfjxliklb                        0x000055e5b099c3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.len() == 0 {\n         \
    \       return \"No\"\n            }\n            stack.pop()\n        } else\
    \ {\n            if stack.len() == 0 {\n                return \"No\"\n      \
    \      }\n            stack.pop()\n            stack.push(s)\n        }\n    }\n\
    \    if stack.len() != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9ax_3sjs.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54187fyw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return stack.count < 2 ? \"No\" : \"Yes\"\n        }\n    }\n    return \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6o3xt00y.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp6o3xt00y.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp6o3xt00y.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4mtxn_s3/tmp4mtxn_s3.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b547ff72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b547fc69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b547fc69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b547fc687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4mtxn_s3                        0x0000560d0d9ba960 <unavailable> + 6496

    5    libc.so.6                          0x00002b548015e460 __libc_start_main +
    245

    6    tmp4mtxn_s3                        0x0000560d0d9ba3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpywjqg4nd.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.len() == 0 {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"\"\n        }\n    }\n    if stack.len() == 0 {\n      \
    \  return \"Yes\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpj478e0uq.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if !stack.isEmpty {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp19yx2_in.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbh15uy7v/tmpbh15uy7v.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d0d18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d0a0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d0a0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d0a0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh15uy7v                        0x000056261bac8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b61d0f04460 __libc_start_main +
    245

    6    tmpbh15uy7v                        0x000056261bac83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\") {\n                result = \"Yes\"\n                break\n            }\
    \ else {\n                result = \"No\"\n            }\n        } else {\n \
    \           result = \"No\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpxump6pe5/tmpxump6pe5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba860d8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba860a82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba860a82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba860a817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxump6pe5                        0x000055937c7dfa7b <unavailable> + 6779

    5    libc.so.6                          0x00002ba860f77460 __libc_start_main +
    245

    6    tmpxump6pe5                        0x000055937c7df369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = Stack()\n    var res = \"\"\
    \n    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n   \
    \     } else if s == \")\" {\n            if stack.count > 0 {\n             \
    \   stack.pop()\n            } else {\n                res += s\n            }\n\
    \        } else {\n            res += s\n        }\n    }\n    if stack.count\
    \ != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp1mqws7t6.swift:19:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if stack.top() != \"\" {\n        return \"No\"\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxywji5hw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"No\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyeojscgm/tmpyeojscgm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90f88c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90f85b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90f85b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90f85b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyeojscgm                        0x000055db8a64f7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b90f8aac460 __libc_start_main +
    245

    6    tmpyeojscgm                        0x000055db8a64f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4mtxn_s3/tmp4mtxn_s3.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b547ff72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b547fc69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b547fc69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b547fc687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4mtxn_s3                        0x0000560d0d9ba960 <unavailable> + 6496

    5    libc.so.6                          0x00002b548015e460 __libc_start_main +
    245

    6    tmp4mtxn_s3                        0x0000560d0d9ba3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjylwbhyi/tmpjylwbhyi.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b796e555c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b796e24cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b796e24c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b796e24b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjylwbhyi                        0x0000561cec3a2960 <unavailable> + 6496

    5    libc.so.6                          0x00002b796e741460 __libc_start_main +
    245

    6    tmpjylwbhyi                        0x0000561cec3a23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count < 2 {\n          \
    \      result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpbwvx12zb/tmpbwvx12zb.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78eb25bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78eaf52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78eaf52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78eaf517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbwvx12zb                        0x0000557cf2fa27f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b78eb447460 __libc_start_main +
    245

    6    tmpbwvx12zb                        0x0000557cf2fa23d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            if s.contains(\"\
    )\")\n                result += \"Yes\"\n            else\n                result\
    \ += \"No\"\n        } else {\n            result += \"No\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp0woh_gue.swift:19:31: error: expected '{' after 'if' condition\n\
    \            if s.contains(\")\")\n                              ^\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             stack.removeLast()\n            }\n            if stack.count ==\
    \ 0 {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpmpgwj3yb/tmpmpgwj3yb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af75f97dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af75f674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af75f674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af75f6737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmpgwj3yb                        0x0000562ed0d27ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002af75fb69460 __libc_start_main +
    245

    6    tmpmpgwj3yb                        0x0000562ed0d27559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count ==\
    \ 0 {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5iyk0h2u/tmp5iyk0h2u.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3267ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3264e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3264e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3264e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5iyk0h2u                        0x000055eb983fb9b0 <unavailable> + 6576

    5    libc.so.6                          0x00002ba3269d8460 __libc_start_main +
    245

    6    tmp5iyk0h2u                        0x000055eb983fb429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if !stack.isEmpty {\n                return \"No\"\n            }\n      \
    \  }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2q902oif.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if len(stack) == 0 {\n          \
    \      result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.count < 1 {\n                result =\
    \ \"No\"\n                break\n            }\n            stack[stack.count\
    \ - 1] = s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpgpnfopfm.swift:25:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpgpnfopfm.swift:29:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ } else {\n                stack.pop()\n            }\n        } else {\n   \
    \         if stack.isEmpty {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp1x_khzge.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmp1x_khzge.swift:26:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"\"\n    for s in lst {\n        if s == \"(\" {\n        \
    \    stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            if stack.last != s {\n                return \"No\"\
    \n            }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsk5yfcs2/tmpsk5yfcs2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4016ef9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4016bf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4016bf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4016bef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsk5yfcs2                        0x000055b05c2f1856 <unavailable> + 6230

    5    libc.so.6                          0x00002b40170e5460 __libc_start_main +
    245

    6    tmpsk5yfcs2                        0x000055b05c2f1439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var open =\
    \ 0\n    var close = 0\n    for s in lst {\n        if s == \"(\" {\n        \
    \    open += 1\n            stack.append(s)\n        } else if s == \")\" {\n\
    \            close += 1\n            if open > close {\n                return\
    \ \"Yes\"\n            }\n            open--\n            stack.pop()\n      \
    \  }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2owaas4e.swift:31:17: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            open--\n                ^~\n/tmp/tmp2owaas4e.swift:32:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            }\n            stack.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpfyq_xrbn/tmpfyq_xrbn.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae21a4e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae21a1dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae21a1da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae21a1d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfyq_xrbn                        0x000055b1450de7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ae21a6cf460 __libc_start_main +
    245

    6    tmpfyq_xrbn                        0x000055b1450de3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s.isOpen {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                let last\
    \ = stack.removeLast()\n                if last == s {\n                    result\
    \ += \"Yes\"\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq9r0_2cq.swift:20:14: error: value of type 'String' has no member\
    \ 'isOpen'\n        if s.isOpen {\n           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count ==\
    \ 0 {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.isEmpty {\n            \
    \    result = \"Yes\"\n                break\n            }\n            stack.pop()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptuvh5j5e.swift:29:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            if len(stack) != 0 {\n                return \"No\"\n           \
    \ }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_8wuq0h0.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmp_8wuq0h0.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmp_8wuq0h0.swift:26:16: error: cannot find 'len'\
    \ in scope\n            if len(stack) != 0 {\n               ^~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp80ispu0r/tmp80ispu0r.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29af252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29aef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29aef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29aef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80ispu0r                        0x000055a4b2177960 <unavailable> + 6496

    5    libc.so.6                          0x00002b29af43e460 __libc_start_main +
    245

    6    tmp80ispu0r                        0x000055a4b21773d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"\"\n    for s in lst {\n        if s == \"(\" {\n        \
    \    stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                return \"Yes\"\
    \n            }\n            stack.removeLast()\n            stack.append(s)\n\
    \        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsurwo6ts/tmpsurwo6ts.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2efdefec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2efdbf5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2efdbf5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2efdbf47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsurwo6ts                        0x00005573facf9aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b2efe0ea460 __libc_start_main +
    245

    6    tmpsurwo6ts                        0x00005573facf93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    var stack = [String]()\n    var result\
    \ = \"No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"Yes\"\n            \
    \        break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpf14bi33m/tmpf14bi33m.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c0c292c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c0bf89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c0bf89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c0bf887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf14bi33m                        0x0000561b7b1629c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b1c0c47e460 __libc_start_main +
    245

    6    tmpf14bi33m                        0x0000561b7b162439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.push(s)\n        } else if s == \")\" {\n            if stack.len()\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7lrcwk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp96fscatw.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp96fscatw.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp96fscatw.swift:16:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(\"(\")\n\
    \        } else if s == \")\" {\n            if stack.top() == \"(\" {\n     \
    \           stack.pop()\n            } else {\n                return \"No\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if stack.top() == \"(\" {\n        stack.pop()\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpztenf1v9.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.top() == \"(\" {\n         \
    \       stack.pop()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   if stack.top() == \"(\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54187fyw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.len() == 0 {\n             \
    \   return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            if stack.len() != 0 {\n                return \"No\"\n          \
    \  }\n        }\n    }\n    if stack.len() != 0 {\n        return \"No\"\n   \
    \ }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxm7_6r0c.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count ==\
    \ 0 {\n        return \"No\"\n    }\n    var stack = Stack()\n    for s in lst\
    \ {\n        if s == \"(\" {\n            stack.push(s)\n        } else if s ==\
    \ \")\" {\n            if stack.top() == \"(\" {\n                stack.pop()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.top() != \"(\" {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjfrqb2ul.swift:19:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979588
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"Yes\"\n        \
    \    }\n            stack.removeLast()\n        }\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsmqqneg9/tmpsmqqneg9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b354446dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3544164b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3544164988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35441637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmqqneg9                        0x000056266c756aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b3544659460 __libc_start_main +
    245

    6    tmpsmqqneg9                        0x000056266c7563d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  return \"No\"\n            }\n            stack.removeLast()\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4w7ywhox/tmp4w7ywhox.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1b602dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1b5d24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1b5d24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1b5d237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4w7ywhox                        0x00005614340767f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ba1b6219460 __libc_start_main +
    245

    6    tmp4w7ywhox                        0x00005614340763d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979587
