language: swift
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            } else\
    \ {\n                stack.pop()\n            }\n        } else {\n          \
    \  if stack.isEmpty {\n                result = \"Yes\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeljrmmsy.swift:26:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.isEmpty {\n                return \"Yes\"\n            }\n      \
    \  }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmph4iqclyy.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0dlksbs.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   return \"\"\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxynt8tlf.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  } else {\n                stack.pop()\n            }\n        } else {\n  \
    \          if stack.isEmpty {\n                result = \"Yes\"\n            \
    \    break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjll5tara.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpjll5tara.swift:26:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n    \
    \    } else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.pop()\n        } else {\n         \
    \   if stack.count < 1 {\n                return \"No\"\n            }\n     \
    \   }\n    }\n    if stack.count != 0 {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9a72_7ny.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n            stack.append(s)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbh15uy7v/tmpbh15uy7v.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d0d18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d0a0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d0a0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d0a0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbh15uy7v                        0x000056261bac8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b61d0f04460 __libc_start_main +
    245

    6    tmpbh15uy7v                        0x000056261bac83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] += s\n            } else {\n\
    \                result = \"Yes\"\n                break\n            }\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpntf_o9z8.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpntf_o9z8.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmpntf_o9z8.swift:28:22: error: cannot find 'len'\
    \ in scope\n            if stack[len(stack)-1] == \"(\" {\n                  \
    \   ^~~\n/tmp/tmpntf_o9z8.swift:29:23: error: cannot find 'len' in scope\n   \
    \             stack[len(stack)-1] += s\n                      ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    guard lst.count\
    \ >= 2 else { return \"No\" }\n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.count > 0 {\n          \
    \      stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpo4mq8bc8/tmpo4mq8bc8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba50e67bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba50e372b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba50e372988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba50e3717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4mq8bc8                        0x0000559fd657d960 <unavailable> + 6496

    5    libc.so.6                          0x00002ba50e867460 __libc_start_main +
    245

    6    tmpo4mq8bc8                        0x0000559fd657d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if len(stack) == 0 {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.isEmpty {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvgbcbpvk.swift:21:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpvgbcbpvk.swift:24:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.push(s)\n        } else if s == \")\" {\n            if stack.len()\
    \ == 0 {\n                result = \"No\"\n                break\n           \
    \ }\n            stack.pop()\n        } else {\n            if stack.len() !=\
    \ 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7lrcwk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack()\n\
    \    for s in lst {\n        if s == '(' {\n            stack.push(s)\n      \
    \  } else if s == ')' {\n            if stack.top() == '(' {\n               \
    \ stack.pop()\n            } else {\n                return \"No\"\n         \
    \   }\n        } else {\n            return \"No\"\n        }\n    }\n    if stack.top()\
    \ != nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbyb3exue.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpbyb3exue.swift:20:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpbyb3exue.swift:21:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpbyb3exue.swift:16:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824858
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd2m0pazo/tmpd2m0pazo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76c0e4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76c0b41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76c0b41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76c0b407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2m0pazo                        0x0000559ed6886960 <unavailable> + 6496

    5    libc.so.6                          0x00002b76c1036460 __libc_start_main +
    245

    6    tmpd2m0pazo                        0x0000559ed68863d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           stack.removeLast()\n        } else if stack.isEmpty {\n          \
    \  result = \"Yes\"\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp49trg0xx/tmp49trg0xx.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b196dc53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b196d94ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b196d94a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b196d9497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp49trg0xx                        0x000055813ce73aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b196de3f460 __libc_start_main +
    245

    6    tmp49trg0xx                        0x000055813ce733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824859
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if len(stack)\
    \ == 0 {\n                result = \"Yes\"\n                break\n          \
    \  }\n            stack.pop()\n        } else {\n            if stack[len(stack)-1]\
    \ != s {\n                result = \"No\"\n                break\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpna0h7l36.swift:22:16: error: cannot find 'len' in scope\n     \
    \       if len(stack) == 0 {\n               ^~~\n/tmp/tmpna0h7l36.swift:26:19:\
    \ error: value of type '[String]' has no member 'pop'\n            stack.pop()\n\
    \            ~~~~~ ^~~\n/tmp/tmpna0h7l36.swift:28:22: error: cannot find 'len'\
    \ in scope\n            if stack[len(stack)-1] != s {\n                     ^~~\n"
  stdout: ''
  timestamp: 1659824858
