name: HumanEval_103_rounded_avg
language: swift
prompt: "\nextension Int: Error {}\n        \n/// You are given two positive integers\
  \ n and m, and your task is to compute the\n/// average of the integers from n through\
  \ m (including n and m). \n/// Round the answer to the nearest integer and convert\
  \ that to binary.\n/// If n is greater than m, return -1.\n/// Example:\n/// >>>\
  \ rounded_avg(n: 1, m: 5)\n/// .success(\"0b11\")\n/// >>> rounded_avg(n: 7, m:\
  \ 5)\n/// .failure(-1)\n/// >>> rounded_avg(n: 10, m: 20)\n/// .success(\"0b1111\"\
  )\n/// >>> rounded_avg(n: 20, m: 33)\n/// .success(\"0b11010\")\nfunc rounded_avg(n:\
  \ Int, m: Int) -> Result<String, Int> {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"\
  ))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n:\
  \ 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997)\
  \ == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"\
  0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"\
  ))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n:\
  \ 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233)\
  \ == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\n\
  assert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5)\
  \ == .success(\"0b101\"))"
completions: ["    if n > m {\n        return .failure(-1)\n    }\n    let sum = n\
    \ * m / 2\n    let remainder = n * m % 2\n    let result = String(format: \"0b%0*b\"\
    , remainder, sum)\n    return .success(result)", "    let sum = n * m / 2\n  \
    \  let avg = sum / 2\n    let binary = String(format: \"%0*b%0*b\", Int(ceil(log2(Float(sum)))),\
    \ sum, Int(ceil(log2(Float(avg)))), avg)\n    guard let bin = binary.unicodeScalars.first\
    \ else { return .failure(-1) }\n    return .success(bin)", "    let sum = n *\
    \ m / 2\n    let avg = sum / 2\n    let binary = String(format: \"%b\", UInt8(avg))\n\
    \    guard let bin = binary.unicodeScalars.first else {\n        return .failure(-1)\n\
    \    }\n    return .success(bin)", "    if n < m {\n        return .failure(-1)\n\
    \    }\n    let sum = (n - m) / 2\n    let binary = String(sum, radix: 2)\n  \
    \  return .success(binary)", "    \n    let result = n / m\n    let remainder\
    \ = n % m\n    \n    if remainder == 0 {\n        return .success(String(format:\
    \ \"0b%0*b\", result.count, result))\n    }\n    \n    return .failure(-1)", " \
    \   let sum = n * m\n    let avg = sum / 2\n    let remainder = sum % 2\n    \n\
    \    if remainder == 0 {\n        return .success(String(format: \"0b%b\", avg))\n\
    \    } else {\n        return .failure(-1)\n    }", "    if n >= m {\n       \
    \ return .failure(-1)\n    }\n    let sum = n * m / 2\n    let binary = String(sum)\n\
    \    let rounded = Int(binary)\n    return .success(binary)", "    let sum = n\
    \ + m\n    let avg = sum / 2\n    let binary = String(format: \"%0*b%0*b\", 0,\
    \ Int(avg), 0, Int(sum))\n    return binary.isValid() ? .success(binary) : .failure(-1)",
  "    let sum = n * m\n    let avg = sum / Double(n)\n    let rounded = Int(round(avg))\n\
    \    return if rounded == avg { return .success(String(rounded)) } else { return\
    \ .failure(-1) }", "    guard n >= 0 && m >= 0 else {\n        return .failure(-1)\n\
    \    }\n    \n    let sum = n * m / 2\n    let remainder = n * m % 2\n    \n \
    \   let result = (sum + remainder).rounded(.towardZero)\n    \n    if result <\
    \ 0 {\n        return .failure(-1)\n    }\n    \n    return .success(String(result))",
  "    let n = n.toInt()\n    let m = m.toInt()\n    \n    if n > m {\n        return\
    \ .failure(-1)\n    }\n    \n    let sum = n * m / 2\n    let binary = String(sum,\
    \ radix: 2)\n    \n    return .success(binary)", "    guard n >= 0 && m >= 0 else\
    \ {\n        return .failure(-1)\n    }\n    \n    let sum = n * m / 2\n    let\
    \ remainder = n % 2\n    \n    if remainder == 0 {\n        return .success(String(format:\
    \ \"0b%0*b\", Int(m), sum))\n    }\n    \n    return .failure(-1)", "    let result\
    \ = n / m\n    let remainder = n % m\n    if remainder == 0 {\n        return\
    \ .success(String(format: \"0b%0*b\", result.bitCount, result))\n    }\n    return\
    \ .failure(-1)", "    if n > m {\n        return .failure(-1)\n    }\n    \n \
    \   let sum = n * m / 2\n    let remainder = n * m % 2\n    \n    return .success(String(format:\
    \ \"0b%0*b\", (remainder + 1).count, remainder))", "    let sum = n + m\n    let\
    \ avg = sum / 2\n    let binary = String(format: \"%0*b%0*b\", Int(ceil(log2(Float(sum)))),\
    \ n, m, avg)\n    return binary.roundToInt().map(String.init)", "    let sum =\
    \ n * m / 2\n    let remainder = n * m % 2\n    if remainder == 0 {\n        return\
    \ .success(String(sum))\n    }\n    return .failure(-1)", "    let result = n\
    \ / m\n    if result > m {\n        return .failure(-1)\n    }\n    return .success(String(format:\
    \ \"0b%0*b\", result.magnitude, result))", "    guard n >= 0 && m >= 0 else {\n\
    \        return .failure(-1)\n    }\n    \n    let sum = n * m / 2\n    let avg\
    \ = sum / 2\n    let binary = String(format: \"%0*b\", Int(ceil(log2(Double(sum)))),\
    \ avg)\n    \n    if binary == \"0b0\" {\n        return .success(binary)\n  \
    \  }\n    \n    return .failure(-1)", "    let result = n / m\n    let remainder\
    \ = n % m\n    \n    if remainder == 0 {\n        return .success(String(format:\
    \ \"0b%0*b\", m.toBinary(), result))\n    }\n    \n    return .failure(-1)", " \
    \   if n > m {\n        return .failure(-1)\n    }\n    \n    var sum = 0\n  \
    \  for i in 0..<m {\n        sum += i\n    }\n    \n    var result = \"\"\n  \
    \  for i in 0..<n {\n        let digit = sum % 2 == 0 ? \"0\" : \"1\"\n      \
    \  result += digit\n        sum /= 2\n    }\n    \n    return .success(result)"]
stop_tokens:
- "\n}"
