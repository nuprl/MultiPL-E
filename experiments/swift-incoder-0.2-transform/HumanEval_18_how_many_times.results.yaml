language: swift
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp16n0_oq4.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp16n0_oq4.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp16n0_oq4.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_occurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0mthzj1n.swift:10:12: error: cannot find 'count_occurrences' in\
    \ scope\n    return count_occurrences(string, substring)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) || string.hasSuffix(substring) {\n   \
    \     return how_many_times(string[string.startIndex..<string.endIndex], substring)\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \   }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8ataffe8.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmp8ataffe8.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp8ataffe8.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmp8ataffe8.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp8ataffe8.swift:23:30:\
    \ error: missing argument labels 'string:substring:' in call\n        return how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring) + how_many_times(string[string.endIndex..<string.startIndex], substring)\n\
    \                             ^\n                              string:       \
    \                               substring: \n/tmp/tmp8ataffe8.swift:23:37: error:\
    \ subscript 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \        return how_many_times(string[string.startIndex..<string.endIndex], substring)\
    \ + how_many_times(string[str"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, options: .caseInsensitive)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        end = start\n        count += 1\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpclp81b2e.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpclp81b2e.swift:17:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpclp81b2e.swift:17:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmpclp81b2e.swift:17:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex && j < string.endIndex {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else {\n            i += 1\n        }\n        j += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk0p0xey4.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpk0p0xey4.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpk0p0xey4.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex && j < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpk0p0xey4.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpk0p0xey4.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpk0p0xey4.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpk0p0xey4.swift:26:11: error:\
    \ binary operator '+=' cannot be applied to operands of type 'String.Index' and\
    \ 'Int'\n        j += 1\n        ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    } else {\n        return\
    \ string.countSubstrings(substring) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobzrh2eu.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpobzrh2eu.swift:13:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\
    \ + 1\n               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count += 1\n        }\n        i += 1\n     \
    \   k += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwmtjv_ol.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpwmtjv_ol.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpwmtjv_ol.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpwmtjv_ol.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpwmtjv_ol.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwmtjv_ol.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += how_many_times(string: String(string[i..<k]), substring:\
    \ String(substring[1..<string.count]))\n            i += k\n            k += string.count\n\
    \        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptlciat0s.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmptlciat0s.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptlciat0s.swift:22:52:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            count += how_many_times(string:\
    \ String(string[i..<k]), substring: String(substring[1..<string.count]))\n   \
    \                                                ^~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmptlciat0s.swift:22:86: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n            count += how_many_times(string: String(string[i..<k]),\
    \ substring: String(substring[1..<string.count]))\n                          \
    \                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmptlciat0s.swift:18:9: warning:\
    \ variable 'j' was never mutated; consider changing to 'let' constant\n    var\
    \ j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = 0\n    var m = string.characters.count\n    var n = substring.characters.count\n\
    \    while i < m && j < n {\n        if string.characters[i] == substring.characters[j]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        }\
    \ else if string.characters[i] == substring.characters[j] {\n            count\
    \ += 1\n            i += 1\n        } else {\n            j += 1\n        }\n\
    \    }\n    if i < m {\n        while i < m {\n            if string.characters[i]\
    \ == substring.characters[j] {\n                count += 1\n                i\
    \ += 1\n            } else {\n                i += 1\n            }\n        }\n\
    \    }\n    if j < n {\n        while j < n {\n            if string.characters[i]\
    \ == substring.characters[j] {\n                count += 1\n                j\
    \ += 1\n            } else {\n                j += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptcf4enab.swift:21:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var m = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmptcf4enab.swift:22:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var n =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptcf4enab.swift:24:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[j] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptcf4enab.swift:24:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptcf4enab.swift:24:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[j] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmptcf4enab.swift:24:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptcf4enab.swift:28:19:\
    \ error: 'subs"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex += 1\n            continue\n        }\n        count +=\
    \ 1\n        startIndex = endIndex + 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpld5i3_ww.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpld5i3_ww.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpld5i3_ww.swift:20:27:\
    \ error: no exact matches in call to instance method 'index'\n        endIndex\
    \ = string.index(substring, startIndex)\n                          ^\n/tmp/tmpld5i3_ww.swift:20:27:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    \
    \    endIndex = string.index(substring, startIndex)\n                        \
    \  ^\n/tmp/tmpld5i3_ww.swift:20:27: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        endIndex = string.index(substring, startIndex)\n    \
    \               ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return string.countSubstrings(substring)\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppec4qd_l.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppec4qd_l.swift:13:19: error: value of\
    \ type 'String' has no member 'countSubstrings'\n    return string.countSubstrings(substring)\
    \ + 1\n           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            i++\n            count++\n            while i < j && string[i]\
    \ == substring[1] {\n                i++\n                count++\n          \
    \  }\n        } else {\n            i++\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpanjk8f9p.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpanjk8f9p.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpanjk8f9p.swift:22:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  i++\n             ^~\n/tmp/tmpanjk8f9p.swift:23:18: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            count++\n                 ^~\n\
    /tmp/tmpanjk8f9p.swift:24:28: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n            while i < j &&\
    \ string[i] == substring[1] {\n                           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpanjk8f9p.swift:24:41:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while i < j && string[i] == substring[1]\
    \ {\n                                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpanjk8f9p.swift:25:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      i++\n                 ^~\n/tmp/tmpanjk8f9p.swift:26:22: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                count++\n    \
    \                 ^~\n/tmp/tmpanjk8f9p.swift:29:14: error: cannot find"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = string.startIndex.advanced(by: 1)\n\
    \        end = string.endIndex.advanced(by: -1)\n        if string.substring(from:\
    \ start, to: end) == substring {\n            count += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoa7oars4.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpoa7oars4.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpoa7oars4.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpoa7oars4.swift:20:35: error: value of type 'String.Index'\
    \ has no member 'advanced'\n        start = string.startIndex.advanced(by: 1)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpoa7oars4.swift:21:31: error:\
    \ value of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ -1)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpoa7oars4.swift:22:19: error:\
    \ value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start, to: end) == substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += k\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj7pftlsq.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpj7pftlsq.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpj7pftlsq.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmpj7pftlsq.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        } else {\n            count = 0\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1e3bhdqm.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcsm3raxz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpcsm3raxz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzfey0u0_.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpzfey0u0_.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpzfey0u0_.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpzfey0u0_.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcsm3raxz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpcsm3raxz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ 1)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppb0fwavf.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(), substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplnkyk3gu.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                 ^\n                                  string:\
    \             substring: \n/tmp/tmplnkyk3gu.swift:17:42: error: cannot convert\
    \ value of type 'String.SubSequence' (aka 'Substring') to expected argument type\
    \ 'String'\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                         ^\n                                \
    \  String(           )\n/tmp/tmplnkyk3gu.swift:20:34: error: missing argument\
    \ labels 'string:substring:' in call\n        return 1 + how_many_times(string.dropLast(),\
    \ substring)\n                                 ^\n                           \
    \       string:            substring: \n/tmp/tmplnkyk3gu.swift:20:42: error: cannot\
    \ convert value of type 'String.SubSequence' (aka 'Substring') to expected argument\
    \ type 'String'\n        return 1 + how_many_times(string.dropLast(), substring)\n\
    \                                         ^\n                                \
    \  String(          )\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzfey0u0_.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpzfey0u0_.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpzfey0u0_.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpzfey0u0_.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count = count + 1\n        }\n        i = i +\
    \ 1\n        k = k - 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvucrq6sr.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpvucrq6sr.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpvucrq6sr.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpvucrq6sr.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvucrq6sr.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvucrq6sr.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp053d206r.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphzset7ju.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ 1)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppb0fwavf.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpulfwzc6d.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpulfwzc6d.swift:14:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpulfwzc6d.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpulfwzc6d.swift:14:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    for c in string {\n\
    \        if c == substring {\n            count += 1\n        } else {\n     \
    \       count = 0\n        }\n        if i == string.count {\n            break\n\
    \        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdjh68j1j.swift:19:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmpdjh68j1j.swift:19:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    while startIndex < string.count {\n        endIndex\
    \ = string.index(substring, startIndex)\n        if endIndex == startIndex {\n\
    \            count += 1\n            startIndex = string.index(substring, startIndex)\
    \ + 1\n        } else {\n            count += endIndex - startIndex\n        \
    \    startIndex = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa2tq0m_6.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpa2tq0m_6.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmpa2tq0m_6.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpa2tq0m_6.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa2tq0m_6.swift:23:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpa2tq0m_6.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpa2tq0m_6.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpa2tq0m_6.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpa2tq0m_6.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, from: start)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\
    \ + 1\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwzd93smn.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwzd93smn.swift:17:66:\
    \ error: extra argument 'from' in call\n        let index = string.characters.index(of:\
    \ substring, from: start)\n                                           ~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpwzd93smn.swift:17:49: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = string.characters.index(of: substring, from: start)\n                    \
    \                            ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j && k < string.count {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n        } else if string[i] == substring[k] && k < string.count {\n  \
    \          i += 1\n            k += 1\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkv3fsl3l.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpkv3fsl3l.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkv3fsl3l.swift:25:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] == substring[k] &&\
    \ k < string.count {\n                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpkv3fsl3l.swift:25:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[k] && k < string.count {\n         \
    \                      ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpkv3fsl3l.swift:18:9: warning: variable\
    \ 'j' was never mutated; consider changing to 'let' constant\n    var j = string.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string.characters[i]\
    \ == substring.characters[k] {\n            count += 1\n            i += 1\n \
    \           k += 1\n            if k == substring.characters.count {\n       \
    \         k = 0\n            }\n        } else {\n            i += 1\n       \
    \ }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmz9cz83g.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpmz9cz83g.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpmz9cz83g.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmz9cz83g.swift:21:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpmz9cz83g.swift:21:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpmz9cz83g.swift:21:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmz9cz83g.swift:25:31:\
    \ error: 'char"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.count\n    var k = substring.count\n    while\
    \ i < j {\n        if string[i] == substring[k] {\n            count += 1\n  \
    \          i += k\n            k += k\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvtkjztq5.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvtkjztq5.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvtkjztq5.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += k\n        } else {\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8ix1v5y8.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8ix1v5y8.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8ix1v5y8.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp8ix1v5y8.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8ix1v5y8.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8ix1v5y8.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    while i < string.count {\n        if string[i]\
    \ == substring[j] {\n            count += 1\n            i += 1\n            j\
    \ += 1\n            if j == substring.count {\n                j = 0\n       \
    \     }\n        } else {\n            j = 0\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdwzf33_c.swift:17:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdwzf33_c.swift:17:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end)\n        if start == end {\n        \
    \    count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp089lxd21.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp089lxd21.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp089lxd21.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp089lxd21.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmp089lxd21.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end)\n\
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\
    \ else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbknvk_wq.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpbknvk_wq.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpbknvk_wq.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpbknvk_wq.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw7h674tz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpw7h674tz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n/tmp/tmpw7h674tz.swift:17:23:\
    \ error: cannot call value of non-function type 'Int'\n        return string.count(substring)\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqlib6lbk.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqlib6lbk.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else if string[i] == substring[1]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[2] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[3] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[4] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[5] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[6]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[7] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[8] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[9] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[10] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[11]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[12] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[13] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[14] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[15] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[16]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[17] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[18] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[19] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[20] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[21]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[22] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[23] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[24] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[25] {\n            count += 1\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpudocwob8.swift:116:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpudocwob8.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpudocwob8.swift:116:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpudocwob8.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpudocwob8.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpudocwob8.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpudocwob8.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpudocwob8.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpudocwob8.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  if string.substring(start, end) == substring {\n            count += 1\n  \
    \          start = end + 1\n        } else {\n            start = string.index(string.startIndex,\
    \ offsetBy: start)\n            end = string.index(string.endIndex, offsetBy:\
    \ end)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3vwuxecu.swift:17:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(start, end) == substring {\n      \
    \     ~~~~~~ ^~~~~~~~~\n/tmp/tmp3vwuxecu.swift:21:28: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            start = string.index(string.startIndex,\
    \ offsetBy: start)\n                    ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3vwuxecu.swift:22:26: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            end = string.index(string.endIndex, offsetBy: end)\n\
    \                  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcsm3raxz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpcsm3raxz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphzset7ju.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.count\n    var k = substring.count\n    while i < j {\n    \
    \    if string[i] == substring[k] {\n            count += 1\n            i +=\
    \ 1\n            k += 1\n            if k == substring.count {\n             \
    \   k = 0\n            }\n        } else {\n            i += 1\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkbhq09j6.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpkbhq09j6.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkbhq09j6.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += k\n        } else {\n            i += k\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy5z8svp1.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpy5z8svp1.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpy5z8svp1.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpy5z8svp1.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpy5z8svp1.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy5z8svp1.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  let index = string.index(start, offsetBy: substring.count)\n        if index\
    \ == nil {\n            break\n        }\n        start = index!\n        count\
    \ += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6t59vqvv.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for c in string {\n        if c == substring {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjik59mw1.swift:12:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmpjik59mw1.swift:12:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count = count + 1\n        }\n        i += 1\n\
    \        k += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpor5j2jeb.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpor5j2jeb.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpor5j2jeb.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpor5j2jeb.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpor5j2jeb.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpor5j2jeb.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.startIndex..<string.endIndex.predecessor()], substring)\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyjbo008q.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                  substring: \n\
    /tmp/tmpyjbo008q.swift:17:41: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpyjbo008q.swift:17:60:\
    \ error: value of type 'String.Index' has no member 'successor'\n        return\
    \ 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpyjbo008q.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                    substring:\
    \ \n/tmp/tmpyjbo008q.swift:20:41: error: subscript 'subscript(_:)' requires the\
    \ types 'String.Index' and 'Int' be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpyjbo008q.swift:20:78:\
    \ error: value of type 'String.Index' has no member 'predecessor'\n        return\
    \ 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                                             "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.distance(from: string.startIndex, to:\
    \ string.endIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm_8pbuqr.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3nvoi8po.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp3nvoi8po.swift:19:31:\
    \ note: to match this opening '{'\n    while i < string.endIndex {\n         \
    \                     ^\n/tmp/tmp3nvoi8po.swift:114:67: error: expected '}' at\
    \ end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmp3nvoi8po.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmp3nvoi8po.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmp3nvoi8po.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmp3nvoi8po.swift:19:13: error:\
    \ operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp3nvoi8po.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp3nvoi8po.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3nvoi8po.swift:22:28:\
    \ error: value of t"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ += 1\n        }\n        i += 1\n        k += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8qndq0rv.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8qndq0rv.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8qndq0rv.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8qndq0rv.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp8qndq0rv.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string.characters[i] == substring.characters[k]\
    \ {\n            count += 1\n            i += k\n            k -= 1\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8j28ixg4.swift:12:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8j28ixg4.swift:13:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8j28ixg4.swift:15:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8j28ixg4.swift:15:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8j28ixg4.swift:15:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8j28ixg4.swift:15:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8j28ixg4.swift:12:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += k\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplz_is4b_.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmplz_is4b_.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmplz_is4b_.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmplz_is4b_.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplz_is4b_.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmplz_is4b_.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var last = 0\n    var last2 = 0\n    var last3 = 0\n    var last4 = 0\n  \
    \  var last5 = 0\n    var last6 = 0\n    var last7 = 0\n    var last8 = 0\n  \
    \  var last9 = 0\n    var last10 = 0\n    var last11 = 0\n    var last12 = 0\n\
    \    var last13 = 0\n    var last14 = 0\n    var last15 = 0\n    var last16 =\
    \ 0\n    var last17 = 0\n    var last18 = 0\n    var last19 = 0\n    var last20\
    \ = 0\n    var last21 = 0\n    var last22 = 0\n    var last23 = 0\n    var last24\
    \ = 0\n    var last25 = 0\n    var last26 = 0\n    var last27 = 0\n    var last28\
    \ = 0\n    var last29 = 0\n    var last30 = 0\n    var last31 = 0\n    var last32\
    \ = 0\n    var last33 = 0\n    var last34 = 0\n    var last35 = 0\n    var last36\
    \ = 0\n    var last37 = 0\n    var last38 = 0\n    var last39 = 0\n    var last40\
    \ = 0\n    var last41 = 0\n    var last42 = 0\n    var last43 = 0\n    var last44\
    \ = 0\n    var last45 = 0\n    var last46 = 0\n    var last47 = 0\n    var last48\
    \ = 0\n    var last49 = 0\n    var last50 = 0\n    var last51 = 0\n    var last52\
    \ = 0\n    var last53 = 0\n    var last54 = 0\n    var last55 = 0\n    var last56\
    \ = 0\n    var last57 = 0\n    var last58 = 0\n    var last59 = 0\n    var last60\
    \ = 0\n    var last61 = 0\n    var last62 = 0\n    var last63 = 0\n    var last64\
    \ = 0\n    var last65 = 0\n    var last66 = 0\n    var last67 = 0\n    var last68\
    \ = 0\n    var last69 = 0\n    var last70 = 0\n    var last71 = 0\n    var last72\
    \ = 0\n    var last73 = 0\n    var last74 = 0\n    var last75 = 0\n    var last76\
    \ = 0\n    var last77 = 0\n    var last78 = 0\n    var last79 = 0\n    var last80\
    \ = 0\n    var last81 = 0\n    var last82 = 0\n    var last83 = 0\n    var last84\
    \ = 0\n    var last85 = 0\n    var last86 = 0\n    var last87 = 0\n    var last88\
    \ = 0\n    var last89 = 0\n    var last90 = 0\n    var last91 = 0\n    var last92\
    \ = 0\n    var last93 = 0\n    var last94 = 0\n    var last95 = 0\n    var last96\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcqselcr6.swift:115:9: error: type annotation missing in pattern\n\
    \    var last96\n        ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            while i < string.endIndex\
    \ && string[i] == substring[1] {\n                i += 1\n            }\n    \
    \        j = i\n        } else {\n            i = 0\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprramhvs_.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmprramhvs_.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprramhvs_.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmprramhvs_.swift:23:21: error: operator function\
    \ '<' requires that 'String.Index' conform to 'BinaryInteger'\n            while\
    \ i < string.endIndex && string[i] == substring[1] {\n                    ^\n\
    Swift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n    public static\
    \ func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger\n\
    \                       ^\n/tmp/tmprramhvs_.swift:26:17: error: cannot assign\
    \ value of type 'Int' to type 'String.Index'\n            j = i\n            \
    \    ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += k\n        } else {\n            i += k\n            k += k\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz3sag_4h.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpz3sag_4h.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpz3sag_4h.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpz3sag_4h.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz3sag_4h.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpz3sag_4h.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\", true)\n    }\n    var count = 0\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    var found = false\n    for index in 0..<string.characters.count\
    \ {\n        if found {\n            if string.characters[index] == substring.characters[0]\
    \ {\n                count += 1\n                startIndex = index\n        \
    \        found = false\n            } else {\n                count = 0\n    \
    \            startIndex = index\n                found = false\n            }\n\
    \        } else {\n            if string.characters[index] == substring.characters[0]\
    \ {\n                count += 1\n                startIndex = index\n        \
    \    } else {\n                count = 0\n                startIndex = index\n\
    \            }\n        }\n        if string.characters[index] == substring.characters[substring.characters.count\
    \ - 1] {\n            found = true\n            endIndex = index\n        }\n\
    \    }\n    if count > 0 {\n        return count\n    }\n    if endIndex == startIndex\
    \ {\n        return 0\n    }\n    return countOccurrences(string, substring, true)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3ksadab9.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\", true)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp3ksadab9.swift:20:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp3ksadab9.swift:22:16: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n            if string.characters[index]\
    \ == substring.characters[0] {\n               ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3ksadab9.swift:22:23:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if string.characters[index] == substring.characters[0] {\n                 \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp3ksadab9.swift:22:44:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if string.characters[index] == substring.characters[0]\
    \ {\n                                           ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3ksadab9.swift:22:54:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if string.characters[index] == substring.characters[0] {\n                 \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3ksadab9.swift:32:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String wit"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var stringLength = string.characters.count\n\
    \    var substringLength = substring.characters.count\n    while i < stringLength\
    \ && j < substringLength {\n        if string.characters[i] == substring.characters[j]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        }\
    \ else {\n            if string.characters[i] != substring.characters[j] {\n \
    \               count += 1\n                i += 1\n            }\n          \
    \  if string.characters[i] != substring.characters[j] {\n                j +=\
    \ 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpukqw6koz.swift:14:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpukqw6koz.swift:15:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var substringLength = substring.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpukqw6koz.swift:17:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string.characters[i] == substring.characters[j] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpukqw6koz.swift:17:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpukqw6koz.swift:17:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[j] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpukqw6koz.swift:17:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n         "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var i = 0\n    var j = 0\n    var k = string.startIndex\n\n    while i <\
    \ string.endIndex {\n        if k == string.endIndex {\n            break\n  \
    \      }\n\n        if string[k] == substring[j] {\n            count += 1\n \
    \           j += 1\n            if j == substring.count {\n                j =\
    \ 0\n                k += 1\n            }\n        } else {\n            j =\
    \ 0\n            k += 1\n        }\n\n        i += 1\n    }\n\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfkbtpg_q.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpfkbtpg_q.swift:24:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfkbtpg_q.swift:29:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                k += 1\n                ~ ^  ~\n/tmp/tmpfkbtpg_q.swift:33:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            k += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    return string.distance(from: start, to: end)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpapdw13nm.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpapdw13nm.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpapdw13nm.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpapdw13nm.swift:11:63: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let count = string.distance(from: start, to: end)\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdfeco_y_.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdfeco_y_.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpdfeco_y_.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdfeco_y_.swift:11:63: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let count =\
    \ string.characters.filter({ $0 == substring }).count\n    return count > 0 ?\
    \ count : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcl0xyjd8.swift:10:47: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n    let\
    \ count = string.characters.filter({ $0 == substring }).count\n              \
    \                             ~~ ^  ~~~~~~~~~\n/tmp/tmpcl0xyjd8.swift:10:47: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n    let count = string.characters.filter({ $0\
    \ == substring }).count\n                                              ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd8stxwvm.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpd8stxwvm.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpd8stxwvm.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpd8stxwvm.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpd8stxwvm.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpd8stxwvm.swift:23:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' ="
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphzset7ju.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.characters.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.characters.count,\
    \ limitedBy: string.endIndex) ?? string.endIndex\n        if index == string.endIndex\
    \ {\n            count += 1\n            break\n        }\n        if string[index]\
    \ != substring[0] {\n            count += 1\n            start = index\n     \
    \   } else {\n            start = index + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvpuv8cf3.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpvpuv8cf3.swift:20:34:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        let index = string.index(start, offsetBy: substring.characters.count,\
    \ limitedBy: string.endIndex) ?? string.endIndex\n                           \
    \      ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var lastCharIndex = 0\n    var lastSubstringIndex = 0\n    var lastSubstringIndex2\
    \ = 0\n    var lastSubstringIndex3 = 0\n    var lastSubstringIndex4 = 0\n    var\
    \ lastSubstringIndex5 = 0\n    var lastSubstringIndex6 = 0\n    var lastSubstringIndex7\
    \ = 0\n    var lastSubstringIndex8 = 0\n    var lastSubstringIndex9 = 0\n    var\
    \ lastSubstringIndex10 = 0\n    var lastSubstringIndex11 = 0\n    var lastSubstringIndex12\
    \ = 0\n    var lastSubstringIndex13 = 0\n    var lastSubstringIndex14 = 0\n  \
    \  var lastSubstringIndex15 = 0\n    var lastSubstringIndex16 = 0\n    var lastSubstringIndex17\
    \ = 0\n    var lastSubstringIndex18 = 0\n    var lastSubstringIndex19 = 0\n  \
    \  var lastSubstringIndex20 = 0\n    var lastSubstringIndex21 = 0\n    var lastSubstringIndex22\
    \ = 0\n    var lastSubstringIndex23 = 0\n    var lastSubstringIndex24 = 0\n  \
    \  var lastSubstringIndex25 = 0\n    var lastSubstringIndex26 = 0\n    var lastSubstringIndex27\
    \ = 0\n    var lastSubstringIndex28 = 0\n    var lastSubstringIndex29 = 0\n  \
    \  var lastSubstringIndex30 = 0\n    var lastSubstringIndex31 = 0\n    var lastSubstringIndex32\
    \ = 0\n    var lastSubstringIndex33 = 0\n    var lastSubstringIndex34 = 0\n  \
    \  var lastSubstringIndex35 = 0\n    var lastSubstringIndex36 = 0\n    var lastSubstringIndex37\
    \ = 0\n    var lastSubstringIndex38 = 0\n    var lastSubstringIndex39 = 0\n  \
    \  var lastSubstringIndex40 = 0\n    var lastSubstringIndex41 = 0\n    var lastSubstringIndex42\
    \ = 0\n    var lastSubstringIndex43 = 0\n    var lastSubstringIndex44 = 0\n  \
    \  var lastSubstringIndex45 = 0\n    var lastSubstringIndex46 = 0\n    var lastSubstringIndex47\
    \ = 0\n    var lastSubstringIndex48 = 0\n    var lastSubstringIndex49 = 0\n  \
    \  var lastSubstringIndex50 = 0\n    var lastSubstringIndex51 = 0\n    var lastSubstringIndex52\
    \ = 0\n    var lastSubstringIndex53 = 0\n    var lastSubstringIndex54 = 0\n  \
    \  var lastSubstringIndex55 = 0\n    var lastSubstringIndex56 = 0\n    var lastSubstringIndex57\
    \ = 0\n    var lastSubstringIndex58 = 0\n    var lastSubstringIndex59 = 0\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphrsd___f.swift:16:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmphrsd___f.swift:17:9: warning:\
    \ initialization of variable 'i' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmphrsd___f.swift:18:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmphrsd___f.swift:19:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmphrsd___f.swift:20:9:\
    \ warning: initialization of variable 'lastCharIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var lastCharIndex = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmphrsd___f.swift:21:9: warning: initialization\
    \ of variable 'lastSubstringIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var lastSubstringIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmphrsd___f.swift:22:9: warning: initialization of variable 'lastSubstringIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var lastSubstringIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphrsd___f.swift:23:9:\
    \ warning: initialization of variable 'lastSubstringIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var lastSubstringIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphrsd___f.swift:24:9: warning:\
    \ initialization of variable 'lastSubstringIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var lastSubstringIndex4 = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphrsd___f.swift:25:9: warning: initialization\
    \ of variable 'lastSubstringIndex5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var lastSubstringIndex5 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmphrsd_"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            while i < string.endIndex\
    \ && string[i] == substring[1] {\n                i += 1\n            }\n    \
    \        if i == string.endIndex {\n                count += 1\n            }\n\
    \        } else {\n            count = 0\n        }\n        if j == string.endIndex\
    \ {\n            break\n        }\n        j = string.index(i, j)\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpftwvnnkb.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpftwvnnkb.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpftwvnnkb.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpftwvnnkb.swift:23:21: error: operator function\
    \ '<' requires that 'String.Index' conform to 'BinaryInteger'\n            while\
    \ i < string.endIndex && string[i] == substring[1] {\n                    ^\n\
    Swift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n    public static\
    \ func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger\n\
    \                       ^\n/tmp/tmpftwvnnkb.swift:26:18: error: operator function\
    \ '==' requires that 'String.Index' conform to 'BinaryInteger'\n            if\
    \ i == string.endIndex {\n                 ^\nSwift.BinaryInteger:2:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func == <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpftwvnnkb.swift:35:25: error: missing argument label 'offsetBy:' in call\n\
    \        j = string.index(i, j)\n                        ^\n                 \
    \           offsetBy: \n/tmp/tmpftwvnnkb.swift:35:29: error: unnamed argument\
    \ #2 must precede unnamed argument #1\n "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for char in string {\n        if char == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi9pxlszp.swift:12:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpi9pxlszp.swift:12:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i = j\n        } else {\n            j += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjfpimqve.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpjfpimqve.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpjfpimqve.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpjfpimqve.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpjfpimqve.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjfpimqve.swift:22:17:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  i = j\n                ^\n/tmp/tmpjfpimqve.swift:24:15: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \      j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[index] {\n            count += 1\n        } else {\n\
    \            if count > 0 {\n                count -= 1\n            }\n     \
    \       last = index\n        }\n    }\n    if count > 0 {\n        count -= 1\n\
    \    }\n    return count + last - string.characters.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6nyrppox.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp6nyrppox.swift:16:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[index] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6nyrppox.swift:16:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6nyrppox.swift:16:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[index] {\n      \
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6nyrppox.swift:16:50:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                                         \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6nyrppox.swift:28:34:\
    \ error: 'characters' is unavailable: Please use String directly\n    return count\
    \ + last - string.characters.count\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphzset7ju.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else {\n\
    \            count = 0\n            i += 1\n        }\n        if i == string.endIndex\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6bl5134d.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp6bl5134d.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6bl5134d.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp6bl5134d.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n/tmp/tmp6bl5134d.swift:27:14: error: operator function\
    \ '==' requires that 'String.Index' conform to 'BinaryInteger'\n        if i ==\
    \ string.endIndex {\n             ^\nSwift.BinaryInteger:2:24: note: where 'Other'\
    \ = 'String.Index'\n    public static func == <Other>(lhs: Self, rhs: Other) ->\
    \ Bool where Other : BinaryInteger\n                       ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ != substring[j] {\n            count = count + 1\n        }\n        i += 1\n\
    \        j += 1\n    }\n    while k < substring.characters.count {\n        if\
    \ string[k] != substring[k] {\n            count = count + 1\n        }\n    \
    \    k += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe9wc94ru.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpe9wc94ru.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpe9wc94ru.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpe9wc94ru.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpe9wc94ru.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpe9wc94ru.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpe9wc94ru.swift:27:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    while k\
    \ < substring.characters.count {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpe9wc94ru.swift:28:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[k] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been expl"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string, substring.dropLast(substring.length))\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1tww0qg8.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmp1tww0qg8.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmp1tww0qg8.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmp1tww0qg8.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string, substring.dropLast(substring.length))\n\
    \                                 ^\n                                  string:\
    \ substring: \n/tmp/tmp1tww0qg8.swift:20:53: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \        return 1 + how_many_times(string, substring.dropLast(substring.length))\n\
    \                                                    ^\n                     \
    \                     String(                             )\n/tmp/tmp1tww0qg8.swift:20:72:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string,\
    \ substring.dropLast(substring.length))\n                                    \
    \                         ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ substring.count)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppk06ke67.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end)\n        if start == end {\n        \
    \    count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp089lxd21.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp089lxd21.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp089lxd21.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp089lxd21.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmp089lxd21.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end)\n\
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ -= 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_kvm6qph.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp_kvm6qph.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp_kvm6qph.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp_kvm6qph.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_kvm6qph.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_kvm6qph.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcsm3raxz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpcsm3raxz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else {\n            i += 1\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk0pzm8er.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpk0pzm8er.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpk0pzm8er.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    return countOccurrences(string, substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppt1wwf2t.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmppt1wwf2t.swift:16:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            if i == string.endIndex\
    \ {\n                i = string.startIndex\n                j += 1\n         \
    \   }\n        } else {\n            i = 0\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpouzb64u7.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpouzb64u7.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpouzb64u7.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpouzb64u7.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpouzb64u7.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpouzb64u7.swift:23:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if i == string.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpouzb64u7.swift:24:28: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n                i = string.startIndex\n                    ~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpouzb64u7.swift:25:19: error: binary operator '+=' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n                j += 1\n        \
    \        ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += 1\n            k\
    \ += 1\n            if k == substring.characters.count {\n                k =\
    \ 0\n            }\n        } else {\n            i += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbniu2fff.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbniu2fff.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpbniu2fff.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbniu2fff.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbniu2fff.swift:25:31: error: 'characters' is\
    \ unavailable: Please use String directly\n            if k == substring.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbniu2fff.swift:18:9: warning: variable 'j' was never\
    \ mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = endIndex + 1\n        } else {\n            count +=\
    \ 1\n            startIndex = endIndex + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcvpd9flu.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpcvpd9flu.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpcvpd9flu.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string, substring.dropLast())\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return 1 + how_many_times(string.dropFirst(), substring)\n    }\n\
    \    if string.hasSuffix(substring) {\n        return 1 + how_many_times(string,\
    \ substring.dropLast())\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplm926wj5.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                 ^\n                                  string:\
    \             substring: \n/tmp/tmplm926wj5.swift:17:42: error: cannot convert\
    \ value of type 'String.SubSequence' (aka 'Substring') to expected argument type\
    \ 'String'\n        return 1 + how_many_times(string.dropFirst(), substring)\n\
    \                                         ^\n                                \
    \  String(           )\n/tmp/tmplm926wj5.swift:20:34: error: missing argument\
    \ labels 'string:substring:' in call\n        return 1 + how_many_times(string,\
    \ substring.dropLast())\n                                 ^\n                \
    \                  string: substring: \n/tmp/tmplm926wj5.swift:20:53: error: cannot\
    \ convert value of type 'String.SubSequence' (aka 'Substring') to expected argument\
    \ type 'String'\n        return 1 + how_many_times(string, substring.dropLast())\n\
    \                                                    ^\n                     \
    \                     String(             )\n/tmp/tmplm926wj5.swift:23:34: error:\
    \ missing argument labels 'string:substring:' in call\n        return 1 + how_many_times(string.dropFirst(),\
    \ substring)\n                                 ^\n                           \
    \       string:             substring: \n/tmp/tmplm926wj5.swift:23:42: error:\
    \ cannot convert value of type 'String.SubSequence' (aka 'Substring') to expected\
    \ argument type 'String'\n        return 1 + how_many_times(string.dropFirst(),\
    \ substring)\n                                         ^\n                   \
    \               String(           )\n/tmp/tmplm926wj5.swift:26:34: error: missing\
    \ argument labels 'string:substring:' in call\n        return 1 + how_many_times(string,\
    \ substring.dropLast())\n                                 ^\n                \
    \                  string: substring: \n/tmp/tmplm926wj5.swift:26:53: error: cannot\
    \ convert value of type 'String.SubSequence' (aka 'Substring') to expected argument\
    \ ty"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            i += 1\n            count += k\n            if i == j {\n   \
    \             i += 1\n                count += k\n            }\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp590a43hh.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp590a43hh.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp590a43hh.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmp590a43hh.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzfey0u0_.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpzfey0u0_.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpzfey0u0_.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpzfey0u0_.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd8stxwvm.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpd8stxwvm.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpd8stxwvm.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpd8stxwvm.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpd8stxwvm.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpd8stxwvm.swift:23:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' ="
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    } else {\n        return\
    \ string.countSubstrings(substring) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobzrh2eu.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpobzrh2eu.swift:13:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\
    \ + 1\n               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end+1)\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpt1__x2un.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpt1__x2un.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpt1__x2un.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpt1__x2un.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpt1__x2un.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end+1)\n\
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    } else {\n        return\
    \ string.countSubstrings(substring) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobzrh2eu.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpobzrh2eu.swift:13:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\
    \ + 1\n               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var last = 0\n    var found = false\n    for i < string.count {\n        if\
    \ string[i] == substring[0] {\n            found = true\n            for j < substring.count\
    \ {\n                if string[i+j] == substring[j] {\n                    found\
    \ = true\n                    j++\n                } else {\n                \
    \    found = false\n                    break\n                }\n           \
    \ }\n            if found {\n                count++\n                last = i\n\
    \                i += j\n            } else {\n                count++\n     \
    \           last = i\n                i += j + 1\n            }\n        } else\
    \ {\n            count++\n            last = i\n            i += 1\n        }\n\
    \    }\n    if last == string.count {\n        return count\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf1e9b3yy.swift:22:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmpf1e9b3yy.swift:22:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmpf1e9b3yy.swift:25:19: error: expected\
    \ 'in' after for-each pattern\n            for j < substring.count {\n       \
    \           ^\n/tmp/tmpf1e9b3yy.swift:25:19: error: unary operator cannot be separated\
    \ from its operand\n            for j < substring.count {\n                  ^~\n\
    \                   \n/tmp/tmpf1e9b3yy.swift:22:11: error: '<' is not a prefix\
    \ unary operator\n    for i < string.count {\n          ^\n/tmp/tmpf1e9b3yy.swift:25:19:\
    \ error: '<' is not a prefix unary operator\n            for j < substring.count\
    \ {\n                  ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    while i < j {\n       \
    \ if string.characters[i] == substring.characters[0] {\n            count += 1\n\
    \            i += 1\n            continue\n        }\n        if string.characters[i]\
    \ == substring.characters[1] {\n            count += 1\n            i += 2\n \
    \           continue\n        }\n        if string.characters[i] == substring.characters[2]\
    \ {\n            count += 1\n            i += 3\n            continue\n      \
    \  }\n        if string.characters[i] == substring.characters[3] {\n         \
    \   count += 1\n            i += 4\n            continue\n        }\n        if\
    \ string.characters[i] == substring.characters[4] {\n            count += 1\n\
    \            i += 5\n            continue\n        }\n        if string.characters[i]\
    \ == substring.characters[5] {\n            count += 1\n            i += 6\n \
    \           continue\n        }\n        if string.characters[i] == substring.characters[6]\
    \ {\n            count += 1\n            i += 7\n            continue\n      \
    \  }\n        if string.characters[i] == substring.characters[7] {\n         \
    \   count += 1\n            i += 8\n            continue\n        }\n        if\
    \ string.characters[i] == substring.characters[8] {\n            count += 1\n\
    \            i += 9\n            continue\n        }\n        if string.characters[i]\
    \ == substring.characters[9] {\n            count += 1\n            i += 10\n\
    \            continue\n        }\n        if string.characters[i] == substring.characters[10]\
    \ {\n            count += 1\n            i += 11\n            continue\n     \
    \   }\n        if string.characters[i] == substring.characters[11] {\n       \
    \     count += 1\n            i += 12\n            continue\n        }\n     \
    \   if string.characters[i] == substring.characters[12] {\n            count +=\
    \ 1\n            i += 13\n            continue\n        }\n        if string.characters[i]\
    \ == substring.characters[13] {\n            count += 1\n            i += 14\n\
    \            continue\n        }\n        if string.characters[i] == substring.characters[14]\
    \ {\n            count += 1\n            i += 15\n            continue\n     \
    \   }\n        if string.characters[i] == substring.characters[15] {\n       \
    \     count += 1\n            i += 16\n            continue\n        }\n     \
    \   if string.characters[i] == substring.characters[16] {\n            count +=\
    \ 1\n            i += 17\n            continue\n        }\n        if string.characters[i]\
    \ == substring.characters[17] {\n            count += 1\n            i += 18\n\
    \            continue\n        }\n        if string.characters[i] == substring.characters[18]\
    \ {\n            count += 1\n            i += 19\n            continue\n     \
    \   }\n        if string.characters[i] == substring.characters[19] {\n       \
    \     count += 1\n            i += 20\n            continue\n        }\n     \
    \   if string.characters[i] == substring.characters[20] {\n            count +=\
    \ 1\n            i += 21\n            continue\n        }\n        if \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwzys1cg1.swift:122:11: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmpwzys1cg1.swift:141:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpwzys1cg1.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpwzys1cg1.swift:15:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpwzys1cg1.swift:17:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwzys1cg1.swift:17:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpwzys1cg1.swift:17:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[0] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwzys1cg1.swift:17:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[0] {\n     "
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return string.countSubstrings(substring)\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppec4qd_l.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppec4qd_l.swift:13:19: error: value of\
    \ type 'String' has no member 'countSubstrings'\n    return string.countSubstrings(substring)\
    \ + 1\n           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var startIndex = string.startIndex\n    var endIndex = string.endIndex\n\
    \    while startIndex != endIndex {\n        let index = string.index(startIndex,\
    \ offsetBy: substring.count)\n        if index != endIndex {\n            count\
    \ += 1\n        }\n        startIndex = index\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: Exception
  stderr: 'tmpr9a1velm/tmpr9a1velm.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ddc933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ddc62ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ddc62a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ddc6297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9a1velm                        0x000055703386b4e2 <unavailable> + 5346

    5    libc.so.6                          0x00002b2ddcb1f460 __libc_start_main +
    245

    6    tmpr9a1velm                        0x000055703386b059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    }\n    return 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpulfwzc6d.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpulfwzc6d.swift:14:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSubstrings(substring)\n    } else {\n        return\
    \ string.countSubstrings(substring) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobzrh2eu.swift:11:23: error: value of type 'String' has no member\
    \ 'countSubstrings'\n        return string.countSubstrings(substring)\n      \
    \         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpobzrh2eu.swift:13:23: error: value of\
    \ type 'String' has no member 'countSubstrings'\n        return string.countSubstrings(substring)\
    \ + 1\n               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \    return string.distance(from: start, to: end) / substring.length\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpn_mva_9k.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpn_mva_9k.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpn_mva_9k.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpn_mva_9k.swift:11:61: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpn_mva_9k.swift:12:62:\
    \ error: value of type 'String' has no member 'length'\n    return string.distance(from:\
    \ start, to: end) / substring.length\n                                       \
    \            ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    return index == nil ? 0 : index!.distance(string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_acwfpel.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = string.count\n\
    \    while startIndex < endIndex {\n        let index = string.index(startIndex,\
    \ offsetBy: substring.count)\n        if index == startIndex {\n            startIndex\
    \ += substring.count\n            continue\n        }\n        if index == endIndex\
    \ {\n            endIndex -= substring.count\n            continue\n        }\n\
    \        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n            count += 1\n            startIndex = index\n        }\n     \
    \   startIndex = index\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpobs213cm.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(startIndex,\
    \ offsetBy: substring.count)\n                                 ^\n/tmp/tmpobs213cm.swift:29:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = string.startIndex\n    while i < string.endIndex\
    \ {\n        if string[k] == substring[j] {\n            count += 1\n        \
    \    i += 1\n            j += 1\n            if j == substring.count {\n     \
    \           j = 0\n                k += 1\n            }\n        } else {\n \
    \           j = 0\n            k += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0vqt9pom.swift:17:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp0vqt9pom.swift:18:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0vqt9pom.swift:24:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                k += 1\n                ~ ^  ~\n/tmp/tmp0vqt9pom.swift:28:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            k += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var start = 0\n    var end = string.characters.count\n\n    while start <\
    \ end {\n        let index = string.characters.index(of: substring, options: .caseInsensitive)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\
    \ + 1\n        end = start\n        count += 1\n    }\n\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl2rxkztt.swift:16:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpl2rxkztt.swift:19:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpl2rxkztt.swift:19:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmpl2rxkztt.swift:19:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = string.index(substring, startIndex) + 1\n        } else\
    \ {\n            count += 1\n            startIndex = endIndex + 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcj18eftx.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpcj18eftx.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpcj18eftx.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcj18eftx.swift:23:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpcj18eftx.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpcj18eftx.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        let mid = start + (end - start) / 2\n      \
    \  if string[mid] == substring[0] {\n            start = mid + 1\n           \
    \ count += 1\n        } else if string[mid] == substring[1] {\n            end\
    \ = mid - 1\n            count += 2\n        } else {\n            start = mid\
    \ + 1\n            end = mid - 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzuhnni0h.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpzuhnni0h.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpzuhnni0h.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[k] == substring[j] {\n   \
    \         count += 1\n            i += 1\n            j += 1\n            if j\
    \ == substring.endIndex {\n                j = 0\n                k += 1\n   \
    \         }\n        } else {\n            i = 0\n            j += 1\n       \
    \     if j == substring.endIndex {\n                j = 0\n                k +=\
    \ 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzr2hdys6.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpzr2hdys6.swift:21:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzr2hdys6.swift:25:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if j == substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpzr2hdys6.swift:27:19: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n                k += 1\n     \
    \           ~ ^  ~\n/tmp/tmpzr2hdys6.swift:32:18: error: operator function '=='\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n            if j ==\
    \ substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func == <Other>(lhs: Self, rhs:\
    \ Other) -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpzr2hdys6.swift:34:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                k += 1\n                ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end) + 1\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_dtolfyj.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp_dtolfyj.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp_dtolfyj.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp_dtolfyj.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmp_dtolfyj.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end)\
    \ + 1\n              ^~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n            count += 1\n   \
    \     }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbzhwtejc.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbzhwtejc.swift:12:57: error: cannot find 'NSMakeRange' in scope\n\
    \        if string.characters.contains(substring, range: NSMakeRange(index, substring.length))\
    \ {\n                                                        ^~~~~~~~~~~\n/tmp/tmpbzhwtejc.swift:12:57:\
    \ error: extra argument 'range' in call\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n                           \
    \          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbzhwtejc.swift:12:86:\
    \ error: value of type 'String' has no member 'length'\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n                           \
    \                                                ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) || string.hasSuffix(substring) {\n   \
    \     return how_many_times(string[string.startIndex..<string.endIndex], substring)\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \   }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8ataffe8.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmp8ataffe8.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp8ataffe8.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmp8ataffe8.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp8ataffe8.swift:23:30:\
    \ error: missing argument labels 'string:substring:' in call\n        return how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring) + how_many_times(string[string.endIndex..<string.startIndex], substring)\n\
    \                             ^\n                              string:       \
    \                               substring: \n/tmp/tmp8ataffe8.swift:23:37: error:\
    \ subscript 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \        return how_many_times(string[string.startIndex..<string.endIndex], substring)\
    \ + how_many_times(string[str"
  stdout: ''
  timestamp: 1659824991
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.index(of: substring)\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.characters.count - string.characters.index(of:\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3kao_bmk.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.index(of: substring)\n                                 ^\n/tmp/tmp3kao_bmk.swift:11:126:\
    \ error: cannot convert value of type 'String.Index?' to expected argument type\
    \ 'Int'\n    return index != nil ? string.distance(from: string.startIndex, to:\
    \ index!) : string.characters.count - string.characters.index(of: substring)\n\
    \                                                                            \
    \                                                 ^\n/tmp/tmp3kao_bmk.swift:11:136:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    return index != nil ? string.distance(from: string.startIndex,\
    \ to: index!) : string.characters.count - string.characters.index(of: substring)\n\
    \                                                                            \
    \                                                           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm8hf58sj.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbp3mggur.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpbp3mggur.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpbp3mggur.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpbp3mggur.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count += 1\n  \
    \          i += substring.length - 1\n        } else if string[i] == substring[1]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[2] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[3] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[4] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[5] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[6]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[7] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[8] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[9] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[10] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[11]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[12] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[13] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[14] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[15] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[16]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[17] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[18] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[19] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[20] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[21]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[22] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[23] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[24] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[25] {\n            count += 1\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpudocwob8.swift:116:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpudocwob8.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpudocwob8.swift:116:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpudocwob8.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpudocwob8.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpudocwob8.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpudocwob8.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpudocwob8.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpudocwob8.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var i = 0\n    var j = string.characters.count\n\n    while i < j {\n   \
    \     if string.characters[i] != substring.characters[i] {\n            count\
    \ += 1\n        }\n        i += 1\n    }\n\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuvsjws78.swift:16:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpuvsjws78.swift:19:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string.characters[i] != substring.characters[i]\
    \ {\n           ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpuvsjws78.swift:19:19: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[i] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpuvsjws78.swift:19:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[i] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpuvsjws78.swift:19:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[i] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpuvsjws78.swift:16:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.characters.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \       } else {\n            count += endIndex - startIndex\n        }\n    \
    \    startIndex = endIndex + 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpt9sjl_4b.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpt9sjl_4b.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpt9sjl_4b.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    var k = string.endIndex\n    while i < k {\n        if string[j] != substring[i]\
    \ {\n            count += 1\n            i = j\n        } else {\n           \
    \ i += 1\n        }\n        if i == k {\n            break\n        }\n     \
    \   j = i\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpg55i856u.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpg55i856u.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpg55i856u.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < k {\n            ^\nSwift.BinaryInteger:4:24: note: where 'Other'\
    \ = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other) ->\
    \ Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpg55i856u.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[j] != substring[i] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpg55i856u.swift:23:17: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            i = j\n                ^\n\
    /tmp/tmpg55i856u.swift:27:14: error: operator function '==' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n        if i == k {\n             ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpg55i856u.swift:30:13: error: cannot assign value of type 'Int'\
    \ to type 'String.Index'\n        j = i\n            ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count = countOccurrences(string, substring)\n            i +=\
    \ substring.length - 1\n        } else {\n            i += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps7j5j7j1.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmps7j5j7j1.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmps7j5j7j1.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps7j5j7j1.swift:21:21:\
    \ error: cannot find 'countOccurrences' in scope\n            count = countOccurrences(string,\
    \ substring)\n                    ^~~~~~~~~~~~~~~~\n/tmp/tmps7j5j7j1.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ ho\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmce24jyv.swift:81:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpmce24jyv.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpmce24jyv.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpmce24jyv.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpmce24jyv.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpmce24jyv.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpmce24jyv.swift:23:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex..<string.endIndex], substring)\n \
    \                    "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, options: .caseInsensitive)\n\
    \        if index == nil {\n            break\n        }\n        let start =\
    \ index!\n        let end = start+substring.length\n        if end > end {\n \
    \           break\n        }\n        count += 1\n        start = end\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5jwk38q_.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp5jwk38q_.swift:17:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp5jwk38q_.swift:17:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmp5jwk38q_.swift:17:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n/tmp/tmp5jwk38q_.swift:22:35:\
    \ error: value of type 'String' has no member 'length'\n        let end = start+substring.length\n\
    \                        ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = 0\n    var m = string.characters.count\n    var n = substring.characters.count\n\
    \    for (i; i < m; i++ {\n        if string[i] == substring[j] {\n          \
    \  count++\n            j++\n            if j == n {\n                j = 0\n\
    \                k++\n                if k == m {\n                    k = 0\n\
    \                    l++\n                    if l == n {\n                  \
    \      l = 0\n                        i++\n                        if i == m {\n\
    \                            i = 0\n                            count++\n    \
    \                        if count == 1 {\n                                return\
    \ count\n                            }\n                        }\n          \
    \          }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpom3j6g6u.swift:23:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i; i < m; i++ {\n    ^   ~~~~~~~~~~~~~~~~\n/tmp/tmpom3j6g6u.swift:48:17:\
    \ error: expected '{' to start the body of for-each loop\n    return count\n \
    \               ^\n/tmp/tmpom3j6g6u.swift:21:20: error: 'characters' is unavailable:\
    \ Please use String directly\n    var m = string.characters.count\n          \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpom3j6g6u.swift:22:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var n =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!.advanced(by:\
    \ substring.count)\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppk06ke67.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let range = start..<end\n    return string.distance(from: range.lowerBound,\
    \ to: range.upperBound)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2g_j6how.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp2g_j6how.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcsm3raxz.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmpcsm3raxz.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.count\n    while start < end {\n      \
    \  start = string.index(substring, start) + 1\n        end = string.index(substring,\
    \ end) + 1\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7bewtzpj.swift:17:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmp7bewtzpj.swift:17:24: error: no exact\
    \ matches in call to instance method 'index'\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp7bewtzpj.swift:17:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp7bewtzpj.swift:17:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp7bewtzpj.swift:17:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp7bewtzpj.swift:18:22: error: no\
    \ exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp7bewtzpj.swift:18:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmp7bewtzpj.swift:18:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmp7bewtzpj.swift:18:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n/tmp/tmp7bewtzpj.swift:18:22: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        end =\
    \ string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbp3mggur.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpbp3mggur.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpbp3mggur.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpbp3mggur.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex).offsetByOrThrow(string.distance(startIndex, string.startIndex))\n\
    \        if endIndex == startIndex {\n            count += 1\n        } else {\n\
    \            count += endIndex - startIndex + 1\n        }\n        startIndex\
    \ = endIndex + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqg18pwfv.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex).offsetByOrThrow(string.distance(startIndex,\
    \ string.startIndex))\n                          ^\n/tmp/tmpqg18pwfv.swift:20:27:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    \
    \    endIndex = string.index(substring, startIndex).offsetByOrThrow(string.distance(startIndex,\
    \ string.startIndex))\n                          ^\n/tmp/tmpqg18pwfv.swift:20:79:\
    \ error: no exact matches in call to instance method 'distance'\n        endIndex\
    \ = string.index(substring, startIndex).offsetByOrThrow(string.distance(startIndex,\
    \ string.startIndex))\n                                                      \
    \                        ^\n/tmp/tmpqg18pwfv.swift:20:79: note: found candidate\
    \ with type '(String.Index, String.Index) -> Int'\n        endIndex = string.index(substring,\
    \ startIndex).offsetByOrThrow(string.distance(startIndex, string.startIndex))\n\
    \                                                                            \
    \  ^\n/tmp/tmpqg18pwfv.swift:20:56: error: value of type 'String.Index' has no\
    \ member 'offsetByOrThrow'\n        endIndex = string.index(substring, startIndex).offsetByOrThrow(string.distance(startIndex,\
    \ string.startIndex))\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   for i < string.count {\n        if string[i] == substring[0] {\n         \
    \   count += 1\n            i = i + 1\n            for j < substring.count {\n\
    \                if string[i+j] == substring[j] {\n                    count =\
    \ count + 1\n                    i = i + j + 1\n                    j = j + j\
    \ + 1\n                    k = k + 1\n                }\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbhh3exb4.swift:20:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmpbhh3exb4.swift:20:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmpbhh3exb4.swift:24:19: error: expected\
    \ 'in' after for-each pattern\n            for j < substring.count {\n       \
    \           ^\n/tmp/tmpbhh3exb4.swift:24:19: error: unary operator cannot be separated\
    \ from its operand\n            for j < substring.count {\n                  ^~\n\
    \                   \n/tmp/tmpbhh3exb4.swift:20:11: error: '<' is not a prefix\
    \ unary operator\n    for i < string.count {\n          ^\n/tmp/tmpbhh3exb4.swift:24:19:\
    \ error: '<' is not a prefix unary operator\n            for j < substring.count\
    \ {\n                  ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n   \
    \ var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var\
    \ s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x\
    \ = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n    var ac\
    \ = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n    var\
    \ ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al = 0\n   \
    \ var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq = 0\n\
    \    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var av =\
    \ 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n    var ba\
    \ = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n    var\
    \ bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj = 0\n   \
    \ var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo = 0\n\
    \    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var bt =\
    \ 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n    var bx = 0\n    var by\
    \ = 0\n    var bz = 0\n    var ca = 0\n    var cb = 0\n    var cc = 0\n    var\
    \ cd = 0\n    var ce = 0\n    var cf = 0\n    var cg = 0\n    var ch = 0\n   \
    \ var ci = 0\n    var cj = 0\n    var ck = 0\n    var cl = 0\n    var cm = 0\n\
    \    var cn = 0\n    var co = 0\n    var cp = 0\n    var cq = 0\n    var cr =\
    \ 0\n    var cs = 0\n    var ct = 0\n    var cu = 0\n    var cv = 0\n    var cw\
    \ = 0\n    var cx = 0\n    var cy = 0\n    var cz = 0\n    var da = 0\n    var\
    \ db = 0\n    var dc = 0\n    var dd = 0\n    var de = 0\n    var df = 0\n   \
    \ var dg = 0\n    var dh = 0\n    var di = 0\n    var dj = 0\n    var dk = 0\n\
    \    var dl = 0\n    var dm = 0\n    var dn = 0\n    var do = 0\n    var dp =\
    \ 0\n    var dq = 0\n    var dr = 0\n    var ds = 0\n    var dt = 0\n    var du\
    \ = 0\n    var dv = 0\n    var dw = 0\n    var dx = 0\n    var dy = 0\n    var\
    \ dz = 0\n    var ea = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd1obulq3.swift:50:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpd1obulq3.swift:50:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpd1obulq3.swift:124:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmpd1obulq3.swift:124:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmpd1obulq3.swift:13:9: warning: initialization\
    \ of variable 'count' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpd1obulq3.swift:14:9:\
    \ warning: initialization of variable 'i' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:15:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:16:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:17:9:\
    \ warning: initialization of variable 'l' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var l = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:18:9:\
    \ warning: initialization of variable 'm' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var m = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:19:9:\
    \ warning: initialization of variable 'n' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var n = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:20:9:\
    \ warning: initialization of variable 'o' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var o = 0\n    ~~~~^\n    _\n/tmp/tmpd1obulq3.swift:21:9:\
    \ warning: initialization of variable 'p' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var p = 0\n    ~~~~^\n    _\n/tmp"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[1] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[2]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[3] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[4] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[5] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[6] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[7]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[8] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[9] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[10] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[11] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[12]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[13] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[14] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[15] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[16] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[17]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[18] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[19] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[20] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[21] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[22]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[23] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[24] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[25] {\n            count += 1\n            i += substring.length\
    \ - 1\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb3_iy83x.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpb3_iy83x.swift:16:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpb3_iy83x.swift:114:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpb3_iy83x.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpb3_iy83x.swift:17:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpb3_iy83x.swift:17:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb3_iy83x.swift:19:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpb3_iy83x.swift:20:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb3_iy83x.swift:20:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[k] {\n            count += 1\n            i += k\n            k\
    \ += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkoyhos9k.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpkoyhos9k.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkoyhos9k.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkoyhos9k.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpkoyhos9k.swift:18:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpapzkmrh8.swift:20:24: error: no exact matches in call to instance\
    \ method 'index'\n        start = string.index(substring, start) + 1\n       \
    \                ^\n/tmp/tmpapzkmrh8.swift:20:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpapzkmrh8.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpapzkmrh8.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpapzkmrh8.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpapzkmrh8.swift:21:22: error: no exact\
    \ matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmpapzkmrh8.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpapzkmrh8.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmpapzkmrh8.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n/tmp/tmpapzkmrh8.swift:21:22: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        end =\
    \ string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex && j < string.endIndex {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else {\n            i += 1\n        }\n        if j == string.endIndex\
    \ {\n            j += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpg7anv05m.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex &&\
    \ j < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpg7anv05m.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpg7anv05m.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg7anv05m.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpg7anv05m.swift:27:15: error:\
    \ binary operator '+=' cannot be applied to operands of type 'String.Index' and\
    \ 'Int'\n            j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index != nil {\n            count += 1\n            start = index!\n\
    \        } else {\n            start = end\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6_10zuba.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += 1\n            while i < string.endIndex\
    \ && string[i] == substring[1] {\n                i += 1\n            }\n    \
    \    } else {\n            count = 0\n        }\n        if count == substring.length\
    \ - 1 {\n            return count\n        }\n        if j == string.endIndex\
    \ {\n            return count\n        }\n        j = string.index(string.startIndex,\
    \ offsetBy: 1)\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnwz_6cxa.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpnwz_6cxa.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpnwz_6cxa.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpnwz_6cxa.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpnwz_6cxa.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnwz_6cxa.swift:23:21:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            while i < string.endIndex && string[i] == substring[1] {\n      \
    \              ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpnwz_6cxa.swift:29:31: error:\
    \ value of type 'String' has no member 'length'\n        if count == substring.length\
    \ - 1 {\n                    ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var lastIndex = string.startIndex\n    while lastIndex != string.endIndex {\n\
    \        if string.substring(lastIndex) == substring {\n            count += 1\n\
    \        }\n        lastIndex += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp06y7ixnf.swift:16:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(lastIndex) == substring {\n       \
    \    ~~~~~~ ^~~~~~~~~\n/tmp/tmp06y7ixnf.swift:19:19: error: binary operator '+='\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n        lastIndex\
    \ += 1\n        ~~~~~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = string.startIndex\n    while i < string.endIndex\
    \ {\n        if k == string.startIndex {\n            j = string.startIndex\n\
    \        } else {\n            j = string.index(k, offsetBy: 1)\n        }\n \
    \       if string.substring(from: i, length: substring.length) == substring {\n\
    \            count += 1\n        }\n        k = j\n        i += 1\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphs7xn1hp.swift:17:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmphs7xn1hp.swift:19:24: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n            j = string.startIndex\n\
    \                ~~~~~~~^~~~~~~~~~\n/tmp/tmphs7xn1hp.swift:21:24: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            j = string.index(k,\
    \ offsetBy: 1)\n                ~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphs7xn1hp.swift:23:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ i, length: substring.length) == substring {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmphs7xn1hp.swift:23:56:\
    \ error: value of type 'String' has no member 'length'\n        if string.substring(from:\
    \ i, length: substring.length) == substring {\n                              \
    \               ~~~~~~~~~ ^~~~~~\n/tmp/tmphs7xn1hp.swift:26:13: error: cannot\
    \ assign value of type 'Int' to type 'String.Index'\n        k = j\n         \
    \   ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.startIndex..<string.endIndex.predecessor()], substring)\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyjbo008q.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                  substring: \n\
    /tmp/tmpyjbo008q.swift:17:41: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n        return 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpyjbo008q.swift:17:60:\
    \ error: value of type 'String.Index' has no member 'successor'\n        return\
    \ 1 + how_many_times(string[string.startIndex.successor()..<string.endIndex],\
    \ substring)\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpyjbo008q.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                    substring:\
    \ \n/tmp/tmpyjbo008q.swift:20:41: error: subscript 'subscript(_:)' requires the\
    \ types 'String.Index' and 'Int' be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpyjbo008q.swift:20:78:\
    \ error: value of type 'String.Index' has no member 'predecessor'\n        return\
    \ 1 + how_many_times(string[string.startIndex..<string.endIndex.predecessor()],\
    \ substring)\n                                                             "
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    var k = string.endIndex\n    while i < k {\n        if string[j] != substring[i]\
    \ {\n            count = count + 1\n        }\n        if string[j] == substring[i]\
    \ {\n            j = j + 1\n        }\n        i = i + 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprbcvgy7i.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < k {\n            ^\n\
    Swift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n    public static\
    \ func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger\n\
    \                       ^\n/tmp/tmprbcvgy7i.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[j] != substring[i] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprbcvgy7i.swift:24:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[j] == substring[i] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmprbcvgy7i.swift:25:19: error: binary operator\
    \ '+' cannot be applied to operands of type 'String.Index' and 'Int'\n       \
    \     j = j + 1\n                ~ ^ ~\n/tmp/tmprbcvgy7i.swift:25:19: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Int, Int)\n  \
    \          j = j + 1\n                  ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] != substring[k]\
    \ {\n            count += 1\n            i = j\n        } else {\n           \
    \ i += 1\n            k += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpod1siub7.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpod1siub7.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpod1siub7.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpod1siub7.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] != substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqlib6lbk.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqlib6lbk.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            i += 1\n            count += how_many_times(string: String(string[i..<j]),\
    \ substring: String(substring[1..<k]))\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpeg6o59m1.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpeg6o59m1.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpeg6o59m1.swift:23:52:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            count += how_many_times(string:\
    \ String(string[i..<j]), substring: String(substring[1..<k]))\n              \
    \                                     ^~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpeg6o59m1.swift:23:86: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \  count += how_many_times(string: String(string[i..<j]), substring: String(substring[1..<k]))\n\
    \                                                                            \
    \         ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpeg6o59m1.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmpeg6o59m1.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    "
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var start = 0\n    var end = string.characters.count\n    while start < end\
    \ {\n        let index = string.characters.index(of: substring, from: start)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\
    \ + 1\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwzd93smn.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwzd93smn.swift:17:66:\
    \ error: extra argument 'from' in call\n        let index = string.characters.index(of:\
    \ substring, from: start)\n                                           ~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpwzd93smn.swift:17:49: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = string.characters.index(of: substring, from: start)\n                    \
    \                            ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    var substring_start = string.startIndex\n    var substring_end = string.endIndex\n\
    \    while start < end {\n        if string.substring(start, start+substring.length)\
    \ == substring {\n            count += 1\n            start += substring.length\n\
    \        } else if string.substring(start, start+substring.length) == substring\
    \ {\n            count += 1\n            start += substring.length\n        }\
    \ else {\n            start = string.index(substring_start, start) + 1\n     \
    \       end = string.index(substring_end, start) - 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgxbh3kva.swift:22:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(start, start+substring.length) == substring\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpgxbh3kva.swift:22:52: error: value of\
    \ type 'String' has no member 'length'\n        if string.substring(start, start+substring.length)\
    \ == substring {\n                                         ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpgxbh3kva.swift:24:32: error: value of type 'String' has no member 'length'\n\
    \            start += substring.length\n                     ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpgxbh3kva.swift:25:26: error: value of type 'String' has no member 'substring'\n\
    \        } else if string.substring(start, start+substring.length) == substring\
    \ {\n                  ~~~~~~ ^~~~~~~~~\n/tmp/tmpgxbh3kva.swift:25:59: error:\
    \ value of type 'String' has no member 'length'\n        } else if string.substring(start,\
    \ start+substring.length) == substring {\n                                   \
    \             ~~~~~~~~~ ^~~~~~\n/tmp/tmpgxbh3kva.swift:27:32: error: value of\
    \ type 'String' has no member 'length'\n            start += substring.length\n\
    \                     ~~~~~~~~~ ^~~~~~\n/tmp/tmpgxbh3kva.swift:29:28: error: no\
    \ exact matches in call to instance method 'index'\n            start = string.index(substring_start,\
    \ start) + 1\n                           ^\n/tmp/tmpgxbh3kva.swift:29:28: note:\
    \ candidate has partially matching parameter list (String.Index, offsetBy: Int)\n\
    \            start = string.index(substring_start, start) + 1\n              \
    \             ^\n/tmp/tmpgxbh3kva.swift:29:28: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n            start = string.index(substring_start,\
    \ start) + 1\n                           ^\n/tmp/tmpgxbh3kva.swift:29:28: note:\
    \ candidate has partially matching parameter list (String.Index, offsetBy: Int)\n\
    \            start = string.index(substring_start, start) + 1\n              \
    \             ^\n/tmp/tmpgxbh3kva.swift:29:28: error: cannot convert value of\
    \ type 'String.Index' to expected argument typ"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string.characters[i] != substring.characters[k]\
    \ {\n            count += 1\n        }\n        i += 1\n        k += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy4pl767e.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpy4pl767e.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpy4pl767e.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpy4pl767e.swift:18:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpy4pl767e.swift:18:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] != substring.characters[k] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy4pl767e.swift:18:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ != substring.characters[k] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpy4pl767e.swift:15:9:\
    \ warning: vari"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string.dropLast(substring.length), substring)\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwzy7i7q8.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                             substring: \n/tmp/tmpwzy7i7q8.swift:17:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                           )\n/tmp/tmpwzy7i7q8.swift:17:62:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropFirst(substring.length),\
    \ substring)\n                                                   ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpwzy7i7q8.swift:20:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                 ^\n                           \
    \       string:                            substring: \n/tmp/tmpwzy7i7q8.swift:20:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                         ^\n                   \
    \               String(                          )\n/tmp/tmpwzy7i7q8.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        return 1 + how_many_times(string.dropLast(substring.length),\
    \ substring)\n                                                  ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplsvkcsi8.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp11l_fnbu.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring, true)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ range: NSRange(location: index, length: substring.length)) {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzbl_vq22.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzbl_vq22.swift:12:57: error: cannot find 'NSRange' in scope\n   \
    \     if string.characters.contains(substring, range: NSRange(location: index,\
    \ length: substring.length)) {\n                                             \
    \           ^~~~~~~\n/tmp/tmpzbl_vq22.swift:12:57: error: extra argument 'range'\
    \ in call\n        if string.characters.contains(substring, range: NSRange(location:\
    \ index, length: substring.length)) {\n                                     ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzbl_vq22.swift:12:100: error: value of type 'String' has no member 'length'\n\
    \        if string.characters.contains(substring, range: NSRange(location: index,\
    \ length: substring.length)) {\n                                             \
    \                                            ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\
    \ else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp23ictfue.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp23ictfue.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp23ictfue.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ countOccurrences(string, \"\")\n    }\n    var count = 0\n    var i = 0\n  \
    \  var j = string.count\n    var k = substring.count\n    while i < j {\n    \
    \    if string[i] == substring[0] {\n            count += countOccurrences(string,\
    \ string[i:])\n            i += k\n        } else {\n            i += 1\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp49emmxgq.swift:22:56: error: expected expression in list of expressions\n\
    \            count += countOccurrences(string, string[i:])\n                 \
    \                                      ^\n/tmp/tmp49emmxgq.swift:14:16: error:\
    \ cannot find 'countOccurrences' in scope\n        return countOccurrences(string,\
    \ \"\")\n               ^~~~~~~~~~~~~~~~\n/tmp/tmp49emmxgq.swift:21:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp49emmxgq.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp49emmxgq.swift:22:22: error: cannot find 'countOccurrences'\
    \ in scope\n            count += countOccurrences(string, string[i:])\n      \
    \               ^~~~~~~~~~~~~~~~\n/tmp/tmp49emmxgq.swift:22:56: error: missing\
    \ argument for parameter #1 in call\n            count += countOccurrences(string,\
    \ string[i:])\n                                                       ^\n    \
    \                                                   <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            i += 1\n            count += how_many_times(string: String(string[i..<k]),\
    \ substring: String(substring[k..<k]))\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfgum2srg.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfgum2srg.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfgum2srg.swift:23:52:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            count += how_many_times(string:\
    \ String(string[i..<k]), substring: String(substring[k..<k]))\n              \
    \                                     ^~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpfgum2srg.swift:23:86: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \  count += how_many_times(string: String(string[i..<k]), substring: String(substring[k..<k]))\n\
    \                                                                            \
    \         ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpfgum2srg.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmpfgum2srg.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    "
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var\
    \ k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += how_many_times(string: String(string.dropFirst(1)),\
    \ substring: String(substring.dropFirst(1)))\n            i += 1\n        }\n\
    \        if string[i] == substring[1] {\n            count += how_many_times(string:\
    \ String(string.dropFirst(1)), substring: String(substring.dropFirst(2)))\n  \
    \          i += 1\n        }\n        if string[i] == substring[2] {\n       \
    \     count += how_many_times(string: String(string.dropFirst(1)), substring:\
    \ String(substring.dropFirst(3)))\n            i += 1\n        }\n        if string[i]\
    \ == substring[3] {\n            count += how_many_times(string: String(string.dropFirst(1)),\
    \ substring: String(substring.dropFirst(4)))\n            i += 1\n        }\n\
    \        if string[i] == substring[4] {\n            count += how_many_times(string:\
    \ String(string.dropFirst(1)), substring: String(substring.dropFirst(5)))\n  \
    \          i += 1\n        }\n        if string[i] == substring[5] {\n       \
    \     count += how_many_times(string: String(string.dropFirst(1)), substring:\
    \ String(substring.dropFirst(6)))\n            i += 1\n        }\n        if string[i]\
    \ == substring[6] {\n            count += how_many_times(string: String(string.dropFirst(1)),\
    \ substring: String(substring.dropFirst(7)))\n            i += 1\n        }\n\
    \        if string[i] == substring[7] {\n            count += how_many_times(string:\
    \ String(string.dropFirst(1)), substring: String(substring.dropFirst(8)))\n  \
    \          i += 1\n        }\n        if string[i] == substring[8] {\n       \
    \     count += how_many_times(string: String(string.dropFirst(1)), substring:\
    \ String(substring.dropFirst(9)))\n            i += 1\n        }\n        if string[i]\
    \ == substring[9] {\n            count += how_many_times(string: String(string.dropFirst(1)),\
    \ substring: String(substring.dropFirst(10)))\n            i += 1\n        }\n\
    \        if string[i] == substring[10] {\n            count += how_many_times(string:\
    \ String(string.dropFirst(1)), substring: String(substring.dropFirst(11)))\n \
    \           i += 1\n        }\n        if string[i] == substring[11] {\n     \
    \       count += how_many_times(string: String(string.dropFirst(1)), substring:\
    \ String(substring.dropFirst(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppb1gvh6g.swift:67:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmppb1gvh6g.swift:85:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmppb1gvh6g.swift:20:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmppb1gvh6g.swift:85:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmppb1gvh6g.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmppb1gvh6g.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppb1gvh6g.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppb1gvh6g.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[1] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppb1gvh6g.swift:25:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[1] {\n                        ^~~~~~~~~~~~\nSwif"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += substring.length - 1\n        } else if string[i] ==\
    \ substring[1] {\n            count += 1\n            i += substring.length -\
    \ 1\n        } else if string[i] == substring[2] {\n            count += 1\n \
    \           i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgxf60p1j.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpgxf60p1j.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpgxf60p1j.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpgxf60p1j.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpgxf60p1j.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpgxf60p1j.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgxf60p1j.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpgxf60p1j.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgxf60p1j.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[k] == substring[j] {\n   \
    \         count += 1\n            i += k\n            j++\n            if j ==\
    \ substring.count {\n                j = 0\n                k += k\n         \
    \   }\n        } else {\n            j = 0\n            k += k\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7tve49l2.swift:20:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex {\n\
    \            ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmp7tve49l2.swift:21:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7tve49l2.swift:23:18:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            i += k\n                 ^\n/tmp/tmp7tve49l2.swift:24:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n/tmp/tmp7tve49l2.swift:27:19: error: binary operator\
    \ '+=' cannot be applied to two 'String.Index' operands\n                k +=\
    \ k\n                ~ ^  ~\n/tmp/tmp7tve49l2.swift:31:15: error: binary operator\
    \ '+=' cannot be applied to two 'String.Index' operands\n            k += k\n\
    \            ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     end = find(string, substring, end)\n        if start < end {\n         \
    \   count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw95rz2lx.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpw95rz2lx.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpw95rz2lx.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpw95rz2lx.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpw95rz2lx.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end)\n\
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += endIndex - startIndex\
    \ + 1\n            startIndex = endIndex + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa21chdr2.swift:17:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpa21chdr2.swift:17:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpa21chdr2.swift:17:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa21chdr2.swift:20:33: error: no exact matches in call to instance method\
    \ 'index'\n            startIndex = string.index(substring, startIndex) + 1\n\
    \                                ^\n/tmp/tmpa21chdr2.swift:20:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n/tmp/tmpa21chdr2.swift:20:33: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpa21chdr2.swift:20:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpa21chdr2.swift:20:33:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            startIndex = string.index(substring, startIndex) + 1\n  \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).contains(substring) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqducfdp0.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqducfdp0.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = string.index(substring, startIndex) + 1\n        } else\
    \ {\n            count += 1\n            startIndex = endIndex + 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcj18eftx.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpcj18eftx.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpcj18eftx.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcj18eftx.swift:23:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpcj18eftx.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpcj18eftx.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex = 0\n\
    \    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex)\n        if endIndex == startIndex {\n            count += 1\n \
    \           startIndex = string.index(substring, startIndex) + 1\n        } else\
    \ {\n            count += 1\n            startIndex = endIndex + 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcj18eftx.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpcj18eftx.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpcj18eftx.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcj18eftx.swift:23:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpcj18eftx.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpcj18eftx.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpcj18eftx.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string[string.startIndex.successor()...] == substring {\n \
    \       return 1 + how_many_times(string[string.startIndex.successor()...], substring)\n\
    \    }\n    if string[string.startIndex.successor()...] == substring.reversed()\
    \ {\n        return 1 + how_many_times(string[string.startIndex.successor()...],\
    \ substring.reversed())\n    }\n    return how_many_times(string[string.startIndex.successor()...],\
    \ substring) + how_many_times(string, substring)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplxcvhb5x.swift:16:33: error: value of type 'String.Index' has no\
    \ member 'successor'\n    if string[string.startIndex.successor()...] == substring\
    \ {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmplxcvhb5x.swift:17:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex.successor()...], substring)\n    \
    \                             ^\n                                  string:   \
    \                                substring: \n/tmp/tmplxcvhb5x.swift:17:60: error:\
    \ value of type 'String.Index' has no member 'successor'\n        return 1 + how_many_times(string[string.startIndex.successor()...],\
    \ substring)\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmplxcvhb5x.swift:19:62: error: cannot convert value of type '[String.Element]'\
    \ (aka 'Array<Character>') to expected argument type 'String.SubSequence' (aka\
    \ 'Substring')\n    if string[string.startIndex.successor()...] == substring.reversed()\
    \ {\n                                                             ^\n/tmp/tmplxcvhb5x.swift:19:33:\
    \ error: value of type 'String.Index' has no member 'successor'\n    if string[string.startIndex.successor()...]\
    \ == substring.reversed() {\n              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmplxcvhb5x.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.startIndex.successor()...], substring.reversed())\n\
    \                                 ^\n                                  string:\
    \                                   substring: \n/tmp/tmplxcvhb5x.swift:20:87:\
    \ error: cannot convert value of type 'ReversedCollection<String>' to expected\
    \ argument type 'String'\n        return 1 + how_many_times(string[string.startIndex.successor()...],\
    \ substring.reversed())\n                                                    \
    \                                  ^\n/tmp/tmplxcvhb5x.swift:20:60: error: value\
    \ of type 'String.Index' has no member 'successor'\n        return 1 + how_many_times(string[string.startIndex.success"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var\
    \ k = string.startIndex\n    while i < string.endIndex {\n        if string[k]\
    \ == substring[j] {\n            count += 1\n            i += 1\n            j\
    \ += 1\n            if j == substring.endIndex {\n                j = 0\n    \
    \            k += 1\n            }\n        } else {\n            i = 0\n    \
    \        j += 1\n            if j == substring.endIndex {\n                j =\
    \ 0\n                k += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8h0inysm.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8h0inysm.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8h0inysm.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp8h0inysm.swift:21:25: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[k] == substring[j]\
    \ {\n                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8h0inysm.swift:25:18: error: operator\
    \ function '==' requires that 'String.Index' conform to 'BinaryInteger'\n    \
    \        if j == substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmp8h0inysm.swift:27:19: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n                k += 1\n     \
    \           ~ ^  ~\n/tmp/tmp8h0inysm.swift:32:18: error: operator function '=='\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n            if j ==\
    \ substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func == <Other>(lhs: Self, rhs:\
    \ Other) -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp8h0inysm.swift:34:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                k += 1\n                ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ += 1\n            i = j\n        } else {\n            i += 1\n            k\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvqm41k1t.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpvqm41k1t.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvqm41k1t.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvqm41k1t.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpvqm41k1t.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    var k = 0\n    var stringLength = string.characters.count\n\
    \    var substringLength = substring.characters.count\n    while i < stringLength\
    \ && j < substringLength {\n        if string.characters[i] == substring.characters[j]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        }\
    \ else if string.characters[i] == substring.characters[j] {\n            count\
    \ += 1\n            i += 1\n        } else {\n            i += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgxa2yjlr.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgxa2yjlr.swift:18:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var substringLength = substring.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgxa2yjlr.swift:20:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string.characters[i] == substring.characters[j] {\n           ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgxa2yjlr.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgxa2yjlr.swift:20:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[i] == substring.characters[j] {\n              \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgxa2yjlr.swift:20:46: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters[i]\
    \ == substring.characters[j] {\n                                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n         "
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var i = 0\n    var j = string.count\n    while i < j {\n        if string[i]\
    \ == substring {\n            count += 1\n            i += substring.length -\
    \ 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxry6p7vc.swift:14:18: error: no exact matches in call to subscript\
    \ \n        if string[i] == substring {\n                 ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmpxry6p7vc.swift:16:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.distance(from: string.startIndex, to:\
    \ string.endIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm_8pbuqr.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += substring.length - 1\n        } else {\n            i\
    \ = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4eb1fhga.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4eb1fhga.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4eb1fhga.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    while i < j {\n        if string[i] == substring[0] {\n            count\
    \ += 1\n            i += substring.length - 1\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgz_pf_zb.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgz_pf_zb.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgz_pf_zb.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let range = start..<end\n    let count = string.distance(from: range.lowerBound,\
    \ to: range.upperBound)\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl3iy9qzu.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpl3iy9qzu.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var start = 0\n    var end = count(string)\n\
    \    while start < end {\n        start = find(string, substring, start)\n   \
    \     if start == end {\n            return count\n        }\n        end = find(string,\
    \ substring, start + 1)\n        count += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgjy3cb5h.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpgjy3cb5h.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpgjy3cb5h.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpgjy3cb5h.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpgjy3cb5h.swift:24:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, start\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.endIndex))\n\
    \    let range = start..<end\n    return range.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8zmk2ns2.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8zmk2ns2.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8zmk2ns2.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.endIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8zmk2ns2.swift:11:63: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.startIndex.distanceTo(string.endIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var startIndex = 0\n    var endIndex = 0\n\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += endIndex - startIndex\n\
    \            startIndex = endIndex + 1\n        }\n    }\n\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyeelo2fr.swift:19:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpyeelo2fr.swift:19:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpyeelo2fr.swift:19:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyeelo2fr.swift:22:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpyeelo2fr.swift:22:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpyeelo2fr.swift:22:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpyeelo2fr.swift:22:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpyeelo2fr.swift:22:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[k]\
    \ {\n            count += 1\n            i += k\n            k += k\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbp3mggur.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpbp3mggur.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpbp3mggur.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpbp3mggur.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex {\n        if string[i] == substring[0] {\n   \
    \         count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3nvoi8po.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp3nvoi8po.swift:19:31:\
    \ note: to match this opening '{'\n    while i < string.endIndex {\n         \
    \                     ^\n/tmp/tmp3nvoi8po.swift:114:67: error: expected '}' at\
    \ end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmp3nvoi8po.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmp3nvoi8po.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmp3nvoi8po.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmp3nvoi8po.swift:19:13: error:\
    \ operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmp3nvoi8po.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp3nvoi8po.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3nvoi8po.swift:22:28:\
    \ error: value of t"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.characters.count - string.characters.index(before:\
    \ string.endIndex, offsetBy: substring.characters.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxgpyiwvk.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmpxgpyiwvk.swift:11:126: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.characters.count - string.characters.index(before:\
    \ string.endIndex, offsetBy: substring.characters.count)\n                   \
    \                                                                            \
    \                              ^\n/tmp/tmpxgpyiwvk.swift:11:131: error: extraneous\
    \ argument label 'before:' in call\n    return index != nil ? string.distance(from:\
    \ string.startIndex, to: index!) : string.characters.count - string.characters.index(before:\
    \ string.endIndex, offsetBy: substring.characters.count)\n                   \
    \                                                                            \
    \                                   ^~~~~~~~~\n                              \
    \                                                                            \
    \                         \n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for c in string.unicodeScalars {\n        if c == substring {\n     \
    \       count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk1yqs19y.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.count\n    var k = substring.count\n    while\
    \ i < j {\n        if string[i] == substring[k] {\n            count += 1\n  \
    \          i += 1\n            k += 1\n            if k == substring.count {\n\
    \                k = 0\n            }\n        } else {\n            i += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp44zv07jc.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp44zv07jc.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp44zv07jc.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if s == substring {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj3qqjyy0.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for c in string.unicodeScalars {\n        if c == substring {\n     \
    \       count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk1yqs19y.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.startIndex\n\
    \    while i < string.endIndex && j < string.endIndex {\n        if string[j]\
    \ != substring[i] {\n            count = count + 1\n        }\n        i += 1\n\
    \        j += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvzoq3hzj.swift:19:13: error: operator function '<' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n    while i < string.endIndex &&\
    \ j < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpvzoq3hzj.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[j] != substring[i] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpvzoq3hzj.swift:24:11: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \  j += 1\n        ~ ^  ~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k -= 1\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbkk07rdy.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbkk07rdy.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpbkk07rdy.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbkk07rdy.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbkk07rdy.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var start = 0\n    var end = string.count\n\n    while start < end {\n\
    \        let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmkw9lbtn.swift:15:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if string.hasPrefix(substring) {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzfey0u0_.swift:17:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                      substring: \n/tmp/tmpzfey0u0_.swift:17:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpzfey0u0_.swift:20:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \                                ^\n                                  string:\
    \                                      substring: \n/tmp/tmpzfey0u0_.swift:20:41:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n        return 1 + how_many_times(string[string.endIndex..<string.startIndex],\
    \ substring)\n                                        ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.characters.count\n\
    \    var k = substring.characters.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += 1\n            while\
    \ i < j && string[i] == substring[1] {\n                count += 1\n         \
    \       i += 1\n            }\n        } else {\n            i = 0\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpozbxvn0k.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpozbxvn0k.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpozbxvn0k.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpozbxvn0k.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpozbxvn0k.swift:24:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while i < j && string[i] == substring[1] {\n                    \
    \       ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpozbxvn0k.swift:24:41: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   while i < j && string[i] == substring[1] {\n                             \
    \           ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for s in string.split(substring) {\n        if string.range(of: s) !=\
    \ nil {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp74tvw9hn.swift:11:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(substring) {\n                          ^\n\
    \                          separator: \n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcndqrw18.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824885
