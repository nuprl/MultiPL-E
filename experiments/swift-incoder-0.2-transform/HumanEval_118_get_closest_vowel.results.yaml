language: swift
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    var index = word.startIndex\n    \n    while index < word.endIndex\
    \ {\n        if vowels.contains(word.substringToIndex(index)) {\n            return\
    \ word.substringFromIndex(index)\n        }\n        index = index + 1\n    }\n\
    \    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1skecvup.swift:26:33: error: value of type 'String' has no member\
    \ 'substringToIndex'\n        if vowels.contains(word.substringToIndex(index))\
    \ {\n                           ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp1skecvup.swift:27:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n         \
    \   return word.substringFromIndex(index)\n                   ~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1skecvup.swift:29:23: error: binary operator '+' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n        index = index + 1\n     \
    \           ~~~~~ ^ ~\n/tmp/tmp1skecvup.swift:29:23: note: overloads for '+' exist\
    \ with these partially matching parameter lists: (Int, Int)\n        index = index\
    \ + 1\n                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    for vowel in vowels {\n        if vowel.hasPrefix(\"A\") {\n            return\
    \ vowel\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8shecl7.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpk8shecl7.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelsCount = vowels.count\n    var vowelIndex\
    \ = 0\n    var vowelIndexEnd = vowels.count - 1\n    var vowelIndexStart = vowels.count\
    \ - 1\n    var vowelIndexEnd2 = vowels.count - 1\n    var vowelIndexStart2 = vowels.count\
    \ - 1\n    var vowelIndexEnd3 = vowels.count - 1\n    var vowelIndexStart3 = vowels.count\
    \ - 1\n    var vowelIndexEnd4 = vowels.count - 1\n    var vowelIndexStart4 = vowels.count\
    \ - 1\n    var vowelIndexEnd5 = vowels.count - 1\n    var vowelIndexStart5 = vowels.count\
    \ - 1\n    var vowelIndexEnd6 = vowels.count - 1\n    var vowelIndexStart6 = vowels.count\
    \ - 1\n    var vowelIndexEnd7 = vowels.count - 1\n    var vowelIndexStart7 = vowels.count\
    \ - 1\n    var vowelIndexEnd8 = vowels.count - 1\n    var vowelIndexStart8 = vowels.count\
    \ - 1\n    var vowelIndexEnd9 = vowels.count - 1\n    var vowelIndexStart9 = vowels.count\
    \ - 1\n    var vowelIndexEnd10 = vowels.count - 1\n    var vowelIndexStart10 =\
    \ vowels.count - 1\n    var vowelIndexEnd11 = vowels.count - 1\n    var vowelIndexStart11\
    \ = vowels.count - 1\n    var vowelIndexEnd12 = vowels.count - 1\n    var vowelIndexStart12\
    \ = vowels.count - 1\n    var vowelIndexEnd13 = vowels.count - 1\n    var vowelIndexStart13\
    \ = vowels.count - 1\n    var vowelIndexEnd14 = vowels.count - 1\n    var vowelIndexStart14\
    \ = vowels.count - 1\n    var vowelIndexEnd15 = vowels.count - 1\n    var vowelIndexStart15\
    \ = vowels.count - 1\n    var vowelIndexEnd16 = vowels.count - 1\n    var vowelIndexStart16\
    \ = vowels.count - 1\n    var vowelIndexEnd17 = vowels.count - 1\n    var vowelIndexStart17\
    \ = vowels.count - 1\n    var vowelIndexEnd18 = vowels.count - 1\n    var vowelIndexStart18\
    \ = vowels.count - 1\n    var vowelIndexEnd19 = vowels.count - 1\n    var vowelIndexStart19\
    \ = vowels.count - 1\n    var vowelIndexEnd20 = vowels.count - 1\n    var vowelIndexStart20\
    \ = vowels.count - 1\n    var vowelIndexEnd21 = vowels.count - 1\n    var vowelIndexStart21\
    \ = vowels.count - 1\n    var vowelIndexEnd22 = vowels.count - 1\n    var vowelIndexStart22\
    \ = vowels.count - 1\n    var vowelIndexEnd23 = vowels.count - 1\n    var vowelIndexStart23\
    \ = vowels.count - 1\n    var vowelIndexEnd24 = vowels.count \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp13oe3fsh.swift:17:9: warning: variable 'vowels' was never mutated;\
    \ consider changing to 'let' constant\n    var vowels = \"aeiouAEIOU\"\n    ~~~\
    \ ^\n    let\n/tmp/tmp13oe3fsh.swift:18:9: warning: initialization of variable\
    \ 'vowelsCount' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:19:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmp13oe3fsh.swift:20:9: warning: initialization of variable 'vowelIndexEnd'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:21:9:\
    \ warning: initialization of variable 'vowelIndexStart' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart = vowels.count\
    \ - 1\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:22:9: warning: initialization\
    \ of variable 'vowelIndexEnd2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexEnd2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp13oe3fsh.swift:23:9: warning: initialization of variable 'vowelIndexStart2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexStart2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp13oe3fsh.swift:24:9: warning: initialization of variable 'vowelIndexEnd3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd3 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:25:9:\
    \ warning: initialization of variable 'vowelIndexStart3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart3 =\
    \ vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:26:9:\
    \ warning: initialization of variable 'vowelIndexEnd4' was never used; consider\
    \ re"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountMax:\
    \ Int = vowels.count\n    var vowelsCountMin: Int = vowels.count - 1\n    var\
    \ vowelsCountSum: Int = 0\n    var vowelsCountSumMax: Int = vowelsCountMax\n \
    \   var vowelsCountSumMin: Int = vowelsCountMin - 1\n    var vowelsCountSumSum:\
    \ Int = 0\n    var vowelsCountSumSumMax: Int = vowelsCountSumMax\n    var vowelsCountSumSumMin:\
    \ Int = vowelsCountSumMin - 1\n    var vowelsCountSumSumSum: Int = 0\n    var\
    \ vowelsCountSumSumSumMax: Int = vowelsCountSumSumMax\n    var vowelsCountSumSumSumMin:\
    \ Int = vowelsCountSumSumMin - 1\n    var vowelsCountSumSumSumSum: Int = 0\n \
    \   var vowelsCountSumSumSumSumMax: Int = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumMin - 1\n    var vowelsCountSumSumSumSumSum: Int =\
    \ 0\n    var vowelsCountSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumMin - 1\n\
    \    var vowelsCountSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumMin - 1\n    var vowelsCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumMin\
    \ - 1\n    var vowelsCountSumSumSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMin - 1\n    var vowels\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyam_p5yh.swift:39:49: error: use of local variable 'vowelsCountSumSumSumSumSumSumMin'\
    \ before its declaration\n    var vowelsCountSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumMin\
    \ - 1\n                                                ^\n/tmp/tmpyam_p5yh.swift:39:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumMin' declared here\n    var vowelsCountSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumMin - 1\n        ^\n/tmp/tmpyam_p5yh.swift:41:52:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumMax' before its\
    \ declaration\n    var vowelsCountSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumMax\n\
    \                                                   ^\n/tmp/tmpyam_p5yh.swift:41:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumMax\n        ^\n/tmp/tmpyam_p5yh.swift:42:52:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumMin' before its\
    \ declaration\n    var vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumMin\
    \ - 1\n                                                   ^\n/tmp/tmpyam_p5yh.swift:42:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumMin' declared here\n    var vowelsCountSumSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumSumMin - 1\n        ^\n/tmp/tmpyam_p5yh.swift:44:55:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumSumMax' before\
    \ its declaration\n    var vowelsCountSumSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumSumMax\n\
    \                                                      ^\n/tmp/tmpyam_p5yh.swift:44:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMax\n        ^\n/tmp/tmpyam_p5yh.swift:45:52:\
    \ error: cannot find 'vowelsCountSumSumSumSumSumSumSumSumMin' in scope\n    var\
    \ vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumSumMin\
    \ - 1\n                                                   ^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndex: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount2: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount3: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount4: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount5: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount6: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount7: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount8: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount9: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount10: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount11: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount12: [Int] = [0, 1, 2, 3, 4]\n   \
    \ var vowelsIndexCount13: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount14:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount15: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount16: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount17:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount18: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount19: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount20:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount21: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount22: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount23:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount24: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount25: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount26:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount27: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount28: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount29:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount30: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount31: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount32:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount33: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount34: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount35:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount36: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount37: [\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kf6fl6b.swift:56:30: error: expected element type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n                              <#type#>\n\
    /tmp/tmp8kf6fl6b.swift:56:30: error: expected ']' in array type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n/tmp/tmp8kf6fl6b.swift:56:29: note: to match\
    \ this opening '['\n    var vowelsIndexCount37: [\n                          \
    \  ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = vowels.filter {\n        !$0.isEmpty &&\
    \ $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnbbswo8t.swift:76:43: error: unterminated string literal\n    \
    \    !$0.isEmpty && $0.lowercased() != \"e\n                                 \
    \         ^\n/tmp/tmpnbbswo8t.swift:104:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmpnbbswo8t.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmpnbbswo8t.swift:80:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    var\
    \ vowelIndex2 = word.count\n    \n    var vowelIndex3 = word.count\n    \n   \
    \ var vowelIndex4 = word.count\n    \n    var vowelIndex5 = word.count\n    \n\
    \    var vowelIndex6 = word.count\n    \n    var vowelIndex7 = word.count\n  \
    \  \n    var vowelIndex8 = word.count\n    \n    var vowelIndex9 = word.count\n\
    \    \n    var vowelIndex10 = word.count\n    \n    var vowelIndex11 = word.count\n\
    \    \n    var vowelIndex12 = word.count\n    \n    var vowelIndex13 = word.count\n\
    \    \n    var vowelIndex14 = word.count\n    \n    var vowelIndex15 = word.count\n\
    \    \n    var vowelIndex16 = word.count\n    \n    var vowelIndex17 = word.count\n\
    \    \n    var vowelIndex18 = word.count\n    \n    var vowelIndex19 = word.count\n\
    \    \n    var vowelIndex20 = word.count\n    \n    var vowelIndex21 = word.count\n\
    \    \n    var vowelIndex22 = word.count\n    \n    var vowelIndex23 = word.count\n\
    \    \n    var vowelIndex24 = word.count\n    \n    var vowelIndex25 = word.count\n\
    \    \n    var vowelIndex26 = word.count\n    \n    var vowelIndex27 = word.count\n\
    \    \n    var vowelIndex28 = word.count\n    \n    var vowelIndex29 = word.count\n\
    \    \n    var vowelIndex30 = word.count\n    \n    var vowelIndex31 = word.count\n\
    \    \n    var vowelIndex32 = word.count\n    \n    var vowelIndex33 = word.count\n\
    \    \n    var vowelIndex34 = word.count\n    \n    var vowelIndex35 = word.count\n\
    \    \n    var vowelIndex36 = word.count\n    \n    var vowelIndex37 = word.count\n\
    \    \n    var vowelIndex38 = word.count\n    \n    var vowelIndex39 = word.count\n\
    \    \n    var vowelIndex40 = word.count\n    \n    var vowelIndex41 = word.count\n\
    \    \n    var vowelIndex42 = word.count\n    \n    var vowelIndex43 = word.count\n\
    \    \n    var vowelIndex44 = word.count\n    \n    var vowelIndex45 = word.count\n\
    \    \n    var vowelIndex46 = word.count\n    \n    var vowelIndex47 = word.count\n\
    \    \n    var vowelIndex48 = word.count\n    \n    var vowelIndex49 = word.count\n\
    \    \n    var vowelIndex50 = word.count\n    \n    var vowelIndex51 = word.count\n\
    \    \n    var vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxd7u075m.swift:122:9: error: type annotation missing in pattern\n\
    \    var vowel\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ $0.lowercased() }),\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpegnkzkt6.swift:79:40: error: expected expression in conditional\n\
    \        let vowelsCount = vowels.count,\n                                   \
    \    ^\n/tmp/tmpegnkzkt6.swift:17:24: error: cannot find 'vowels' in scope\n \
    \   guard let vowels = vowels.characters.map({ $0.lowercased() }),\n         \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    if word.characters.count < 2 {\n \
    \       return \"\"\n    }\n    \n    var index = 0\n    var currentIndex = 0\n\
    \    \n    while index < word.characters.count {\n        if vowels.contains(word.characters[index])\
    \ {\n            currentIndex = index\n        }\n        \n        index += 1\n\
    \    }\n    \n    if currentIndex == 0 {\n        return \"\"\n    }\n    \n \
    \   if currentIndex == word.characters.count - 1 {\n        return word.characters[currentIndex\
    \ - 1]\n    }\n    \n    if word.characters[currentIndex - 1] == word.characters[currentIndex\
    \ + 1] {\n        return word.characters[currentIndex - 1]\n    }\n    \n    if\
    \ word.characters[currentIndex - 1] == word.characters[currentIndex - 2] {\n \
    \       return word.characters[currentIndex - 1]\n    }\n    \n    if word.characters[currentIndex\
    \ + 1] == word.characters[currentIndex + 2] {\n        return word.characters[currentIndex\
    \ + 1]\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpb0qat2ol.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 2 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb0qat2ol.swift:27:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    while index\
    \ < word.characters.count {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb0qat2ol.swift:28:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if vowels.contains(word.characters[index]) {\n                      \
    \     ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpb0qat2ol.swift:28:33: error: 'characters' is\
    \ unavailable: Please use String directly\n        if vowels.contains(word.characters[index])\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb0qat2ol.swift:39:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    if currentIndex == word.characters.count - 1\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb0qat2ol.swift:40:31: error: cannot convert return\
    \ expression of type 'Character' to return type 'String'\n        return word.characters[currentIndex\
    \ - 1]\n               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpb0qat2ol.swift:43:8:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    if word.characters[currentIndex - 1] == word.characters[currentIndex\
    \ + 1] {\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpm3ta725j.swift:93:11: error: expected member name following '.'\n\
    \    vowels.\n          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count,\n        let word = word.lowercased(),\n        let wordCount\
    \ = word.characters.count else {\n        return \"\"\n    }\n    \n    let vowelsCount\
    \ = vowels.count\n    let wordCount = word.characters.count\n    \n    let vowelsIndex\
    \ = word.characters.reversed().index(of: vowels.first!)\n    let vowelsIndex2\
    \ = vowelsIndex + vowelsCount - 1\n    \n    if vowelsIndex2 < wordCount {\n \
    \       return vowels[vowelsIndex2]\n    }\n    \n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbeh5mt5i.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map({ String($0) }),\n               \
    \        ^~~~~~\n/tmp/tmpbeh5mt5i.swift:20:30: error: 'characters' is unavailable:\
    \ Please use String directly\n        let wordCount = word.characters.count else\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbeh5mt5i.swift:19:9: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n        let word = word.lowercased(),\n\
    \        ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpbeh5mt5i.swift:20:9: error: initializer\
    \ for conditional binding must have Optional type, not 'Int'\n        let wordCount\
    \ = word.characters.count else {\n        ^               ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbeh5mt5i.swift:25:26: error: 'characters' is unavailable: Please use String\
    \ directly\n    let wordCount = word.characters.count\n                      \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbeh5mt5i.swift:25:9:\
    \ error: invalid redeclaration of 'wordCount'\n    let wordCount = word.characters.count\n\
    \        ^\n/tmp/tmpbeh5mt5i.swift:20:13: note: 'wordCount' previously declared\
    \ here\n        let wordCount = word.characters.count else {\n            ^\n\
    /tmp/tmpbeh5mt5i.swift:28:36: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n    let vowelsIndex2 = vowelsIndex + vowelsCount\
    \ - 1\n                                   ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.firstIndex(of: char) {\n \
    \           return index\n        }\n        return -1\n    }.min()\n    if vowelsIndex\
    \ == -1 {\n        return \"\"\n    }\n    let vowelsRange = vowelsIndex..<vowelsIndex\
    \ + vowelsCount\n    let vowelsRangeCount = vowelsRange.count\n    let vowelsRangeIndex\
    \ = word.characters.reversed().enumerate().map { (index, char) in\n        if\
    \ let index = vowelsRange.firstIndex(of: char) {\n            return index\n \
    \       }\n        return -1\n    }.min()\n    if vowelsRangeIndex == -1 {\n \
    \       return \"\"\n    }\n    let vowelsRangeCount = vowelsRangeIndex - vowelsIndex\n\
    \    let vowelsRangeCount2 = vowelsRangeCount * vowelsCount\n    let vowelsRangeIndex2\
    \ = vowelsIndex + vowelsRangeCount\n    let vowelsRangeIndex3 = vowelsIndex +\
    \ vowelsRangeCount2\n    let vowelsRangeIndex4 = vowelsIndex + vowelsRangeCount3\n\
    \    let vowelsRangeIndex5 = vowelsIndex + vowelsRangeCount4\n    let vowelsRangeIndex6\
    \ = vowelsIndex + vowelsRangeCount5\n    let vowelsRangeIndex7 = vowelsIndex +\
    \ vowelsRangeCount6\n    let vowelsRangeIndex8 = vowelsIndex + vowelsRangeCount7\n\
    \    let vowelsRangeIndex9 = vowelsIndex + vowelsRangeCount8\n    let vowelsRangeIndex10\
    \ = vowelsIndex + vowelsRangeCount9\n    let vowelsRangeIndex11 = vowelsIndex\
    \ + vowelsRangeCount10\n    let vowelsRangeIndex12 = vowelsIndex + vowelsRangeCount11\n\
    \    let vowelsRangeIndex13 = vowelsIndex + vowelsRangeCount12\n    let vowelsRangeIndex14\
    \ = vowelsIndex + vowelsRangeCount13\n    let vowelsRangeIndex15 = vowelsIndex\
    \ + vowelsRangeCount14\n    let vowelsRangeIndex16 = vowelsIndex + vowelsRangeCount15\n\
    \    let vowelsRangeIndex17 = vowelsIndex + vowelsRangeCount16\n    let vowelsRangeIndex18\
    \ = vowelsIndex + vowelsRangeCount17\n    let vowelsRangeIndex19 = vowelsIndex\
    \ + vowelsRangeCount18\n    let vowelsRangeIndex20 = vowelsIndex + vowelsRangeCount19\n\
    \    let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ubqxog8.swift:62:8: error: expected pattern\n    let \n      \
    \ ^\n/tmp/tmp2ubqxog8.swift:17:24: error: cannot find 'vowels' in scope\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n                   \
    \    ^~~~~~\n/tmp/tmp2ubqxog8.swift:21:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                 ^\n/tmp/tmp2ubqxog8.swift:32:55:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsRangeIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                      ^\n\
    /tmp/tmp2ubqxog8.swift:45:43: error: cannot find 'vowelsRangeCount3' in scope\n\
    \    let vowelsRangeIndex4 = vowelsIndex + vowelsRangeCount3\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:46:43: error:\
    \ cannot find 'vowelsRangeCount4' in scope\n    let vowelsRangeIndex5 = vowelsIndex\
    \ + vowelsRangeCount4\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:47:43: error: cannot find 'vowelsRangeCount5' in scope\n\
    \    let vowelsRangeIndex6 = vowelsIndex + vowelsRangeCount5\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:48:43: error:\
    \ cannot find 'vowelsRangeCount6' in scope\n    let vowelsRangeIndex7 = vowelsIndex\
    \ + vowelsRangeCount6\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:49:43: error: cannot find 'vowelsRangeCount7' in scope\n\
    \    let vowelsRangeIndex8 = vowelsIndex + vowelsRangeCount7\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:50:43: error:\
    \ cannot find 'vowelsRangeCount8' in scope\n    let vowelsRangeIndex9 = vowelsIndex\
    \ + vowelsRangeCount8\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:51:44: error: cannot find 'vowelsRangeCount9' in scope\n\
    \    let vowelsRangeIndex10 = vowelsIndex "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndex: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount2: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount3: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount4: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount5: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount6: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount7: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount8: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount9: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount10: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount11: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount12: [Int] = [0, 1, 2, 3, 4]\n   \
    \ var vowelsIndexCount13: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount14:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount15: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount16: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount17:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount18: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount19: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount20:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount21: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount22: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount23:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount24: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount25: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount26:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount27: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount28: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount29:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount30: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount31: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount32:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount33: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount34: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount35:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount36: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount37: [\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kf6fl6b.swift:56:30: error: expected element type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n                              <#type#>\n\
    /tmp/tmp8kf6fl6b.swift:56:30: error: expected ']' in array type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n/tmp/tmp8kf6fl6b.swift:56:29: note: to match\
    \ this opening '['\n    var vowelsIndexCount37: [\n                          \
    \  ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowelIndex = 0\n    var\
    \ vowelCount = 0\n    var consonantIndex = 0\n    var consonantCount = 0\n   \
    \ for index in 0..<word.count {\n        let char = word[index]\n        if char.isUppercase\
    \ {\n            vowelCount += 1\n        }\n        if char.isLowercase {\n \
    \           consonantCount += 1\n        }\n        if char.isVowel {\n      \
    \      vowelIndex += 1\n        }\n        if char.isConsonant {\n           \
    \ consonantIndex += 1\n        }\n    }\n    if vowelIndex == 0 {\n        return\
    \ \"\"\n    }\n    if consonantIndex == 0 {\n        return \"\"\n    }\n    if\
    \ vowelIndex > consonantIndex {\n        return \"\"\n    }\n    if vowelIndex\
    \ == consonantIndex {\n        return word[vowelIndex - 1]\n    }\n    if vowelIndex\
    \ < consonantIndex {\n        return word[consonantIndex - 1]\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdgz7ma4z.swift:25:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = word[index]\n                   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdgz7ma4z.swift:32:17: error: value\
    \ of type 'Character' has no member 'isVowel'\n        if char.isVowel {\n   \
    \        ~~~~ ^~~~~~~\n/tmp/tmpdgz7ma4z.swift:35:17: error: value of type 'Character'\
    \ has no member 'isConsonant'\n        if char.isConsonant {\n           ~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpdgz7ma4z.swift:49:20: error: cannot convert return expression\
    \ of type 'Character' to return type 'String'\n        return word[vowelIndex\
    \ - 1]\n               ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpdgz7ma4z.swift:52:20: error:\
    \ cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return word[consonantIndex - 1]\n               ~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    let vowelRange = vowelIndex..<vowelIndex + vowelsCount\n\
    \    \n    let vowelRangeCount = vowelRange.count\n    \n    if vowelRangeCount\
    \ == 0 {\n        return \"\"\n    }\n    \n    let vowelRangeStart = vowelRange.first!\n\
    \    \n    let vowelRangeEnd = vowelRange.last!\n    \n    let vowelRangeLength\
    \ = vowelRangeEnd - vowelRangeStart + 1\n    \n    let vowelRangeRange = vowelRangeStart\
    \ ..< vowelRangeEnd\n    \n    let vowelRangeRangeCount = vowelRangeRange.count\n\
    \    \n    if vowelRangeRangeCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelRangeRangeStart = vowelRangeRange.first!\n    \n    let vowelRangeRangeEnd\
    \ = vowelRangeRange.last!\n    \n    let vowelRangeRangeLength = vowelRangeRangeEnd\
    \ - vowelRangeRangeStart + 1\n    \n    let vowelRangeRangeRange = vowelRangeRangeStart\
    \ ..< vowelRangeRangeEnd\n    \n    let vowelRangeRangeRangeCount = vowelRangeRangeRange.count\n\
    \    \n    if vowelRangeRangeRangeCount == 0 {\n        return \"\"\n    }\n \
    \   \n    let vowelRangeRangeRangeStart = vowelRangeRangeRange.first!\n    \n\
    \    let vowelRangeRangeRangeEnd = vowelRangeRangeRange.last!\n    \n    let vowelRangeRangeRangeLength\
    \ = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart + 1\n    \n    let vowelRangeRangeRangeRange\
    \ = vowelRangeRangeRangeStart ..< vowelRangeRangeRangeEnd\n    \n    let vowelRangeRangeRangeRangeCount\
    \ = vowelRangeRangeRangeRange.count\n    \n    if vowelRangeRangeRangeRangeCount\
    \ == 0 {\n        return \"\"\n    }\n    \n    let vowelRangeRangeRangeRangeStart\
    \ = vowelRangeRangeRangeRange.first!\n    \n    let vowelRangeRangeRangeRangeEnd\
    \ = vowelRangeRangeRangeRange.last!\n    \n    let vowelRangeRangeRangeRangeLength\
    \ = vowelRangeRangeRangeRangeEnd - vowelRangeRangeRangeRangeStart + 1\n    \n\
    \    let vowelRangeRangeRangeRangeRange = vowelRangeRangeRangeRangeStart ..< vowelRangeRangeRangeRangeEnd\n\
    \    \n    let vowelRangeRangeRangeRangeRangeCount = vowelRangeRangeRangeRangeRange.count\n\
    \    \n    if vowelRangeRangeRangeRangeRangeCount == 0 {\n        return \"\"\n\
    \    }\n    \n    let vowelRangeRangeRangeRangeRangeStart = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_568njt.swift:89:46: error: expected initial value after '='\n\
    \    let vowelRangeRangeRangeRangeRangeStart = \n                            \
    \                 ^\n/tmp/tmpl_568njt.swift:17:24: error: cannot find 'vowels'\
    \ in scope\n    guard let vowels = vowels.characters.map(String.init) else {\n\
    \                       ^~~~~~\n/tmp/tmpl_568njt.swift:37:60: error: binary operator\
    \ '+' cannot be applied to operands of type 'Duration' and 'Int'\n    let vowelRangeLength\
    \ = vowelRangeEnd - vowelRangeStart + 1\n                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpl_568njt.swift:37:60: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n    let\
    \ vowelRangeLength = vowelRangeEnd - vowelRangeStart + 1\n                   \
    \                                        ^\n/tmp/tmpl_568njt.swift:51:75: error:\
    \ binary operator '+' cannot be applied to operands of type 'Duration' and 'Int'\n\
    \    let vowelRangeRangeLength = vowelRangeRangeEnd - vowelRangeRangeStart + 1\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n\
    /tmp/tmpl_568njt.swift:51:75: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Duration, Duration), (Int, Int)\n    let vowelRangeRangeLength\
    \ = vowelRangeRangeEnd - vowelRangeRangeStart + 1\n                          \
    \                                                ^\n/tmp/tmpl_568njt.swift:65:90:\
    \ error: binary operator '+' cannot be applied to operands of type 'Duration'\
    \ and 'Int'\n    let vowelRangeRangeRangeLength = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart\
    \ + 1\n                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpl_568njt.swift:65:90: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n    let\
    \ vowelRangeRangeRangeLength = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart\
    \ + 1\n                                                                      \
    \                   ^\n/tmp/tmpl_568njt.swift:7"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgsfhk8r_.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpgsfhk8r_.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n                                  \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for letter in word {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    \n    var vowelIndex: Int = 0\n    var vowelCount: Int = 0\n    var vowelEndIndex:\
    \ Int = 0\n    var vowelStartIndex: Int = 0\n    \n    for letter in vowels {\n\
    \        if letter == vowels[vowelIndex] {\n            vowelIndex += 1\n    \
    \        vowelCount += 1\n            if vowelIndex == vowels.count {\n      \
    \          vowelIndex = 0\n            }\n        } else {\n            if vowelIndex\
    \ == 0 {\n                vowelStartIndex = vowelEndIndex\n            }\n   \
    \         vowelEndIndex = vowelIndex\n            vowelIndex = 0\n        }\n\
    \    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n   \
    \ if vowelIndex == vowels.count {\n        return \"\"\n    }\n    \n    if vowelCount\
    \ > 1 {\n        return \"\"\n    }\n    \n    if vowelStartIndex == vowelEndIndex\
    \ {\n        return \"\"\n    }\n    \n    return vowels[vowelStartIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpenxz0mfy.swift:62:18: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n    return vowels[vowelStartIndex]\n\
    \           ~~~~~~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for char in word.unicodeScalars {\n        if\
    \ let _ = char.value > 64 && char.value < 91 {\n            vowels.append(char)\n\
    \        }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    let\
    \ vowelIndex = vowels.firstIndex(of: Character(\"a\"))\n    if vowelIndex == -1\
    \ {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2wtkdob.swift:20:20: error: no exact matches in call to instance\
    \ method 'append'\n            vowels.append(char)\n                   ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmp_2wtkdob.swift:20:20: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n/tmp/tmp_2wtkdob.swift:19:12: error: initializer for conditional\
    \ binding must have Optional type, not 'Bool'\n        if let _ = char.value >\
    \ 64 && char.value < 91 {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_2wtkdob.swift:31:9: error: invalid redeclaration of 'vowelsCount'\n \
    \   let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:32:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:33:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:34:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:35:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n      "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount = [String: Int]()\n    for\
    \ char in word.characters {\n        if vowels.contains(char) {\n            vowelsCount[char]\
    \ = vowelsCount[char]! + 1\n        }\n    }\n    var minVowel: String = String()\n\
    \    var minVowelCount: Int = Int.max\n    for char in vowels {\n        if vowelsCount[char]\
    \ < minVowelCount {\n            minVowel = char\n            minVowelCount =\
    \ vowelsCount[char]\n        }\n    }\n    return minVowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpw3rkkj68.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpw3rkkj68.swift:23:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpw3rkkj68.swift:24:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowelsCount[char] = vowelsCount[char]! + 1\n                    \
    \    ^\n/tmp/tmpw3rkkj68.swift:24:45: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowelsCount[char] = vowelsCount[char]!\
    \ + 1\n                                            ^\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if vowelsCount[char] < minVowelCount {\n                      ^\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if vowelsCount[char] < minVowelCount {\n                    \
    \  ^\n                             ?? <#default value#>\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if vowelsCount[char] < minVowelCount {\n                    \
    \  ^\n                            !\n/tmp/tmpw3rkkj68.swift:32:40: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \     minVowelCount = vowelsCount[char]\n                                    \
    \   ^\n/tmp/tmpw3rkkj68.swift:32:40: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            minVowelCount = vowelsCount[char]\n\
    \                                       ^\n                                  \
    \            ?? <#default value#>\n/tmp/tmpw3rkkj68.swift:32:40: note: force-unwrap\
    \ using '!' to abort executi"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    let startIndex = vowelIndex - 1\n    let endIndex = vowelIndex + 1\n\
    \    \n    if startIndex < 0 {\n        startIndex = 0\n    }\n    \n    if endIndex\
    \ == vowels.count {\n        endIndex = vowels.count - 1\n    }\n    \n    let\
    \ firstVowel = vowels[startIndex]\n    let secondVowel = vowels[endIndex]\n  \
    \  \n    if firstVowel == secondVowel {\n        return firstVowel\n    }\n  \
    \  \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyt9ak4zu.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpyt9ak4zu.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpyt9ak4zu.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmpyt9ak4zu.swift:37:9:\
    \ error: cannot assign to value: 'startIndex' is a 'let' constant\n        startIndex\
    \ = 0\n        ^~~~~~~~~~\n/tmp/tmpyt9ak4zu.swift:33:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let startIndex = vowelIndex - 1\n    ^~~\n   \
    \ var\n/tmp/tmpyt9ak4zu.swift:41:9: error: cannot assign to value: 'endIndex'\
    \ is a 'let' constant\n        endIndex = vowels.count - 1\n        ^~~~~~~~\n\
    /tmp/tmpyt9ak4zu.swift:34:5: note: change 'let' to 'var' to make it mutable\n\
    \    let endIndex = vowelIndex + 1\n    ^~~\n    var\n/tmp/tmpyt9ak4zu.swift:44:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    let firstVowel = vowels[startIndex]\n     \
    \                ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpyt9ak4zu.swift:45:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    let secondVowel = vowels[endIndex]\n                      ^~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpyt9ak4zu.swift:48:16:\
    \ error: cann"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsIndex = word.characters.reversed().enumerate().filter { (index, element)\
    \ -> Bool in\n        element.lowercaseString.contains(vowels)\n    }.minElement\
    \ { (first, second) -> Bool in\n        first.1 < second.1\n    }.1\n    if vowelsIndex\
    \ == 0 {\n        return \"\"\n    }\n    let vowelsIndex2 = vowelsIndex - 1\n\
    \    let vowelsIndex3 = vowelsIndex + vowelsCount\n    let consonantsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n        element.lowercaseString.contains(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    }.minElement { (first, second) -> Bool in\n        first.1 < second.1\n\
    \    }.1\n    if consonantsIndex == word.characters.count {\n        return \"\
    \"\n    }\n    let consonantsIndex2 = consonantsIndex - 1\n    let consonantsIndex3\
    \ = consonantsIndex + consonantsCount\n    let vowelsIndex4 = vowelsIndex2 - vowelsCount\n\
    \    let consonantsIndex4 = consonantsIndex2 - consonantsCount\n    if vowelsIndex4\
    \ < 0 {\n        return \"\"\n    }\n    if consonantsIndex4 < 0 {\n        return\
    \ \"\"\n    }\n    if vowelsIndex4 > consonantsIndex4 {\n        return \"\"\n\
    \    }\n    if vowelsIndex4 < consonantsIndex4 {\n        return vowels[vowelsIndex4]\n\
    \    }\n    if consonantsIndex4 > vowelsIndex4 {\n        return \"\"\n    }\n\
    \    if consonantsIndex4 < vowelsIndex4 {\n        return consonants[consonantsIndex4]\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkbumpszv.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpkbumpszv.swift:19:50: error: reference to member 'enumerate' cannot\
    \ be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n                                            \
    \     ^\n/tmp/tmpkbumpszv.swift:29:54: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let consonantsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n                                            \
    \         ^\n/tmp/tmpkbumpszv.swift:38:46: error: cannot find 'consonantsCount'\
    \ in scope\n    let consonantsIndex3 = consonantsIndex + consonantsCount\n   \
    \                                          ^~~~~~~~~~~~~~~\n/tmp/tmpkbumpszv.swift:40:47:\
    \ error: cannot find 'consonantsCount' in scope\n    let consonantsIndex4 = consonantsIndex2\
    \ - consonantsCount\n                                              ^~~~~~~~~~~~~~~\n\
    /tmp/tmpkbumpszv.swift:57:16: error: cannot find 'consonants' in scope\n     \
    \   return consonants[consonantsIndex4]\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex = 0\n    var vowelsCountMax\
    \ = vowels.count\n    var vowelsCountMaxIndex = vowelsCountMax\n    var vowelsCountMin\
    \ = vowels.count\n    var vowelsCountMinIndex = vowelsCountMin\n    var vowelsCountSum\
    \ = vowelsCountMax\n    var vowelsCountSumIndex = vowelsCountSum\n    var vowelsCountSumMax\
    \ = vowelsCountSum\n    var vowelsCountSumMaxIndex = vowelsCountSumMax\n    var\
    \ vowelsCountSumMin = vowelsCountSum\n    var vowelsCountSumMinIndex = vowelsCountSumMin\n\
    \    var vowelsCountSumSum = vowelsCountSumMax\n    var vowelsCountSumSumIndex\
    \ = vowelsCountSumSum\n    var vowelsCountSumSumMax = vowelsCountSumSum\n    var\
    \ vowelsCountSumSumMaxIndex = vowelsCountSumSumMax\n    var vowelsCountSumSumMin\
    \ = vowelsCountSumSum\n    var vowelsCountSumSumMinIndex = vowelsCountSumSumMin\n\
    \    var vowelsCountSumSumSum = vowelsCountSumSumMax\n    var vowelsCountSumSumSumIndex\
    \ = vowelsCountSumSumSum\n    var vowelsCountSumSumSumMax = vowelsCountSumSumSum\n\
    \    var vowelsCountSumSumSumMaxIndex = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumMin\
    \ = vowelsCountSumSumSum\n    var vowelsCountSumSumSumMinIndex = vowelsCountSumSumSumMin\n\
    \    var vowelsCountSumSumSumSum = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumSumIndex\
    \ = vowelsCountSumSumSumSum\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumMaxIndex = vowelsCountSumSumSumSumMax\n    var\
    \ vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n    var vowelsCountSumSumSumSumMinIndex\
    \ = vowelsCountSumSumSumSumMin\n    var vowelsCountSumSumSumSumSum = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumIndex = vowelsCountSumSumSumSumSum\n    var\
    \ vowelsCountSumSumSumSumSumMax = vowelsCountSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumMaxIndex\
    \ = vowelsCountSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp200sr7rd.swift:44:38: error: use of local variable 'vowelsCountSumSumSumSumMax'\
    \ before its declaration\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \                                     ^\n/tmp/tmp200sr7rd.swift:44:9: note: 'vowelsCountSumSumSumSumMax'\
    \ declared here\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \        ^\n/tmp/tmp200sr7rd.swift:46:38: error: use of local variable 'vowelsCountSumSumSumSumMin'\
    \ before its declaration\n    var vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n\
    \                                     ^\n/tmp/tmp200sr7rd.swift:46:9: note: 'vowelsCountSumSumSumSumMin'\
    \ declared here\n    var vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n\
    \        ^\n/tmp/tmp200sr7rd.swift:50:41: error: use of local variable 'vowelsCountSumSumSumSumSumMax'\
    \ before its declaration\n    var vowelsCountSumSumSumSumSumMax = vowelsCountSumSumSumSumSumMax\n\
    \                                        ^\n/tmp/tmp200sr7rd.swift:50:9: note:\
    \ 'vowelsCountSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumMax\
    \ = vowelsCountSumSumSumSumSumMax\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.unicodeScalars {\n        if char.value > 0x41\
    \ && char.value < 0x5A {\n            vowels.append(char.value)\n        }\n \
    \   }\n    \n    if vowels.count < 2 {\n        return \"\"\n    }\n    \n   \
    \ var minDistance = vowels.count - 1\n    var minIndex = vowels.count - 1\n  \
    \  \n    for index in 0..<vowels.count {\n        if vowels[index] == vowels[minIndex]\
    \ {\n            continue\n        }\n        \n        let distance = abs(vowels[index]\
    \ - vowels[minIndex])\n        \n        if distance < minDistance {\n       \
    \     minDistance = distance\n            minIndex = index\n        }\n    }\n\
    \    \n    return vowels[minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoew2jo4c.swift:25:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpoew2jo4c.swift:41:42: error: binary\
    \ operator '-' cannot be applied to two 'String' operands\n        let distance\
    \ = abs(vowels[index] - vowels[minIndex])\n                                  \
    \       ^\nSwift.Strideable:1:11: note: candidate requires that 'String' conform\
    \ to '_Pointer' (requirement specified as 'Self' : '_Pointer')\nextension Strideable\
    \ where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  for letter in word {\n        if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n            vowels.append(letter)\n\
    \        }\n    }\n    if vowels.count > 0 {\n        return vowels[vowels.count\
    \ - 1]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbob21t0b.swift:23:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n        return \"\"\n    }\n    let vowelIndex = word.characters.index(of:\
    \ vowels.last!)\n    if index == vowelIndex {\n        return \"\"\n    }\n  \
    \  let start = index\n    let end = vowelIndex\n    let range = start..<end\n\
    \    let vowel = word.substring(with: range)\n    return vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpesg28ujc.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let index = word.characters.index(of: vowels.first!)\
    \ else {\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpesg28ujc.swift:18:39: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n                                      ^\n/tmp/tmpesg28ujc.swift:18:39:\
    \ note: use 'firstIndex(of:)' instead\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n                                      ^~~~~\n       \
    \                               firstIndex\n/tmp/tmpesg28ujc.swift:21:55: error:\
    \ value of type 'Set<String.Element>' (aka 'Set<Character>') has no member 'last'\n\
    \    let vowelIndex = word.characters.index(of: vowels.last!)\n              \
    \                                 ~~~~~~ ^~~~\n/tmp/tmpesg28ujc.swift:28:22: error:\
    \ value of type 'String' has no member 'substring'\n    let vowel = word.substring(with:\
    \ range)\n                ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpihpnyelp.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, vowels: vowels)\n         \
    \  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpihpnyelp.swift:17:51: error: cannot find 'vowels'\
    \ in scope\n    return find_closest_vowel(word: word, vowels: vowels)\n      \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count else {\n        return \"\"\n    }\n    \n    let vowelsSet =\
    \ Set(vowels)\n    \n    let vowelsCount = vowels.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount {\n        return\
    \ \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount\
    \ = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n    \n  \
    \  if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n    \n    let\
    \ vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgjv89b0.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map({ String($0) }),\n               \
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ var vowelIndex = 0\n    var vowelCount = 0\n    var vowelString = \"\"\n   \
    \ var consonantIndex = 0\n    var consonantCount = 0\n    var consonantString\
    \ = \"\"\n    \n    for char in word.characters {\n        if vowels.characters.contains(char)\
    \ {\n            vowelIndex += 1\n            vowelCount += 1\n            if\
    \ vowelIndex == vowelsCount {\n                vowelIndex = 0\n              \
    \  vowelCount -= 1\n            }\n        } else {\n            consonantIndex\
    \ += 1\n            consonantCount += 1\n            if consonantIndex == consonantCount\
    \ {\n                consonantIndex = 0\n                consonantCount -= 1\n\
    \            }\n        }\n    }\n    \n    if vowelIndex == 0 {\n        return\
    \ \"\"\n    }\n    \n    if vowelIndex == vowelsCount {\n        vowelIndex -=\
    \ 1\n    }\n    \n    if consonantIndex == 0 {\n        return \"\"\n    }\n \
    \   \n    if consonantIndex == consonantCount {\n        consonantIndex -= 1\n\
    \    }\n    \n    if vowelIndex == 0 && consonantIndex == 0 {\n        return\
    \ \"\"\n    }\n    \n    if vowelIndex == vowelsCount && consonantIndex == consonantCount\
    \ {\n        return vowels[vowelIndex - 1]\n    }\n    \n    if vowelIndex ==\
    \ vowelsCount {\n        vowelIndex -= 1\n    }\n    \n    if consonantIndex ==\
    \ 0 {\n        return \"\"\n    }\n    \n    if consonantIndex == consonantCount\
    \ {\n        consonantIndex -= 1\n    }\n    \n    if vowelIndex == 0 && consonantIndex\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex == vowelsCount &&\
    \ consonantIndex == consonantCount {\n        return vowels[vowelIndex - 1]\n\
    \    }\n    \n    if vowelIndex == vowelsCount {\n        vowelIndex -= 1\n  \
    \  }\n    \n    if consonantIndex == 0 {\n        return \"\"\n    }\n    \n \
    \   if consonantIndex == consonantCount {\n        consonantIndex -= 1\n    }\n\
    \    \n    if vowelIndex == 0 && consonantIndex == 0 {\n        return \"\"\n\
    \    }\n    \n    if vowelIndex == vowelsCount && consonantIndex == consonantCount\
    \ {\n        return vowels[vowelIndex - 1]\n    }\n    \n    if vowelIndex ==\
    \ vowelsCount {\n        vowelIndex -= 1\n    }\n    \n    if consonantIndex ==\
    \ 0 {\n        return \"\"\n    }\n    \n    if con\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp68q9s5de.swift:116:11: error: expected '{' after 'if' condition\n\
    \    if con\n          ^\n/tmp/tmp68q9s5de.swift:18:30: error: 'characters' is\
    \ unavailable: Please use String directly\n    let vowelsCount = vowels.characters.count\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp68q9s5de.swift:26:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in word.characters {\n            \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp68q9s5de.swift:27:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if vowels.characters.contains(char)\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp68q9s5de.swift:65:22: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n        return vowels[vowelIndex -\
    \ 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp68q9s5de.swift:85:22: error:\
    \ cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return vowels[vowelIndex - 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n\
    /tmp/tmp68q9s5de.swift:105:22: error: cannot convert return expression of type\
    \ 'Character' to return type 'String'\n        return vowels[vowelIndex - 1]\n\
    \               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp68q9s5de.swift:116:8: error: cannot\
    \ find 'con' in scope\n    if con\n       ^~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).firstIndex(of: vowels.last!)\n    \n    if vowelsIndex == word.characters.count\
    \ - 1 {\n        return \"\"\n    }\n    \n    let vowelsBefore = word.substring(to:\
    \ vowelsIndex - 1)\n    let vowelsAfter = word.substring(from: vowelsIndex + 1)\n\
    \    \n    if vowelsBefore.isEmpty || vowelsAfter.isEmpty {\n        return \"\
    \"\n    }\n    \n    let vowelsBeforeCount = vowelsBefore.characters.filter({\
    \ vowels.contains($0) }).count\n    let vowelsAfterCount = vowelsAfter.characters.filter({\
    \ vowels.contains($0) }).count\n    \n    if vowelsBeforeCount == 0 {\n      \
    \  return vowelsAfter\n    }\n    \n    if vowelsAfterCount == 0 {\n        return\
    \ vowelsBefore\n    }\n    \n    let vowelsBeforeIndex = vowelsBefore.characters.reversed().filter({\
    \ vowels.contains($0) }).firstIndex(of: vowels.last!)\n    let vowelsAfterIndex\
    \ = vowelsAfter.characters.reversed().filter({ vowels.contains($0) }).firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelsBeforeIndex == vowelsBefore.characters.count\
    \ - 1 {\n        return vowelsBefore\n    }\n    \n    if vowelsAfterIndex ==\
    \ vowelsAfter.characters.count - 1 {\n        return vowelsAfter\n    }\n    \n\
    \    let vowelsBeforeBefore = word.substring(to: vowelsBeforeIndex - 1)\n    let\
    \ vowelsBeforeAfter = word.substring(from: vowelsBeforeIndex + 1)\n    let vowelsAfterBefore\
    \ = word.substring(to: vowelsAfterIndex - 1)\n    let vowelsAfterAfter = word.substring(from:\
    \ vowelsAfterIndex + 1)\n    \n    if vowelsBeforeBefore.isEmpty || vowelsBeforeAfter.isEmpty\
    \ {\n        return vowelsBefore\n    }\n    \n    if vowelsAfterBefore.isEmpty\
    \ || vowelsAfterAfter.isEmpty {\n        return vowelsAfter\n    }\n    \n   \
    \ let vowelsBeforeBeforeCount = vowelsBeforeBefore.characters.filter({ vowels.contains($0)\
    \ }).count\n    let vowelsBeforeAfterCount = vowelsBeforeAfter.characters.filter({\
    \ vowels.contains($0) }).count\n    let vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpftsucd_7.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpftsucd_7.swift:33:29: error: value of type 'String'\
    \ has no member 'substring'\n    let vowelsBefore = word.substring(to: vowelsIndex\
    \ - 1)\n                       ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:34:28: error:\
    \ value of type 'String' has no member 'substring'\n    let vowelsAfter = word.substring(from:\
    \ vowelsIndex + 1)\n                      ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:62:35:\
    \ error: value of type 'String' has no member 'substring'\n    let vowelsBeforeBefore\
    \ = word.substring(to: vowelsBeforeIndex - 1)\n                             ~~~~\
    \ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:63:34: error: value of type 'String' has no\
    \ member 'substring'\n    let vowelsBeforeAfter = word.substring(from: vowelsBeforeIndex\
    \ + 1)\n                            ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:64:34:\
    \ error: value of type 'String' has no member 'substring'\n    let vowelsAfterBefore\
    \ = word.substring(to: vowelsAfterIndex - 1)\n                            ~~~~\
    \ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:65:33: error: value of type 'String' has no\
    \ member 'substring'\n    let vowelsAfterAfter = word.substring(from: vowelsAfterIndex\
    \ + 1)\n                           ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:77:9:\
    \ error: type annotation missing in pattern\n    let vowel\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelIndex2 = 0\n    var vowelIndex3 = 0\n  \
    \  var vowelIndex4 = 0\n    var vowelIndex5 = 0\n    var vowelIndex6 = 0\n   \
    \ var vowelIndex7 = 0\n    var vowelIndex8 = 0\n    var vowelIndex9 = 0\n    var\
    \ vowelIndex10 = 0\n    var vowelIndex11 = 0\n    var vowelIndex12 = 0\n    var\
    \ vowelIndex13 = 0\n    var vowelIndex14 = 0\n    var vowelIndex15 = 0\n    var\
    \ vowelIndex16 = 0\n    var vowelIndex17 = 0\n    var vowelIndex18 = 0\n    var\
    \ vowelIndex19 = 0\n    var vowelIndex20 = 0\n    var vowelIndex21 = 0\n    var\
    \ vowelIndex22 = 0\n    var vowelIndex23 = 0\n    var vowelIndex24 = 0\n    var\
    \ vowelIndex25 = 0\n    var vowelIndex26 = 0\n    var vowelIndex27 = 0\n    var\
    \ vowelIndex28 = 0\n    var vowelIndex29 = 0\n    var vowelIndex30 = 0\n    var\
    \ vowelIndex31 = 0\n    var vowelIndex32 = 0\n    var vowelIndex33 = 0\n    var\
    \ vowelIndex34 = 0\n    var vowelIndex35 = 0\n    var vowelIndex36 = 0\n    var\
    \ vowelIndex37 = 0\n    var vowelIndex38 = 0\n    var vowelIndex39 = 0\n    var\
    \ vowelIndex40 = 0\n    var vowelIndex41 = 0\n    var vowelIndex42 = 0\n    var\
    \ vowelIndex43 = 0\n    var vowelIndex44 = 0\n    var vowelIndex45 = 0\n    var\
    \ vowelIndex46 = 0\n    var vowelIndex47 = 0\n    var vowelIndex48 = 0\n    var\
    \ vowelIndex49 = 0\n    var vowelIndex50 = 0\n    var vowelIndex51 = 0\n    var\
    \ vowelIndex52 = 0\n    var vowelIndex53 = 0\n    var vowelIndex54 = 0\n    var\
    \ vowelIndex55 = 0\n    var vowelIndex56 = 0\n    var vowelIndex57 = 0\n    var\
    \ vowelIndex58 = 0\n    var vowelIndex59 = 0\n    var vowelIndex60 = 0\n    var\
    \ vowelIndex61 = 0\n    var vowelIndex62 = 0\n    var vowelIndex63 = 0\n    var\
    \ vowelIndex64 = 0\n    var vowelIndex65 = 0\n    var vowelIndex66 = 0\n    var\
    \ vowelIndex67 = 0\n    var vowelIndex68 = 0\n    var vowelIndex69 = 0\n    var\
    \ vowelIndex70 = 0\n    var vowelIndex71 = 0\n    var vowelIndex72 = 0\n    var\
    \ vowelIndex73 = 0\n    var vowelIndex74 = 0\n    var vowelIndex75 = 0\n    var\
    \ vowelIndex76 = 0\n    var vowelIndex77 = 0\n    var vowelIndex78 = 0\n    var\
    \ vowelIndex79 = 0\n    var vowelIndex80 = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp36tl5q41.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp36tl5q41.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels: [String] = []\n    \n    for vowel in vowels {\n        if word.hasSuffix(vowel)\
    \ {\n            return vowel\n        }\n    }\n    \n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpskwgudpy/tmpskwgudpy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2f4db0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2f4aa7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2f4aa7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2f4aa67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpskwgudpy                        0x00005643da5f55c7 <unavailable> + 5575

    5    libc.so.6                          0x00002ac2f4f9c460 __libc_start_main +
    245

    6    tmpskwgudpy                        0x00005643da5f5209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndex2\
    \ = vowels.count\n    \n    var currentIndex = 0\n    var currentIndex2 = word.count\n\
    \    \n    var closestIndex = 0\n    var closestIndex2 = vowels.count\n    \n\
    \    while vowelIndex < vowels.count && currentIndex < word.count {\n        if\
    \ vowels[vowelIndex] == word[currentIndex] {\n            vowelIndex++\n     \
    \       currentIndex++\n        } else {\n            vowelIndex++\n        }\n\
    \    }\n    \n    while vowelIndex2 < vowels.count && currentIndex2 < word.count\
    \ {\n        if vowels[vowelIndex2] == word[currentIndex2] {\n            vowelIndex2++\n\
    \            currentIndex2++\n        } else {\n            vowelIndex2++\n  \
    \      }\n    }\n    \n    if vowelIndex == vowels.count {\n        return \"\"\
    \n    }\n    \n    if vowelIndex2 == vowels.count {\n        return \"\"\n   \
    \ }\n    \n    if vowelIndex < vowels.count && vowelIndex2 < vowels.count {\n\
    \        if vowels[vowelIndex] < vowels[vowelIndex2] {\n            closestIndex\
    \ = vowelIndex\n            closestIndex2 = vowelIndex2\n        } else {\n  \
    \          closestIndex = vowelIndex2\n            closestIndex2 = vowelIndex\n\
    \        }\n    } else {\n        if vowelIndex < vowels.count {\n           \
    \ closestIndex = vowelIndex\n        } else {\n            closestIndex = vowelIndex2\n\
    \        }\n    }\n    \n    if closestIndex == closestIndex2 {\n        return\
    \ \"\"\n    }\n    \n    if closestIndex > closestIndex2 {\n        return vowels[closestIndex2]\n\
    \    } else {\n        return vowels[closestIndex]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmtq9d69b.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels[vowelIndex]\
    \ == word[currentIndex] {\n           ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:30:34: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if vowels[vowelIndex] == word[currentIndex] {\n          \
    \                       ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:31:23: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            vowelIndex++\n\
    \                      ^~\n/tmp/tmpmtq9d69b.swift:32:25: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            currentIndex++\n          \
    \              ^~\n/tmp/tmpmtq9d69b.swift:34:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            vowelIndex++\n                 \
    \     ^~\n/tmp/tmpmtq9d69b.swift:39:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ vowels[vowelIndex2] == word[currentIndex2] {\n           ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:39:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if vowels[vowelIndex2] == word[currentIndex2]\
    \ {\n                                  ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:40:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n   "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(String(char))\n        }\n    }\n    if\
    \ vowels.count < 2 {\n        return \"\"\n    }\n    var vowelsCount = vowels.count\n\
    \    var vowelIndex = 0\n    var vowelIndex2 = vowels.count - 1\n    var vowelIndex3\
    \ = vowels.count - 2\n    var vowelIndex4 = vowels.count - 3\n    var vowelIndex5\
    \ = vowels.count - 4\n    var vowelIndex6 = vowels.count - 5\n    var vowelIndex7\
    \ = vowels.count - 6\n    var vowelIndex8 = vowels.count - 7\n    var vowelIndex9\
    \ = vowels.count - 8\n    var vowelIndex10 = vowels.count - 9\n    var vowelIndex11\
    \ = vowels.count - 10\n    var vowelIndex12 = vowels.count - 11\n    var vowelIndex13\
    \ = vowels.count - 12\n    var vowelIndex14 = vowels.count - 13\n    var vowelIndex15\
    \ = vowels.count - 14\n    var vowelIndex16 = vowels.count - 15\n    var vowelIndex17\
    \ = vowels.count - 16\n    var vowelIndex18 = vowels.count - 17\n    var vowelIndex19\
    \ = vowels.count - 18\n    var vowelIndex20 = vowels.count - 19\n    var vowelIndex21\
    \ = vowels.count - 20\n    var vowelIndex22 = vowels.count - 21\n    var vowelIndex23\
    \ = vowels.count - 22\n    var vowelIndex24 = vowels.count - 23\n    var vowelIndex25\
    \ = vowels.count - 24\n    var vowelIndex26 = vowels.count - 25\n    var vowelIndex27\
    \ = vowels.count - 26\n    var vowelIndex28 = vowels.count - 27\n    var vowelIndex29\
    \ = vowels.count - 28\n    var vowelIndex30 = vowels.count - 29\n    var vowelIndex31\
    \ = vowels.count - 30\n    var vowelIndex32 = vowels.count - 31\n    var vowelIndex33\
    \ = vowels.count - 32\n    var vowelIndex34 = vowels.count - 33\n    var vowelIndex35\
    \ = vowels.count - 34\n    var vowelIndex36 = vowels.count - 35\n    var vowelIndex37\
    \ = vowels.count - 36\n    var vowelIndex38 = vowels.count - 37\n    var vowelIndex39\
    \ = vowels.count - 38\n    var vowelIndex40 = vowels.count - 39\n    var vowelIndex41\
    \ = vowels.count - 40\n    var vowelIndex42 = vowels.count \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdbn70epc.swift:29:9: warning: initialization of variable 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:30:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:31:9: warning: initialization of variable 'vowelIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:32:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = vowels.count -\
    \ 2\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:33:9: warning: initialization\
    \ of variable 'vowelIndex4' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndex4 = vowels.count - 3\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:34:9: warning: initialization of variable 'vowelIndex5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex5 = vowels.count - 4\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:35:9:\
    \ warning: initialization of variable 'vowelIndex6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex6 = vowels.count -\
    \ 5\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:36:9: warning: initialization\
    \ of variable 'vowelIndex7' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndex7 = vowels.count - 6\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:37:9: warning: initialization of variable 'vowelIndex8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex8 = vowels.count - 7\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:38:9:\
    \ warning: initialization of variable 'vowelIndex9' was never used; consider replacing\
    \ wit"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgsfhk8r_.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpgsfhk8r_.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n                                  \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndexEnd = vowels.count - 1\n    \n    for char in word.characters\
    \ {\n        if vowelIndex == vowelIndexEnd {\n            break\n        }\n\
    \        \n        if vowels.contains(String(char)) {\n            vowelIndexEnd\
    \ = vowels.firstIndex(of: String(char))!\n            break\n        }\n    }\n\
    \    \n    return String(word.characters.dropFirst(vowelIndex))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpeo5zmek9.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpeo5zmek9.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpeo5zmek9.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmpeo5zmek9.swift:35:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpeo5zmek9.swift:41:64: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n            vowelIndexEnd = vowels.firstIndex(of:\
    \ String(char))!\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmpeo5zmek9.swift:41:51: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n            vowelIndexEnd\
    \ = vowels.firstIndex(of: String(char))!\n                                   \
    \               ^\n/tmp/tmpeo5zmek9.swift:46:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    return String(word.characters.dropFirst(vowelIndex))\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for char in word.unicodeScalars {\n        if\
    \ char.value > 0x41 && char.value < 0x7A {\n            vowels.append(char)\n\
    \        }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n   \
    \ var vowelIndex: Int = 0\n    var vowelIndex2: Int = 0\n    var vowelIndex3:\
    \ Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5: Int = 0\n    var\
    \ vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var vowelIndex8: Int\
    \ = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int = 0\n    var vowelIndex11:\
    \ Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13: Int = 0\n    var\
    \ vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var vowelIndex16:\
    \ Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18: Int = 0\n    var\
    \ vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var vowelIndex21:\
    \ Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23: Int = 0\n    var\
    \ vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var vowelIndex26:\
    \ Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28: Int = 0\n    var\
    \ vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var vowelIndex31:\
    \ Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33: Int = 0\n    var\
    \ vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var vowelIndex36:\
    \ Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38: Int = 0\n    var\
    \ vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var vowelIndex41:\
    \ Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43: Int = 0\n    var\
    \ vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var vowelIndex46:\
    \ Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48: Int = 0\n    var\
    \ vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var vowelIndex51:\
    \ Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53: Int = 0\n    var\
    \ vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var vowelIndex56:\
    \ Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58: Int = 0\n    var\
    \ vowelIndex59: \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpipfmipeh.swift:84:22: error: expected type\n    var vowelIndex59:\
    \ \n                     ^\n                      <#type#>\n/tmp/tmpipfmipeh.swift:20:20:\
    \ error: no exact matches in call to instance method 'append'\n            vowels.append(char)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmpipfmipeh.swift:20:20: note: found candidate\
    \ with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    var index = word.startIndex\n    while index\
    \ != word.endIndex {\n        let char = word[index]\n        if vowels.contains(char)\
    \ {\n            return char\n        }\n        index -= 1\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp31x2_bss.swift:22:20: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n            return char\n        \
    \           ^~~~\n/tmp/tmp31x2_bss.swift:24:15: error: binary operator '-=' cannot\
    \ be applied to operands of type 'String.Index' and 'Int'\n        index -= 1\n\
    \        ~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.map(String.init).count\n \
    \   \n    var closestVowel = \"\"\n    \n    for i in 0..<vowelsCount {\n    \
    \    let index = vowels.index(of: vowels[i])\n        \n        if index == vowels.count\
    \ - 1 {\n            closestVowel = vowels[i]\n            break\n        }\n\
    \        \n        let nextIndex = vowels.index(after: index)\n        \n    \
    \    if nextIndex == vowels.count - 1 {\n            closestVowel = vowels[i]\n\
    \            break\n        }\n        \n        let nextNextIndex = vowels.index(after:\
    \ nextIndex)\n        \n        if nextNextIndex == vowels.count - 1 {\n     \
    \       closestVowel = vowels[i]\n            break\n        }\n        \n   \
    \     let nextNextNextIndex = vowels.index(after: nextNextIndex)\n        \n \
    \       if nextNextNextIndex == vowels.count - 1 {\n            closestVowel =\
    \ vowels[i]\n            break\n        }\n        \n        let nextNextNextNextIndex\
    \ = vowels.index(after: nextNextNextIndex)\n        \n        if nextNextNextNextIndex\
    \ == vowels.count - 1 {\n            closestVowel = vowels[i]\n            break\n\
    \        }\n        \n        let nextNextNextNextNextIndex = vowels.index(after:\
    \ nextNextNextNextIndex)\n        \n        if nextNextNextNextNextIndex == vowels.count\
    \ - 1 {\n            closestVowel = vowels[i]\n            break\n        }\n\
    \    }\n    \n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ga0ezds.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp0ga0ezds.swift:21:28: error: 'characters' is unavailable:\
    \ Please use String directly\n    let vowelsCount = word.characters.map(String.init).count\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ > 0 && char.unicodeScalars.last!.value == 0xE001 {\n            vowels.append(char.unicodeScalars.first!.value)\n\
    \        }\n    }\n    \n    if vowels.count > 0 {\n        return vowels.sorted().first!\n\
    \    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmflw1o1p.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpmflw1o1p.swift:25:54:\
    \ error: cannot convert value of type 'UInt32' to expected argument type 'String'\n\
    \            vowels.append(char.unicodeScalars.first!.value)\n               \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.firstIndex(of: char) {\n \
    \           return index\n        }\n        return vowels.count\n    }.min()\n\
    \    let vowelsIndex2 = vowels.firstIndex(of: word[vowelsIndex])\n    let vowelsIndex3\
    \ = vowels.firstIndex(of: word[vowelsIndex2])\n    if vowelsIndex3 == vowelsIndex\
    \ {\n        return \"\"\n    }\n    if vowelsIndex2 == vowelsIndex {\n      \
    \  return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2 {\n \
    \       return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpilahe04w.swift:89:35: error: expected '{' after 'if' condition\n\
    \    if vowelsIndex3 == vowelsIndex\n                                  ^\n/tmp/tmpilahe04w.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map(String.init)\
    \ else {\n                       ^~~~~~\n/tmp/tmpilahe04w.swift:21:50: error:\
    \ reference to member 'enumerate' cannot be resolved without a contextual type\n\
    \    let vowelsIndex = word.characters.reversed().enumerate().map { (index, char)\
    \ in\n                                                 ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsIndex = word.characters.reversed().enumerate().filter({ ($0.element\
    \ == vowels.characters.first!) }).first?.offset\n    let vowelsIndex2 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) }).first?.offset\n    let vowelsIndex3\
    \ = word.characters.reversed().enumerate().filter({ ($0.element == vowels.characters.first!)\
    \ && ($0.offset > vowelsIndex) }).first?.offset\n    let vowelsIndex4 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) && ($0.offset < vowelsIndex) }).first?.offset\n\
    \    if vowelsIndex == nil || vowelsIndex2 == nil || vowelsIndex3 == nil || vowelsIndex4\
    \ == nil {\n        return \"\"\n    }\n    if vowelsIndex == nil && vowelsIndex2\
    \ == nil && vowelsIndex3 == nil && vowelsIndex4 == nil {\n        return \"\"\n\
    \    }\n    if vowelsIndex != nil {\n        return vowels[vowelsIndex!]\n   \
    \ }\n    if vowelsIndex2 != nil {\n        return vowels[vowelsIndex2!]\n    }\n\
    \    if vowelsIndex3 != nil {\n        return vowels[vowelsIndex3!]\n    }\n \
    \   if vowelsIndex4 != nil {\n        return vowels[vowelsIndex4!]\n    }\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqkkzq24f.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqkkzq24f.swift:19:122: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.first!) }).first?.offset\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:20:122: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex2 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) }).first?.offset\n                 \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:21:152: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex3 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.first!) && ($0.offset > vowelsIndex) }).first?.offset\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:22:151: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex4 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) && ($0.offset < vowelsIndex) }).first?.offset\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:30:22: error: no 'subscript' candidates produce the expected\
    \ contextual result type 'String'\n        return vowels[vowelsIndex!]\n     \
    \                ^\nSwift.String:12:12: note: 'subscript(_:)' produces 'Characte"
  stdout: ''
  timestamp: 1660014416
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndexEnd = word.count\
    \ - 1\n    var vowelIndexStart = 0\n    var vowelIndexEnd2 = word.count - 1\n\
    \    var vowelIndexStart2 = 0\n    var vowelIndexEnd3 = word.count - 1\n    var\
    \ vowelIndexStart3 = 0\n    var vowelIndexEnd4 = word.count - 1\n    var vowelIndexStart4\
    \ = 0\n    var vowelIndexEnd5 = word.count - 1\n    var vowelIndexStart5 = 0\n\
    \    var vowelIndexEnd6 = word.count - 1\n    var vowelIndexStart6 = 0\n    var\
    \ vowelIndexEnd7 = word.count - 1\n    var vowelIndexStart7 = 0\n    var vowelIndexEnd8\
    \ = word.count - 1\n    var vowelIndexStart8 = 0\n    var vowelIndexEnd9 = word.count\
    \ - 1\n    var vowelIndexStart9 = 0\n    var vowelIndexEnd10 = word.count - 1\n\
    \    var vowelIndexStart10 = 0\n    var vowelIndexEnd11 = word.count - 1\n   \
    \ var vowelIndexStart11 = 0\n    var vowelIndexEnd12 = word.count - 1\n    var\
    \ vowelIndexStart12 = 0\n    var vowelIndexEnd13 = word.count - 1\n    var vowelIndexStart13\
    \ = 0\n    var vowelIndexEnd14 = word.count - 1\n    var vowelIndexStart14 = 0\n\
    \    var vowelIndexEnd15 = word.count - 1\n    var vowelIndexStart15 = 0\n   \
    \ var vowelIndexEnd16 = word.count - 1\n    var vowelIndexStart16 = 0\n    var\
    \ vowelIndexEnd17 = word.count - 1\n    var vowelIndexStart17 = 0\n    var vowelIndexEnd18\
    \ = word.count - 1\n    var vowelIndexStart18 = 0\n    var vowelIndexEnd19 = word.count\
    \ - 1\n    var vowelIndexStart19 = 0\n    var vowelIndexEnd20 = word.count - 1\n\
    \    var vowelIndexStart20 = 0\n    var vowelIndexEnd21 = word.count - 1\n   \
    \ var vowelIndexStart21 = 0\n    var vowelIndexEnd22 = word.count - 1\n    var\
    \ vowelIndexStart22 = 0\n    var vowelIndexEnd23 = word.count - 1\n    var vowelIndexStart23\
    \ = 0\n    var vowelIndexEnd24 = word.count - 1\n    var vowelIndexStart24 = 0\n\
    \    var vowelIndexEnd25 = word.count - 1\n    var vowelIndexStart25 = 0\n   \
    \ var vowelIndexEnd26 = word.count - 1\n    var vowelIndexStart26 = 0\n    var\
    \ vowelIndexEnd27 = word.count - 1\n    var vowelIndexStart27 = 0\n    var vowelIndexEnd28\
    \ = word.count - 1\n    var vowelIndexStart28 = 0\n    var vowelIndexEnd29 = word.count\
    \ - 1\n    var vowelIndexStart29 = 0\n    var vowelIndexEnd30 = word.count - 1\n\
    \    var vowelIndexStart30 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvlm15c8g.swift:79:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpvlm15c8g.swift:17:9: warning: initialization of immutable value 'vowels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let vowels = \"aeiouAEIOU\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:18:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:19:9: warning: initialization of variable 'vowelIndexEnd'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd = word.count - 1\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:20:9:\
    \ warning: initialization of variable 'vowelIndexStart' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:21:9: warning: initialization\
    \ of variable 'vowelIndexEnd2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexEnd2 = word.count - 1\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:22:9: warning: initialization of variable 'vowelIndexStart2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexStart2 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:23:9:\
    \ warning: initialization of variable 'vowelIndexEnd3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexEnd3 = word.count\
    \ - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:24:9: warning: initialization\
    \ of variable 'vowelIndexStart3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexStart3 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:25:9: warning: initialization of variable 'vowelIndexEnd4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd4 = word.count - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:26:9:\
    \ war"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n        if let index = vowels.index(of: char) {\n\
    \            return index\n        }\n        return vowelsCount - 1\n    }.min()\n\
    \    \n    if vowelsIndex < 0 {\n        return \"\"\n    }\n    \n    let consonantsCount\
    \ = word.characters.count\n    let consonantsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n        if let index = consonants.index(of: char)\
    \ {\n            return index\n        }\n        return consonantsCount - 1\n\
    \    }.max()\n    \n    if consonantsIndex > vowelsIndex {\n        return \"\"\
    \n    }\n    \n    let vowelsIndex = vowelsIndex\n    let consonantsIndex = consonantsIndex\n\
    \    \n    let vowelsChar = vowels[vowelsIndex]\n    let consonantsChar = word.characters.reversed()[consonantsIndex]\n\
    \    \n    if vowelsChar != consonantsChar {\n        return \"\"\n    }\n   \
    \ \n    return vowelsChar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5wv4g553.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp5wv4g553.swift:22:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n                                                \
    \ ^\n/tmp/tmp5wv4g553.swift:33:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let consonantsCount = word.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5wv4g553.swift:35:24: error: cannot find 'consonants' in\
    \ scope\n        if let index = consonants.index(of: char) {\n               \
    \        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n\
    \        }\n    }\n    if vowels.count > 0 {\n        let vowel = vowels.sorted().first!\n\
    \        let index = word.unicodeScalars.firstIndex(of: vowel)\n        if index\
    \ != nil {\n            let start = word.unicodeScalars.startIndex.advanced(by:\
    \ index!)\n            let end = word.unicodeScalars.endIndex.advanced(by: index!)\n\
    \            return String(word.unicodeScalars.subSequence(from: start, to: end))\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr9c_ux_p.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpr9c_ux_p.swift:19:12: error: initializer\
    \ for conditional binding must have Optional type, not 'Bool'\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr9c_ux_p.swift:25:56: error: cannot convert value of type 'String' to\
    \ expected argument type 'Unicode.Scalar'\n        let index = word.unicodeScalars.firstIndex(of:\
    \ vowel)\n                                                       ^\n/tmp/tmpr9c_ux_p.swift:27:56:\
    \ error: value of type 'String.UnicodeScalarView.Index' (aka 'String.Index') has\
    \ no member 'advanced'\n            let start = word.unicodeScalars.startIndex.advanced(by:\
    \ index!)\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr9c_ux_p.swift:28:52:\
    \ error: value of type 'String.UnicodeScalarView.Index' (aka 'String.Index') has\
    \ no member 'advanced'\n            let end = word.unicodeScalars.endIndex.advanced(by:\
    \ index!)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr9c_ux_p.swift:29:47:\
    \ error: value of type 'String.UnicodeScalarView' has no member 'subSequence'\n\
    \            return String(word.unicodeScalars.subSequence(from: start, to: end))\n\
    \                          ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for letter in word {\n        if letter.isUpper() {\n        \
    \    vowels.append(letter)\n        }\n    }\n    \n    var vowelsCount = vowels.count\n\
    \    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex\
    \ = 0\n    \n    for letter in word {\n        if letter.isUpper() {\n       \
    \     vowelIndex += 1\n        }\n    }\n    \n    var vowelsCountInWord = vowels.count\n\
    \    \n    if vowelsCountInWord == 0 {\n        return \"\"\n    }\n    \n   \
    \ var vowelIndexInWord = vowelIndex\n    \n    var vowelIndexInWord2 = vowelIndexInWord\n\
    \    \n    var vowelIndexInWord3 = vowelIndexInWord\n    \n    var vowelIndexInWord4\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord5 = vowelIndexInWord\n   \
    \ \n    var vowelIndexInWord6 = vowelIndexInWord\n    \n    var vowelIndexInWord7\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord8 = vowelIndexInWord\n   \
    \ \n    var vowelIndexInWord9 = vowelIndexInWord\n    \n    var vowelIndexInWord10\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord11 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord12 = vowelIndexInWord\n    \n    var vowelIndexInWord13\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord14 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord15 = vowelIndexInWord\n    \n    var vowelIndexInWord16\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord17 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord18 = vowelIndexInWord\n    \n    var vowelIndexInWord19\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord20 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord21 = vowelIndexInWord\n    \n    var vowelIndexInWord22\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord23 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord24 = vowelIndexInWord\n    \n    var vowelIndexInWord25\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord26 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord27 = vowelIndexInWord\n    \n    var vowelIndexInWord28\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord29\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp84w3x1it.swift:24:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp84w3x1it.swift:25:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp84w3x1it.swift:38:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp84w3x1it.swift:105:9: error: type annotation\
    \ missing in pattern\n    var vowelIndexInWord29\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \
    \  var vowelsCount = 0\n    var vowelIndex = 0\n    var vowelsCountIndex = 0\n\
    \    var vowelsCountIndex2 = 0\n    var vowelsCountIndex3 = 0\n    var vowelsCountIndex4\
    \ = 0\n    var vowelsCountIndex5 = 0\n    var vowelsCountIndex6 = 0\n    var vowelsCountIndex7\
    \ = 0\n    var vowelsCountIndex8 = 0\n    var vowelsCountIndex9 = 0\n    var vowelsCountIndex10\
    \ = 0\n    var vowelsCountIndex11 = 0\n    var vowelsCountIndex12 = 0\n    var\
    \ vowelsCountIndex13 = 0\n    var vowelsCountIndex14 = 0\n    var vowelsCountIndex15\
    \ = 0\n    var vowelsCountIndex16 = 0\n    var vowelsCountIndex17 = 0\n    var\
    \ vowelsCountIndex18 = 0\n    var vowelsCountIndex19 = 0\n    var vowelsCountIndex20\
    \ = 0\n    var vowelsCountIndex21 = 0\n    var vowelsCountIndex22 = 0\n    var\
    \ vowelsCountIndex23 = 0\n    var vowelsCountIndex24 = 0\n    var vowelsCountIndex25\
    \ = 0\n    var vowelsCountIndex26 = 0\n    var vowelsCountIndex27 = 0\n    var\
    \ vowelsCountIndex28 = 0\n    var vowelsCountIndex29 = 0\n    var vowelsCountIndex30\
    \ = 0\n    var vowelsCountIndex31 = 0\n    var vowelsCountIndex32 = 0\n    var\
    \ vowelsCountIndex33 = 0\n    var vowelsCountIndex34 = 0\n    var vowelsCountIndex35\
    \ = 0\n    var vowelsCountIndex36 = 0\n    var vowelsCountIndex37 = 0\n    var\
    \ vowelsCountIndex38 = 0\n    var vowelsCountIndex39 = 0\n    var vowelsCountIndex40\
    \ = 0\n    var vowelsCountIndex41 = 0\n    var vowelsCountIndex42 = 0\n    var\
    \ vowelsCountIndex43 = 0\n    var vowelsCountIndex44 = 0\n    var vowelsCountIndex45\
    \ = 0\n    var vowelsCountIndex46 = 0\n    var vowelsCountIndex47 = 0\n    var\
    \ vowelsCountIndex48 = 0\n    var vowelsCountIndex49 = 0\n    var vowelsCountIndex50\
    \ = 0\n    var vowelsCountIndex51 = 0\n    var vowelsCountIndex52 = 0\n    var\
    \ vowelsCountIndex53 = 0\n    var vowelsCountIndex54 = 0\n    var vowelsCountIndex55\
    \ = 0\n    var vowelsCountIndex56 = 0\n    var vowelsCountIndex57 = 0\n    var\
    \ vowelsCountIndex58 = 0\n    var vowelsCountIndex59 = 0\n    var vowelsCountIndex60\
    \ = 0\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4acqhvzc.swift:81:9: error: type annotation missing in pattern\n\
    \    var vowels\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpihpnyelp.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, vowels: vowels)\n         \
    \  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpihpnyelp.swift:17:51: error: cannot find 'vowels'\
    \ in scope\n    return find_closest_vowel(word: word, vowels: vowels)\n      \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels = [String]()\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmp1s176w7m.swift:105:1: error: missing return in global function
    expected to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = \"aeiouAEIOU\"\n\
    \    var vowelsCount = vowels.count\n    var vowelsIndex = 0\n    var vowelsIndex2\
    \ = vowelsIndex + vowelsCount\n    var vowelsIndex3 = vowelsIndex2 + vowelsCount\n\
    \    var vowelsIndex4 = vowelsIndex3 + vowelsCount\n    var vowelsIndex5 = vowelsIndex4\
    \ + vowelsCount\n    var vowelsIndex6 = vowelsIndex5 + vowelsCount\n    var vowelsIndex7\
    \ = vowelsIndex6 + vowelsCount\n    var vowelsIndex8 = vowelsIndex7 + vowelsCount\n\
    \    var vowelsIndex9 = vowelsIndex8 + vowelsCount\n    var vowelsIndex10 = vowelsIndex9\
    \ + vowelsCount\n    var vowelsIndex11 = vowelsIndex10 + vowelsCount\n    var\
    \ vowelsIndex12 = vowelsIndex11 + vowelsCount\n    var vowelsIndex13 = vowelsIndex12\
    \ + vowelsCount\n    var vowelsIndex14 = vowelsIndex13 + vowelsCount\n    var\
    \ vowelsIndex15 = vowelsIndex14 + vowelsCount\n    var vowelsIndex16 = vowelsIndex15\
    \ + vowelsCount\n    var vowelsIndex17 = vowelsIndex16 + vowelsCount\n    var\
    \ vowelsIndex18 = vowelsIndex17 + vowelsCount\n    var vowelsIndex19 = vowelsIndex18\
    \ + vowelsCount\n    var vowelsIndex20 = vowelsIndex19 + vowelsCount\n    var\
    \ vowelsIndex21 = vowelsIndex20 + vowelsCount\n    var vowelsIndex22 = vowelsIndex21\
    \ + vowelsCount\n    var vowelsIndex23 = vowelsIndex22 + vowelsCount\n    var\
    \ vowelsIndex24 = vowelsIndex23 + vowelsCount\n    var vowelsIndex25 = vowelsIndex24\
    \ + vowelsCount\n    var vowelsIndex26 = vowelsIndex25 + vowelsCount\n    var\
    \ vowelsIndex27 = vowelsIndex26 + vowelsCount\n    var vowelsIndex28 = vowelsIndex27\
    \ + vowelsCount\n    var vowelsIndex29 = vowelsIndex28 + vowelsCount\n    var\
    \ vowelsIndex30 = vowelsIndex29 + vowelsCount\n    var vowelsIndex31 = vowelsIndex30\
    \ + vowelsCount\n    var vowelsIndex32 = vowelsIndex31 + vowelsCount\n    var\
    \ vowelsIndex33 = vowelsIndex32 + vowelsCount\n    var vowelsIndex34 = vowelsIndex33\
    \ + vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplauv9y5p.swift:55:41: error: cannot find 'vowel' in scope\n   \
    \ var vowelsIndex34 = vowelsIndex33 + vowel\n                                \
    \        ^~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnoavf13p.swift:17:24: error: use of local variable 'vowels' before\
    \ its declaration\n    guard let vowels = vowels.characters.map(String.init) else\
    \ {\n                       ^\n/tmp/tmpnoavf13p.swift:105:9: note: 'vowels' declared\
    \ here\n    let vowels\n        ^\n/tmp/tmpnoavf13p.swift:105:9: error: type annotation\
    \ missing in pattern\n    let vowels\n        ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelFound = false\n    for letter in vowels\
    \ {\n        if letter == vowels[vowelIndex+1] {\n            vowelFound = true\n\
    \            vowelIndex += 1\n            if vowelIndex == vowels.count - 1 {\n\
    \                return letter\n            }\n        }\n    }\n    if !vowelFound\
    \ {\n        return \"\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphj_rnj2z.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmphj_rnj2z.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    \n    var vowelsCount = vowels.count\n    \n    if vowelsCount == 0 {\n \
    \       return \"\"\n    }\n    \n    var vowelIndex = 0\n    \n    for vowel\
    \ in vowels {\n        if word.rangeOfString(vowel, options: .CaseInsensitiveSearch).location\
    \ == NSNotFound {\n            vowelIndex = vowelIndex + 1\n        }\n    }\n\
    \    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n    var vowelsCount2\
    \ = vowels.count\n    \n    if vowelsCount2 == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndex2 = 0\n    \n    for vowel2 in vowels {\n        if word.rangeOfString(vowel2,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex2\
    \ = vowelIndex2 + 1\n        }\n    }\n    \n    if vowelIndex2 == 0 {\n     \
    \   return \"\"\n    }\n    \n    var vowelsCount3 = vowels.count\n    \n    if\
    \ vowelsCount3 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex3 =\
    \ 0\n    \n    for vowel3 in vowels {\n        if word.rangeOfString(vowel3, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex3 =\
    \ vowelIndex3 + 1\n        }\n    }\n    \n    if vowelIndex3 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount4 = vowels.count\n    \n    if\
    \ vowelsCount4 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex4 =\
    \ 0\n    \n    for vowel4 in vowels {\n        if word.rangeOfString(vowel4, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex4 =\
    \ vowelIndex4 + 1\n        }\n    }\n    \n    if vowelIndex4 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount5 = vowels.count\n    \n    if\
    \ vowelsCount5 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex5 =\
    \ 0\n    \n    for vowel5 in vowels {\n        if word.rangeOfString(vowel5, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex5 =\
    \ vowelIndex5 + 1\n        }\n    }\n    \n    if vowelIndex5 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount6 = vowels.count\n    \n    if\
    \ vowelsCount6 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex6 =\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpltzaaqps.swift:33:83: error: cannot find 'NSNotFound' in scope\n\
    \        if word.rangeOfString(vowel, options: .CaseInsensitiveSearch).location\
    \ == NSNotFound {\n                                                          \
    \                        ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:33:17: error: value\
    \ of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:33:48: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitiveSearch'\n        if word.rangeOfString(vowel, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                     ~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpltzaaqps.swift:51:84: error:\
    \ cannot find 'NSNotFound' in scope\n        if word.rangeOfString(vowel2, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                                                          ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:51:17:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel2,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:51:49: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitiveSearch'\n        if word.rangeOfString(vowel2, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                      ~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpltzaaqps.swift:69:84: error:\
    \ cannot find 'NSNotFound' in scope\n        if word.rangeOfString(vowel3, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                                                          ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:69:17:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel3,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:69:49: error: cannot infer contextual bas"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n\
    \        }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    var\
    \ vowelIndex = 0\n    var vowelIndexEnd = 0\n    var vowelIndexStart = 0\n   \
    \ while vowelIndex < vowels.count {\n        let vowel = vowels[vowelIndex]\n\
    \        if vowelIndexEnd < vowels.count {\n            let nextVowel = vowels[vowelIndexEnd]\n\
    \            if vowel == nextVowel {\n                vowelIndexEnd += 1\n   \
    \         } else {\n                vowelIndexStart = vowelIndex\n           \
    \     vowelIndexEnd = vowelIndex\n                vowelIndex = vowelIndexStart\n\
    \            }\n        } else {\n            vowelIndexEnd = vowelIndex\n   \
    \         vowelIndex = vowelIndexStart\n        }\n    }\n    return vowels[vowelIndexEnd]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpg61si36m.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpg61si36m.swift:19:12: error: initializer\
    \ for conditional binding must have Optional type, not 'Bool'\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters {\n        if vowels.contains(char) {\n            if let\
    \ index = vowels.index(of: char) {\n                let start = word.index(before:\
    \ index)\n                let end = word.index(before: start, offsetBy: 1)\n \
    \               let range = start..<end\n                let vowel = word[range]\n\
    \                if vowel.lowercased() == \"a\" {\n                    result\
    \ = vowel\n                    break\n                }\n            }\n     \
    \   }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0xuk636.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpp0xuk636.swift:24:35:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        \
    \    if let index = vowels.index(of: char) {\n                               \
    \   ^\n/tmp/tmpp0xuk636.swift:24:35: note: use 'firstIndex(of:)' instead\n   \
    \         if let index = vowels.index(of: char) {\n                          \
    \        ^~~~~\n                                  firstIndex\n/tmp/tmpp0xuk636.swift:26:32:\
    \ error: no exact matches in call to instance method 'index'\n               \
    \ let end = word.index(before: start, offsetBy: 1)\n                         \
    \      ^\nSwift.String:9:17: note: incorrect labels for candidate (have: '(before:offsetBy:)',\
    \ expected: '(_:offsetBy:)')\n    public func index(_ i: String.Index, offsetBy\
    \ distance: Int) -> String.Index\n                ^\nSwift.Collection:6:28: note:\
    \ incorrect labels for candidate (have: '(before:offsetBy:)', expected: '(_:offsetBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int) ->\
    \ Self.Index\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(before:offsetBy:)', expected:\
    \ '(_:offsetBy:)')\n    @inlinable public func index(_ i: Self.Index, offsetBy\
    \ distance: Int) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowelIndex = 0\n \
    \   var vowelIndex2 = word.count\n    var vowelIndex3 = word.count - 1\n    \n\
    \    var vowelIndex4 = word.count - 2\n    \n    var vowelIndex5 = word.count\
    \ - 3\n    \n    var vowelIndex6 = word.count - 4\n    \n    var vowelIndex7 =\
    \ word.count - 5\n    \n    var vowelIndex8 = word.count - 6\n    \n    var vowelIndex9\
    \ = word.count - 7\n    \n    var vowelIndex10 = word.count - 8\n    \n    var\
    \ vowelIndex11 = word.count - 9\n    \n    var vowelIndex12 = word.count - 10\n\
    \    \n    var vowelIndex13 = word.count - 11\n    \n    var vowelIndex14 = word.count\
    \ - 12\n    \n    var vowelIndex15 = word.count - 13\n    \n    var vowelIndex16\
    \ = word.count - 14\n    \n    var vowelIndex17 = word.count - 15\n    \n    var\
    \ vowelIndex18 = word.count - 16\n    \n    var vowelIndex19 = word.count - 17\n\
    \    \n    var vowelIndex20 = word.count - 18\n    \n    var vowelIndex21 = word.count\
    \ - 19\n    \n    var vowelIndex22 = word.count - 20\n    \n    var vowelIndex23\
    \ = word.count - 21\n    \n    var vowelIndex24 = word.count - 22\n    \n    var\
    \ vowelIndex25 = word.count - 23\n    \n    var vowelIndex26 = word.count - 24\n\
    \    \n    var vowelIndex27 = word.count - 25\n    \n    var vowelIndex28 = word.count\
    \ - 26\n    \n    var vowelIndex29 = word.count - 27\n    \n    var vowelIndex30\
    \ = word.count - 28\n    \n    var vowelIndex31 = word.count - 29\n    \n    var\
    \ vowelIndex32 = word.count - 30\n    \n    var vowelIndex33 = word.count - 31\n\
    \    \n    var vowelIndex34 = word.count - 32\n    \n    var vowelIndex35 = word.count\
    \ - 33\n    \n    var vowelIndex36 = word.count - 34\n    \n    var vowelIndex37\
    \ = word.count - 35\n    \n    var vowelIndex38 = word.count - 36\n    \n    var\
    \ vowelIndex39 = word.count - 37\n    \n    var vowelIndex40 = word.count - 38\n\
    \    \n    var vowelIndex41 = word.count - 39\n    \n    var vowelIndex42 = word.count\
    \ - 40\n    \n    var vowelIndex43 = word.count - 41\n    \n    var vowelIndex44\
    \ = word.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpds8y43yl.swift:105:28: error: expected member name following '.'\n\
    \    var vowelIndex44 = word.\n                           ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = []\n\
    \    for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(char.value)\n        }\n    }\n    if vowels.isEmpty\
    \ {\n        return \"\"\n    }\n    var index = vowels.count - 1\n    var vowel\
    \ = vowels[index]\n    if vowels.count > 2 {\n        for index in vowels.indices\
    \ {\n            if index > 0 {\n                if vowels[index - 1] == vowel\
    \ {\n                    vowel = vowels[index]\n                    break\n  \
    \              }\n            }\n        }\n    }\n    return vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrrz6mz.swift:23:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters.reverse() {\n        if vowels.contains(char) {\n       \
    \     result = char\n            break\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbn8c5fsu.swift:22:33: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in word.characters.reverse() {\n                ~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowelsCount > 0,\n        let vowelsCount\
    \ = vowelsCount < word.characters.count,\n        let vowelsCount = vowels.count\
    \ > 0,\n        let vowelsCount = vowels.count < word.characters.count else {\n\
    \            return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd44llk2.swift:79:29: error: expected member name following '.'\n\
    \    let vowelsCount = vowels.\n                            ^\n/tmp/tmpqd44llk2.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map({\
    \ String($0) }),\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"\
    e\")\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"\
    u\")\n    \n    var vowelsCount = vowels.count\n    \n    var lastConsonantIndex\
    \ = word.characters.count - 1\n    \n    var closestVowelIndex: Int?\n    \n \
    \   for index in 0..<word.characters.count {\n        \n        let currentChar\
    \ = word.characters[index]\n        \n        if currentChar == vowels.first {\n\
    \            \n            if closestVowelIndex == nil {\n                \n \
    \               closestVowelIndex = index\n                \n            }\n \
    \           \n            if index == lastConsonantIndex {\n                \n\
    \                closestVowelIndex = nil\n                \n            }\n  \
    \          \n        } else {\n            \n            if closestVowelIndex\
    \ != nil {\n                \n                if index == lastConsonantIndex {\n\
    \                    \n                    closestVowelIndex = nil\n         \
    \           \n                } else {\n                    \n               \
    \     closestVowelIndex = index\n                    \n                }\n   \
    \             \n            }\n            \n        }\n        \n    }\n    \n\
    \    if closestVowelIndex != nil {\n        \n        return word.substring(to:\
    \ closestVowelIndex!)\n        \n    } else {\n        \n        return \"\"\n\
    \        \n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp51d14pw9.swift:27:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var lastConsonantIndex = word.characters.count - 1\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp51d14pw9.swift:31:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in 0..<word.characters.count {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp51d14pw9.swift:33:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ currentChar = word.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp51d14pw9.swift:33:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = word.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp51d14pw9.swift:71:21:\
    \ error: value of type 'String' has no member 'substring'\n        return word.substring(to:\
    \ closestVowelIndex!)\n               ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count < 2 {\n        return \"\"\n    }\n    var vowelIndex\
    \ = 0\n    var vowelCount = 0\n    var consonantIndex = 0\n    var consonantCount\
    \ = 0\n    var currentVowel = \"\"\n    var currentConsonant = \"\"\n    var currentVowelIndex\
    \ = 0\n    var currentConsonantIndex = 0\n    for index in 0..<word.characters.count\
    \ {\n        let character = word.characters[index]\n        if character == \"\
    a\" || character == \"e\" || character == \"i\" || character == \"o\" || character\
    \ == \"u\" {\n            vowelCount += 1\n            if vowelIndex == 0 {\n\
    \                currentVowel = character\n                currentVowelIndex =\
    \ index\n            }\n        }\n        if character == \"b\" || character\
    \ == \"c\" || character == \"d\" || character == \"f\" || character == \"g\" ||\
    \ character == \"h\" || character == \"j\" || character == \"k\" || character\
    \ == \"l\" || character == \"m\" || character == \"n\" || character == \"p\" ||\
    \ character == \"q\" || character == \"r\" || character == \"s\" || character\
    \ == \"t\" || character == \"v\" || character == \"w\" || character == \"x\" ||\
    \ character == \"y\" || character == \"z\" {\n            vowelCount += 1\n  \
    \          if vowelIndex == 0 {\n                currentVowel = character\n  \
    \              currentVowelIndex = index\n            }\n        }\n        if\
    \ character == \"A\" || character == \"E\" || character == \"I\" || character\
    \ == \"O\" || character == \"U\" {\n            vowelCount += 1\n            if\
    \ vowelIndex == 0 {\n                currentVowel = character\n              \
    \  currentVowelIndex = index\n            }\n        }\n        if character ==\
    \ \"B\" || character == \"C\" || character == \"D\" || character == \"F\" || character\
    \ == \"G\" || character == \"H\" || character == \"J\" || character == \"K\" ||\
    \ character == \"L\" || character == \"M\" || character == \"N\" || character\
    \ == \"P\" || character == \"Q\" || character == \"R\" || character == \"S\" ||\
    \ character == \"T\" || character == \"V\" || character == \"W\" || character\
    \ == \"X\" || character == \"Y\" || character == \"Z\" {\n            vowelCount\
    \ += 1\n            if vowelIndex == 0 {\n                currentVowel = character\n\
    \                currentVowelIndex = index\n            }\n        }\n       \
    \ if character == \"0\" {\n            vowelCount += 1\n            if vowelIndex\
    \ == 0 {\n                currentVowel = character\n                currentVowelIndex\
    \ = index\n            }\n        }\n        if character == \"1\" {\n       \
    \     vowelCount += 1\n            if vowelIndex == 0 {\n                currentVowel\
    \ = character\n                currentVowelIndex = index\n            }\n    \
    \    }\n        if character == \"2\" {\n            vowelCount += 1\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0gt0462.swift:101:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpq0gt0462.swift:28:44: note: to match this opening\
    \ '{'\n    for index in 0..<word.characters.count {\n                        \
    \                   ^\n/tmp/tmpq0gt0462.swift:101:48: error: expected '}' at end\
    \ of brace statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n  \
    \                                             ^\n/tmp/tmpq0gt0462.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpq0gt0462.swift:17:13:\
    \ error: 'characters' is unavailable: Please use String directly\n    if word.characters.count\
    \ < 2 {\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpq0gt0462.swift:28:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<word.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpq0gt0462.swift:29:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = word.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpq0gt0462.swift:29:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = word.characters[index]\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq0gt0462.swift:33:32:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      currentVowel"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndexEnd = word.count\n\
    \    var vowelIndexStart = 0\n    var vowelIndexStartEnd = word.count\n    var\
    \ vowelIndexEndStart = 0\n    var vowelIndexStartEndEnd = 0\n    var vowelIndexStartEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n  \
    \  var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4xl76ya.swift:33:9: error: invalid redeclaration of 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n        ^\n/tmp/tmpx4xl76ya.swift:32:9:\
    \ note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd' previously declared\
    \ here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n       \
    \ ^\n/tmp/tmpx4xl76ya.swift:38:9: error: invalid redeclaration of 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n  \
    \      ^\n/tmp/tmpx4xl76ya.swift:37:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:41:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n   \
    \     ^\n/tmp/tmpx4xl76ya.swift:40:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:42:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n   \
    \     ^\n/tmp/tmpx4xl76ya.swift:40:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:44:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n  \
    \  var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd =\
    \ 0\n        ^\n/tmp/tmpx4xl76ya.swift:43:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndE"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndex2 = vowelIndex - 1\n    \n    for char in word.characters\
    \ {\n        if vowels.contains(String(char)) {\n            vowelIndex2 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex2\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex2 < vowelIndex {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex3 = vowelIndex2\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex3 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex3 == 0 {\n        return \"\"\n    }\n\
    \    \n    if vowelIndex3 < vowelIndex2 {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex4 = vowelIndex3\n    \n    for char in word.characters {\n\
    \        if vowels.contains(String(char)) {\n            vowelIndex4 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex4\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex4 < vowelIndex3 {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex5 = vowelIndex4\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex5 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex5 == 0 {\n        return \"\"\n    }\n\
    \    \n    if vowelIndex5 < vowelIndex4 {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex6 = vowelIndex5\n    \n    for char in word.characters {\n\
    \        if vowels.contains(String(char)) {\n            vowelIndex6 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex6\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex6 < vowelIndex5 {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex7 = vowelIndex6\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex7 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex7 == 0 {\n        return \"\"\n    }\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_5njhrvp.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_5njhrvp.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp_5njhrvp.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmp_5njhrvp.swift:35:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp_5njhrvp.swift:37:62: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n            vowelIndex2 = vowels.firstIndex(of:\
    \ String(char))!\n                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmp_5njhrvp.swift:37:49: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n            vowelIndex2\
    \ = vowels.firstIndex(of: String(char))!\n                                   \
    \             ^\n/tmp/tmp_5njhrvp.swift:52:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in word.characters {\n            \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_5njhrvp.swift:54:62:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex3 = vowels.firstIndex(of: String(char))!\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp_5njhrvp.swift:54:49: err"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountMax:\
    \ Int = vowels.count\n    var vowelsCountMin: Int = vowels.count - 1\n    var\
    \ vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpab63gkrz.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpab63gkrz.swift:24:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:25:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:26:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:27:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:28:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:29:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:30:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously decl"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    if\
    \ word.hasPrefix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasPrefix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.hasPrefix(\"i\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"I\")\n    }\n    if word.hasPrefix(\"o\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"O\")\n    }\n    if word.hasPrefix(\"\
    u\") {\n        vowels.removeAll()\n        vowels.append(\"U\")\n    }\n    \n\
    \    if word.hasSuffix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasSuffix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.hasSuffix(\"i\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"I\")\n    }\n    if word.hasSuffix(\"o\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"O\")\n    }\n    if word.hasSuffix(\"\
    u\") {\n        vowels.removeAll()\n        vowels.append(\"U\")\n    }\n    \n\
    \    if word.hasPrefix(\"A\") {\n        vowels.removeAll()\n        vowels.append(\"\
    a\")\n    }\n    if word.hasPrefix(\"E\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"e\")\n    }\n    if word.hasPrefix(\"I\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"i\")\n    }\n    if word.hasPrefix(\"O\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"o\")\n    }\n    if word.hasPrefix(\"\
    U\") {\n        vowels.removeAll()\n        vowels.append(\"u\")\n    }\n    \n\
    \    if word.hasSuffix(\"A\") {\n        vowels.removeAll()\n        vowels.append(\"\
    a\")\n    }\n    if word.hasSuffix(\"E\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"e\")\n    }\n    if word.hasSuffix(\"I\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"i\")\n    }\n    if word.hasSuffix(\"O\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"o\")\n    }\n    if word.hasSuffix(\"\
    U\") {\n        vowels.removeAll()\n        vowels.append(\"u\")\n    }\n    \n\
    \    if word.hasPrefix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasPrefix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgovydp0t.swift:112:12: error: expected member name following '.'\n\
    \    if word.\n           ^\n/tmp/tmpgovydp0t.swift:112:13: error: expected '{'\
    \ after 'if' condition\n    if word.\n            ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkn8ia523.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    var vowelsCount = 0\n    \n \
    \   for char in word.characters {\n        if vowels.contains(char) {\n      \
    \      vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount > 0 {\n  \
    \      var vowelsCountFromRight = 0\n        \n        for char in word.characters\
    \ {\n            if vowels.contains(char) {\n                vowelsCountFromRight\
    \ += 1\n            }\n        }\n        \n        if vowelsCountFromRight >\
    \ 0 {\n            var vowelsCountFromRightToLeft = 0\n            \n        \
    \    for char in word.characters {\n                if vowels.contains(char) {\n\
    \                    vowelsCountFromRightToLeft += 1\n                }\n    \
    \        }\n            \n            if vowelsCountFromRightToLeft > 0 {\n  \
    \              let closestVowel = vowels[vowels.count - vowelsCountFromRightToLeft]\n\
    \                return closestVowel\n            }\n        }\n    }\n    \n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpelhqvyh7.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:26:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpelhqvyh7.swift:34:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ char in word.characters {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:35:32: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            if\
    \ vowels.contains(char) {\n                               ^\n/tmp/tmpelhqvyh7.swift:43:30:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ for char in word.characters {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:44:36: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   if vowels.contains(char) {\n                                   ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelsCount = 0\n    var vowelsIndex = 0\n  \
    \  var vowelsIndex2 = 0\n    var vowelsIndex3 = 0\n    var vowelsIndex4 = 0\n\
    \    var vowelsIndex5 = 0\n    var vowelsIndex6 = 0\n    var vowelsIndex7 = 0\n\
    \    var vowelsIndex8 = 0\n    var vowelsIndex9 = 0\n    var vowelsIndex10 = 0\n\
    \    var vowelsIndex11 = 0\n    var vowelsIndex12 = 0\n    var vowelsIndex13 =\
    \ 0\n    var vowelsIndex14 = 0\n    var vowelsIndex15 = 0\n    var vowelsIndex16\
    \ = 0\n    var vowelsIndex17 = 0\n    var vowelsIndex18 = 0\n    var vowelsIndex19\
    \ = 0\n    var vowelsIndex20 = 0\n    var vowelsIndex21 = 0\n    var vowelsIndex22\
    \ = 0\n    var vowelsIndex23 = 0\n    var vowelsIndex24 = 0\n    var vowelsIndex25\
    \ = 0\n    var vowelsIndex26 = 0\n    var vowelsIndex27 = 0\n    var vowelsIndex28\
    \ = 0\n    var vowelsIndex29 = 0\n    var vowelsIndex30 = 0\n    var vowelsIndex31\
    \ = 0\n    var vowelsIndex32 = 0\n    var vowelsIndex33 = 0\n    var vowelsIndex34\
    \ = 0\n    var vowelsIndex35 = 0\n    var vowelsIndex36 = 0\n    var vowelsIndex37\
    \ = 0\n    var vowelsIndex38 = 0\n    var vowelsIndex39 = 0\n    var vowelsIndex40\
    \ = 0\n    var vowelsIndex41 = 0\n    var vowelsIndex42 = 0\n    var vowelsIndex43\
    \ = 0\n    var vowelsIndex44 = 0\n    var vowelsIndex45 = 0\n    var vowelsIndex46\
    \ = 0\n    var vowelsIndex47 = 0\n    var vowelsIndex48 = 0\n    var vowelsIndex49\
    \ = 0\n    var vowelsIndex50 = 0\n    var vowelsIndex51 = 0\n    var vowelsIndex52\
    \ = 0\n    var vowelsIndex53 = 0\n    var vowelsIndex54 = 0\n    var vowelsIndex55\
    \ = 0\n    var vowelsIndex56 = 0\n    var vowelsIndex57 = 0\n    var vowelsIndex58\
    \ = 0\n    var vowelsIndex59 = 0\n    var vowelsIndex60 = 0\n    var vowelsIndex61\
    \ = 0\n    var vowelsIndex62 = 0\n    var vowelsIndex63 = 0\n    var vowelsIndex64\
    \ = 0\n    var vowelsIndex65 = 0\n    var vowelsIndex66 = 0\n    var vowelsIndex67\
    \ = 0\n    var vowelsIndex68 = 0\n    var vowelsIndex69 = 0\n    var vowelsIndex70\
    \ = 0\n    var vowelsIndex71 = 0\n    var vowelsIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpprf7zaln.swift:90:9: error: type annotation missing in pattern\n\
    \    var vowelsIndex\n        ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ Int = 0\n    var vowelIndex: Int = 0\n    var vowelIndex2: Int = 0\n    var\
    \ vowelIndex3: Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5: Int\
    \ = 0\n    var vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var vowelIndex8:\
    \ Int = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int = 0\n    var\
    \ vowelIndex11: Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13:\
    \ Int = 0\n    var vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var\
    \ vowelIndex16: Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18:\
    \ Int = 0\n    var vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var\
    \ vowelIndex21: Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23:\
    \ Int = 0\n    var vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var\
    \ vowelIndex26: Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28:\
    \ Int = 0\n    var vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var\
    \ vowelIndex31: Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33:\
    \ Int = 0\n    var vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var\
    \ vowelIndex36: Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38:\
    \ Int = 0\n    var vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var\
    \ vowelIndex41: Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43:\
    \ Int = 0\n    var vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var\
    \ vowelIndex46: Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48:\
    \ Int = 0\n    var vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var\
    \ vowelIndex51: Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53:\
    \ Int = 0\n    var vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var\
    \ vowelIndex56: Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58:\
    \ Int = 0\n    var vowelIndex59: Int = 0\n    var vowelIndex60: Int = 0\n    var\
    \ vowelIndex61: Int = 0\n    var vowelIndex62: \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplyflt0qq.swift:80:22: error: expected type\n    var vowelIndex62:\
    \ \n                     ^\n                      <#type#>\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n    \n    if vowelIndex == -1 { return \"\" }\n    \n    let vowelIndex1\
    \ = word.characters.reversed().firstIndex(of: vowels[vowelIndex!])\n    \n   \
    \ if vowelIndex1 == -1 { return \"\" }\n    \n    let vowelIndex2 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex1!])\n    \n    if vowelIndex2 == -1 { return \"\" }\n    \n\
    \    let vowelIndex3 = word.characters.reversed().firstIndex(of: vowels[vowelIndex2!])\n\
    \    \n    if vowelIndex3 == -1 { return \"\" }\n    \n    let vowelIndex4 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex3!])\n    \n    if vowelIndex4 == -1 { return \"\" }\n    \n\
    \    let vowelIndex5 = word.characters.reversed().firstIndex(of: vowels[vowelIndex4!])\n\
    \    \n    if vowelIndex5 == -1 { return \"\" }\n    \n    let vowelIndex6 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex5!])\n    \n    if vowelIndex6 == -1 { return \"\" }\n    \n\
    \    let vowelIndex7 = word.characters.reversed().firstIndex(of: vowels[vowelIndex6!])\n\
    \    \n    if vowelIndex7 == -1 { return \"\" }\n    \n    let vowelIndex8 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex7!])\n    \n    if vowelIndex8 == -1 { return \"\" }\n    \n\
    \    let vowelIndex9 = word.characters.reversed().firstIndex(of: vowels[vowelIndex8!])\n\
    \    \n    if vowelIndex9 == -1 { return \"\" }\n    \n    let vowelIndex10 =\
    \ word.characters.reversed().firstIndex(of: vowels[vowelIndex9!])\n    \n    if\
    \ vowelIndex10 == -1 { return \"\" }\n    \n    let vowelIndex11 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex10!])\n    \n    if vowelIndex11 == -1 { return \"\" }\n  \
    \  \n    let vowelIndex12 = word.characters.reversed().firstIndex(of: vowels[vowelIndex11!])\n\
    \    \n    if vowelIndex12 == -1 { return \"\" }\n    \n    let vowelIndex13 =\
    \ word.characters.reversed().firstIndex(of: vowels[vowelIndex12!])\n    \n   \
    \ if vowelIndex13 == -1 { return \"\" }\n    \n    let vowelIndex14 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ynmv2i_.swift:77:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp8ynmv2i_.swift:76:72: note: to match this opening '['\n    let vowelIndex14\
    \ = word.characters.reversed().firstIndex(of: vowels[vowelIndex\n            \
    \                                                           ^\n/tmp/tmp8ynmv2i_.swift:20:64:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n                                                               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  var vowelsCount = 0\n    var consonants = [String]()\n    var consonantsCount\
    \ = 0\n    var consonantsCount2 = 0\n    var consonantsCount3 = 0\n    var consonantsCount4\
    \ = 0\n    var consonantsCount5 = 0\n    var consonantsCount6 = 0\n    var consonantsCount7\
    \ = 0\n    var consonantsCount8 = 0\n    var consonantsCount9 = 0\n    var consonantsCount10\
    \ = 0\n    var consonantsCount11 = 0\n    var consonantsCount12 = 0\n    var consonantsCount13\
    \ = 0\n    var consonantsCount14 = 0\n    var consonantsCount15 = 0\n    var consonantsCount16\
    \ = 0\n    var consonantsCount17 = 0\n    var consonantsCount18 = 0\n    var consonantsCount19\
    \ = 0\n    var consonantsCount20 = 0\n    var consonantsCount21 = 0\n    var consonantsCount22\
    \ = 0\n    var consonantsCount23 = 0\n    var consonantsCount24 = 0\n    var consonantsCount25\
    \ = 0\n    var consonantsCount26 = 0\n    var consonantsCount27 = 0\n    var consonantsCount28\
    \ = 0\n    var consonantsCount29 = 0\n    var consonantsCount30 = 0\n    var consonantsCount31\
    \ = 0\n    var consonantsCount32 = 0\n    var consonantsCount33 = 0\n    var consonantsCount34\
    \ = 0\n    var consonantsCount35 = 0\n    var consonantsCount36 = 0\n    var consonantsCount37\
    \ = 0\n    var consonantsCount38 = 0\n    var consonantsCount39 = 0\n    var consonantsCount40\
    \ = 0\n    var consonantsCount41 = 0\n    var consonantsCount42 = 0\n    var consonantsCount43\
    \ = 0\n    var consonantsCount44 = 0\n    var consonantsCount45 = 0\n    var consonantsCount46\
    \ = 0\n    var consonantsCount47 = 0\n    var consonantsCount48 = 0\n    var consonantsCount49\
    \ = 0\n    var consonantsCount50 = 0\n    var consonantsCount51 = 0\n    var consonantsCount52\
    \ = 0\n    var consonantsCount53 = 0\n    var consonantsCount54 = 0\n    var consonantsCount55\
    \ = 0\n    var consonantsCount56 = 0\n    var consonantsCount57 = 0\n    var consonantsCount58\
    \ = 0\n    var consonantsCount59 = 0\n    var consonantsCount60 = 0\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnor1p79n.swift:20:9: warning: initialization of variable 'vowels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowels = [String]()\n    ~~~~^~~~~~\n    _\n/tmp/tmpnor1p79n.swift:21:9:\
    \ warning: initialization of variable 'vowelsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelsCount = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:22:9: warning: initialization of variable 'consonants'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonants = [String]()\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:23:9:\
    \ warning: initialization of variable 'consonantsCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantsCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:24:9: warning: initialization\
    \ of variable 'consonantsCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantsCount2 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:25:9: warning: initialization of variable 'consonantsCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantsCount3 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:26:9:\
    \ warning: initialization of variable 'consonantsCount4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantsCount4 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:27:9: warning: initialization\
    \ of variable 'consonantsCount5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantsCount5 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:28:9: warning: initialization of variable 'consonantsCount6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantsCount6 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:29:9:\
    \ warning: initialization of variable 'consonantsCount7' was never used; consider\
    \ replacing with assignment to '_' o"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelsCount = vowels.count\n    var vowelsIndex\
    \ = 0\n    var vowelsIndexEnd = vowelsIndex + vowelsCount\n    var vowelsIndexStart\
    \ = 0\n    var vowelsIndexStartEnd = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd2\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd3 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd4 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd5 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd6\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd7 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd8 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd9 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd10\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd11 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd12 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd13 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd14\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd15 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd16 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd17 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd18\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd19 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd20 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd21 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd22\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd23 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd24 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd25 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd26\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd27 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd28 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfz48ulva.swift:50:9: error: type annotation missing in pattern\n\
    \    var vowelsIndexStart\n        ^\n"
  stdout: ''
  timestamp: 1660013629
