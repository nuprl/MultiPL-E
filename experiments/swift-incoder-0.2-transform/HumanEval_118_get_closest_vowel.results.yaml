language: swift
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    var index = word.startIndex\n    \n    while index < word.endIndex\
    \ {\n        if vowels.contains(word.substringToIndex(index)) {\n            return\
    \ word.substringFromIndex(index)\n        }\n        index = index + 1\n    }\n\
    \    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1skecvup.swift:26:33: error: value of type 'String' has no member\
    \ 'substringToIndex'\n        if vowels.contains(word.substringToIndex(index))\
    \ {\n                           ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp1skecvup.swift:27:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n         \
    \   return word.substringFromIndex(index)\n                   ~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1skecvup.swift:29:23: error: binary operator '+' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n        index = index + 1\n     \
    \           ~~~~~ ^ ~\n/tmp/tmp1skecvup.swift:29:23: note: overloads for '+' exist\
    \ with these partially matching parameter lists: (Int, Int)\n        index = index\
    \ + 1\n                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    for vowel in vowels {\n        if vowel.hasPrefix(\"A\") {\n            return\
    \ vowel\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8shecl7.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpk8shecl7.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelsCount = vowels.count\n    var vowelIndex\
    \ = 0\n    var vowelIndexEnd = vowels.count - 1\n    var vowelIndexStart = vowels.count\
    \ - 1\n    var vowelIndexEnd2 = vowels.count - 1\n    var vowelIndexStart2 = vowels.count\
    \ - 1\n    var vowelIndexEnd3 = vowels.count - 1\n    var vowelIndexStart3 = vowels.count\
    \ - 1\n    var vowelIndexEnd4 = vowels.count - 1\n    var vowelIndexStart4 = vowels.count\
    \ - 1\n    var vowelIndexEnd5 = vowels.count - 1\n    var vowelIndexStart5 = vowels.count\
    \ - 1\n    var vowelIndexEnd6 = vowels.count - 1\n    var vowelIndexStart6 = vowels.count\
    \ - 1\n    var vowelIndexEnd7 = vowels.count - 1\n    var vowelIndexStart7 = vowels.count\
    \ - 1\n    var vowelIndexEnd8 = vowels.count - 1\n    var vowelIndexStart8 = vowels.count\
    \ - 1\n    var vowelIndexEnd9 = vowels.count - 1\n    var vowelIndexStart9 = vowels.count\
    \ - 1\n    var vowelIndexEnd10 = vowels.count - 1\n    var vowelIndexStart10 =\
    \ vowels.count - 1\n    var vowelIndexEnd11 = vowels.count - 1\n    var vowelIndexStart11\
    \ = vowels.count - 1\n    var vowelIndexEnd12 = vowels.count - 1\n    var vowelIndexStart12\
    \ = vowels.count - 1\n    var vowelIndexEnd13 = vowels.count - 1\n    var vowelIndexStart13\
    \ = vowels.count - 1\n    var vowelIndexEnd14 = vowels.count - 1\n    var vowelIndexStart14\
    \ = vowels.count - 1\n    var vowelIndexEnd15 = vowels.count - 1\n    var vowelIndexStart15\
    \ = vowels.count - 1\n    var vowelIndexEnd16 = vowels.count - 1\n    var vowelIndexStart16\
    \ = vowels.count - 1\n    var vowelIndexEnd17 = vowels.count - 1\n    var vowelIndexStart17\
    \ = vowels.count - 1\n    var vowelIndexEnd18 = vowels.count - 1\n    var vowelIndexStart18\
    \ = vowels.count - 1\n    var vowelIndexEnd19 = vowels.count - 1\n    var vowelIndexStart19\
    \ = vowels.count - 1\n    var vowelIndexEnd20 = vowels.count - 1\n    var vowelIndexStart20\
    \ = vowels.count - 1\n    var vowelIndexEnd21 = vowels.count - 1\n    var vowelIndexStart21\
    \ = vowels.count - 1\n    var vowelIndexEnd22 = vowels.count - 1\n    var vowelIndexStart22\
    \ = vowels.count - 1\n    var vowelIndexEnd23 = vowels.count - 1\n    var vowelIndexStart23\
    \ = vowels.count - 1\n    var vowelIndexEnd24 = vowels.count \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp13oe3fsh.swift:17:9: warning: variable 'vowels' was never mutated;\
    \ consider changing to 'let' constant\n    var vowels = \"aeiouAEIOU\"\n    ~~~\
    \ ^\n    let\n/tmp/tmp13oe3fsh.swift:18:9: warning: initialization of variable\
    \ 'vowelsCount' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:19:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmp13oe3fsh.swift:20:9: warning: initialization of variable 'vowelIndexEnd'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:21:9:\
    \ warning: initialization of variable 'vowelIndexStart' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart = vowels.count\
    \ - 1\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:22:9: warning: initialization\
    \ of variable 'vowelIndexEnd2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexEnd2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp13oe3fsh.swift:23:9: warning: initialization of variable 'vowelIndexStart2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexStart2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp13oe3fsh.swift:24:9: warning: initialization of variable 'vowelIndexEnd3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd3 = vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:25:9:\
    \ warning: initialization of variable 'vowelIndexStart3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart3 =\
    \ vowels.count - 1\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp13oe3fsh.swift:26:9:\
    \ warning: initialization of variable 'vowelIndexEnd4' was never used; consider\
    \ re"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountMax:\
    \ Int = vowels.count\n    var vowelsCountMin: Int = vowels.count - 1\n    var\
    \ vowelsCountSum: Int = 0\n    var vowelsCountSumMax: Int = vowelsCountMax\n \
    \   var vowelsCountSumMin: Int = vowelsCountMin - 1\n    var vowelsCountSumSum:\
    \ Int = 0\n    var vowelsCountSumSumMax: Int = vowelsCountSumMax\n    var vowelsCountSumSumMin:\
    \ Int = vowelsCountSumMin - 1\n    var vowelsCountSumSumSum: Int = 0\n    var\
    \ vowelsCountSumSumSumMax: Int = vowelsCountSumSumMax\n    var vowelsCountSumSumSumMin:\
    \ Int = vowelsCountSumSumMin - 1\n    var vowelsCountSumSumSumSum: Int = 0\n \
    \   var vowelsCountSumSumSumSumMax: Int = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumMin - 1\n    var vowelsCountSumSumSumSumSum: Int =\
    \ 0\n    var vowelsCountSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumMin - 1\n\
    \    var vowelsCountSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumMin - 1\n    var vowelsCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumMin\
    \ - 1\n    var vowelsCountSumSumSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMin - 1\n    var vowels\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyam_p5yh.swift:39:49: error: use of local variable 'vowelsCountSumSumSumSumSumSumMin'\
    \ before its declaration\n    var vowelsCountSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumMin\
    \ - 1\n                                                ^\n/tmp/tmpyam_p5yh.swift:39:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumMin' declared here\n    var vowelsCountSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumMin - 1\n        ^\n/tmp/tmpyam_p5yh.swift:41:52:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumMax' before its\
    \ declaration\n    var vowelsCountSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumMax\n\
    \                                                   ^\n/tmp/tmpyam_p5yh.swift:41:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumMax\n        ^\n/tmp/tmpyam_p5yh.swift:42:52:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumMin' before its\
    \ declaration\n    var vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumMin\
    \ - 1\n                                                   ^\n/tmp/tmpyam_p5yh.swift:42:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumMin' declared here\n    var vowelsCountSumSumSumSumSumSumSumMin:\
    \ Int = vowelsCountSumSumSumSumSumSumSumMin - 1\n        ^\n/tmp/tmpyam_p5yh.swift:44:55:\
    \ error: use of local variable 'vowelsCountSumSumSumSumSumSumSumSumMax' before\
    \ its declaration\n    var vowelsCountSumSumSumSumSumSumSumSumMax: Int = vowelsCountSumSumSumSumSumSumSumSumMax\n\
    \                                                      ^\n/tmp/tmpyam_p5yh.swift:44:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumSumSumSumMax:\
    \ Int = vowelsCountSumSumSumSumSumSumSumSumMax\n        ^\n/tmp/tmpyam_p5yh.swift:45:52:\
    \ error: cannot find 'vowelsCountSumSumSumSumSumSumSumSumMin' in scope\n    var\
    \ vowelsCountSumSumSumSumSumSumSumMin: Int = vowelsCountSumSumSumSumSumSumSumSumMin\
    \ - 1\n                                                   ^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndex: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount2: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount3: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount4: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount5: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount6: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount7: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount8: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount9: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount10: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount11: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount12: [Int] = [0, 1, 2, 3, 4]\n   \
    \ var vowelsIndexCount13: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount14:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount15: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount16: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount17:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount18: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount19: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount20:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount21: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount22: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount23:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount24: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount25: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount26:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount27: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount28: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount29:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount30: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount31: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount32:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount33: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount34: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount35:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount36: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount37: [\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kf6fl6b.swift:56:30: error: expected element type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n                              <#type#>\n\
    /tmp/tmp8kf6fl6b.swift:56:30: error: expected ']' in array type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n/tmp/tmp8kf6fl6b.swift:56:29: note: to match\
    \ this opening '['\n    var vowelsIndexCount37: [\n                          \
    \  ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = vowels.filter {\n        !$0.isEmpty &&\
    \ $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty\
    \ && $0.lowercased() != \"e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnbbswo8t.swift:76:43: error: unterminated string literal\n    \
    \    !$0.isEmpty && $0.lowercased() != \"e\n                                 \
    \         ^\n/tmp/tmpnbbswo8t.swift:104:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmpnbbswo8t.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmpnbbswo8t.swift:80:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    var\
    \ vowelIndex2 = word.count\n    \n    var vowelIndex3 = word.count\n    \n   \
    \ var vowelIndex4 = word.count\n    \n    var vowelIndex5 = word.count\n    \n\
    \    var vowelIndex6 = word.count\n    \n    var vowelIndex7 = word.count\n  \
    \  \n    var vowelIndex8 = word.count\n    \n    var vowelIndex9 = word.count\n\
    \    \n    var vowelIndex10 = word.count\n    \n    var vowelIndex11 = word.count\n\
    \    \n    var vowelIndex12 = word.count\n    \n    var vowelIndex13 = word.count\n\
    \    \n    var vowelIndex14 = word.count\n    \n    var vowelIndex15 = word.count\n\
    \    \n    var vowelIndex16 = word.count\n    \n    var vowelIndex17 = word.count\n\
    \    \n    var vowelIndex18 = word.count\n    \n    var vowelIndex19 = word.count\n\
    \    \n    var vowelIndex20 = word.count\n    \n    var vowelIndex21 = word.count\n\
    \    \n    var vowelIndex22 = word.count\n    \n    var vowelIndex23 = word.count\n\
    \    \n    var vowelIndex24 = word.count\n    \n    var vowelIndex25 = word.count\n\
    \    \n    var vowelIndex26 = word.count\n    \n    var vowelIndex27 = word.count\n\
    \    \n    var vowelIndex28 = word.count\n    \n    var vowelIndex29 = word.count\n\
    \    \n    var vowelIndex30 = word.count\n    \n    var vowelIndex31 = word.count\n\
    \    \n    var vowelIndex32 = word.count\n    \n    var vowelIndex33 = word.count\n\
    \    \n    var vowelIndex34 = word.count\n    \n    var vowelIndex35 = word.count\n\
    \    \n    var vowelIndex36 = word.count\n    \n    var vowelIndex37 = word.count\n\
    \    \n    var vowelIndex38 = word.count\n    \n    var vowelIndex39 = word.count\n\
    \    \n    var vowelIndex40 = word.count\n    \n    var vowelIndex41 = word.count\n\
    \    \n    var vowelIndex42 = word.count\n    \n    var vowelIndex43 = word.count\n\
    \    \n    var vowelIndex44 = word.count\n    \n    var vowelIndex45 = word.count\n\
    \    \n    var vowelIndex46 = word.count\n    \n    var vowelIndex47 = word.count\n\
    \    \n    var vowelIndex48 = word.count\n    \n    var vowelIndex49 = word.count\n\
    \    \n    var vowelIndex50 = word.count\n    \n    var vowelIndex51 = word.count\n\
    \    \n    var vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxd7u075m.swift:122:9: error: type annotation missing in pattern\n\
    \    var vowel\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ $0.lowercased() }),\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowels.count,\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpegnkzkt6.swift:79:40: error: expected expression in conditional\n\
    \        let vowelsCount = vowels.count,\n                                   \
    \    ^\n/tmp/tmpegnkzkt6.swift:17:24: error: cannot find 'vowels' in scope\n \
    \   guard let vowels = vowels.characters.map({ $0.lowercased() }),\n         \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    if word.characters.count < 2 {\n \
    \       return \"\"\n    }\n    \n    var index = 0\n    var currentIndex = 0\n\
    \    \n    while index < word.characters.count {\n        if vowels.contains(word.characters[index])\
    \ {\n            currentIndex = index\n        }\n        \n        index += 1\n\
    \    }\n    \n    if currentIndex == 0 {\n        return \"\"\n    }\n    \n \
    \   if currentIndex == word.characters.count - 1 {\n        return word.characters[currentIndex\
    \ - 1]\n    }\n    \n    if word.characters[currentIndex - 1] == word.characters[currentIndex\
    \ + 1] {\n        return word.characters[currentIndex - 1]\n    }\n    \n    if\
    \ word.characters[currentIndex - 1] == word.characters[currentIndex - 2] {\n \
    \       return word.characters[currentIndex - 1]\n    }\n    \n    if word.characters[currentIndex\
    \ + 1] == word.characters[currentIndex + 2] {\n        return word.characters[currentIndex\
    \ + 1]\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpb0qat2ol.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 2 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb0qat2ol.swift:27:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    while index\
    \ < word.characters.count {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb0qat2ol.swift:28:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if vowels.contains(word.characters[index]) {\n                      \
    \     ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpb0qat2ol.swift:28:33: error: 'characters' is\
    \ unavailable: Please use String directly\n        if vowels.contains(word.characters[index])\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb0qat2ol.swift:39:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    if currentIndex == word.characters.count - 1\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpb0qat2ol.swift:40:31: error: cannot convert return\
    \ expression of type 'Character' to return type 'String'\n        return word.characters[currentIndex\
    \ - 1]\n               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpb0qat2ol.swift:43:8:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    if word.characters[currentIndex - 1] == word.characters[currentIndex\
    \ + 1] {\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"y\")\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpm3ta725j.swift:93:11: error: expected member name following '.'\n\
    \    vowels.\n          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count,\n        let word = word.lowercased(),\n        let wordCount\
    \ = word.characters.count else {\n        return \"\"\n    }\n    \n    let vowelsCount\
    \ = vowels.count\n    let wordCount = word.characters.count\n    \n    let vowelsIndex\
    \ = word.characters.reversed().index(of: vowels.first!)\n    let vowelsIndex2\
    \ = vowelsIndex + vowelsCount - 1\n    \n    if vowelsIndex2 < wordCount {\n \
    \       return vowels[vowelsIndex2]\n    }\n    \n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbeh5mt5i.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map({ String($0) }),\n               \
    \        ^~~~~~\n/tmp/tmpbeh5mt5i.swift:20:30: error: 'characters' is unavailable:\
    \ Please use String directly\n        let wordCount = word.characters.count else\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbeh5mt5i.swift:19:9: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n        let word = word.lowercased(),\n\
    \        ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpbeh5mt5i.swift:20:9: error: initializer\
    \ for conditional binding must have Optional type, not 'Int'\n        let wordCount\
    \ = word.characters.count else {\n        ^               ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbeh5mt5i.swift:25:26: error: 'characters' is unavailable: Please use String\
    \ directly\n    let wordCount = word.characters.count\n                      \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbeh5mt5i.swift:25:9:\
    \ error: invalid redeclaration of 'wordCount'\n    let wordCount = word.characters.count\n\
    \        ^\n/tmp/tmpbeh5mt5i.swift:20:13: note: 'wordCount' previously declared\
    \ here\n        let wordCount = word.characters.count else {\n            ^\n\
    /tmp/tmpbeh5mt5i.swift:28:36: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n    let vowelsIndex2 = vowelsIndex + vowelsCount\
    \ - 1\n                                   ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.firstIndex(of: char) {\n \
    \           return index\n        }\n        return -1\n    }.min()\n    if vowelsIndex\
    \ == -1 {\n        return \"\"\n    }\n    let vowelsRange = vowelsIndex..<vowelsIndex\
    \ + vowelsCount\n    let vowelsRangeCount = vowelsRange.count\n    let vowelsRangeIndex\
    \ = word.characters.reversed().enumerate().map { (index, char) in\n        if\
    \ let index = vowelsRange.firstIndex(of: char) {\n            return index\n \
    \       }\n        return -1\n    }.min()\n    if vowelsRangeIndex == -1 {\n \
    \       return \"\"\n    }\n    let vowelsRangeCount = vowelsRangeIndex - vowelsIndex\n\
    \    let vowelsRangeCount2 = vowelsRangeCount * vowelsCount\n    let vowelsRangeIndex2\
    \ = vowelsIndex + vowelsRangeCount\n    let vowelsRangeIndex3 = vowelsIndex +\
    \ vowelsRangeCount2\n    let vowelsRangeIndex4 = vowelsIndex + vowelsRangeCount3\n\
    \    let vowelsRangeIndex5 = vowelsIndex + vowelsRangeCount4\n    let vowelsRangeIndex6\
    \ = vowelsIndex + vowelsRangeCount5\n    let vowelsRangeIndex7 = vowelsIndex +\
    \ vowelsRangeCount6\n    let vowelsRangeIndex8 = vowelsIndex + vowelsRangeCount7\n\
    \    let vowelsRangeIndex9 = vowelsIndex + vowelsRangeCount8\n    let vowelsRangeIndex10\
    \ = vowelsIndex + vowelsRangeCount9\n    let vowelsRangeIndex11 = vowelsIndex\
    \ + vowelsRangeCount10\n    let vowelsRangeIndex12 = vowelsIndex + vowelsRangeCount11\n\
    \    let vowelsRangeIndex13 = vowelsIndex + vowelsRangeCount12\n    let vowelsRangeIndex14\
    \ = vowelsIndex + vowelsRangeCount13\n    let vowelsRangeIndex15 = vowelsIndex\
    \ + vowelsRangeCount14\n    let vowelsRangeIndex16 = vowelsIndex + vowelsRangeCount15\n\
    \    let vowelsRangeIndex17 = vowelsIndex + vowelsRangeCount16\n    let vowelsRangeIndex18\
    \ = vowelsIndex + vowelsRangeCount17\n    let vowelsRangeIndex19 = vowelsIndex\
    \ + vowelsRangeCount18\n    let vowelsRangeIndex20 = vowelsIndex + vowelsRangeCount19\n\
    \    let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ubqxog8.swift:62:8: error: expected pattern\n    let \n      \
    \ ^\n/tmp/tmp2ubqxog8.swift:17:24: error: cannot find 'vowels' in scope\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n                   \
    \    ^~~~~~\n/tmp/tmp2ubqxog8.swift:21:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                 ^\n/tmp/tmp2ubqxog8.swift:32:55:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsRangeIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                      ^\n\
    /tmp/tmp2ubqxog8.swift:45:43: error: cannot find 'vowelsRangeCount3' in scope\n\
    \    let vowelsRangeIndex4 = vowelsIndex + vowelsRangeCount3\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:46:43: error:\
    \ cannot find 'vowelsRangeCount4' in scope\n    let vowelsRangeIndex5 = vowelsIndex\
    \ + vowelsRangeCount4\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:47:43: error: cannot find 'vowelsRangeCount5' in scope\n\
    \    let vowelsRangeIndex6 = vowelsIndex + vowelsRangeCount5\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:48:43: error:\
    \ cannot find 'vowelsRangeCount6' in scope\n    let vowelsRangeIndex7 = vowelsIndex\
    \ + vowelsRangeCount6\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:49:43: error: cannot find 'vowelsRangeCount7' in scope\n\
    \    let vowelsRangeIndex8 = vowelsIndex + vowelsRangeCount7\n               \
    \                           ^~~~~~~~~~~~~~~~~\n/tmp/tmp2ubqxog8.swift:50:43: error:\
    \ cannot find 'vowelsRangeCount8' in scope\n    let vowelsRangeIndex9 = vowelsIndex\
    \ + vowelsRangeCount8\n                                          ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ubqxog8.swift:51:44: error: cannot find 'vowelsRangeCount9' in scope\n\
    \    let vowelsRangeIndex10 = vowelsIndex "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndex: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount2: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount3: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount4: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount5: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount6: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount7: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount8: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount9: [Int] = [0, 1, 2, 3, 4]\n    var\
    \ vowelsIndexCount10: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount11: [Int]\
    \ = [0, 1, 2, 3, 4]\n    var vowelsIndexCount12: [Int] = [0, 1, 2, 3, 4]\n   \
    \ var vowelsIndexCount13: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount14:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount15: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount16: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount17:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount18: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount19: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount20:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount21: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount22: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount23:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount24: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount25: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount26:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount27: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount28: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount29:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount30: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount31: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount32:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount33: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount34: [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount35:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndexCount36: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndexCount37: [\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kf6fl6b.swift:56:30: error: expected element type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n                              <#type#>\n\
    /tmp/tmp8kf6fl6b.swift:56:30: error: expected ']' in array type\n    var vowelsIndexCount37:\
    \ [\n                             ^\n/tmp/tmp8kf6fl6b.swift:56:29: note: to match\
    \ this opening '['\n    var vowelsIndexCount37: [\n                          \
    \  ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowelIndex = 0\n    var\
    \ vowelCount = 0\n    var consonantIndex = 0\n    var consonantCount = 0\n   \
    \ for index in 0..<word.count {\n        let char = word[index]\n        if char.isUppercase\
    \ {\n            vowelCount += 1\n        }\n        if char.isLowercase {\n \
    \           consonantCount += 1\n        }\n        if char.isVowel {\n      \
    \      vowelIndex += 1\n        }\n        if char.isConsonant {\n           \
    \ consonantIndex += 1\n        }\n    }\n    if vowelIndex == 0 {\n        return\
    \ \"\"\n    }\n    if consonantIndex == 0 {\n        return \"\"\n    }\n    if\
    \ vowelIndex > consonantIndex {\n        return \"\"\n    }\n    if vowelIndex\
    \ == consonantIndex {\n        return word[vowelIndex - 1]\n    }\n    if vowelIndex\
    \ < consonantIndex {\n        return word[consonantIndex - 1]\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdgz7ma4z.swift:25:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = word[index]\n                   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdgz7ma4z.swift:32:17: error: value\
    \ of type 'Character' has no member 'isVowel'\n        if char.isVowel {\n   \
    \        ~~~~ ^~~~~~~\n/tmp/tmpdgz7ma4z.swift:35:17: error: value of type 'Character'\
    \ has no member 'isConsonant'\n        if char.isConsonant {\n           ~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpdgz7ma4z.swift:49:20: error: cannot convert return expression\
    \ of type 'Character' to return type 'String'\n        return word[vowelIndex\
    \ - 1]\n               ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpdgz7ma4z.swift:52:20: error:\
    \ cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return word[consonantIndex - 1]\n               ~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    let vowelRange = vowelIndex..<vowelIndex + vowelsCount\n\
    \    \n    let vowelRangeCount = vowelRange.count\n    \n    if vowelRangeCount\
    \ == 0 {\n        return \"\"\n    }\n    \n    let vowelRangeStart = vowelRange.first!\n\
    \    \n    let vowelRangeEnd = vowelRange.last!\n    \n    let vowelRangeLength\
    \ = vowelRangeEnd - vowelRangeStart + 1\n    \n    let vowelRangeRange = vowelRangeStart\
    \ ..< vowelRangeEnd\n    \n    let vowelRangeRangeCount = vowelRangeRange.count\n\
    \    \n    if vowelRangeRangeCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelRangeRangeStart = vowelRangeRange.first!\n    \n    let vowelRangeRangeEnd\
    \ = vowelRangeRange.last!\n    \n    let vowelRangeRangeLength = vowelRangeRangeEnd\
    \ - vowelRangeRangeStart + 1\n    \n    let vowelRangeRangeRange = vowelRangeRangeStart\
    \ ..< vowelRangeRangeEnd\n    \n    let vowelRangeRangeRangeCount = vowelRangeRangeRange.count\n\
    \    \n    if vowelRangeRangeRangeCount == 0 {\n        return \"\"\n    }\n \
    \   \n    let vowelRangeRangeRangeStart = vowelRangeRangeRange.first!\n    \n\
    \    let vowelRangeRangeRangeEnd = vowelRangeRangeRange.last!\n    \n    let vowelRangeRangeRangeLength\
    \ = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart + 1\n    \n    let vowelRangeRangeRangeRange\
    \ = vowelRangeRangeRangeStart ..< vowelRangeRangeRangeEnd\n    \n    let vowelRangeRangeRangeRangeCount\
    \ = vowelRangeRangeRangeRange.count\n    \n    if vowelRangeRangeRangeRangeCount\
    \ == 0 {\n        return \"\"\n    }\n    \n    let vowelRangeRangeRangeRangeStart\
    \ = vowelRangeRangeRangeRange.first!\n    \n    let vowelRangeRangeRangeRangeEnd\
    \ = vowelRangeRangeRangeRange.last!\n    \n    let vowelRangeRangeRangeRangeLength\
    \ = vowelRangeRangeRangeRangeEnd - vowelRangeRangeRangeRangeStart + 1\n    \n\
    \    let vowelRangeRangeRangeRangeRange = vowelRangeRangeRangeRangeStart ..< vowelRangeRangeRangeRangeEnd\n\
    \    \n    let vowelRangeRangeRangeRangeRangeCount = vowelRangeRangeRangeRangeRange.count\n\
    \    \n    if vowelRangeRangeRangeRangeRangeCount == 0 {\n        return \"\"\n\
    \    }\n    \n    let vowelRangeRangeRangeRangeRangeStart = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_568njt.swift:89:46: error: expected initial value after '='\n\
    \    let vowelRangeRangeRangeRangeRangeStart = \n                            \
    \                 ^\n/tmp/tmpl_568njt.swift:17:24: error: cannot find 'vowels'\
    \ in scope\n    guard let vowels = vowels.characters.map(String.init) else {\n\
    \                       ^~~~~~\n/tmp/tmpl_568njt.swift:37:60: error: binary operator\
    \ '+' cannot be applied to operands of type 'Duration' and 'Int'\n    let vowelRangeLength\
    \ = vowelRangeEnd - vowelRangeStart + 1\n                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpl_568njt.swift:37:60: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n    let\
    \ vowelRangeLength = vowelRangeEnd - vowelRangeStart + 1\n                   \
    \                                        ^\n/tmp/tmpl_568njt.swift:51:75: error:\
    \ binary operator '+' cannot be applied to operands of type 'Duration' and 'Int'\n\
    \    let vowelRangeRangeLength = vowelRangeRangeEnd - vowelRangeRangeStart + 1\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n\
    /tmp/tmpl_568njt.swift:51:75: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Duration, Duration), (Int, Int)\n    let vowelRangeRangeLength\
    \ = vowelRangeRangeEnd - vowelRangeRangeStart + 1\n                          \
    \                                                ^\n/tmp/tmpl_568njt.swift:65:90:\
    \ error: binary operator '+' cannot be applied to operands of type 'Duration'\
    \ and 'Int'\n    let vowelRangeRangeRangeLength = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart\
    \ + 1\n                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpl_568njt.swift:65:90: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n    let\
    \ vowelRangeRangeRangeLength = vowelRangeRangeRangeEnd - vowelRangeRangeRangeStart\
    \ + 1\n                                                                      \
    \                   ^\n/tmp/tmpl_568njt.swift:7"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgsfhk8r_.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpgsfhk8r_.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n                                  \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for letter in word {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    \n    var vowelIndex: Int = 0\n    var vowelCount: Int = 0\n    var vowelEndIndex:\
    \ Int = 0\n    var vowelStartIndex: Int = 0\n    \n    for letter in vowels {\n\
    \        if letter == vowels[vowelIndex] {\n            vowelIndex += 1\n    \
    \        vowelCount += 1\n            if vowelIndex == vowels.count {\n      \
    \          vowelIndex = 0\n            }\n        } else {\n            if vowelIndex\
    \ == 0 {\n                vowelStartIndex = vowelEndIndex\n            }\n   \
    \         vowelEndIndex = vowelIndex\n            vowelIndex = 0\n        }\n\
    \    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n   \
    \ if vowelIndex == vowels.count {\n        return \"\"\n    }\n    \n    if vowelCount\
    \ > 1 {\n        return \"\"\n    }\n    \n    if vowelStartIndex == vowelEndIndex\
    \ {\n        return \"\"\n    }\n    \n    return vowels[vowelStartIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpenxz0mfy.swift:62:18: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n    return vowels[vowelStartIndex]\n\
    \           ~~~~~~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for char in word.unicodeScalars {\n        if\
    \ let _ = char.value > 64 && char.value < 91 {\n            vowels.append(char)\n\
    \        }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    let\
    \ vowelIndex = vowels.firstIndex(of: Character(\"a\"))\n    if vowelIndex == -1\
    \ {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2wtkdob.swift:20:20: error: no exact matches in call to instance\
    \ method 'append'\n            vowels.append(char)\n                   ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmp_2wtkdob.swift:20:20: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n/tmp/tmp_2wtkdob.swift:19:12: error: initializer for conditional\
    \ binding must have Optional type, not 'Bool'\n        if let _ = char.value >\
    \ 64 && char.value < 91 {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_2wtkdob.swift:31:9: error: invalid redeclaration of 'vowelsCount'\n \
    \   let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:32:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:33:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:34:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp_2wtkdob.swift:30:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp_2wtkdob.swift:35:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n      "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount = [String: Int]()\n    for\
    \ char in word.characters {\n        if vowels.contains(char) {\n            vowelsCount[char]\
    \ = vowelsCount[char]! + 1\n        }\n    }\n    var minVowel: String = String()\n\
    \    var minVowelCount: Int = Int.max\n    for char in vowels {\n        if vowelsCount[char]\
    \ < minVowelCount {\n            minVowel = char\n            minVowelCount =\
    \ vowelsCount[char]\n        }\n    }\n    return minVowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpw3rkkj68.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpw3rkkj68.swift:23:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpw3rkkj68.swift:24:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowelsCount[char] = vowelsCount[char]! + 1\n                    \
    \    ^\n/tmp/tmpw3rkkj68.swift:24:45: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowelsCount[char] = vowelsCount[char]!\
    \ + 1\n                                            ^\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if vowelsCount[char] < minVowelCount {\n                      ^\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if vowelsCount[char] < minVowelCount {\n                    \
    \  ^\n                             ?? <#default value#>\n/tmp/tmpw3rkkj68.swift:30:23:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if vowelsCount[char] < minVowelCount {\n                    \
    \  ^\n                            !\n/tmp/tmpw3rkkj68.swift:32:40: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \     minVowelCount = vowelsCount[char]\n                                    \
    \   ^\n/tmp/tmpw3rkkj68.swift:32:40: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            minVowelCount = vowelsCount[char]\n\
    \                                       ^\n                                  \
    \            ?? <#default value#>\n/tmp/tmpw3rkkj68.swift:32:40: note: force-unwrap\
    \ using '!' to abort executi"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    let startIndex = vowelIndex - 1\n    let endIndex = vowelIndex + 1\n\
    \    \n    if startIndex < 0 {\n        startIndex = 0\n    }\n    \n    if endIndex\
    \ == vowels.count {\n        endIndex = vowels.count - 1\n    }\n    \n    let\
    \ firstVowel = vowels[startIndex]\n    let secondVowel = vowels[endIndex]\n  \
    \  \n    if firstVowel == secondVowel {\n        return firstVowel\n    }\n  \
    \  \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyt9ak4zu.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpyt9ak4zu.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpyt9ak4zu.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmpyt9ak4zu.swift:37:9:\
    \ error: cannot assign to value: 'startIndex' is a 'let' constant\n        startIndex\
    \ = 0\n        ^~~~~~~~~~\n/tmp/tmpyt9ak4zu.swift:33:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let startIndex = vowelIndex - 1\n    ^~~\n   \
    \ var\n/tmp/tmpyt9ak4zu.swift:41:9: error: cannot assign to value: 'endIndex'\
    \ is a 'let' constant\n        endIndex = vowels.count - 1\n        ^~~~~~~~\n\
    /tmp/tmpyt9ak4zu.swift:34:5: note: change 'let' to 'var' to make it mutable\n\
    \    let endIndex = vowelIndex + 1\n    ^~~\n    var\n/tmp/tmpyt9ak4zu.swift:44:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    let firstVowel = vowels[startIndex]\n     \
    \                ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpyt9ak4zu.swift:45:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    let secondVowel = vowels[endIndex]\n                      ^~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpyt9ak4zu.swift:48:16:\
    \ error: cann"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsIndex = word.characters.reversed().enumerate().filter { (index, element)\
    \ -> Bool in\n        element.lowercaseString.contains(vowels)\n    }.minElement\
    \ { (first, second) -> Bool in\n        first.1 < second.1\n    }.1\n    if vowelsIndex\
    \ == 0 {\n        return \"\"\n    }\n    let vowelsIndex2 = vowelsIndex - 1\n\
    \    let vowelsIndex3 = vowelsIndex + vowelsCount\n    let consonantsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n        element.lowercaseString.contains(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    }.minElement { (first, second) -> Bool in\n        first.1 < second.1\n\
    \    }.1\n    if consonantsIndex == word.characters.count {\n        return \"\
    \"\n    }\n    let consonantsIndex2 = consonantsIndex - 1\n    let consonantsIndex3\
    \ = consonantsIndex + consonantsCount\n    let vowelsIndex4 = vowelsIndex2 - vowelsCount\n\
    \    let consonantsIndex4 = consonantsIndex2 - consonantsCount\n    if vowelsIndex4\
    \ < 0 {\n        return \"\"\n    }\n    if consonantsIndex4 < 0 {\n        return\
    \ \"\"\n    }\n    if vowelsIndex4 > consonantsIndex4 {\n        return \"\"\n\
    \    }\n    if vowelsIndex4 < consonantsIndex4 {\n        return vowels[vowelsIndex4]\n\
    \    }\n    if consonantsIndex4 > vowelsIndex4 {\n        return \"\"\n    }\n\
    \    if consonantsIndex4 < vowelsIndex4 {\n        return consonants[consonantsIndex4]\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkbumpszv.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpkbumpszv.swift:19:50: error: reference to member 'enumerate' cannot\
    \ be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n                                            \
    \     ^\n/tmp/tmpkbumpszv.swift:29:54: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let consonantsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n                                            \
    \         ^\n/tmp/tmpkbumpszv.swift:38:46: error: cannot find 'consonantsCount'\
    \ in scope\n    let consonantsIndex3 = consonantsIndex + consonantsCount\n   \
    \                                          ^~~~~~~~~~~~~~~\n/tmp/tmpkbumpszv.swift:40:47:\
    \ error: cannot find 'consonantsCount' in scope\n    let consonantsIndex4 = consonantsIndex2\
    \ - consonantsCount\n                                              ^~~~~~~~~~~~~~~\n\
    /tmp/tmpkbumpszv.swift:57:16: error: cannot find 'consonants' in scope\n     \
    \   return consonants[consonantsIndex4]\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex = 0\n    var vowelsCountMax\
    \ = vowels.count\n    var vowelsCountMaxIndex = vowelsCountMax\n    var vowelsCountMin\
    \ = vowels.count\n    var vowelsCountMinIndex = vowelsCountMin\n    var vowelsCountSum\
    \ = vowelsCountMax\n    var vowelsCountSumIndex = vowelsCountSum\n    var vowelsCountSumMax\
    \ = vowelsCountSum\n    var vowelsCountSumMaxIndex = vowelsCountSumMax\n    var\
    \ vowelsCountSumMin = vowelsCountSum\n    var vowelsCountSumMinIndex = vowelsCountSumMin\n\
    \    var vowelsCountSumSum = vowelsCountSumMax\n    var vowelsCountSumSumIndex\
    \ = vowelsCountSumSum\n    var vowelsCountSumSumMax = vowelsCountSumSum\n    var\
    \ vowelsCountSumSumMaxIndex = vowelsCountSumSumMax\n    var vowelsCountSumSumMin\
    \ = vowelsCountSumSum\n    var vowelsCountSumSumMinIndex = vowelsCountSumSumMin\n\
    \    var vowelsCountSumSumSum = vowelsCountSumSumMax\n    var vowelsCountSumSumSumIndex\
    \ = vowelsCountSumSumSum\n    var vowelsCountSumSumSumMax = vowelsCountSumSumSum\n\
    \    var vowelsCountSumSumSumMaxIndex = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumMin\
    \ = vowelsCountSumSumSum\n    var vowelsCountSumSumSumMinIndex = vowelsCountSumSumSumMin\n\
    \    var vowelsCountSumSumSumSum = vowelsCountSumSumSumMax\n    var vowelsCountSumSumSumSumIndex\
    \ = vowelsCountSumSumSumSum\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumMaxIndex = vowelsCountSumSumSumSumMax\n    var\
    \ vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n    var vowelsCountSumSumSumSumMinIndex\
    \ = vowelsCountSumSumSumSumMin\n    var vowelsCountSumSumSumSumSum = vowelsCountSumSumSumSumMax\n\
    \    var vowelsCountSumSumSumSumSumIndex = vowelsCountSumSumSumSumSum\n    var\
    \ vowelsCountSumSumSumSumSumMax = vowelsCountSumSumSumSumSumMax\n    var vowelsCountSumSumSumSumSumMaxIndex\
    \ = vowelsCountSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp200sr7rd.swift:44:38: error: use of local variable 'vowelsCountSumSumSumSumMax'\
    \ before its declaration\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \                                     ^\n/tmp/tmp200sr7rd.swift:44:9: note: 'vowelsCountSumSumSumSumMax'\
    \ declared here\n    var vowelsCountSumSumSumSumMax = vowelsCountSumSumSumSumMax\n\
    \        ^\n/tmp/tmp200sr7rd.swift:46:38: error: use of local variable 'vowelsCountSumSumSumSumMin'\
    \ before its declaration\n    var vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n\
    \                                     ^\n/tmp/tmp200sr7rd.swift:46:9: note: 'vowelsCountSumSumSumSumMin'\
    \ declared here\n    var vowelsCountSumSumSumSumMin = vowelsCountSumSumSumSumMin\n\
    \        ^\n/tmp/tmp200sr7rd.swift:50:41: error: use of local variable 'vowelsCountSumSumSumSumSumMax'\
    \ before its declaration\n    var vowelsCountSumSumSumSumSumMax = vowelsCountSumSumSumSumSumMax\n\
    \                                        ^\n/tmp/tmp200sr7rd.swift:50:9: note:\
    \ 'vowelsCountSumSumSumSumSumMax' declared here\n    var vowelsCountSumSumSumSumSumMax\
    \ = vowelsCountSumSumSumSumSumMax\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.unicodeScalars {\n        if char.value > 0x41\
    \ && char.value < 0x5A {\n            vowels.append(char.value)\n        }\n \
    \   }\n    \n    if vowels.count < 2 {\n        return \"\"\n    }\n    \n   \
    \ var minDistance = vowels.count - 1\n    var minIndex = vowels.count - 1\n  \
    \  \n    for index in 0..<vowels.count {\n        if vowels[index] == vowels[minIndex]\
    \ {\n            continue\n        }\n        \n        let distance = abs(vowels[index]\
    \ - vowels[minIndex])\n        \n        if distance < minDistance {\n       \
    \     minDistance = distance\n            minIndex = index\n        }\n    }\n\
    \    \n    return vowels[minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoew2jo4c.swift:25:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpoew2jo4c.swift:41:42: error: binary\
    \ operator '-' cannot be applied to two 'String' operands\n        let distance\
    \ = abs(vowels[index] - vowels[minIndex])\n                                  \
    \       ^\nSwift.Strideable:1:11: note: candidate requires that 'String' conform\
    \ to '_Pointer' (requirement specified as 'Self' : '_Pointer')\nextension Strideable\
    \ where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  for letter in word {\n        if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n            vowels.append(letter)\n\
    \        }\n    }\n    if vowels.count > 0 {\n        return vowels[vowels.count\
    \ - 1]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbob21t0b.swift:23:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n        return \"\"\n    }\n    let vowelIndex = word.characters.index(of:\
    \ vowels.last!)\n    if index == vowelIndex {\n        return \"\"\n    }\n  \
    \  let start = index\n    let end = vowelIndex\n    let range = start..<end\n\
    \    let vowel = word.substring(with: range)\n    return vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpesg28ujc.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let index = word.characters.index(of: vowels.first!)\
    \ else {\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpesg28ujc.swift:18:39: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n                                      ^\n/tmp/tmpesg28ujc.swift:18:39:\
    \ note: use 'firstIndex(of:)' instead\n    guard let index = word.characters.index(of:\
    \ vowels.first!) else {\n                                      ^~~~~\n       \
    \                               firstIndex\n/tmp/tmpesg28ujc.swift:21:55: error:\
    \ value of type 'Set<String.Element>' (aka 'Set<Character>') has no member 'last'\n\
    \    let vowelIndex = word.characters.index(of: vowels.last!)\n              \
    \                                 ~~~~~~ ^~~~\n/tmp/tmpesg28ujc.swift:28:22: error:\
    \ value of type 'String' has no member 'substring'\n    let vowel = word.substring(with:\
    \ range)\n                ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpihpnyelp.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, vowels: vowels)\n         \
    \  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpihpnyelp.swift:17:51: error: cannot find 'vowels'\
    \ in scope\n    return find_closest_vowel(word: word, vowels: vowels)\n      \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count else {\n        return \"\"\n    }\n    \n    let vowelsSet =\
    \ Set(vowels)\n    \n    let vowelsCount = vowels.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount {\n        return\
    \ \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount\
    \ = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n    \n  \
    \  if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n    \n    let\
    \ vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n    \n    let vowelsSet = vowelsSet.sorted()\n\
    \    \n    let vowelsCount = vowelsSet.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    if vowelsCount > vowelsSetCount {\n        return \"\"\n    }\n   \
    \ \n    let vowelsSet = vowelsSet.sorted()\n    \n    let vowelsCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.count\n    \n    if vowelsCount > vowelsSetCount\
    \ {\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgjv89b0.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map({ String($0) }),\n               \
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ var vowelIndex = 0\n    var vowelCount = 0\n    var vowelString = \"\"\n   \
    \ var consonantIndex = 0\n    var consonantCount = 0\n    var consonantString\
    \ = \"\"\n    \n    for char in word.characters {\n        if vowels.characters.contains(char)\
    \ {\n            vowelIndex += 1\n            vowelCount += 1\n            if\
    \ vowelIndex == vowelsCount {\n                vowelIndex = 0\n              \
    \  vowelCount -= 1\n            }\n        } else {\n            consonantIndex\
    \ += 1\n            consonantCount += 1\n            if consonantIndex == consonantCount\
    \ {\n                consonantIndex = 0\n                consonantCount -= 1\n\
    \            }\n        }\n    }\n    \n    if vowelIndex == 0 {\n        return\
    \ \"\"\n    }\n    \n    if vowelIndex == vowelsCount {\n        vowelIndex -=\
    \ 1\n    }\n    \n    if consonantIndex == 0 {\n        return \"\"\n    }\n \
    \   \n    if consonantIndex == consonantCount {\n        consonantIndex -= 1\n\
    \    }\n    \n    if vowelIndex == 0 && consonantIndex == 0 {\n        return\
    \ \"\"\n    }\n    \n    if vowelIndex == vowelsCount && consonantIndex == consonantCount\
    \ {\n        return vowels[vowelIndex - 1]\n    }\n    \n    if vowelIndex ==\
    \ vowelsCount {\n        vowelIndex -= 1\n    }\n    \n    if consonantIndex ==\
    \ 0 {\n        return \"\"\n    }\n    \n    if consonantIndex == consonantCount\
    \ {\n        consonantIndex -= 1\n    }\n    \n    if vowelIndex == 0 && consonantIndex\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex == vowelsCount &&\
    \ consonantIndex == consonantCount {\n        return vowels[vowelIndex - 1]\n\
    \    }\n    \n    if vowelIndex == vowelsCount {\n        vowelIndex -= 1\n  \
    \  }\n    \n    if consonantIndex == 0 {\n        return \"\"\n    }\n    \n \
    \   if consonantIndex == consonantCount {\n        consonantIndex -= 1\n    }\n\
    \    \n    if vowelIndex == 0 && consonantIndex == 0 {\n        return \"\"\n\
    \    }\n    \n    if vowelIndex == vowelsCount && consonantIndex == consonantCount\
    \ {\n        return vowels[vowelIndex - 1]\n    }\n    \n    if vowelIndex ==\
    \ vowelsCount {\n        vowelIndex -= 1\n    }\n    \n    if consonantIndex ==\
    \ 0 {\n        return \"\"\n    }\n    \n    if con\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp68q9s5de.swift:116:11: error: expected '{' after 'if' condition\n\
    \    if con\n          ^\n/tmp/tmp68q9s5de.swift:18:30: error: 'characters' is\
    \ unavailable: Please use String directly\n    let vowelsCount = vowels.characters.count\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp68q9s5de.swift:26:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in word.characters {\n            \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp68q9s5de.swift:27:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if vowels.characters.contains(char)\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp68q9s5de.swift:65:22: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n        return vowels[vowelIndex -\
    \ 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp68q9s5de.swift:85:22: error:\
    \ cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return vowels[vowelIndex - 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n\
    /tmp/tmp68q9s5de.swift:105:22: error: cannot convert return expression of type\
    \ 'Character' to return type 'String'\n        return vowels[vowelIndex - 1]\n\
    \               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp68q9s5de.swift:116:8: error: cannot\
    \ find 'con' in scope\n    if con\n       ^~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).firstIndex(of: vowels.last!)\n    \n    if vowelsIndex == word.characters.count\
    \ - 1 {\n        return \"\"\n    }\n    \n    let vowelsBefore = word.substring(to:\
    \ vowelsIndex - 1)\n    let vowelsAfter = word.substring(from: vowelsIndex + 1)\n\
    \    \n    if vowelsBefore.isEmpty || vowelsAfter.isEmpty {\n        return \"\
    \"\n    }\n    \n    let vowelsBeforeCount = vowelsBefore.characters.filter({\
    \ vowels.contains($0) }).count\n    let vowelsAfterCount = vowelsAfter.characters.filter({\
    \ vowels.contains($0) }).count\n    \n    if vowelsBeforeCount == 0 {\n      \
    \  return vowelsAfter\n    }\n    \n    if vowelsAfterCount == 0 {\n        return\
    \ vowelsBefore\n    }\n    \n    let vowelsBeforeIndex = vowelsBefore.characters.reversed().filter({\
    \ vowels.contains($0) }).firstIndex(of: vowels.last!)\n    let vowelsAfterIndex\
    \ = vowelsAfter.characters.reversed().filter({ vowels.contains($0) }).firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelsBeforeIndex == vowelsBefore.characters.count\
    \ - 1 {\n        return vowelsBefore\n    }\n    \n    if vowelsAfterIndex ==\
    \ vowelsAfter.characters.count - 1 {\n        return vowelsAfter\n    }\n    \n\
    \    let vowelsBeforeBefore = word.substring(to: vowelsBeforeIndex - 1)\n    let\
    \ vowelsBeforeAfter = word.substring(from: vowelsBeforeIndex + 1)\n    let vowelsAfterBefore\
    \ = word.substring(to: vowelsAfterIndex - 1)\n    let vowelsAfterAfter = word.substring(from:\
    \ vowelsAfterIndex + 1)\n    \n    if vowelsBeforeBefore.isEmpty || vowelsBeforeAfter.isEmpty\
    \ {\n        return vowelsBefore\n    }\n    \n    if vowelsAfterBefore.isEmpty\
    \ || vowelsAfterAfter.isEmpty {\n        return vowelsAfter\n    }\n    \n   \
    \ let vowelsBeforeBeforeCount = vowelsBeforeBefore.characters.filter({ vowels.contains($0)\
    \ }).count\n    let vowelsBeforeAfterCount = vowelsBeforeAfter.characters.filter({\
    \ vowels.contains($0) }).count\n    let vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpftsucd_7.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpftsucd_7.swift:33:29: error: value of type 'String'\
    \ has no member 'substring'\n    let vowelsBefore = word.substring(to: vowelsIndex\
    \ - 1)\n                       ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:34:28: error:\
    \ value of type 'String' has no member 'substring'\n    let vowelsAfter = word.substring(from:\
    \ vowelsIndex + 1)\n                      ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:62:35:\
    \ error: value of type 'String' has no member 'substring'\n    let vowelsBeforeBefore\
    \ = word.substring(to: vowelsBeforeIndex - 1)\n                             ~~~~\
    \ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:63:34: error: value of type 'String' has no\
    \ member 'substring'\n    let vowelsBeforeAfter = word.substring(from: vowelsBeforeIndex\
    \ + 1)\n                            ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:64:34:\
    \ error: value of type 'String' has no member 'substring'\n    let vowelsAfterBefore\
    \ = word.substring(to: vowelsAfterIndex - 1)\n                            ~~~~\
    \ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:65:33: error: value of type 'String' has no\
    \ member 'substring'\n    let vowelsAfterAfter = word.substring(from: vowelsAfterIndex\
    \ + 1)\n                           ~~~~ ^~~~~~~~~\n/tmp/tmpftsucd_7.swift:77:9:\
    \ error: type annotation missing in pattern\n    let vowel\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelIndex2 = 0\n    var vowelIndex3 = 0\n  \
    \  var vowelIndex4 = 0\n    var vowelIndex5 = 0\n    var vowelIndex6 = 0\n   \
    \ var vowelIndex7 = 0\n    var vowelIndex8 = 0\n    var vowelIndex9 = 0\n    var\
    \ vowelIndex10 = 0\n    var vowelIndex11 = 0\n    var vowelIndex12 = 0\n    var\
    \ vowelIndex13 = 0\n    var vowelIndex14 = 0\n    var vowelIndex15 = 0\n    var\
    \ vowelIndex16 = 0\n    var vowelIndex17 = 0\n    var vowelIndex18 = 0\n    var\
    \ vowelIndex19 = 0\n    var vowelIndex20 = 0\n    var vowelIndex21 = 0\n    var\
    \ vowelIndex22 = 0\n    var vowelIndex23 = 0\n    var vowelIndex24 = 0\n    var\
    \ vowelIndex25 = 0\n    var vowelIndex26 = 0\n    var vowelIndex27 = 0\n    var\
    \ vowelIndex28 = 0\n    var vowelIndex29 = 0\n    var vowelIndex30 = 0\n    var\
    \ vowelIndex31 = 0\n    var vowelIndex32 = 0\n    var vowelIndex33 = 0\n    var\
    \ vowelIndex34 = 0\n    var vowelIndex35 = 0\n    var vowelIndex36 = 0\n    var\
    \ vowelIndex37 = 0\n    var vowelIndex38 = 0\n    var vowelIndex39 = 0\n    var\
    \ vowelIndex40 = 0\n    var vowelIndex41 = 0\n    var vowelIndex42 = 0\n    var\
    \ vowelIndex43 = 0\n    var vowelIndex44 = 0\n    var vowelIndex45 = 0\n    var\
    \ vowelIndex46 = 0\n    var vowelIndex47 = 0\n    var vowelIndex48 = 0\n    var\
    \ vowelIndex49 = 0\n    var vowelIndex50 = 0\n    var vowelIndex51 = 0\n    var\
    \ vowelIndex52 = 0\n    var vowelIndex53 = 0\n    var vowelIndex54 = 0\n    var\
    \ vowelIndex55 = 0\n    var vowelIndex56 = 0\n    var vowelIndex57 = 0\n    var\
    \ vowelIndex58 = 0\n    var vowelIndex59 = 0\n    var vowelIndex60 = 0\n    var\
    \ vowelIndex61 = 0\n    var vowelIndex62 = 0\n    var vowelIndex63 = 0\n    var\
    \ vowelIndex64 = 0\n    var vowelIndex65 = 0\n    var vowelIndex66 = 0\n    var\
    \ vowelIndex67 = 0\n    var vowelIndex68 = 0\n    var vowelIndex69 = 0\n    var\
    \ vowelIndex70 = 0\n    var vowelIndex71 = 0\n    var vowelIndex72 = 0\n    var\
    \ vowelIndex73 = 0\n    var vowelIndex74 = 0\n    var vowelIndex75 = 0\n    var\
    \ vowelIndex76 = 0\n    var vowelIndex77 = 0\n    var vowelIndex78 = 0\n    var\
    \ vowelIndex79 = 0\n    var vowelIndex80 = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp36tl5q41.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp36tl5q41.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels: [String] = []\n    \n    for vowel in vowels {\n        if word.hasSuffix(vowel)\
    \ {\n            return vowel\n        }\n    }\n    \n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpskwgudpy/tmpskwgudpy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2f4db0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2f4aa7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2f4aa7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2f4aa67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpskwgudpy                        0x00005643da5f55c7 <unavailable> + 5575

    5    libc.so.6                          0x00002ac2f4f9c460 __libc_start_main +
    245

    6    tmpskwgudpy                        0x00005643da5f5209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndex2\
    \ = vowels.count\n    \n    var currentIndex = 0\n    var currentIndex2 = word.count\n\
    \    \n    var closestIndex = 0\n    var closestIndex2 = vowels.count\n    \n\
    \    while vowelIndex < vowels.count && currentIndex < word.count {\n        if\
    \ vowels[vowelIndex] == word[currentIndex] {\n            vowelIndex++\n     \
    \       currentIndex++\n        } else {\n            vowelIndex++\n        }\n\
    \    }\n    \n    while vowelIndex2 < vowels.count && currentIndex2 < word.count\
    \ {\n        if vowels[vowelIndex2] == word[currentIndex2] {\n            vowelIndex2++\n\
    \            currentIndex2++\n        } else {\n            vowelIndex2++\n  \
    \      }\n    }\n    \n    if vowelIndex == vowels.count {\n        return \"\"\
    \n    }\n    \n    if vowelIndex2 == vowels.count {\n        return \"\"\n   \
    \ }\n    \n    if vowelIndex < vowels.count && vowelIndex2 < vowels.count {\n\
    \        if vowels[vowelIndex] < vowels[vowelIndex2] {\n            closestIndex\
    \ = vowelIndex\n            closestIndex2 = vowelIndex2\n        } else {\n  \
    \          closestIndex = vowelIndex2\n            closestIndex2 = vowelIndex\n\
    \        }\n    } else {\n        if vowelIndex < vowels.count {\n           \
    \ closestIndex = vowelIndex\n        } else {\n            closestIndex = vowelIndex2\n\
    \        }\n    }\n    \n    if closestIndex == closestIndex2 {\n        return\
    \ \"\"\n    }\n    \n    if closestIndex > closestIndex2 {\n        return vowels[closestIndex2]\n\
    \    } else {\n        return vowels[closestIndex]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmtq9d69b.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels[vowelIndex]\
    \ == word[currentIndex] {\n           ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:30:34: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if vowels[vowelIndex] == word[currentIndex] {\n          \
    \                       ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:31:23: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            vowelIndex++\n\
    \                      ^~\n/tmp/tmpmtq9d69b.swift:32:25: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            currentIndex++\n          \
    \              ^~\n/tmp/tmpmtq9d69b.swift:34:23: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            vowelIndex++\n                 \
    \     ^~\n/tmp/tmpmtq9d69b.swift:39:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ vowels[vowelIndex2] == word[currentIndex2] {\n           ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:39:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if vowels[vowelIndex2] == word[currentIndex2]\
    \ {\n                                  ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmtq9d69b.swift:40:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n   "
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(String(char))\n        }\n    }\n    if\
    \ vowels.count < 2 {\n        return \"\"\n    }\n    var vowelsCount = vowels.count\n\
    \    var vowelIndex = 0\n    var vowelIndex2 = vowels.count - 1\n    var vowelIndex3\
    \ = vowels.count - 2\n    var vowelIndex4 = vowels.count - 3\n    var vowelIndex5\
    \ = vowels.count - 4\n    var vowelIndex6 = vowels.count - 5\n    var vowelIndex7\
    \ = vowels.count - 6\n    var vowelIndex8 = vowels.count - 7\n    var vowelIndex9\
    \ = vowels.count - 8\n    var vowelIndex10 = vowels.count - 9\n    var vowelIndex11\
    \ = vowels.count - 10\n    var vowelIndex12 = vowels.count - 11\n    var vowelIndex13\
    \ = vowels.count - 12\n    var vowelIndex14 = vowels.count - 13\n    var vowelIndex15\
    \ = vowels.count - 14\n    var vowelIndex16 = vowels.count - 15\n    var vowelIndex17\
    \ = vowels.count - 16\n    var vowelIndex18 = vowels.count - 17\n    var vowelIndex19\
    \ = vowels.count - 18\n    var vowelIndex20 = vowels.count - 19\n    var vowelIndex21\
    \ = vowels.count - 20\n    var vowelIndex22 = vowels.count - 21\n    var vowelIndex23\
    \ = vowels.count - 22\n    var vowelIndex24 = vowels.count - 23\n    var vowelIndex25\
    \ = vowels.count - 24\n    var vowelIndex26 = vowels.count - 25\n    var vowelIndex27\
    \ = vowels.count - 26\n    var vowelIndex28 = vowels.count - 27\n    var vowelIndex29\
    \ = vowels.count - 28\n    var vowelIndex30 = vowels.count - 29\n    var vowelIndex31\
    \ = vowels.count - 30\n    var vowelIndex32 = vowels.count - 31\n    var vowelIndex33\
    \ = vowels.count - 32\n    var vowelIndex34 = vowels.count - 33\n    var vowelIndex35\
    \ = vowels.count - 34\n    var vowelIndex36 = vowels.count - 35\n    var vowelIndex37\
    \ = vowels.count - 36\n    var vowelIndex38 = vowels.count - 37\n    var vowelIndex39\
    \ = vowels.count - 38\n    var vowelIndex40 = vowels.count - 39\n    var vowelIndex41\
    \ = vowels.count - 40\n    var vowelIndex42 = vowels.count \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdbn70epc.swift:29:9: warning: initialization of variable 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:30:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:31:9: warning: initialization of variable 'vowelIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex2 = vowels.count - 1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:32:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = vowels.count -\
    \ 2\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:33:9: warning: initialization\
    \ of variable 'vowelIndex4' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndex4 = vowels.count - 3\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:34:9: warning: initialization of variable 'vowelIndex5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex5 = vowels.count - 4\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:35:9:\
    \ warning: initialization of variable 'vowelIndex6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex6 = vowels.count -\
    \ 5\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:36:9: warning: initialization\
    \ of variable 'vowelIndex7' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndex7 = vowels.count - 6\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpdbn70epc.swift:37:9: warning: initialization of variable 'vowelIndex8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex8 = vowels.count - 7\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpdbn70epc.swift:38:9:\
    \ warning: initialization of variable 'vowelIndex9' was never used; consider replacing\
    \ wit"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgsfhk8r_.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpgsfhk8r_.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n                                  \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndexEnd = vowels.count - 1\n    \n    for char in word.characters\
    \ {\n        if vowelIndex == vowelIndexEnd {\n            break\n        }\n\
    \        \n        if vowels.contains(String(char)) {\n            vowelIndexEnd\
    \ = vowels.firstIndex(of: String(char))!\n            break\n        }\n    }\n\
    \    \n    return String(word.characters.dropFirst(vowelIndex))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpeo5zmek9.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpeo5zmek9.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpeo5zmek9.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmpeo5zmek9.swift:35:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpeo5zmek9.swift:41:64: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n            vowelIndexEnd = vowels.firstIndex(of:\
    \ String(char))!\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmpeo5zmek9.swift:41:51: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n            vowelIndexEnd\
    \ = vowels.firstIndex(of: String(char))!\n                                   \
    \               ^\n/tmp/tmpeo5zmek9.swift:46:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    return String(word.characters.dropFirst(vowelIndex))\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for char in word.unicodeScalars {\n        if\
    \ char.value > 0x41 && char.value < 0x7A {\n            vowels.append(char)\n\
    \        }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n   \
    \ var vowelIndex: Int = 0\n    var vowelIndex2: Int = 0\n    var vowelIndex3:\
    \ Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5: Int = 0\n    var\
    \ vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var vowelIndex8: Int\
    \ = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int = 0\n    var vowelIndex11:\
    \ Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13: Int = 0\n    var\
    \ vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var vowelIndex16:\
    \ Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18: Int = 0\n    var\
    \ vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var vowelIndex21:\
    \ Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23: Int = 0\n    var\
    \ vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var vowelIndex26:\
    \ Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28: Int = 0\n    var\
    \ vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var vowelIndex31:\
    \ Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33: Int = 0\n    var\
    \ vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var vowelIndex36:\
    \ Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38: Int = 0\n    var\
    \ vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var vowelIndex41:\
    \ Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43: Int = 0\n    var\
    \ vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var vowelIndex46:\
    \ Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48: Int = 0\n    var\
    \ vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var vowelIndex51:\
    \ Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53: Int = 0\n    var\
    \ vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var vowelIndex56:\
    \ Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58: Int = 0\n    var\
    \ vowelIndex59: \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpipfmipeh.swift:84:22: error: expected type\n    var vowelIndex59:\
    \ \n                     ^\n                      <#type#>\n/tmp/tmpipfmipeh.swift:20:20:\
    \ error: no exact matches in call to instance method 'append'\n            vowels.append(char)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmpipfmipeh.swift:20:20: note: found candidate\
    \ with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    var index = word.startIndex\n    while index\
    \ != word.endIndex {\n        let char = word[index]\n        if vowels.contains(char)\
    \ {\n            return char\n        }\n        index -= 1\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp31x2_bss.swift:22:20: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n            return char\n        \
    \           ^~~~\n/tmp/tmp31x2_bss.swift:24:15: error: binary operator '-=' cannot\
    \ be applied to operands of type 'String.Index' and 'Int'\n        index -= 1\n\
    \        ~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.map(String.init).count\n \
    \   \n    var closestVowel = \"\"\n    \n    for i in 0..<vowelsCount {\n    \
    \    let index = vowels.index(of: vowels[i])\n        \n        if index == vowels.count\
    \ - 1 {\n            closestVowel = vowels[i]\n            break\n        }\n\
    \        \n        let nextIndex = vowels.index(after: index)\n        \n    \
    \    if nextIndex == vowels.count - 1 {\n            closestVowel = vowels[i]\n\
    \            break\n        }\n        \n        let nextNextIndex = vowels.index(after:\
    \ nextIndex)\n        \n        if nextNextIndex == vowels.count - 1 {\n     \
    \       closestVowel = vowels[i]\n            break\n        }\n        \n   \
    \     let nextNextNextIndex = vowels.index(after: nextNextIndex)\n        \n \
    \       if nextNextNextIndex == vowels.count - 1 {\n            closestVowel =\
    \ vowels[i]\n            break\n        }\n        \n        let nextNextNextNextIndex\
    \ = vowels.index(after: nextNextNextIndex)\n        \n        if nextNextNextNextIndex\
    \ == vowels.count - 1 {\n            closestVowel = vowels[i]\n            break\n\
    \        }\n        \n        let nextNextNextNextNextIndex = vowels.index(after:\
    \ nextNextNextNextIndex)\n        \n        if nextNextNextNextNextIndex == vowels.count\
    \ - 1 {\n            closestVowel = vowels[i]\n            break\n        }\n\
    \    }\n    \n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ga0ezds.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp0ga0ezds.swift:21:28: error: 'characters' is unavailable:\
    \ Please use String directly\n    let vowelsCount = word.characters.map(String.init).count\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ > 0 && char.unicodeScalars.last!.value == 0xE001 {\n            vowels.append(char.unicodeScalars.first!.value)\n\
    \        }\n    }\n    \n    if vowels.count > 0 {\n        return vowels.sorted().first!\n\
    \    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmflw1o1p.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpmflw1o1p.swift:25:54:\
    \ error: cannot convert value of type 'UInt32' to expected argument type 'String'\n\
    \            vowels.append(char.unicodeScalars.first!.value)\n               \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.firstIndex(of: char) {\n \
    \           return index\n        }\n        return vowels.count\n    }.min()\n\
    \    let vowelsIndex2 = vowels.firstIndex(of: word[vowelsIndex])\n    let vowelsIndex3\
    \ = vowels.firstIndex(of: word[vowelsIndex2])\n    if vowelsIndex3 == vowelsIndex\
    \ {\n        return \"\"\n    }\n    if vowelsIndex2 == vowelsIndex {\n      \
    \  return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2 {\n \
    \       return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex2\
    \ {\n        return word[vowelsIndex3]\n    }\n    if vowelsIndex2 == vowelsIndex3\
    \ {\n        return word[vowelsIndex2]\n    }\n    if vowelsIndex3 == vowelsIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpilahe04w.swift:89:35: error: expected '{' after 'if' condition\n\
    \    if vowelsIndex3 == vowelsIndex\n                                  ^\n/tmp/tmpilahe04w.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map(String.init)\
    \ else {\n                       ^~~~~~\n/tmp/tmpilahe04w.swift:21:50: error:\
    \ reference to member 'enumerate' cannot be resolved without a contextual type\n\
    \    let vowelsIndex = word.characters.reversed().enumerate().map { (index, char)\
    \ in\n                                                 ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsIndex = word.characters.reversed().enumerate().filter({ ($0.element\
    \ == vowels.characters.first!) }).first?.offset\n    let vowelsIndex2 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) }).first?.offset\n    let vowelsIndex3\
    \ = word.characters.reversed().enumerate().filter({ ($0.element == vowels.characters.first!)\
    \ && ($0.offset > vowelsIndex) }).first?.offset\n    let vowelsIndex4 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) && ($0.offset < vowelsIndex) }).first?.offset\n\
    \    if vowelsIndex == nil || vowelsIndex2 == nil || vowelsIndex3 == nil || vowelsIndex4\
    \ == nil {\n        return \"\"\n    }\n    if vowelsIndex == nil && vowelsIndex2\
    \ == nil && vowelsIndex3 == nil && vowelsIndex4 == nil {\n        return \"\"\n\
    \    }\n    if vowelsIndex != nil {\n        return vowels[vowelsIndex!]\n   \
    \ }\n    if vowelsIndex2 != nil {\n        return vowels[vowelsIndex2!]\n    }\n\
    \    if vowelsIndex3 != nil {\n        return vowels[vowelsIndex3!]\n    }\n \
    \   if vowelsIndex4 != nil {\n        return vowels[vowelsIndex4!]\n    }\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqkkzq24f.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqkkzq24f.swift:19:122: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.first!) }).first?.offset\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:20:122: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex2 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) }).first?.offset\n                 \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:21:152: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex3 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.first!) && ($0.offset > vowelsIndex) }).first?.offset\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:22:151: error: type of expression is ambiguous without\
    \ more context\n    let vowelsIndex4 = word.characters.reversed().enumerate().filter({\
    \ ($0.element == vowels.characters.last!) && ($0.offset < vowelsIndex) }).first?.offset\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpqkkzq24f.swift:30:22: error: no 'subscript' candidates produce the expected\
    \ contextual result type 'String'\n        return vowels[vowelsIndex!]\n     \
    \                ^\nSwift.String:12:12: note: 'subscript(_:)' produces 'Characte"
  stdout: ''
  timestamp: 1660014416
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndexEnd = word.count\
    \ - 1\n    var vowelIndexStart = 0\n    var vowelIndexEnd2 = word.count - 1\n\
    \    var vowelIndexStart2 = 0\n    var vowelIndexEnd3 = word.count - 1\n    var\
    \ vowelIndexStart3 = 0\n    var vowelIndexEnd4 = word.count - 1\n    var vowelIndexStart4\
    \ = 0\n    var vowelIndexEnd5 = word.count - 1\n    var vowelIndexStart5 = 0\n\
    \    var vowelIndexEnd6 = word.count - 1\n    var vowelIndexStart6 = 0\n    var\
    \ vowelIndexEnd7 = word.count - 1\n    var vowelIndexStart7 = 0\n    var vowelIndexEnd8\
    \ = word.count - 1\n    var vowelIndexStart8 = 0\n    var vowelIndexEnd9 = word.count\
    \ - 1\n    var vowelIndexStart9 = 0\n    var vowelIndexEnd10 = word.count - 1\n\
    \    var vowelIndexStart10 = 0\n    var vowelIndexEnd11 = word.count - 1\n   \
    \ var vowelIndexStart11 = 0\n    var vowelIndexEnd12 = word.count - 1\n    var\
    \ vowelIndexStart12 = 0\n    var vowelIndexEnd13 = word.count - 1\n    var vowelIndexStart13\
    \ = 0\n    var vowelIndexEnd14 = word.count - 1\n    var vowelIndexStart14 = 0\n\
    \    var vowelIndexEnd15 = word.count - 1\n    var vowelIndexStart15 = 0\n   \
    \ var vowelIndexEnd16 = word.count - 1\n    var vowelIndexStart16 = 0\n    var\
    \ vowelIndexEnd17 = word.count - 1\n    var vowelIndexStart17 = 0\n    var vowelIndexEnd18\
    \ = word.count - 1\n    var vowelIndexStart18 = 0\n    var vowelIndexEnd19 = word.count\
    \ - 1\n    var vowelIndexStart19 = 0\n    var vowelIndexEnd20 = word.count - 1\n\
    \    var vowelIndexStart20 = 0\n    var vowelIndexEnd21 = word.count - 1\n   \
    \ var vowelIndexStart21 = 0\n    var vowelIndexEnd22 = word.count - 1\n    var\
    \ vowelIndexStart22 = 0\n    var vowelIndexEnd23 = word.count - 1\n    var vowelIndexStart23\
    \ = 0\n    var vowelIndexEnd24 = word.count - 1\n    var vowelIndexStart24 = 0\n\
    \    var vowelIndexEnd25 = word.count - 1\n    var vowelIndexStart25 = 0\n   \
    \ var vowelIndexEnd26 = word.count - 1\n    var vowelIndexStart26 = 0\n    var\
    \ vowelIndexEnd27 = word.count - 1\n    var vowelIndexStart27 = 0\n    var vowelIndexEnd28\
    \ = word.count - 1\n    var vowelIndexStart28 = 0\n    var vowelIndexEnd29 = word.count\
    \ - 1\n    var vowelIndexStart29 = 0\n    var vowelIndexEnd30 = word.count - 1\n\
    \    var vowelIndexStart30 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvlm15c8g.swift:79:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpvlm15c8g.swift:17:9: warning: initialization of immutable value 'vowels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let vowels = \"aeiouAEIOU\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:18:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:19:9: warning: initialization of variable 'vowelIndexEnd'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd = word.count - 1\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:20:9:\
    \ warning: initialization of variable 'vowelIndexStart' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexStart = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:21:9: warning: initialization\
    \ of variable 'vowelIndexEnd2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexEnd2 = word.count - 1\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:22:9: warning: initialization of variable 'vowelIndexStart2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexStart2 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:23:9:\
    \ warning: initialization of variable 'vowelIndexEnd3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelIndexEnd3 = word.count\
    \ - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:24:9: warning: initialization\
    \ of variable 'vowelIndexStart3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndexStart3 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpvlm15c8g.swift:25:9: warning: initialization of variable 'vowelIndexEnd4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndexEnd4 = word.count - 1\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpvlm15c8g.swift:26:9:\
    \ war"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n        if let index = vowels.index(of: char) {\n\
    \            return index\n        }\n        return vowelsCount - 1\n    }.min()\n\
    \    \n    if vowelsIndex < 0 {\n        return \"\"\n    }\n    \n    let consonantsCount\
    \ = word.characters.count\n    let consonantsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n        if let index = consonants.index(of: char)\
    \ {\n            return index\n        }\n        return consonantsCount - 1\n\
    \    }.max()\n    \n    if consonantsIndex > vowelsIndex {\n        return \"\"\
    \n    }\n    \n    let vowelsIndex = vowelsIndex\n    let consonantsIndex = consonantsIndex\n\
    \    \n    let vowelsChar = vowels[vowelsIndex]\n    let consonantsChar = word.characters.reversed()[consonantsIndex]\n\
    \    \n    if vowelsChar != consonantsChar {\n        return \"\"\n    }\n   \
    \ \n    return vowelsChar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5wv4g553.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp5wv4g553.swift:22:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n                                                \
    \ ^\n/tmp/tmp5wv4g553.swift:33:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let consonantsCount = word.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5wv4g553.swift:35:24: error: cannot find 'consonants' in\
    \ scope\n        if let index = consonants.index(of: char) {\n               \
    \        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n\
    \        }\n    }\n    if vowels.count > 0 {\n        let vowel = vowels.sorted().first!\n\
    \        let index = word.unicodeScalars.firstIndex(of: vowel)\n        if index\
    \ != nil {\n            let start = word.unicodeScalars.startIndex.advanced(by:\
    \ index!)\n            let end = word.unicodeScalars.endIndex.advanced(by: index!)\n\
    \            return String(word.unicodeScalars.subSequence(from: start, to: end))\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr9c_ux_p.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpr9c_ux_p.swift:19:12: error: initializer\
    \ for conditional binding must have Optional type, not 'Bool'\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr9c_ux_p.swift:25:56: error: cannot convert value of type 'String' to\
    \ expected argument type 'Unicode.Scalar'\n        let index = word.unicodeScalars.firstIndex(of:\
    \ vowel)\n                                                       ^\n/tmp/tmpr9c_ux_p.swift:27:56:\
    \ error: value of type 'String.UnicodeScalarView.Index' (aka 'String.Index') has\
    \ no member 'advanced'\n            let start = word.unicodeScalars.startIndex.advanced(by:\
    \ index!)\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr9c_ux_p.swift:28:52:\
    \ error: value of type 'String.UnicodeScalarView.Index' (aka 'String.Index') has\
    \ no member 'advanced'\n            let end = word.unicodeScalars.endIndex.advanced(by:\
    \ index!)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr9c_ux_p.swift:29:47:\
    \ error: value of type 'String.UnicodeScalarView' has no member 'subSequence'\n\
    \            return String(word.unicodeScalars.subSequence(from: start, to: end))\n\
    \                          ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for letter in word {\n        if letter.isUpper() {\n        \
    \    vowels.append(letter)\n        }\n    }\n    \n    var vowelsCount = vowels.count\n\
    \    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex\
    \ = 0\n    \n    for letter in word {\n        if letter.isUpper() {\n       \
    \     vowelIndex += 1\n        }\n    }\n    \n    var vowelsCountInWord = vowels.count\n\
    \    \n    if vowelsCountInWord == 0 {\n        return \"\"\n    }\n    \n   \
    \ var vowelIndexInWord = vowelIndex\n    \n    var vowelIndexInWord2 = vowelIndexInWord\n\
    \    \n    var vowelIndexInWord3 = vowelIndexInWord\n    \n    var vowelIndexInWord4\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord5 = vowelIndexInWord\n   \
    \ \n    var vowelIndexInWord6 = vowelIndexInWord\n    \n    var vowelIndexInWord7\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord8 = vowelIndexInWord\n   \
    \ \n    var vowelIndexInWord9 = vowelIndexInWord\n    \n    var vowelIndexInWord10\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord11 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord12 = vowelIndexInWord\n    \n    var vowelIndexInWord13\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord14 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord15 = vowelIndexInWord\n    \n    var vowelIndexInWord16\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord17 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord18 = vowelIndexInWord\n    \n    var vowelIndexInWord19\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord20 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord21 = vowelIndexInWord\n    \n    var vowelIndexInWord22\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord23 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord24 = vowelIndexInWord\n    \n    var vowelIndexInWord25\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord26 = vowelIndexInWord\n  \
    \  \n    var vowelIndexInWord27 = vowelIndexInWord\n    \n    var vowelIndexInWord28\
    \ = vowelIndexInWord\n    \n    var vowelIndexInWord29\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp84w3x1it.swift:24:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp84w3x1it.swift:25:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp84w3x1it.swift:38:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp84w3x1it.swift:105:9: error: type annotation\
    \ missing in pattern\n    var vowelIndexInWord29\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \
    \  var vowelsCount = 0\n    var vowelIndex = 0\n    var vowelsCountIndex = 0\n\
    \    var vowelsCountIndex2 = 0\n    var vowelsCountIndex3 = 0\n    var vowelsCountIndex4\
    \ = 0\n    var vowelsCountIndex5 = 0\n    var vowelsCountIndex6 = 0\n    var vowelsCountIndex7\
    \ = 0\n    var vowelsCountIndex8 = 0\n    var vowelsCountIndex9 = 0\n    var vowelsCountIndex10\
    \ = 0\n    var vowelsCountIndex11 = 0\n    var vowelsCountIndex12 = 0\n    var\
    \ vowelsCountIndex13 = 0\n    var vowelsCountIndex14 = 0\n    var vowelsCountIndex15\
    \ = 0\n    var vowelsCountIndex16 = 0\n    var vowelsCountIndex17 = 0\n    var\
    \ vowelsCountIndex18 = 0\n    var vowelsCountIndex19 = 0\n    var vowelsCountIndex20\
    \ = 0\n    var vowelsCountIndex21 = 0\n    var vowelsCountIndex22 = 0\n    var\
    \ vowelsCountIndex23 = 0\n    var vowelsCountIndex24 = 0\n    var vowelsCountIndex25\
    \ = 0\n    var vowelsCountIndex26 = 0\n    var vowelsCountIndex27 = 0\n    var\
    \ vowelsCountIndex28 = 0\n    var vowelsCountIndex29 = 0\n    var vowelsCountIndex30\
    \ = 0\n    var vowelsCountIndex31 = 0\n    var vowelsCountIndex32 = 0\n    var\
    \ vowelsCountIndex33 = 0\n    var vowelsCountIndex34 = 0\n    var vowelsCountIndex35\
    \ = 0\n    var vowelsCountIndex36 = 0\n    var vowelsCountIndex37 = 0\n    var\
    \ vowelsCountIndex38 = 0\n    var vowelsCountIndex39 = 0\n    var vowelsCountIndex40\
    \ = 0\n    var vowelsCountIndex41 = 0\n    var vowelsCountIndex42 = 0\n    var\
    \ vowelsCountIndex43 = 0\n    var vowelsCountIndex44 = 0\n    var vowelsCountIndex45\
    \ = 0\n    var vowelsCountIndex46 = 0\n    var vowelsCountIndex47 = 0\n    var\
    \ vowelsCountIndex48 = 0\n    var vowelsCountIndex49 = 0\n    var vowelsCountIndex50\
    \ = 0\n    var vowelsCountIndex51 = 0\n    var vowelsCountIndex52 = 0\n    var\
    \ vowelsCountIndex53 = 0\n    var vowelsCountIndex54 = 0\n    var vowelsCountIndex55\
    \ = 0\n    var vowelsCountIndex56 = 0\n    var vowelsCountIndex57 = 0\n    var\
    \ vowelsCountIndex58 = 0\n    var vowelsCountIndex59 = 0\n    var vowelsCountIndex60\
    \ = 0\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4acqhvzc.swift:81:9: error: type annotation missing in pattern\n\
    \    var vowels\n        ^\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpihpnyelp.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, vowels: vowels)\n         \
    \  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpihpnyelp.swift:17:51: error: cannot find 'vowels'\
    \ in scope\n    return find_closest_vowel(word: word, vowels: vowels)\n      \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels = [String]()\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n    vowels.append(\"-\")\n    vowels.append(\"-\")\n\
    \    vowels.append(\"-\")\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmp1s176w7m.swift:105:1: error: missing return in global function
    expected to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = \"aeiouAEIOU\"\n\
    \    var vowelsCount = vowels.count\n    var vowelsIndex = 0\n    var vowelsIndex2\
    \ = vowelsIndex + vowelsCount\n    var vowelsIndex3 = vowelsIndex2 + vowelsCount\n\
    \    var vowelsIndex4 = vowelsIndex3 + vowelsCount\n    var vowelsIndex5 = vowelsIndex4\
    \ + vowelsCount\n    var vowelsIndex6 = vowelsIndex5 + vowelsCount\n    var vowelsIndex7\
    \ = vowelsIndex6 + vowelsCount\n    var vowelsIndex8 = vowelsIndex7 + vowelsCount\n\
    \    var vowelsIndex9 = vowelsIndex8 + vowelsCount\n    var vowelsIndex10 = vowelsIndex9\
    \ + vowelsCount\n    var vowelsIndex11 = vowelsIndex10 + vowelsCount\n    var\
    \ vowelsIndex12 = vowelsIndex11 + vowelsCount\n    var vowelsIndex13 = vowelsIndex12\
    \ + vowelsCount\n    var vowelsIndex14 = vowelsIndex13 + vowelsCount\n    var\
    \ vowelsIndex15 = vowelsIndex14 + vowelsCount\n    var vowelsIndex16 = vowelsIndex15\
    \ + vowelsCount\n    var vowelsIndex17 = vowelsIndex16 + vowelsCount\n    var\
    \ vowelsIndex18 = vowelsIndex17 + vowelsCount\n    var vowelsIndex19 = vowelsIndex18\
    \ + vowelsCount\n    var vowelsIndex20 = vowelsIndex19 + vowelsCount\n    var\
    \ vowelsIndex21 = vowelsIndex20 + vowelsCount\n    var vowelsIndex22 = vowelsIndex21\
    \ + vowelsCount\n    var vowelsIndex23 = vowelsIndex22 + vowelsCount\n    var\
    \ vowelsIndex24 = vowelsIndex23 + vowelsCount\n    var vowelsIndex25 = vowelsIndex24\
    \ + vowelsCount\n    var vowelsIndex26 = vowelsIndex25 + vowelsCount\n    var\
    \ vowelsIndex27 = vowelsIndex26 + vowelsCount\n    var vowelsIndex28 = vowelsIndex27\
    \ + vowelsCount\n    var vowelsIndex29 = vowelsIndex28 + vowelsCount\n    var\
    \ vowelsIndex30 = vowelsIndex29 + vowelsCount\n    var vowelsIndex31 = vowelsIndex30\
    \ + vowelsCount\n    var vowelsIndex32 = vowelsIndex31 + vowelsCount\n    var\
    \ vowelsIndex33 = vowelsIndex32 + vowelsCount\n    var vowelsIndex34 = vowelsIndex33\
    \ + vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplauv9y5p.swift:55:41: error: cannot find 'vowel' in scope\n   \
    \ var vowelsIndex34 = vowelsIndex33 + vowel\n                                \
    \        ^~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnoavf13p.swift:17:24: error: use of local variable 'vowels' before\
    \ its declaration\n    guard let vowels = vowels.characters.map(String.init) else\
    \ {\n                       ^\n/tmp/tmpnoavf13p.swift:105:9: note: 'vowels' declared\
    \ here\n    let vowels\n        ^\n/tmp/tmpnoavf13p.swift:105:9: error: type annotation\
    \ missing in pattern\n    let vowels\n        ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelFound = false\n    for letter in vowels\
    \ {\n        if letter == vowels[vowelIndex+1] {\n            vowelFound = true\n\
    \            vowelIndex += 1\n            if vowelIndex == vowels.count - 1 {\n\
    \                return letter\n            }\n        }\n    }\n    if !vowelFound\
    \ {\n        return \"\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphj_rnj2z.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmphj_rnj2z.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    \n    var vowelsCount = vowels.count\n    \n    if vowelsCount == 0 {\n \
    \       return \"\"\n    }\n    \n    var vowelIndex = 0\n    \n    for vowel\
    \ in vowels {\n        if word.rangeOfString(vowel, options: .CaseInsensitiveSearch).location\
    \ == NSNotFound {\n            vowelIndex = vowelIndex + 1\n        }\n    }\n\
    \    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n    var vowelsCount2\
    \ = vowels.count\n    \n    if vowelsCount2 == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndex2 = 0\n    \n    for vowel2 in vowels {\n        if word.rangeOfString(vowel2,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex2\
    \ = vowelIndex2 + 1\n        }\n    }\n    \n    if vowelIndex2 == 0 {\n     \
    \   return \"\"\n    }\n    \n    var vowelsCount3 = vowels.count\n    \n    if\
    \ vowelsCount3 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex3 =\
    \ 0\n    \n    for vowel3 in vowels {\n        if word.rangeOfString(vowel3, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex3 =\
    \ vowelIndex3 + 1\n        }\n    }\n    \n    if vowelIndex3 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount4 = vowels.count\n    \n    if\
    \ vowelsCount4 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex4 =\
    \ 0\n    \n    for vowel4 in vowels {\n        if word.rangeOfString(vowel4, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex4 =\
    \ vowelIndex4 + 1\n        }\n    }\n    \n    if vowelIndex4 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount5 = vowels.count\n    \n    if\
    \ vowelsCount5 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex5 =\
    \ 0\n    \n    for vowel5 in vowels {\n        if word.rangeOfString(vowel5, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n            vowelIndex5 =\
    \ vowelIndex5 + 1\n        }\n    }\n    \n    if vowelIndex5 == 0 {\n       \
    \ return \"\"\n    }\n    \n    var vowelsCount6 = vowels.count\n    \n    if\
    \ vowelsCount6 == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex6 =\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpltzaaqps.swift:33:83: error: cannot find 'NSNotFound' in scope\n\
    \        if word.rangeOfString(vowel, options: .CaseInsensitiveSearch).location\
    \ == NSNotFound {\n                                                          \
    \                        ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:33:17: error: value\
    \ of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:33:48: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitiveSearch'\n        if word.rangeOfString(vowel, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                     ~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpltzaaqps.swift:51:84: error:\
    \ cannot find 'NSNotFound' in scope\n        if word.rangeOfString(vowel2, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                                                          ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:51:17:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel2,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:51:49: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitiveSearch'\n        if word.rangeOfString(vowel2, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                      ~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpltzaaqps.swift:69:84: error:\
    \ cannot find 'NSNotFound' in scope\n        if word.rangeOfString(vowel3, options:\
    \ .CaseInsensitiveSearch).location == NSNotFound {\n                         \
    \                                                          ^~~~~~~~~~\n/tmp/tmpltzaaqps.swift:69:17:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if word.rangeOfString(vowel3,\
    \ options: .CaseInsensitiveSearch).location == NSNotFound {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpltzaaqps.swift:69:49: error: cannot infer contextual bas"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n\
    \        }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    var\
    \ vowelIndex = 0\n    var vowelIndexEnd = 0\n    var vowelIndexStart = 0\n   \
    \ while vowelIndex < vowels.count {\n        let vowel = vowels[vowelIndex]\n\
    \        if vowelIndexEnd < vowels.count {\n            let nextVowel = vowels[vowelIndexEnd]\n\
    \            if vowel == nextVowel {\n                vowelIndexEnd += 1\n   \
    \         } else {\n                vowelIndexStart = vowelIndex\n           \
    \     vowelIndexEnd = vowelIndex\n                vowelIndex = vowelIndexStart\n\
    \            }\n        } else {\n            vowelIndexEnd = vowelIndex\n   \
    \         vowelIndex = vowelIndexStart\n        }\n    }\n    return vowels[vowelIndexEnd]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpg61si36m.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpg61si36m.swift:19:12: error: initializer\
    \ for conditional binding must have Optional type, not 'Bool'\n        if let\
    \ _ = char.value > 0x41 && char.value < 0x5A {\n           ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters {\n        if vowels.contains(char) {\n            if let\
    \ index = vowels.index(of: char) {\n                let start = word.index(before:\
    \ index)\n                let end = word.index(before: start, offsetBy: 1)\n \
    \               let range = start..<end\n                let vowel = word[range]\n\
    \                if vowel.lowercased() == \"a\" {\n                    result\
    \ = vowel\n                    break\n                }\n            }\n     \
    \   }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0xuk636.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpp0xuk636.swift:24:35:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        \
    \    if let index = vowels.index(of: char) {\n                               \
    \   ^\n/tmp/tmpp0xuk636.swift:24:35: note: use 'firstIndex(of:)' instead\n   \
    \         if let index = vowels.index(of: char) {\n                          \
    \        ^~~~~\n                                  firstIndex\n/tmp/tmpp0xuk636.swift:26:32:\
    \ error: no exact matches in call to instance method 'index'\n               \
    \ let end = word.index(before: start, offsetBy: 1)\n                         \
    \      ^\nSwift.String:9:17: note: incorrect labels for candidate (have: '(before:offsetBy:)',\
    \ expected: '(_:offsetBy:)')\n    public func index(_ i: String.Index, offsetBy\
    \ distance: Int) -> String.Index\n                ^\nSwift.Collection:6:28: note:\
    \ incorrect labels for candidate (have: '(before:offsetBy:)', expected: '(_:offsetBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int) ->\
    \ Self.Index\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(before:offsetBy:)', expected:\
    \ '(_:offsetBy:)')\n    @inlinable public func index(_ i: Self.Index, offsetBy\
    \ distance: Int) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowelIndex = 0\n \
    \   var vowelIndex2 = word.count\n    var vowelIndex3 = word.count - 1\n    \n\
    \    var vowelIndex4 = word.count - 2\n    \n    var vowelIndex5 = word.count\
    \ - 3\n    \n    var vowelIndex6 = word.count - 4\n    \n    var vowelIndex7 =\
    \ word.count - 5\n    \n    var vowelIndex8 = word.count - 6\n    \n    var vowelIndex9\
    \ = word.count - 7\n    \n    var vowelIndex10 = word.count - 8\n    \n    var\
    \ vowelIndex11 = word.count - 9\n    \n    var vowelIndex12 = word.count - 10\n\
    \    \n    var vowelIndex13 = word.count - 11\n    \n    var vowelIndex14 = word.count\
    \ - 12\n    \n    var vowelIndex15 = word.count - 13\n    \n    var vowelIndex16\
    \ = word.count - 14\n    \n    var vowelIndex17 = word.count - 15\n    \n    var\
    \ vowelIndex18 = word.count - 16\n    \n    var vowelIndex19 = word.count - 17\n\
    \    \n    var vowelIndex20 = word.count - 18\n    \n    var vowelIndex21 = word.count\
    \ - 19\n    \n    var vowelIndex22 = word.count - 20\n    \n    var vowelIndex23\
    \ = word.count - 21\n    \n    var vowelIndex24 = word.count - 22\n    \n    var\
    \ vowelIndex25 = word.count - 23\n    \n    var vowelIndex26 = word.count - 24\n\
    \    \n    var vowelIndex27 = word.count - 25\n    \n    var vowelIndex28 = word.count\
    \ - 26\n    \n    var vowelIndex29 = word.count - 27\n    \n    var vowelIndex30\
    \ = word.count - 28\n    \n    var vowelIndex31 = word.count - 29\n    \n    var\
    \ vowelIndex32 = word.count - 30\n    \n    var vowelIndex33 = word.count - 31\n\
    \    \n    var vowelIndex34 = word.count - 32\n    \n    var vowelIndex35 = word.count\
    \ - 33\n    \n    var vowelIndex36 = word.count - 34\n    \n    var vowelIndex37\
    \ = word.count - 35\n    \n    var vowelIndex38 = word.count - 36\n    \n    var\
    \ vowelIndex39 = word.count - 37\n    \n    var vowelIndex40 = word.count - 38\n\
    \    \n    var vowelIndex41 = word.count - 39\n    \n    var vowelIndex42 = word.count\
    \ - 40\n    \n    var vowelIndex43 = word.count - 41\n    \n    var vowelIndex44\
    \ = word.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpds8y43yl.swift:105:28: error: expected member name following '.'\n\
    \    var vowelIndex44 = word.\n                           ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = []\n\
    \    for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(char.value)\n        }\n    }\n    if vowels.isEmpty\
    \ {\n        return \"\"\n    }\n    var index = vowels.count - 1\n    var vowel\
    \ = vowels[index]\n    if vowels.count > 2 {\n        for index in vowels.indices\
    \ {\n            if index > 0 {\n                if vowels[index - 1] == vowel\
    \ {\n                    vowel = vowels[index]\n                    break\n  \
    \              }\n            }\n        }\n    }\n    return vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrrz6mz.swift:23:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters.reverse() {\n        if vowels.contains(char) {\n       \
    \     result = char\n            break\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbn8c5fsu.swift:22:33: error: value of type 'String' has no member\
    \ 'reverse'\n    for char in word.characters.reverse() {\n                ~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count,\n        let vowelsCount = vowelsCount > 0,\n        let vowelsCount\
    \ = vowelsCount < word.characters.count,\n        let vowelsCount = vowels.count\
    \ > 0,\n        let vowelsCount = vowels.count < word.characters.count else {\n\
    \            return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd44llk2.swift:79:29: error: expected member name following '.'\n\
    \    let vowelsCount = vowels.\n                            ^\n/tmp/tmpqd44llk2.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map({\
    \ String($0) }),\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"\
    e\")\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"\
    u\")\n    \n    var vowelsCount = vowels.count\n    \n    var lastConsonantIndex\
    \ = word.characters.count - 1\n    \n    var closestVowelIndex: Int?\n    \n \
    \   for index in 0..<word.characters.count {\n        \n        let currentChar\
    \ = word.characters[index]\n        \n        if currentChar == vowels.first {\n\
    \            \n            if closestVowelIndex == nil {\n                \n \
    \               closestVowelIndex = index\n                \n            }\n \
    \           \n            if index == lastConsonantIndex {\n                \n\
    \                closestVowelIndex = nil\n                \n            }\n  \
    \          \n        } else {\n            \n            if closestVowelIndex\
    \ != nil {\n                \n                if index == lastConsonantIndex {\n\
    \                    \n                    closestVowelIndex = nil\n         \
    \           \n                } else {\n                    \n               \
    \     closestVowelIndex = index\n                    \n                }\n   \
    \             \n            }\n            \n        }\n        \n    }\n    \n\
    \    if closestVowelIndex != nil {\n        \n        return word.substring(to:\
    \ closestVowelIndex!)\n        \n    } else {\n        \n        return \"\"\n\
    \        \n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp51d14pw9.swift:27:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var lastConsonantIndex = word.characters.count - 1\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp51d14pw9.swift:31:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in 0..<word.characters.count {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp51d14pw9.swift:33:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ currentChar = word.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp51d14pw9.swift:33:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = word.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp51d14pw9.swift:71:21:\
    \ error: value of type 'String' has no member 'substring'\n        return word.substring(to:\
    \ closestVowelIndex!)\n               ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count < 2 {\n        return \"\"\n    }\n    var vowelIndex\
    \ = 0\n    var vowelCount = 0\n    var consonantIndex = 0\n    var consonantCount\
    \ = 0\n    var currentVowel = \"\"\n    var currentConsonant = \"\"\n    var currentVowelIndex\
    \ = 0\n    var currentConsonantIndex = 0\n    for index in 0..<word.characters.count\
    \ {\n        let character = word.characters[index]\n        if character == \"\
    a\" || character == \"e\" || character == \"i\" || character == \"o\" || character\
    \ == \"u\" {\n            vowelCount += 1\n            if vowelIndex == 0 {\n\
    \                currentVowel = character\n                currentVowelIndex =\
    \ index\n            }\n        }\n        if character == \"b\" || character\
    \ == \"c\" || character == \"d\" || character == \"f\" || character == \"g\" ||\
    \ character == \"h\" || character == \"j\" || character == \"k\" || character\
    \ == \"l\" || character == \"m\" || character == \"n\" || character == \"p\" ||\
    \ character == \"q\" || character == \"r\" || character == \"s\" || character\
    \ == \"t\" || character == \"v\" || character == \"w\" || character == \"x\" ||\
    \ character == \"y\" || character == \"z\" {\n            vowelCount += 1\n  \
    \          if vowelIndex == 0 {\n                currentVowel = character\n  \
    \              currentVowelIndex = index\n            }\n        }\n        if\
    \ character == \"A\" || character == \"E\" || character == \"I\" || character\
    \ == \"O\" || character == \"U\" {\n            vowelCount += 1\n            if\
    \ vowelIndex == 0 {\n                currentVowel = character\n              \
    \  currentVowelIndex = index\n            }\n        }\n        if character ==\
    \ \"B\" || character == \"C\" || character == \"D\" || character == \"F\" || character\
    \ == \"G\" || character == \"H\" || character == \"J\" || character == \"K\" ||\
    \ character == \"L\" || character == \"M\" || character == \"N\" || character\
    \ == \"P\" || character == \"Q\" || character == \"R\" || character == \"S\" ||\
    \ character == \"T\" || character == \"V\" || character == \"W\" || character\
    \ == \"X\" || character == \"Y\" || character == \"Z\" {\n            vowelCount\
    \ += 1\n            if vowelIndex == 0 {\n                currentVowel = character\n\
    \                currentVowelIndex = index\n            }\n        }\n       \
    \ if character == \"0\" {\n            vowelCount += 1\n            if vowelIndex\
    \ == 0 {\n                currentVowel = character\n                currentVowelIndex\
    \ = index\n            }\n        }\n        if character == \"1\" {\n       \
    \     vowelCount += 1\n            if vowelIndex == 0 {\n                currentVowel\
    \ = character\n                currentVowelIndex = index\n            }\n    \
    \    }\n        if character == \"2\" {\n            vowelCount += 1\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0gt0462.swift:101:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpq0gt0462.swift:28:44: note: to match this opening\
    \ '{'\n    for index in 0..<word.characters.count {\n                        \
    \                   ^\n/tmp/tmpq0gt0462.swift:101:48: error: expected '}' at end\
    \ of brace statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n  \
    \                                             ^\n/tmp/tmpq0gt0462.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpq0gt0462.swift:17:13:\
    \ error: 'characters' is unavailable: Please use String directly\n    if word.characters.count\
    \ < 2 {\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpq0gt0462.swift:28:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<word.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpq0gt0462.swift:29:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = word.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpq0gt0462.swift:29:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = word.characters[index]\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq0gt0462.swift:33:32:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      currentVowel"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndexEnd = word.count\n\
    \    var vowelIndexStart = 0\n    var vowelIndexStartEnd = word.count\n    var\
    \ vowelIndexEndStart = 0\n    var vowelIndexStartEndEnd = 0\n    var vowelIndexStartEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n  \
    \  var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4xl76ya.swift:33:9: error: invalid redeclaration of 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n        ^\n/tmp/tmpx4xl76ya.swift:32:9:\
    \ note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd' previously declared\
    \ here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n       \
    \ ^\n/tmp/tmpx4xl76ya.swift:38:9: error: invalid redeclaration of 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n  \
    \      ^\n/tmp/tmpx4xl76ya.swift:37:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:41:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n   \
    \     ^\n/tmp/tmpx4xl76ya.swift:40:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:42:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n    var\
    \ vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0\n   \
    \     ^\n/tmp/tmpx4xl76ya.swift:40:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmpx4xl76ya.swift:44:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n  \
    \  var vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd =\
    \ 0\n        ^\n/tmp/tmpx4xl76ya.swift:43:9: note: 'vowelIndexStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndEndEndEndEndE"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    var vowelIndex2 = vowelIndex - 1\n    \n    for char in word.characters\
    \ {\n        if vowels.contains(String(char)) {\n            vowelIndex2 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex2\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex2 < vowelIndex {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex3 = vowelIndex2\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex3 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex3 == 0 {\n        return \"\"\n    }\n\
    \    \n    if vowelIndex3 < vowelIndex2 {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex4 = vowelIndex3\n    \n    for char in word.characters {\n\
    \        if vowels.contains(String(char)) {\n            vowelIndex4 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex4\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex4 < vowelIndex3 {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex5 = vowelIndex4\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex5 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex5 == 0 {\n        return \"\"\n    }\n\
    \    \n    if vowelIndex5 < vowelIndex4 {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex6 = vowelIndex5\n    \n    for char in word.characters {\n\
    \        if vowels.contains(String(char)) {\n            vowelIndex6 = vowels.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    if vowelIndex6\
    \ == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex6 < vowelIndex5 {\n\
    \        return \"\"\n    }\n    \n    var vowelIndex7 = vowelIndex6\n    \n \
    \   for char in word.characters {\n        if vowels.contains(String(char)) {\n\
    \            vowelIndex7 = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex7 == 0 {\n        return \"\"\n    }\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_5njhrvp.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_5njhrvp.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp_5njhrvp.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmp_5njhrvp.swift:35:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp_5njhrvp.swift:37:62: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n            vowelIndex2 = vowels.firstIndex(of:\
    \ String(char))!\n                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmp_5njhrvp.swift:37:49: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n            vowelIndex2\
    \ = vowels.firstIndex(of: String(char))!\n                                   \
    \             ^\n/tmp/tmp_5njhrvp.swift:52:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in word.characters {\n            \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_5njhrvp.swift:54:62:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex3 = vowels.firstIndex(of: String(char))!\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmp_5njhrvp.swift:54:49: err"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountMax:\
    \ Int = vowels.count\n    var vowelsCountMin: Int = vowels.count - 1\n    var\
    \ vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n    var vowelsCountMinIndex:\
    \ Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex: Int = vowelsCountMax\
    \ - 1\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpab63gkrz.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpab63gkrz.swift:24:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:25:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:26:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:27:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:28:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously declared here\n    var vowelsCountMaxIndex:\
    \ Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:29:9: error: invalid\
    \ redeclaration of 'vowelsCountMinIndex'\n    var vowelsCountMinIndex: Int = vowelsCountMin\
    \ - 1\n        ^\n/tmp/tmpab63gkrz.swift:23:9: note: 'vowelsCountMinIndex' previously\
    \ declared here\n    var vowelsCountMinIndex: Int = vowelsCountMin - 1\n     \
    \   ^\n/tmp/tmpab63gkrz.swift:30:9: error: invalid redeclaration of 'vowelsCountMaxIndex'\n\
    \    var vowelsCountMaxIndex: Int = vowelsCountMax - 1\n        ^\n/tmp/tmpab63gkrz.swift:22:9:\
    \ note: 'vowelsCountMaxIndex' previously decl"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    if\
    \ word.hasPrefix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasPrefix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.hasPrefix(\"i\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"I\")\n    }\n    if word.hasPrefix(\"o\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"O\")\n    }\n    if word.hasPrefix(\"\
    u\") {\n        vowels.removeAll()\n        vowels.append(\"U\")\n    }\n    \n\
    \    if word.hasSuffix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasSuffix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.hasSuffix(\"i\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"I\")\n    }\n    if word.hasSuffix(\"o\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"O\")\n    }\n    if word.hasSuffix(\"\
    u\") {\n        vowels.removeAll()\n        vowels.append(\"U\")\n    }\n    \n\
    \    if word.hasPrefix(\"A\") {\n        vowels.removeAll()\n        vowels.append(\"\
    a\")\n    }\n    if word.hasPrefix(\"E\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"e\")\n    }\n    if word.hasPrefix(\"I\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"i\")\n    }\n    if word.hasPrefix(\"O\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"o\")\n    }\n    if word.hasPrefix(\"\
    U\") {\n        vowels.removeAll()\n        vowels.append(\"u\")\n    }\n    \n\
    \    if word.hasSuffix(\"A\") {\n        vowels.removeAll()\n        vowels.append(\"\
    a\")\n    }\n    if word.hasSuffix(\"E\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"e\")\n    }\n    if word.hasSuffix(\"I\") {\n        vowels.removeAll()\n\
    \        vowels.append(\"i\")\n    }\n    if word.hasSuffix(\"O\") {\n       \
    \ vowels.removeAll()\n        vowels.append(\"o\")\n    }\n    if word.hasSuffix(\"\
    U\") {\n        vowels.removeAll()\n        vowels.append(\"u\")\n    }\n    \n\
    \    if word.hasPrefix(\"a\") {\n        vowels.removeAll()\n        vowels.append(\"\
    A\")\n    }\n    if word.hasPrefix(\"e\") {\n        vowels.removeAll()\n    \
    \    vowels.append(\"E\")\n    }\n    if word.\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgovydp0t.swift:112:12: error: expected member name following '.'\n\
    \    if word.\n           ^\n/tmp/tmpgovydp0t.swift:112:13: error: expected '{'\
    \ after 'if' condition\n    if word.\n            ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkn8ia523.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    var vowelsCount = 0\n    \n \
    \   for char in word.characters {\n        if vowels.contains(char) {\n      \
    \      vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount > 0 {\n  \
    \      var vowelsCountFromRight = 0\n        \n        for char in word.characters\
    \ {\n            if vowels.contains(char) {\n                vowelsCountFromRight\
    \ += 1\n            }\n        }\n        \n        if vowelsCountFromRight >\
    \ 0 {\n            var vowelsCountFromRightToLeft = 0\n            \n        \
    \    for char in word.characters {\n                if vowels.contains(char) {\n\
    \                    vowelsCountFromRightToLeft += 1\n                }\n    \
    \        }\n            \n            if vowelsCountFromRightToLeft > 0 {\n  \
    \              let closestVowel = vowels[vowels.count - vowelsCountFromRightToLeft]\n\
    \                return closestVowel\n            }\n        }\n    }\n    \n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpelhqvyh7.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:26:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpelhqvyh7.swift:34:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ char in word.characters {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:35:32: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            if\
    \ vowels.contains(char) {\n                               ^\n/tmp/tmpelhqvyh7.swift:43:30:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ for char in word.characters {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpelhqvyh7.swift:44:36: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   if vowels.contains(char) {\n                                   ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelsCount = 0\n    var vowelsIndex = 0\n  \
    \  var vowelsIndex2 = 0\n    var vowelsIndex3 = 0\n    var vowelsIndex4 = 0\n\
    \    var vowelsIndex5 = 0\n    var vowelsIndex6 = 0\n    var vowelsIndex7 = 0\n\
    \    var vowelsIndex8 = 0\n    var vowelsIndex9 = 0\n    var vowelsIndex10 = 0\n\
    \    var vowelsIndex11 = 0\n    var vowelsIndex12 = 0\n    var vowelsIndex13 =\
    \ 0\n    var vowelsIndex14 = 0\n    var vowelsIndex15 = 0\n    var vowelsIndex16\
    \ = 0\n    var vowelsIndex17 = 0\n    var vowelsIndex18 = 0\n    var vowelsIndex19\
    \ = 0\n    var vowelsIndex20 = 0\n    var vowelsIndex21 = 0\n    var vowelsIndex22\
    \ = 0\n    var vowelsIndex23 = 0\n    var vowelsIndex24 = 0\n    var vowelsIndex25\
    \ = 0\n    var vowelsIndex26 = 0\n    var vowelsIndex27 = 0\n    var vowelsIndex28\
    \ = 0\n    var vowelsIndex29 = 0\n    var vowelsIndex30 = 0\n    var vowelsIndex31\
    \ = 0\n    var vowelsIndex32 = 0\n    var vowelsIndex33 = 0\n    var vowelsIndex34\
    \ = 0\n    var vowelsIndex35 = 0\n    var vowelsIndex36 = 0\n    var vowelsIndex37\
    \ = 0\n    var vowelsIndex38 = 0\n    var vowelsIndex39 = 0\n    var vowelsIndex40\
    \ = 0\n    var vowelsIndex41 = 0\n    var vowelsIndex42 = 0\n    var vowelsIndex43\
    \ = 0\n    var vowelsIndex44 = 0\n    var vowelsIndex45 = 0\n    var vowelsIndex46\
    \ = 0\n    var vowelsIndex47 = 0\n    var vowelsIndex48 = 0\n    var vowelsIndex49\
    \ = 0\n    var vowelsIndex50 = 0\n    var vowelsIndex51 = 0\n    var vowelsIndex52\
    \ = 0\n    var vowelsIndex53 = 0\n    var vowelsIndex54 = 0\n    var vowelsIndex55\
    \ = 0\n    var vowelsIndex56 = 0\n    var vowelsIndex57 = 0\n    var vowelsIndex58\
    \ = 0\n    var vowelsIndex59 = 0\n    var vowelsIndex60 = 0\n    var vowelsIndex61\
    \ = 0\n    var vowelsIndex62 = 0\n    var vowelsIndex63 = 0\n    var vowelsIndex64\
    \ = 0\n    var vowelsIndex65 = 0\n    var vowelsIndex66 = 0\n    var vowelsIndex67\
    \ = 0\n    var vowelsIndex68 = 0\n    var vowelsIndex69 = 0\n    var vowelsIndex70\
    \ = 0\n    var vowelsIndex71 = 0\n    var vowelsIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpprf7zaln.swift:90:9: error: type annotation missing in pattern\n\
    \    var vowelsIndex\n        ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ Int = 0\n    var vowelIndex: Int = 0\n    var vowelIndex2: Int = 0\n    var\
    \ vowelIndex3: Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5: Int\
    \ = 0\n    var vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var vowelIndex8:\
    \ Int = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int = 0\n    var\
    \ vowelIndex11: Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13:\
    \ Int = 0\n    var vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var\
    \ vowelIndex16: Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18:\
    \ Int = 0\n    var vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var\
    \ vowelIndex21: Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23:\
    \ Int = 0\n    var vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var\
    \ vowelIndex26: Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28:\
    \ Int = 0\n    var vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var\
    \ vowelIndex31: Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33:\
    \ Int = 0\n    var vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var\
    \ vowelIndex36: Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38:\
    \ Int = 0\n    var vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var\
    \ vowelIndex41: Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43:\
    \ Int = 0\n    var vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var\
    \ vowelIndex46: Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48:\
    \ Int = 0\n    var vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var\
    \ vowelIndex51: Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53:\
    \ Int = 0\n    var vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var\
    \ vowelIndex56: Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58:\
    \ Int = 0\n    var vowelIndex59: Int = 0\n    var vowelIndex60: Int = 0\n    var\
    \ vowelIndex61: Int = 0\n    var vowelIndex62: \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplyflt0qq.swift:80:22: error: expected type\n    var vowelIndex62:\
    \ \n                     ^\n                      <#type#>\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n    \n    if vowelIndex == -1 { return \"\" }\n    \n    let vowelIndex1\
    \ = word.characters.reversed().firstIndex(of: vowels[vowelIndex!])\n    \n   \
    \ if vowelIndex1 == -1 { return \"\" }\n    \n    let vowelIndex2 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex1!])\n    \n    if vowelIndex2 == -1 { return \"\" }\n    \n\
    \    let vowelIndex3 = word.characters.reversed().firstIndex(of: vowels[vowelIndex2!])\n\
    \    \n    if vowelIndex3 == -1 { return \"\" }\n    \n    let vowelIndex4 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex3!])\n    \n    if vowelIndex4 == -1 { return \"\" }\n    \n\
    \    let vowelIndex5 = word.characters.reversed().firstIndex(of: vowels[vowelIndex4!])\n\
    \    \n    if vowelIndex5 == -1 { return \"\" }\n    \n    let vowelIndex6 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex5!])\n    \n    if vowelIndex6 == -1 { return \"\" }\n    \n\
    \    let vowelIndex7 = word.characters.reversed().firstIndex(of: vowels[vowelIndex6!])\n\
    \    \n    if vowelIndex7 == -1 { return \"\" }\n    \n    let vowelIndex8 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex7!])\n    \n    if vowelIndex8 == -1 { return \"\" }\n    \n\
    \    let vowelIndex9 = word.characters.reversed().firstIndex(of: vowels[vowelIndex8!])\n\
    \    \n    if vowelIndex9 == -1 { return \"\" }\n    \n    let vowelIndex10 =\
    \ word.characters.reversed().firstIndex(of: vowels[vowelIndex9!])\n    \n    if\
    \ vowelIndex10 == -1 { return \"\" }\n    \n    let vowelIndex11 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex10!])\n    \n    if vowelIndex11 == -1 { return \"\" }\n  \
    \  \n    let vowelIndex12 = word.characters.reversed().firstIndex(of: vowels[vowelIndex11!])\n\
    \    \n    if vowelIndex12 == -1 { return \"\" }\n    \n    let vowelIndex13 =\
    \ word.characters.reversed().firstIndex(of: vowels[vowelIndex12!])\n    \n   \
    \ if vowelIndex13 == -1 { return \"\" }\n    \n    let vowelIndex14 = word.characters.reversed().firstIndex(of:\
    \ vowels[vowelIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ynmv2i_.swift:77:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp8ynmv2i_.swift:76:72: note: to match this opening '['\n    let vowelIndex14\
    \ = word.characters.reversed().firstIndex(of: vowels[vowelIndex\n            \
    \                                                           ^\n/tmp/tmp8ynmv2i_.swift:20:64:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n                                                               ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  var vowelsCount = 0\n    var consonants = [String]()\n    var consonantsCount\
    \ = 0\n    var consonantsCount2 = 0\n    var consonantsCount3 = 0\n    var consonantsCount4\
    \ = 0\n    var consonantsCount5 = 0\n    var consonantsCount6 = 0\n    var consonantsCount7\
    \ = 0\n    var consonantsCount8 = 0\n    var consonantsCount9 = 0\n    var consonantsCount10\
    \ = 0\n    var consonantsCount11 = 0\n    var consonantsCount12 = 0\n    var consonantsCount13\
    \ = 0\n    var consonantsCount14 = 0\n    var consonantsCount15 = 0\n    var consonantsCount16\
    \ = 0\n    var consonantsCount17 = 0\n    var consonantsCount18 = 0\n    var consonantsCount19\
    \ = 0\n    var consonantsCount20 = 0\n    var consonantsCount21 = 0\n    var consonantsCount22\
    \ = 0\n    var consonantsCount23 = 0\n    var consonantsCount24 = 0\n    var consonantsCount25\
    \ = 0\n    var consonantsCount26 = 0\n    var consonantsCount27 = 0\n    var consonantsCount28\
    \ = 0\n    var consonantsCount29 = 0\n    var consonantsCount30 = 0\n    var consonantsCount31\
    \ = 0\n    var consonantsCount32 = 0\n    var consonantsCount33 = 0\n    var consonantsCount34\
    \ = 0\n    var consonantsCount35 = 0\n    var consonantsCount36 = 0\n    var consonantsCount37\
    \ = 0\n    var consonantsCount38 = 0\n    var consonantsCount39 = 0\n    var consonantsCount40\
    \ = 0\n    var consonantsCount41 = 0\n    var consonantsCount42 = 0\n    var consonantsCount43\
    \ = 0\n    var consonantsCount44 = 0\n    var consonantsCount45 = 0\n    var consonantsCount46\
    \ = 0\n    var consonantsCount47 = 0\n    var consonantsCount48 = 0\n    var consonantsCount49\
    \ = 0\n    var consonantsCount50 = 0\n    var consonantsCount51 = 0\n    var consonantsCount52\
    \ = 0\n    var consonantsCount53 = 0\n    var consonantsCount54 = 0\n    var consonantsCount55\
    \ = 0\n    var consonantsCount56 = 0\n    var consonantsCount57 = 0\n    var consonantsCount58\
    \ = 0\n    var consonantsCount59 = 0\n    var consonantsCount60 = 0\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnor1p79n.swift:20:9: warning: initialization of variable 'vowels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowels = [String]()\n    ~~~~^~~~~~\n    _\n/tmp/tmpnor1p79n.swift:21:9:\
    \ warning: initialization of variable 'vowelsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelsCount = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:22:9: warning: initialization of variable 'consonants'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonants = [String]()\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:23:9:\
    \ warning: initialization of variable 'consonantsCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantsCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:24:9: warning: initialization\
    \ of variable 'consonantsCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantsCount2 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:25:9: warning: initialization of variable 'consonantsCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantsCount3 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:26:9:\
    \ warning: initialization of variable 'consonantsCount4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantsCount4 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:27:9: warning: initialization\
    \ of variable 'consonantsCount5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantsCount5 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpnor1p79n.swift:28:9: warning: initialization of variable 'consonantsCount6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantsCount6 = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpnor1p79n.swift:29:9:\
    \ warning: initialization of variable 'consonantsCount7' was never used; consider\
    \ replacing with assignment to '_' o"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelsCount = vowels.count\n    var vowelsIndex\
    \ = 0\n    var vowelsIndexEnd = vowelsIndex + vowelsCount\n    var vowelsIndexStart\
    \ = 0\n    var vowelsIndexStartEnd = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd2\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd3 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd4 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd5 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd6\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd7 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd8 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd9 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd10\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd11 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd12 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd13 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd14\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd15 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd16 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd17 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd18\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd19 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd20 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd21 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd22\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd23 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd24 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStartEnd25 = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd26\
    \ = vowelsIndexEnd - vowelsCount\n    var vowelsIndexStartEnd27 = vowelsIndexEnd\
    \ - vowelsCount\n    var vowelsIndexStartEnd28 = vowelsIndexEnd - vowelsCount\n\
    \    var vowelsIndexStart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfz48ulva.swift:50:9: error: type annotation missing in pattern\n\
    \    var vowelsIndexStart\n        ^\n"
  stdout: ''
  timestamp: 1660013629
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.filter { $0.isVowel }\n    else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    if vowelsCount ==\
    \ 0 {\n        return \"\"\n    }\n    \n    let vowelsCount = vowels.count\n\
    \    \n    if vowelsCount == 1 {\n        return vowels.first!.character\n   \
    \ }\n    \n    let vowelsCount = vowels.count\n    \n    if vowelsCount == 2 {\n\
    \        return vowels.last!.character\n    }\n    \n    let vowelsCount = vowels.count\n\
    \    \n    if vowelsCount == 3 {\n        return vowels.first!.character + vowels.last!.character\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    if vowelsCount ==\
    \ 4 {\n        return vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character\n    }\n    \n    let vowelsCount = vowels.count\n\
    \    \n    if vowelsCount == 5 {\n        return vowels.first!.character + vowels.last!.character\
    \ + vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character + vowels.first!.character + vowels.last!.character\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    if vowelsCount ==\
    \ 6 {\n        return vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character + vowels.first!.character + vowels.last!.character\
    \ + vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character + vowels.first!.character + vowels.last!.character\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    if vowelsCount ==\
    \ 7 {\n        return vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character + vowels.first!.character + vowels.last!.character\
    \ + vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character + vowels.first!.character + vowels.last!.character\
    \ + vowels.first!.character + vowels.last!.character + vowels.first!.character\
    \ + vowels.last!.character\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzetywvx3.swift:17:38: error: expected 'else' after 'guard' condition\n\
    \    guard let vowels = vowels.filter { $0.isVowel }\n                       \
    \              ^\n                                     else \n/tmp/tmpzetywvx3.swift:17:40:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ vowels = vowels.filter { $0.isVowel }\n                                    \
    \   ^\n/tmp/tmpzetywvx3.swift:18:5: error: expected expression\n    else {\n \
    \   ^\n/tmp/tmpzetywvx3.swift:96:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpzetywvx3.swift:16:48: note: to match this opening\
    \ '{'\nfunc get_closest_vowel(word: String) -> String {\n                    \
    \                           ^\n/tmp/tmpzetywvx3.swift:17:24: error: cannot find\
    \ 'vowels' in scope\n    guard let vowels = vowels.filter { $0.isVowel }\n   \
    \                    ^~~~~~\n/tmp/tmpzetywvx3.swift:72:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660030250
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    var vowelsCount = 1\n    var vowelIndex = 0\n    var\
    \ vowelsCountIndex = 0\n    var vowelsCountIndex2 = 1\n    var vowelsCountIndex3\
    \ = 1\n    var vowelsCountIndex4 = 1\n    var vowelsCountIndex5 = 1\n    var vowelsCountIndex6\
    \ = 1\n    var vowelsCountIndex7 = 1\n    var vowelsCountIndex8 = 1\n    var vowelsCountIndex9\
    \ = 1\n    var vowelsCountIndex10 = 1\n    var vowelsCountIndex11 = 1\n    var\
    \ vowelsCountIndex12 = 1\n    var vowelsCountIndex13 = 1\n    var vowelsCountIndex14\
    \ = 1\n    var vowelsCountIndex15 = 1\n    var vowelsCountIndex16 = 1\n    var\
    \ vowelsCountIndex17 = 1\n    var vowelsCountIndex18 = 1\n    var vowelsCountIndex19\
    \ = 1\n    var vowelsCountIndex20 = 1\n    var vowelsCountIndex21 = 1\n    var\
    \ vowelsCountIndex22 = 1\n    var vowelsCountIndex23 = 1\n    var vowelsCountIndex24\
    \ = 1\n    var vowelsCountIndex25 = 1\n    var vowelsCountIndex26 = 1\n    var\
    \ vowelsCountIndex27 = 1\n    var vowelsCountIndex28 = 1\n    var vowelsCountIndex29\
    \ = 1\n    var vowelsCountIndex30 = 1\n    var vowelsCountIndex31 = 1\n    var\
    \ vowelsCountIndex32 = 1\n    var vowelsCountIndex33 = 1\n    var vowelsCountIndex34\
    \ = 1\n    var vowelsCountIndex35 = 1\n    var vowelsCountIndex36 = 1\n    var\
    \ vowelsCountIndex37 = 1\n    var vowelsCountIndex38 = 1\n    var vowelsCountIndex39\
    \ = 1\n    var vowelsCountIndex40 = 1\n    var vowelsCountIndex41 = 1\n    var\
    \ vowelsCountIndex42 = 1\n    var vowelsCountIndex43 = 1\n    var vowelsCountIndex44\
    \ = 1\n    var vowelsCountIndex45 = 1\n    var vowelsCountIndex46 = 1\n    var\
    \ vowelsCountIndex47 = 1\n    var vowelsCountIndex48 = 1\n    var vowelsCountIndex49\
    \ = 1\n    var vowelsCountIndex50 = 1\n    var vowelsCountIndex51 = 1\n    var\
    \ vowelsCountIndex52 = 1\n    var vowelsCountIndex53 = 1\n    var vowelsCountIndex54\
    \ = 1\n    var vowelsCountIndex55 = 1\n    var vowelsCountIndex56 = 1\n    var\
    \ vowelsCountIndex57 = 1\n    var vowelsCountIndex58 = 1\n    var vowelsCountIndex59\
    \ = 1\n    var vowelsCountIndex60 = 1\n    var vowelsCountIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpq72u4ved.swift:80:9: error: type annotation missing in pattern\n\
    \    var vowelsCountIndex\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelIndex = 0\n    var consonantIndex = 0\n\
    \    var consonant: Character\n    var vowel: Character\n    var consonantCount\
    \ = 0\n    var vowelCount = 0\n    var consonantString = \"\"\n    var vowelString\
    \ = \"\"\n    \n    for consonant in word {\n        if consonant == \"a\" ||\
    \ consonant == \"e\" || consonant == \"i\" || consonant == \"o\" || consonant\
    \ == \"u\" {\n            vowels.append(consonant)\n            vowelIndex +=\
    \ 1\n            vowelCount += 1\n        }\n    }\n    \n    for vowel in vowels\
    \ {\n        if vowelIndex == 0 {\n            vowelIndex += 1\n            vowelCount\
    \ += 1\n        } else {\n            consonantIndex += 1\n            consonantCount\
    \ += 1\n        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n\
    \    }\n    \n    if consonantIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    if vowelIndex > consonantIndex {\n        vowelIndex -= 1\n    }\n    \n\
    \    if vowelIndex < consonantIndex {\n        consonantIndex += 1\n    }\n  \
    \  \n    if consonantIndex == vowelIndex {\n        if vowelIndex == 0 {\n   \
    \         return \"\"\n        }\n        \n        if consonantCount == vowelCount\
    \ {\n            return vowels[vowelIndex - 1]\n        }\n        \n        if\
    \ consonantCount > vowelCount {\n            return vowels[vowelIndex - 1]\n \
    \       }\n        \n        if consonantCount < vowelCount {\n            return\
    \ vowels[vowelIndex]\n        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpn0ldp5tu.swift:29:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(consonant)\n \
    \                         ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word.characters {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelFound = false\n    for letter in word.characters\
    \ {\n        if letter.isUppercase {\n            if vowelIndex == vowels.count\
    \ {\n                vowelFound = true\n                break\n            }\n\
    \            if letter == vowels[vowelIndex] {\n                vowelIndex +=\
    \ 1\n            } else {\n                vowelFound = false\n              \
    \  break\n            }\n        }\n    }\n    if vowelFound {\n        return\
    \ vowels[vowelIndex - 1]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyrf6opan.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in word.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpyrf6opan.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmpyrf6opan.swift:26:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in word.characters {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpyrf6opan.swift:32:23: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \      if letter == vowels[vowelIndex] {\n               ~~~~~~ ^  ~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyrf6opan.swift:32:23: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \     if letter == vowels[vowelIndex] {\n                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelIndex = 0\n    var vowelIndexEnd = word.characters.count\
    \ - 1\n    var vowelIndexStart = 0\n    var vowelIndexEnd2 = word.characters.count\
    \ - 1\n    var vowelIndexStart2 = word.characters.count - 1\n    var vowelIndexEnd3\
    \ = word.characters.count - 1\n    var vowelIndexStart3 = word.characters.count\
    \ - 1\n    var vowelIndexEnd4 = word.characters.count - 1\n    var vowelIndexStart4\
    \ = word.characters.count - 1\n    var vowelIndexEnd5 = word.characters.count\
    \ - 1\n    var vowelIndexStart5 = word.characters.count - 1\n    var vowelIndexEnd6\
    \ = word.characters.count - 1\n    var vowelIndexStart6 = word.characters.count\
    \ - 1\n    var vowelIndexEnd7 = word.characters.count - 1\n    var vowelIndexStart7\
    \ = word.characters.count - 1\n    var vowelIndexEnd8 = word.characters.count\
    \ - 1\n    var vowelIndexStart8 = word.characters.count - 1\n    var vowelIndexEnd9\
    \ = word.characters.count - 1\n    var vowelIndexStart9 = word.characters.count\
    \ - 1\n    var vowelIndexEnd10 = word.characters.count - 1\n    var vowelIndexStart10\
    \ = word.characters.count - 1\n    var vowelIndexEnd11 = word.characters.count\
    \ - 1\n    var vowelIndexStart11 = word.characters.count - 1\n    var vowelIndexEnd12\
    \ = word.characters.count - 1\n    var vowelIndexStart12 = word.characters.count\
    \ - 1\n    var vowelIndexEnd13 = word.characters.count - 1\n    var vowelIndexStart13\
    \ = word.characters.count - 1\n    var vowelIndexEnd14 = word.characters.count\
    \ - 1\n    var vowelIndexStart14 = word.characters.count - 1\n    var vowelIndexEnd15\
    \ = word.characters.count - 1\n    var vowelIndexStart15 = word.characters.count\
    \ - 1\n    var vowelIndexEnd16 = word.characters.count - 1\n    var vowelIndexStart16\
    \ = word.characters.count - 1\n    var vowelIndexEnd17 = word.characters.count\
    \ - 1\n    var vowelIndexStart17 = word.characters.count - 1\n    var vowelIndexEnd18\
    \ = word.characters.count - 1\n    var vowelIndexStart18 = word.characters.count\
    \ - 1\n    var vowelIndexEnd19 = word.characters.count - 1\n    var vowelIndexStart19\
    \ = word.characters.count - 1\n    var vowelIndexEnd20 = word.characters.count\
    \ - 1\n    var vowelIndexStart20 = word.characters.count - 1\n    var vowelIndexEnd21\
    \ = word.characters.count - 1\n    var vowelIndexStart21 = word.characters.count\
    \ - 1\n    var vowelIndexEnd22 = word.characters.count - 1\n    var vowelIndexStart22\
    \ = word.characters.count - 1\n    var vowelIndexEnd23 = word.characters.count\
    \ - 1\n    var vowelIndexStart23 = word.characters.count - 1\n    var vowelIndexEnd24\
    \ = word.characters.count - 1\n    var vowelIndexStart24 = word.characters.count\
    \ - 1\n    var vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2l66a6gr.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowelIndexEnd = word.characters.count - 1\n   \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2l66a6gr.swift:21:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexEnd2 = word.characters.count -\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l66a6gr.swift:22:33: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexStart2 = word.characters.count\
    \ - 1\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l66a6gr.swift:23:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexEnd3 = word.characters.count -\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l66a6gr.swift:24:33: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexStart3 = word.characters.count\
    \ - 1\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l66a6gr.swift:25:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexEnd4 = word.characters.count -\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l66a6gr.swift:26:33: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexStart4 = word.characters.count\
    \ - 1\n                  "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    var vowelIndex = 0\n    var vowelCount = 0\n    \n    for char in\
    \ word.characters {\n        if vowels.contains(String(char)) {\n            vowelCount\
    \ += 1\n        }\n    }\n    \n    if vowelCount > 1 {\n        vowelIndex =\
    \ (word.characters.count - vowelCount) / 2\n    }\n    \n    if vowelIndex < 0\
    \ {\n        vowelIndex = 0\n    }\n    \n    if vowelIndex >= word.characters.count\
    \ {\n        vowelIndex = word.characters.count - 1\n    }\n    \n    return String(word.characters[vowelIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvp2_s7ym.swift:26:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpvp2_s7ym.swift:33:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        vowelIndex\
    \ = (word.characters.count - vowelCount) / 2\n                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvp2_s7ym.swift:40:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    if vowelIndex\
    \ >= word.characters.count {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvp2_s7ym.swift:41:27: error: 'characters'\
    \ is unavailable: Please use String directly\n        vowelIndex = word.characters.count\
    \ - 1\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvp2_s7ym.swift:44:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    return\
    \ String(word.characters[vowelIndex])\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvp2_s7ym.swift:44:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    return String(word.characters[vowelIndex])\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsIndex: [Int] = []\n    var vowelsIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndex: [Int] = [0]\n    var vowelsIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndex: [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndex: [Int] = [0]\n\
    \    var vowelsIndexCountIndexCountIndexCountIndexCount: [Int] = [0]\n    var\
    \ vowelsIndexCountIndexCountIndexCountIndexCountIndex: [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = [0]\n    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbo4jrtzu.swift:41:174: error: expected initial value after '='\n\
    \    var vowelsIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ [Int] = \n                                                                 \
    \                                                                            \
    \                                ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelsCount = 0\n    var vowelIndex = 0\n   \
    \ for char in word.characters {\n        if char.unicodeScalars.count > 0 {\n\
    \            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\")) {\n\
    \                vowels.append(char.unicodeScalars.first!)\n                vowelsCount\
    \ += 1\n            }\n        }\n    }\n    if vowelsCount > 0 {\n        if\
    \ vowelIndex == vowels.count {\n            return \"\"\n        }\n        if\
    \ vowelIndex == 0 {\n            return vowels[vowelIndex - 1]\n        }\n  \
    \      if vowelIndex == vowels.count - 1 {\n            return vowels[vowelIndex\
    \ + 1]\n        }\n        if vowelIndex == vowels.count - 2 {\n            return\
    \ vowels[vowelIndex - 1] + vowels[vowelIndex + 1]\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5q3qlxpo.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5q3qlxpo.swift:22:45:\
    \ error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\
    \ must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\")) {\n\
    \                                            ^\n/tmp/tmp5q3qlxpo.swift:22:45:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\"\
    )) {\n                                            ^\n                        \
    \                                                ?? <#default value#>\n/tmp/tmp5q3qlxpo.swift:22:45:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\"\
    )) {\n                                            ^\n                        \
    \                                               !\n/tmp/tmp5q3qlxpo.swift:23:24:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \  vowels.append(char.unicodeScalars.first!)\n                       ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmp5q3qlxpo.swift:23:24: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n                vowels.append(char.unicodeScalars.first!)\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    let vowelsArrayCount = vowelsArray.count\n\
    \    let vowelsArraySlice = vowelsArray[vowelsArrayCount - vowelsCount - 1 : vowelsArrayCount]\n\
    \    let vowelsArraySliceCount = vowelsArraySlice.count\n    let vowelsArraySliceSlice\
    \ = vowelsArraySlice[vowelsArraySliceCount - vowelsCount - 1 : vowelsArraySliceCount]\n\
    \    let vowelsArraySliceSliceCount = vowelsArraySliceSlice.count\n    let vowelsArraySliceSliceSlice\
    \ = vowelsArraySliceSlice[vowelsArraySliceSliceCount - vowelsCount - 1 : vowelsArraySliceSliceCount]\n\
    \    let vowelsArraySliceSliceSliceCount = vowelsArraySliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceCount = vowelsArraySliceSliceSlice[vowelsArraySliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceCount]\n    let vowelsArraySliceSliceSliceSliceCount\
    \ = vowelsArraySliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceCount - vowelsCount\
    \ - 1 : vowelsArraySliceSliceSliceSliceCount]\n    let vowelsArraySliceSliceSliceSliceSliceCount\
    \ = vowelsArraySliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceSliceSliceCount]\n    let vowelsArraySliceSliceSliceSliceSliceSliceCount\
    \ = vowelsArraySliceSliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceSliceSliceSliceCount]\n    let\
    \ vowelsArraySliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceSliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceSliceSliceSliceSliceCount]\n \
    \   let vowelsArraySliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceCount]\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceSliceCount]\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5szafjke.swift:21:75: error: expected ',' separator\n    let vowelsArraySlice\
    \ = vowelsArray[vowelsArrayCount - vowelsCount - 1 : vowelsArrayCount]\n     \
    \                                                                     ^\n    \
    \                                                                     ,\n/tmp/tmp5szafjke.swift:21:75:\
    \ error: expected expression in list of expressions\n    let vowelsArraySlice\
    \ = vowelsArray[vowelsArrayCount - vowelsCount - 1 : vowelsArrayCount]\n     \
    \                                                                     ^\n/tmp/tmp5szafjke.swift:23:90:\
    \ error: expected ',' separator\n    let vowelsArraySliceSlice = vowelsArraySlice[vowelsArraySliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceCount]\n                               \
    \                                                          ^\n               \
    \                                                                         ,\n\
    /tmp/tmp5szafjke.swift:23:90: error: expected expression in list of expressions\n\
    \    let vowelsArraySliceSlice = vowelsArraySlice[vowelsArraySliceCount - vowelsCount\
    \ - 1 : vowelsArraySliceCount]\n                                             \
    \                                            ^\n/tmp/tmp5szafjke.swift:25:105:\
    \ error: expected ',' separator\n    let vowelsArraySliceSliceSlice = vowelsArraySliceSlice[vowelsArraySliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceCount]\n                          \
    \                                                                            \
    \  ^\n                                                                       \
    \                                ,\n/tmp/tmp5szafjke.swift:25:105: error: expected\
    \ expression in list of expressions\n    let vowelsArraySliceSliceSlice = vowelsArraySliceSlice[vowelsArraySliceSliceCount\
    \ - vowelsCount - 1 : vowelsArraySliceSliceCount]\n                          \
    \                                                                            \
    \  ^\n/tmp/tmp5szafjke.swift:27:120: error: expected ',' separator\n    let vowelsArraySliceSliceSliceCount\
    \ = vowelsArraySliceSliceSl"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    var vowelIndex = 0\n    var vowelIndex2 = 0\n    var vowelIndex3 = 0\n  \
    \  var vowelIndex4 = 0\n    var vowelIndex5 = 0\n    var vowelIndex6 = 0\n   \
    \ var vowelIndex7 = 0\n    var vowelIndex8 = 0\n    var vowelIndex9 = 0\n    var\
    \ vowelIndex10 = 0\n    var vowelIndex11 = 0\n    var vowelIndex12 = 0\n    var\
    \ vowelIndex13 = 0\n    var vowelIndex14 = 0\n    var vowelIndex15 = 0\n    var\
    \ vowelIndex16 = 0\n    var vowelIndex17 = 0\n    var vowelIndex18 = 0\n    var\
    \ vowelIndex19 = 0\n    var vowelIndex20 = 0\n    var vowelIndex21 = 0\n    var\
    \ vowelIndex22 = 0\n    var vowelIndex23 = 0\n    var vowelIndex24 = 0\n    var\
    \ vowelIndex25 = 0\n    var vowelIndex26 = 0\n    var vowelIndex27 = 0\n    var\
    \ vowelIndex28 = 0\n    var vowelIndex29 = 0\n    var vowelIndex30 = 0\n    var\
    \ vowelIndex31 = 0\n    var vowelIndex32 = 0\n    var vowelIndex33 = 0\n    var\
    \ vowelIndex34 = 0\n    var vowelIndex35 = 0\n    var vowelIndex36 = 0\n    var\
    \ vowelIndex37 = 0\n    var vowelIndex38 = 0\n    var vowelIndex39 = 0\n    var\
    \ vowelIndex40 = 0\n    var vowelIndex41 = 0\n    var vowelIndex42 = 0\n    var\
    \ vowelIndex43 = 0\n    var vowelIndex44 = 0\n    var vowelIndex45 = 0\n    var\
    \ vowelIndex46 = 0\n    var vowelIndex47 = 0\n    var vowelIndex48 = 0\n    var\
    \ vowelIndex49 = 0\n    var vowelIndex50 = 0\n    var vowelIndex51 = 0\n    var\
    \ vowelIndex52 = 0\n    var vowelIndex53 = 0\n    var vowelIndex54 = 0\n    var\
    \ vowelIndex55 = 0\n    var vowelIndex56 = 0\n    var vowelIndex57 = 0\n    var\
    \ vowelIndex58 = 0\n    var vowelIndex59 = 0\n    var vowelIndex60 = 0\n    var\
    \ vowelIndex61 = 0\n    var vowelIndex62 = 0\n    var vowelIndex63 = 0\n    var\
    \ vowelIndex64 = 0\n    var vowelIndex65 = 0\n    var vowelIndex66 = 0\n    var\
    \ vowelIndex67 = 0\n    var vowelIndex68 = 0\n    var vowelIndex69 = 0\n    var\
    \ vowelIndex70 = 0\n    var vowelIndex71 = 0\n    var vowelIndex72 = 0\n    var\
    \ vowelIndex73 = 0\n    var vowelIndex74 = 0\n    var vowelIndex75 = 0\n    var\
    \ vowelIndex76 = 0\n    var vowelIndex77 = 0\n    var vowelIndex78 = 0\n    var\
    \ vowelIndex79 = 0\n    var vowelIndex80\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdcsm2mcw.swift:20:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(letter)\n    \
    \                      ^\n/tmp/tmpdcsm2mcw.swift:103:9: error: type annotation\
    \ missing in pattern\n    var vowelIndex80\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  let vowelsSet = Set(\"aeiouAEIOU\")\n    for char in word.characters {\n  \
    \      if vowelsSet.contains(char) {\n            vowels.append(char)\n      \
    \  }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n    let vowelsCount\
    \ = vowels.count\n    let vowelsSetCount = vowelsSet.count\n    if vowelsCount\
    \ > vowelsSetCount {\n        return \"\"\n    }\n    let vowelsSet = Set(\"aeiouAEIOU\"\
    )\n    let vowelsCount = vowels.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    \    let vowelsSetCount = vowelsSet.count\n    let vowelsSetCount = vowelsSet.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2k6tp7dx.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp2k6tp7dx.swift:24:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(char)\n                          ^\n/tmp/tmp2k6tp7dx.swift:35:9:\
    \ error: invalid redeclaration of 'vowelsSet'\n    let vowelsSet = Set(\"aeiouAEIOU\"\
    )\n        ^\n/tmp/tmp2k6tp7dx.swift:21:9: note: 'vowelsSet' previously declared\
    \ here\n    let vowelsSet = Set(\"aeiouAEIOU\")\n        ^\n/tmp/tmp2k6tp7dx.swift:36:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp2k6tp7dx.swift:30:9: note: 'vowelsCount' previously declared\
    \ here\n    let vowelsCount = vowels.count\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \
    \  \n    var vowelIndex: Int = 0\n    var vowelIndex2: Int = 0\n    var vowelIndex3:\
    \ Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5: Int = 0\n    var\
    \ vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var vowelIndex8: Int\
    \ = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int = 0\n    var vowelIndex11:\
    \ Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13: Int = 0\n    var\
    \ vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var vowelIndex16:\
    \ Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18: Int = 0\n    var\
    \ vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var vowelIndex21:\
    \ Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23: Int = 0\n    var\
    \ vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var vowelIndex26:\
    \ Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28: Int = 0\n    var\
    \ vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var vowelIndex31:\
    \ Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33: Int = 0\n    var\
    \ vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var vowelIndex36:\
    \ Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38: Int = 0\n    var\
    \ vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var vowelIndex41:\
    \ Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43: Int = 0\n    var\
    \ vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var vowelIndex46:\
    \ Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48: Int = 0\n    var\
    \ vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var vowelIndex51:\
    \ Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53: Int = 0\n    var\
    \ vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var vowelIndex56:\
    \ Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58: Int = 0\n    var\
    \ vowelIndex59: Int = 0\n    var vowelIndex60: Int = 0\n    var vowelIndex61:\
    \ Int = 0\n    var vowelIndex62: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp4qh7f0z.swift:17:9: warning: variable 'vowels' was written to,\
    \ but never read\n    var vowels: [String] = []\n        ^\n/tmp/tmpp4qh7f0z.swift:20:9:\
    \ warning: variable 'vowelIndex' was never used; consider replacing with '_' or\
    \ removing it\n    var vowelIndex: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpp4qh7f0z.swift:21:9:\
    \ warning: variable 'vowelIndex2' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelIndex2: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpp4qh7f0z.swift:22:9: warning: variable 'vowelIndex3' was never used; consider\
    \ replacing with '_' or removing it\n    var vowelIndex3: Int = 0\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmpp4qh7f0z.swift:23:9: warning: variable 'vowelIndex4' was never\
    \ used; consider replacing with '_' or removing it\n    var vowelIndex4: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpp4qh7f0z.swift:24:9: warning: variable\
    \ 'vowelIndex5' was never used; consider replacing with '_' or removing it\n \
    \   var vowelIndex5: Int = 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpp4qh7f0z.swift:25:9:\
    \ warning: variable 'vowelIndex6' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelIndex6: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpp4qh7f0z.swift:26:9: warning: variable 'vowelIndex7' was never used; consider\
    \ replacing with '_' or removing it\n    var vowelIndex7: Int = 0\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmpp4qh7f0z.swift:27:9: warning: variable 'vowelIndex8' was never\
    \ used; consider replacing with '_' or removing it\n    var vowelIndex8: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpp4qh7f0z.swift:28:9: warning: variable\
    \ 'vowelIndex9' was never used; consider replacing with '_' or removing it\n \
    \   var vowelIndex9: Int = 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpp4qh7f0z.swift:29:9:\
    \ warning: variable 'vowelIndex10' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelIndex10: Int = 0\n        ^~~~~~~~~~~~\n      \
    \  _\n/tmp/tmpp4qh7f0z.swift:30:9: warning: variable 'vowelIndex11' was never\
    \ used; consider replacing with '_' or removing it\n    var vo"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = \"aeiouAEIOU\"\n\
    \    var vowelsCount = vowels.count\n    var vowelsIndex = 0\n    var vowelsIndex2\
    \ = vowelsIndex\n    var vowelsIndex3 = vowelsIndex\n    var vowelsIndex4 = vowelsIndex\n\
    \    var vowelsIndex5 = vowelsIndex\n    var vowelsIndex6 = vowelsIndex\n    var\
    \ vowelsIndex7 = vowelsIndex\n    var vowelsIndex8 = vowelsIndex\n    var vowelsIndex9\
    \ = vowelsIndex\n    var vowelsIndex10 = vowelsIndex\n    var vowelsIndex11 =\
    \ vowelsIndex\n    var vowelsIndex12 = vowelsIndex\n    var vowelsIndex13 = vowelsIndex\n\
    \    var vowelsIndex14 = vowelsIndex\n    var vowelsIndex15 = vowelsIndex\n  \
    \  var vowelsIndex16 = vowelsIndex\n    var vowelsIndex17 = vowelsIndex\n    var\
    \ vowelsIndex18 = vowelsIndex\n    var vowelsIndex19 = vowelsIndex\n    var vowelsIndex20\
    \ = vowelsIndex\n    var vowelsIndex21 = vowelsIndex\n    var vowelsIndex22 =\
    \ vowelsIndex\n    var vowelsIndex23 = vowelsIndex\n    var vowelsIndex24 = vowelsIndex\n\
    \    var vowelsIndex25 = vowelsIndex\n    var vowelsIndex26 = vowelsIndex\n  \
    \  var vowelsIndex27 = vowelsIndex\n    var vowelsIndex28 = vowelsIndex\n    var\
    \ vowelsIndex29 = vowelsIndex\n    var vowelsIndex30 = vowelsIndex\n    var vowelsIndex31\
    \ = vowelsIndex\n    var vowelsIndex32 = vowelsIndex\n    var vowelsIndex33 =\
    \ vowelsIndex\n    var vowelsIndex34 = vowelsIndex\n    var vowelsIndex35 = vowelsIndex\n\
    \    var vowelsIndex36 = vowelsIndex\n    var vowelsIndex37 = vowelsIndex\n  \
    \  var vowelsIndex38 = vowelsIndex\n    var vowelsIndex39 = vowelsIndex\n    var\
    \ vowelsIndex40 = vowelsIndex\n    var vowelsIndex41 = vowelsIndex\n    var vowelsIndex42\
    \ = vowelsIndex\n    var vowelsIndex43 = vowelsIndex\n    var vowelsIndex44 =\
    \ vowelsIndex\n    var vowelsIndex45 = vowelsIndex\n    var vowelsIndex46 = vowelsIndex\n\
    \    var vowelsIndex47 = vowelsIndex\n    var vowelsIndex48 = vowelsIndex\n  \
    \  var vowelsIndex49 = vowelsIndex\n    var vowelsIndex50 = vowels\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpc1a2x1_s.swift:20:9: warning: variable 'vowels' was never mutated;\
    \ consider changing to 'let' constant\n    var vowels = \"aeiouAEIOU\"\n    ~~~\
    \ ^\n    let\n/tmp/tmpc1a2x1_s.swift:21:9: warning: initialization of variable\
    \ 'vowelsCount' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpc1a2x1_s.swift:22:9:\
    \ warning: variable 'vowelsIndex' was never mutated; consider changing to 'let'\
    \ constant\n    var vowelsIndex = 0\n    ~~~ ^\n    let\n/tmp/tmpc1a2x1_s.swift:23:9:\
    \ warning: initialization of variable 'vowelsIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsIndex2 = vowelsIndex\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpc1a2x1_s.swift:24:9: warning: initialization\
    \ of variable 'vowelsIndex3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelsIndex3 = vowelsIndex\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpc1a2x1_s.swift:25:9: warning: initialization of variable 'vowelsIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsIndex4 = vowelsIndex\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpc1a2x1_s.swift:26:9:\
    \ warning: initialization of variable 'vowelsIndex5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsIndex5 = vowelsIndex\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpc1a2x1_s.swift:27:9: warning: initialization\
    \ of variable 'vowelsIndex6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelsIndex6 = vowelsIndex\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpc1a2x1_s.swift:28:9: warning: initialization of variable 'vowelsIndex7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsIndex7 = vowelsIndex\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpc1a2x1_s.swift:29:9:\
    \ warning: initialization of variable 'vowelsIndex8' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsIndex8 = vowelsIndex\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpc1a2x"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount: [Int] = [0, 1, 2, 3, 4]\n\
    \    var vowelsIndex: [Int] = []\n    var vowelsIndexCount: [Int] = []\n    var\
    \ vowelsIndexCountMax: Int = -1\n    var vowelsIndexCountMin: Int = -1\n    var\
    \ vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex: Int =\
    \ -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowelsIndexCountMaxIndex: Int = -1\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpymhwjgky.swift:28:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndex'\n\
    \    var vowelsIndexCountMaxIndex: Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndex' previously declared here\n    var vowelsIndexCountMaxIndex:\
    \ Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:29:9: error: invalid redeclaration\
    \ of 'vowelsIndexCountMinIndex'\n    var vowelsIndexCountMinIndex: Int = -1\n\
    \        ^\n/tmp/tmpymhwjgky.swift:27:9: note: 'vowelsIndexCountMinIndex' previously\
    \ declared here\n    var vowelsIndexCountMinIndex: Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:30:9:\
    \ error: invalid redeclaration of 'vowelsIndexCountMaxIndex'\n    var vowelsIndexCountMaxIndex:\
    \ Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:26:9: note: 'vowelsIndexCountMaxIndex'\
    \ previously declared here\n    var vowelsIndexCountMaxIndex: Int = -1\n     \
    \   ^\n/tmp/tmpymhwjgky.swift:31:9: error: invalid redeclaration of 'vowelsIndexCountMinIndex'\n\
    \    var vowelsIndexCountMinIndex: Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:27:9:\
    \ note: 'vowelsIndexCountMinIndex' previously declared here\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:32:9: error: invalid redeclaration\
    \ of 'vowelsIndexCountMaxIndex'\n    var vowelsIndexCountMaxIndex: Int = -1\n\
    \        ^\n/tmp/tmpymhwjgky.swift:26:9: note: 'vowelsIndexCountMaxIndex' previously\
    \ declared here\n    var vowelsIndexCountMaxIndex: Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:33:9:\
    \ error: invalid redeclaration of 'vowelsIndexCountMinIndex'\n    var vowelsIndexCountMinIndex:\
    \ Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:27:9: note: 'vowelsIndexCountMinIndex'\
    \ previously declared here\n    var vowelsIndexCountMinIndex: Int = -1\n     \
    \   ^\n/tmp/tmpymhwjgky.swift:34:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndex'\n\
    \    var vowelsIndexCountMaxIndex: Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndex' previously declared here\n    var vowelsIndexCountMaxIndex:\
    \ Int = -1\n        ^\n/tmp/tmpymhwjgky.swift:35:9: error: invalid redeclaration\
    \ of 'vowelsIndexCountMin"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    for char in word.characters {\n        if char.unicodeScalars.filter({\
    \ $0.isUppercase }).count > 0 {\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).last!)\n        }\n    }\n    if vowels.count > 0 {\n    \
    \    return vowels.sorted().first!\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpirh2495e.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpirh2495e.swift:19:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUppercase'\n        if\
    \ char.unicodeScalars.filter({ $0.isUppercase }).count > 0 {\n               \
    \                         ~~ ^~~~~~~~~~~\n/tmp/tmpirh2495e.swift:20:20: error:\
    \ no exact matches in call to instance method 'append'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).last!)\n                   ^\n/tmp/tmpirh2495e.swift:20:20:\
    \ note: found candidate with type '(__owned String) -> ()'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).last!)\n                   ^\n/tmp/tmpirh2495e.swift:20:20:\
    \ note: found candidate with type '(__owned Unicode.Scalar) -> ()'\n         \
    \   vowels.append(char.unicodeScalars.filter({ $0.isUppercase }).last!)\n    \
    \               ^\n/tmp/tmpirh2495e.swift:20:59: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).last!)\n                                                 \
    \      ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [Character] = []\n\
    \    for letter in word.unicodeScalars {\n        if letter.isUppercase {\n  \
    \          vowels.append(letter)\n        }\n    }\n    if vowels.count < 2 {\n\
    \        return \"\"\n    }\n    var vowelIndex = 0\n    var vowelCount = 0\n\
    \    for letter in word.unicodeScalars {\n        if letter.isUppercase {\n  \
    \          vowelIndex += 1\n        }\n        if letter.isLowercase {\n     \
    \       vowelCount += 1\n        }\n        if vowelIndex == vowels.count {\n\
    \            break\n        }\n    }\n    if vowelIndex == 0 {\n        return\
    \ \"\"\n    }\n    if vowelIndex == vowels.count {\n        return \"\"\n    }\n\
    \    if vowelIndex == 1 {\n        return vowels[vowelIndex - 1]\n    }\n    if\
    \ vowelIndex == 2 {\n        return vowels[vowelIndex - 2]\n    }\n    if vowelIndex\
    \ == 3 {\n        return vowels[vowelIndex - 3]\n    }\n    if vowelIndex == 4\
    \ {\n        return vowels[vowelIndex - 4]\n    }\n    if vowelIndex == 5 {\n\
    \        return vowels[vowelIndex - 5]\n    }\n    if vowelIndex == 6 {\n    \
    \    return vowels[vowelIndex - 6]\n    }\n    if vowelIndex == 7 {\n        return\
    \ vowels[vowelIndex - 7]\n    }\n    if vowelIndex == 8 {\n        return vowels[vowelIndex\
    \ - 8]\n    }\n    if vowelIndex == 9 {\n        return vowels[vowelIndex - 9]\n\
    \    }\n    if vowelIndex == 10 {\n        return vowels[vowelIndex - 10]\n  \
    \  }\n    if vowelIndex == 11 {\n        return vowels[vowelIndex - 11]\n    }\n\
    \    if vowelIndex == 12 {\n        return vowels[vowelIndex - 12]\n    }\n  \
    \  if vowelIndex == 13 {\n        return vowels[vowelIndex - 13]\n    }\n    if\
    \ vowelIndex == 14 {\n        return vowels[vowelIndex - 14]\n    }\n    if vowelIndex\
    \ == 15 {\n        return vowels[vowelIndex - 15]\n    }\n    if vowelIndex ==\
    \ 16 {\n        return vowels[vowelIndex - 16]\n    }\n    if vowelIndex == 17\
    \ {\n        return vowels[vowelIndex - 17]\n    }\n    if vowelIndex == 18 {\n\
    \        return vowels[vowelIndex - 18]\n    }\n    if vowelIndex == 19 {\n  \
    \      return vowels[vowelIndex - 19]\n    }\n    if vowelIndex == 20 {\n    \
    \    return vowels[vowelIndex - 20]\n    }\n    if vowelIndex == 21 {\n      \
    \  return vowels[vowelIndex - 21]\n    }\n    if vowelIndex == 22 {\n        return\
    \ vowels[vowelIndex - 22]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwuqqyito.swift:22:19: error: value of type 'Unicode.Scalar' has\
    \ no member 'isUppercase'\n        if letter.isUppercase {\n           ~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:23:20: error: no exact matches in call to\
    \ instance method 'append'\n            vowels.append(letter)\n              \
    \     ^\nSwift.Array:6:37: note: candidate expects value of type 'Character' for\
    \ parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating func append(_\
    \ newElement: __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmpwuqqyito.swift:23:20: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(letter)\n\
    \                   ^\n/tmp/tmpwuqqyito.swift:32:19: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n        if letter.isUppercase {\n           ~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:35:19: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLowercase'\n        if letter.isLowercase {\n           ~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:49:22: error: cannot convert return expression\
    \ of type 'Character' to return type 'String'\n        return vowels[vowelIndex\
    \ - 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:52:22: error:\
    \ cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return vowels[vowelIndex - 2]\n               ~~~~~~^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwuqqyito.swift:55:22: error: cannot convert return expression of type\
    \ 'Character' to return type 'String'\n        return vowels[vowelIndex - 3]\n\
    \               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:58:22: error: cannot\
    \ convert return expression of type 'Character' to return type 'String'\n    \
    \    return vowels[vowelIndex - 4]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpwuqqyito.swift:61:22:\
    \ error: cannot convert r"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelsCount = vowels.characters.count\n   \
    \ var vowelIndex = vowels.characters.index(of: word[vowels.characters.count])\n\
    \    if vowelIndex == vowels.characters.count {\n        return \"\"\n    }\n\
    \    if vowelIndex == 0 {\n        return vowels[vowelIndex - 1]\n    }\n    if\
    \ vowelIndex == vowelsCount - 1 {\n        return vowels[vowelIndex + 1]\n   \
    \ }\n    if vowelIndex == vowelsCount - 2 {\n        return vowels[vowelIndex\
    \ - 2]\n    }\n    if vowelIndex == vowelsCount - 3 {\n        return vowels[vowelIndex\
    \ - 3]\n    }\n    if vowelIndex == vowelsCount - 4 {\n        return vowels[vowelIndex\
    \ - 4]\n    }\n    if vowelIndex == vowelsCount - 5 {\n        return vowels[vowelIndex\
    \ - 5]\n    }\n    if vowelIndex == vowelsCount - 6 {\n        return vowels[vowelIndex\
    \ - 6]\n    }\n    if vowelIndex == vowelsCount - 7 {\n        return vowels[vowelIndex\
    \ - 7]\n    }\n    if vowelIndex == vowelsCount - 8 {\n        return vowels[vowelIndex\
    \ - 8]\n    }\n    if vowelIndex == vowelsCount - 9 {\n        return vowels[vowelIndex\
    \ - 9]\n    }\n    if vowelIndex == vowelsCount - 10 {\n        return vowels[vowelIndex\
    \ - 10]\n    }\n    if vowelIndex == vowelsCount - 11 {\n        return vowels[vowelIndex\
    \ - 11]\n    }\n    if vowelIndex == vowelsCount - 12 {\n        return vowels[vowelIndex\
    \ - 12]\n    }\n    if vowelIndex == vowelsCount - 13 {\n        return vowels[vowelIndex\
    \ - 13]\n    }\n    if vowelIndex == vowelsCount - 14 {\n        return vowels[vowelIndex\
    \ - 14]\n    }\n    if vowelIndex == vowelsCount - 15 {\n        return vowels[vowelIndex\
    \ - 15]\n    }\n    if vowelIndex == vowelsCount - 16 {\n        return vowels[vowelIndex\
    \ - 16]\n    }\n    if vowelIndex == vowelsCount - 17 {\n        return vowels[vowelIndex\
    \ - 17]\n    }\n    if vowelIndex == vowelsCount - 18 {\n        return vowels[vowelIndex\
    \ - 18]\n    }\n    if vowelIndex == vowelsCount - 19 {\n        return vowels[vowelIndex\
    \ - 19]\n    }\n    if vowelIndex == vowelsCount - 20 {\n        return vowels[vowelIndex\
    \ - 20]\n    }\n    if vowelIndex == vowelsCount - 21 {\n        return vowels[vowelIndex\
    \ - 21]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvsh911rd.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvsh911rd.swift:19:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowelIndex = vowels.characters.index(of: word[vowels.characters.count])\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvsh911rd.swift:19:40: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    var vowelIndex = vowels.characters.index(of:\
    \ word[vowels.characters.count])\n                                       ^\n/tmp/tmpvsh911rd.swift:19:40:\
    \ note: use 'firstIndex(of:)' instead\n    var vowelIndex = vowels.characters.index(of:\
    \ word[vowels.characters.count])\n                                       ^~~~~\n\
    \                                       firstIndex\n/tmp/tmpvsh911rd.swift:19:50:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    var vowelIndex = vowels.characters.index(of:\
    \ word[vowels.characters.count])\n                                           \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvsh911rd.swift:19:62: error: 'characters'\
    \ is unavailable: Please use String directly\n    var vowelIndex = vowels.characters.index(of:\
    \ word[vowels.characters.count])\n                                           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvsh911rd.swift:20:19: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Index?' and 'Int'\n    if "
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ > 0 {\n            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\"\
    )) {\n                vowels.append(char.unicodeScalars.first!)\n            }\n\
    \        }\n    }\n    \n    if vowels.count > 0 {\n        return vowels.last!\n\
    \    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr6zujzv9.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpr6zujzv9.swift:25:45:\
    \ error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\
    \ must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\")) {\n\
    \                                            ^\n/tmp/tmpr6zujzv9.swift:25:45:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\"\
    )) {\n                                            ^\n                        \
    \                                                ?? <#default value#>\n/tmp/tmpr6zujzv9.swift:25:45:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if char.unicodeScalars.contains(UnicodeScalar(\"AEIOUaeiou\"\
    )) {\n                                            ^\n                        \
    \                                               !\n/tmp/tmpr6zujzv9.swift:26:24:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \  vowels.append(char.unicodeScalars.first!)\n                       ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmpr6zujzv9.swift:26:24: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n                vowels.append(char.unicodeScalars.first!)\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowelIndex = 0\n    var\
    \ vowel = \"\"\n    var consonantIndex = 0\n    var consonant = \"\"\n    for\
    \ index in 0..<word.count {\n        if word[index].isUppercase {\n          \
    \  vowelIndex = index\n            break\n        }\n    }\n    for index in 0..<word.count\
    \ {\n        if word[index].isLowercase {\n            consonantIndex = index\n\
    \            break\n        }\n    }\n    if vowelIndex < consonantIndex {\n \
    \       vowel = word[vowelIndex]\n    } else {\n        vowel = word[consonantIndex]\n\
    \    }\n    for index in (vowelIndex + 1)..<word.count {\n        if word[index].isLowercase\
    \ {\n            consonantIndex = index\n            break\n        }\n    }\n\
    \    if consonantIndex < vowelIndex {\n        consonant = word[consonantIndex]\n\
    \    } else {\n        consonant = word[vowelIndex]\n    }\n    if vowel.lowercased()\
    \ == consonant.lowercased() {\n        return vowel\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2einyctt.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if word[index].isUppercase\
    \ {\n           ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp2einyctt.swift:31:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if word[index].isLowercase {\n           ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2einyctt.swift:37:21:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        vowel\
    \ = word[vowelIndex]\n                ~~~~^~~~~~~~~~~~\n/tmp/tmp2einyctt.swift:39:21:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        vowel\
    \ = word[consonantIndex]\n                ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp2einyctt.swift:42:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if word[index].isLowercase {\n        \
    \   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp2einyctt.swift:48:25: error: cannot assign value of type\
    \ 'Character' to type 'String'\n        consonant = word[consonantIndex]\n   \
    \                 ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp2einyctt.swift:50:25: error: cannot\
    \ assign value of type 'Character' to type 'String'\n        consonant = word[vowelIndex]\n\
    \                    ~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    if word.characters.count < 3 {\n \
    \       return \"\"\n    }\n    \n    let vowelIndex = word.characters.index(of:\
    \ vowels.lowercased())\n    \n    if vowelIndex == nil {\n        return \"\"\n\
    \    }\n    \n    let firstConsonantIndex = word.index(vowelIndex!, offsetBy:\
    \ 1)\n    \n    if firstConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let secondConsonantIndex = word.index(firstConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if secondConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let thirdConsonantIndex = word.index(secondConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if thirdConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let fourthConsonantIndex = word.index(thirdConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if fourthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let fifthConsonantIndex = word.index(fourthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if fifthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let sixthConsonantIndex = word.index(fifthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if sixthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let seventhConsonantIndex = word.index(sixthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if seventhConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let eighthConsonantIndex = word.index(seventhConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if eighthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let ninthConsonantIndex = word.index(eighthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if ninthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let tenthConsonantIndex = word.index(ninthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if tenthConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let eleventhConsonantIndex = word.index(tenthConsonantIndex!, offsetBy:\
    \ 1)\n    \n    if eleventhConsonantIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let twel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdblkpcmd.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 3 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdblkpcmd.swift:24:55:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    let vowelIndex = word.characters.index(of: vowels.lowercased())\n\
    \                                                      ^\n/tmp/tmpdblkpcmd.swift:96:9:\
    \ error: type annotation missing in pattern\n    let twel\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels = [String]()\n  \
    \  vowels.append(\"a\")\n    vowels.append(\"e\")\n    vowels.append(\"i\")\n\
    \    vowels.append(\"o\")\n    vowels.append(\"u\")\n    vowels.append(\"A\")\n\
    \    vowels.append(\"E\")\n    vowels.append(\"I\")\n    vowels.append(\"O\")\n\
    \    vowels.append(\"U\")\n    \n    var vowelsCount = vowels.count\n    var vowelIndex\
    \ = 0\n    var vowelIndex2 = 0\n    var vowelIndex3 = 0\n    var vowelIndex4 =\
    \ 0\n    var vowelIndex5 = 0\n    var vowelIndex6 = 0\n    var vowelIndex7 = 0\n\
    \    var vowelIndex8 = 0\n    var vowelIndex9 = 0\n    var vowelIndex10 = 0\n\
    \    var vowelIndex11 = 0\n    var vowelIndex12 = 0\n    var vowelIndex13 = 0\n\
    \    var vowelIndex14 = 0\n    var vowelIndex15 = 0\n    var vowelIndex16 = 0\n\
    \    var vowelIndex17 = 0\n    var vowelIndex18 = 0\n    var vowelIndex19 = 0\n\
    \    var vowelIndex20 = 0\n    var vowelIndex21 = 0\n    var vowelIndex22 = 0\n\
    \    var vowelIndex23 = 0\n    var vowelIndex24 = 0\n    var vowelIndex25 = 0\n\
    \    var vowelIndex26 = 0\n    var vowelIndex27 = 0\n    var vowelIndex28 = 0\n\
    \    var vowelIndex29 = 0\n    var vowelIndex30 = 0\n    var vowelIndex31 = 0\n\
    \    var vowelIndex32 = 0\n    var vowelIndex33 = 0\n    var vowelIndex34 = 0\n\
    \    var vowelIndex35 = 0\n    var vowelIndex36 = 0\n    var vowelIndex37 = 0\n\
    \    var vowelIndex38 = 0\n    var vowelIndex39 = 0\n    var vowelIndex40 = 0\n\
    \    var vowelIndex41 = 0\n    var vowelIndex42 = 0\n    var vowelIndex43 = 0\n\
    \    var vowelIndex44 = 0\n    var vowelIndex45 = 0\n    var vowelIndex46 = 0\n\
    \    var vowelIndex47 = 0\n    var vowelIndex48 = 0\n    var vowelIndex49 = 0\n\
    \    var vowelIndex50 = 0\n    var vowelIndex51 = 0\n    var vowelIndex52 = 0\n\
    \    var vowelIndex53 = 0\n    var vowelIndex54 = 0\n    var vowelIndex55 = 0\n\
    \    var vowelIndex56 = 0\n    var vowelIndex57 = 0\n    var vowelIndex58 = 0\n\
    \    var vowelIndex59 = 0\n    var vowelIndex60 = 0\n    var vowelIndex61 = 0\n\
    \    var vowelIndex62 = 0\n    var vowelIndex63 = 0\n    var vowelIndex64 = 0\n\
    \    var vowelIndex65 = 0\n    var vowelIndex66 = 0\n    var vowelIndex67 = 0\n\
    \    var vowelIndex68 = 0\n    var vowelIndex69 = 0\n    var vowelIndex70 = 0\n\
    \    var vowelIndex71 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_4s7ruev.swift:32:9: warning: initialization of variable 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp_4s7ruev.swift:33:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmp_4s7ruev.swift:34:9: warning: initialization of variable 'vowelIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex2 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp_4s7ruev.swift:35:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp_4s7ruev.swift:36:9: warning: initialization of variable 'vowelIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex4 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp_4s7ruev.swift:37:9:\
    \ warning: initialization of variable 'vowelIndex5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex5 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp_4s7ruev.swift:38:9: warning: initialization of variable 'vowelIndex6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex6 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp_4s7ruev.swift:39:9:\
    \ warning: initialization of variable 'vowelIndex7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex7 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp_4s7ruev.swift:40:9: warning: initialization of variable 'vowelIndex8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex8 = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp_4s7ruev.swift:41:9:\
    \ warning: initialization of variable 'vowelIndex9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex9 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmp_4s7ruev.swi"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count < 2 {\n        return \"\"\n    }\n    var vowels: [Character]\
    \ = []\n    for char in word.characters {\n        if char.unicodeScalars.contains(.vowel)\
    \ {\n            vowels.append(char)\n        }\n    }\n    if vowels.isEmpty\
    \ {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsIndex\
    \ = vowels.startIndex\n    let vowelsEnd = vowelsIndex + vowelsCount - 1\n   \
    \ let vowelsRange = NSRange(vowelsIndex, vowelsCount)\n    let consonantsRange\
    \ = NSRange(vowelsEnd, word.characters.count - vowelsEnd)\n    let consonants\
    \ = word.substringWithRange(consonantsRange)\n    let consonantsCount = consonants.count\n\
    \    let consonantsIndex = consonants.startIndex\n    let consonantsEnd = consonantsIndex\
    \ + consonantsCount - 1\n    let consonantsRange = NSRange(consonantsIndex, consonantsCount)\n\
    \    let vowelsRange = NSRange(vowelsEnd, vowelsCount)\n    let vowels = word.substringWithRange(vowelsRange)\n\
    \    let vowelsCount = vowels.count\n    let vowelsIndex = vowels.startIndex\n\
    \    let vowelsEnd = vowelsIndex + vowelsCount - 1\n    let vowelsRange = NSRange(vowelsIndex,\
    \ vowelsCount)\n    let consonantsRange = NSRange(consonantsEnd, word.characters.count\
    \ - consonantsEnd)\n    let consonants = word.substringWithRange(consonantsRange)\n\
    \    let consonantsCount = consonants.count\n    let consonantsIndex = consonants.startIndex\n\
    \    let consonantsEnd = consonantsIndex + consonantsCount - 1\n    let consonantsRange\
    \ = NSRange(consonantsIndex, consonantsCount)\n    let vowelsRange = NSRange(vowelsEnd,\
    \ vowelsCount)\n    let vowels = word.substringWithRange(vowelsRange)\n    let\
    \ vowelsCount = vowels.count\n    let vowelsIndex = vowels.startIndex\n    let\
    \ vowelsEnd = vowelsIndex + vowelsCount - 1\n    let vowelsRange = NSRange(vowelsIndex,\
    \ vowelsCount)\n    let consonantsRange = NSRange(consonantsEnd, word.characters.count\
    \ - consonantsEnd)\n    let consonants = word.substringWithRange(consonantsRange)\n\
    \    let consonantsCount = consonants.count\n    let consonantsIndex = consonants.startIndex\n\
    \    let consonantsEnd = consonantsIndex + consonantsCount - 1\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkz4cp24i.swift:17:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 2 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkz4cp24i.swift:21:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpkz4cp24i.swift:22:42: error: type 'Unicode.Scalar'\
    \ has no member 'vowel'\n        if char.unicodeScalars.contains(.vowel) {\n \
    \                                       ~^~~~~\n/tmp/tmpkz4cp24i.swift:32:23:\
    \ error: cannot find 'NSRange' in scope\n    let vowelsRange = NSRange(vowelsIndex,\
    \ vowelsCount)\n                      ^~~~~~~\n/tmp/tmpkz4cp24i.swift:33:27: error:\
    \ cannot find 'NSRange' in scope\n    let consonantsRange = NSRange(vowelsEnd,\
    \ word.characters.count - vowelsEnd)\n                          ^~~~~~~\n/tmp/tmpkz4cp24i.swift:34:27:\
    \ error: value of type 'String' has no member 'substringWithRange'\n    let consonants\
    \ = word.substringWithRange(consonantsRange)\n                     ~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkz4cp24i.swift:37:41: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n    let consonantsEnd = consonantsIndex + consonantsCount\
    \ - 1\n                                        ^\n/tmp/tmpkz4cp24i.swift:38:27:\
    \ error: cannot find 'NSRange' in scope\n    let consonantsRange = NSRange(consonantsIndex,\
    \ consonantsCount)\n                          ^~~~~~~\n/tmp/tmpkz4cp24i.swift:39:23:\
    \ error: cannot find 'NSRange' in scope\n    let vowelsRange = NSRange(vowelsEnd,\
    \ vowelsCount)\n                      ^~~~~~~\n/tmp/tmpkz4cp24i.swift:40:23: error:\
    \ value of type 'String' has no member 'substringWithRange'\n    let vowels =\
    \ word.substringWithRange(vowelsRange)\n                 ~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkz4cp24i.swift:43:33: error: cannot"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \
    \  var vowelsCount = 0\n    var vowelsIndex = 0\n    var vowelsIndex2 = 0\n  \
    \  var vowelsIndex3 = 0\n    var vowelsIndex4 = 0\n    var vowelsIndex5 = 0\n\
    \    var vowelsIndex6 = 0\n    var vowelsIndex7 = 0\n    var vowelsIndex8 = 0\n\
    \    var vowelsIndex9 = 0\n    var vowelsIndex10 = 0\n    var vowelsIndex11 =\
    \ 0\n    var vowelsIndex12 = 0\n    var vowelsIndex13 = 0\n    var vowelsIndex14\
    \ = 0\n    var vowelsIndex15 = 0\n    var vowelsIndex16 = 0\n    var vowelsIndex17\
    \ = 0\n    var vowelsIndex18 = 0\n    var vowelsIndex19 = 0\n    var vowelsIndex20\
    \ = 0\n    var vowelsIndex21 = 0\n    var vowelsIndex22 = 0\n    var vowelsIndex23\
    \ = 0\n    var vowelsIndex24 = 0\n    var vowelsIndex25 = 0\n    var vowelsIndex26\
    \ = 0\n    var vowelsIndex27 = 0\n    var vowelsIndex28 = 0\n    var vowelsIndex29\
    \ = 0\n    var vowelsIndex30 = 0\n    var vowelsIndex31 = 0\n    var vowelsIndex32\
    \ = 0\n    var vowelsIndex33 = 0\n    var vowelsIndex34 = 0\n    var vowelsIndex35\
    \ = 0\n    var vowelsIndex36 = 0\n    var vowelsIndex37 = 0\n    var vowelsIndex38\
    \ = 0\n    var vowelsIndex39 = 0\n    var vowelsIndex40 = 0\n    var vowelsIndex41\
    \ = 0\n    var vowelsIndex42 = 0\n    var vowelsIndex43 = 0\n    var vowelsIndex44\
    \ = 0\n    var vowelsIndex45 = 0\n    var vowelsIndex46 = 0\n    var vowelsIndex47\
    \ = 0\n    var vowelsIndex48 = 0\n    var vowelsIndex49 = 0\n    var vowelsIndex50\
    \ = 0\n    var vowelsIndex51 = 0\n    var vowelsIndex52 = 0\n    var vowelsIndex53\
    \ = 0\n    var vowelsIndex54 = 0\n    var vowelsIndex55 = 0\n    var vowelsIndex56\
    \ = 0\n    var vowelsIndex57 = 0\n    var vowelsIndex58 = 0\n    var vowelsIndex59\
    \ = 0\n    var vowelsIndex60 = 0\n    var vowelsIndex61 = 0\n    var vowelsIndex62\
    \ = 0\n    var vowelsIndex63 = 0\n    var vowelsIndex64 = 0\n    var vowelsIndex65\
    \ = 0\n    var vowelsIndex66 = 0\n    var vowelsIndex67 = 0\n    var vowelsIndex68\
    \ = 0\n    var vowelsIndex69 = 0\n    var vowelsIndex70\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvlalwk03.swift:89:9: error: type annotation missing in pattern\n\
    \    var vowelsIndex70\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    if word.characters.count < 2 {\n \
    \       return \"\"\n    }\n    \n    let firstVowelIndex = word.index(word, startIndex:\
    \ word.startIndex.advancedBy(1))\n    let lastVowelIndex = word.index(word, startIndex:\
    \ word.endIndex.advancedBy(-1))\n    \n    if firstVowelIndex == lastVowelIndex\
    \ {\n        return \"\"\n    }\n    \n    let firstVowel = vowels.characters[firstVowelIndex]\n\
    \    let lastVowel = vowels.characters[lastVowelIndex]\n    \n    if firstVowel\
    \ == lastVowel {\n        return firstVowel\n    }\n    \n    if firstVowelIndex\
    \ < lastVowelIndex {\n        return firstVowel\n    }\n    \n    return lastVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzms5d3s1.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 2 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzms5d3s1.swift:24:32:\
    \ error: no exact matches in call to instance method 'index'\n    let firstVowelIndex\
    \ = word.index(word, startIndex: word.startIndex.advancedBy(1))\n            \
    \                   ^\n/tmp/tmpzms5d3s1.swift:24:32: note: found candidate with\
    \ type '(String.Index, Int) -> String.Index'\n    let firstVowelIndex = word.index(word,\
    \ startIndex: word.startIndex.advancedBy(1))\n                               ^\n\
    /tmp/tmpzms5d3s1.swift:24:72: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let firstVowelIndex = word.index(word, startIndex: word.startIndex.advancedBy(1))\n\
    \                                                       ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpzms5d3s1.swift:25:31: error: no exact matches in call to instance method\
    \ 'index'\n    let lastVowelIndex = word.index(word, startIndex: word.endIndex.advancedBy(-1))\n\
    \                              ^\n/tmp/tmpzms5d3s1.swift:25:31: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n    let lastVowelIndex = word.index(word,\
    \ startIndex: word.endIndex.advancedBy(-1))\n                              ^\n\
    /tmp/tmpzms5d3s1.swift:25:69: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let lastVowelIndex = word.index(word, startIndex: word.endIndex.advancedBy(-1))\n\
    \                                                      ~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    let vowelsArrayCount = vowelsArray.count\n\
    \    let vowelsArrayIndex = vowelsArray.index(of: vowels.lowercased())\n    let\
    \ vowelsArrayIndex2 = vowelsArray.index(of: vowels.lowercased(), offsetBy: vowelsArrayIndex!\
    \ + 1)\n    let vowelsArrayIndex3 = vowelsArray.index(of: vowels.lowercased(),\
    \ offsetBy: vowelsArrayIndex2! + 1)\n    let vowelsArrayIndex4 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex3! + 1)\n    let vowelsArrayIndex5\
    \ = vowelsArray.index(of: vowels.lowercased(), offsetBy: vowelsArrayIndex4! +\
    \ 1)\n    let vowelsArrayIndex6 = vowelsArray.index(of: vowels.lowercased(), offsetBy:\
    \ vowelsArrayIndex5! + 1)\n    let vowelsArrayIndex7 = vowelsArray.index(of: vowels.lowercased(),\
    \ offsetBy: vowelsArrayIndex6! + 1)\n    let vowelsArrayIndex8 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex7! + 1)\n    let vowelsArrayIndex9\
    \ = vowelsArray.index(of: vowels.lowercased(), offsetBy: vowelsArrayIndex8! +\
    \ 1)\n    let vowelsArrayIndex10 = vowelsArray.index(of: vowels.lowercased(),\
    \ offsetBy: vowelsArrayIndex9! + 1)\n    let vowelsArrayIndex11 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex10! + 1)\n    let vowelsArrayIndex12\
    \ = vowelsArray.index(of: vowels.lowercased(), offsetBy: vowelsArrayIndex11! +\
    \ 1)\n    let vowelsArrayIndex13 = vowelsArray.index(of: vowels.lowercased(),\
    \ offsetBy: vowelsArrayIndex12! + 1)\n    let vowelsArrayIndex14 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex13! + 1)\n    let vowelsArrayIndex15\
    \ = vowelsArray.index(of: vowels.lowercased(), offsetBy: vowelsArrayIndex14! +\
    \ 1)\n    let vowelsArrayIndex16 = vowelsArray.index(of: vowels.lowercased(),\
    \ offsetBy: vowelsArrayIndex15! + 1)\n    let vowelsArrayIndex17 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex16! + 1)\n    let vowelsArrayIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpo4n37bmn.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpo4n37bmn.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsArray = vowels.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpo4n37bmn.swift:21:57: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let vowelsArrayIndex\
    \ = vowelsArray.index(of: vowels.lowercased())\n                             \
    \                           ^\n/tmp/tmpo4n37bmn.swift:22:41: error: no exact matches\
    \ in call to instance method 'index'\n    let vowelsArrayIndex2 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex! + 1)\n                    \
    \                    ^\n/tmp/tmpo4n37bmn.swift:22:41: note: found candidate with\
    \ type '(String.Index, Int) -> String.Index'\n    let vowelsArrayIndex2 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex! + 1)\n                    \
    \                    ^\n/tmp/tmpo4n37bmn.swift:23:41: error: no exact matches\
    \ in call to instance method 'index'\n    let vowelsArrayIndex3 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex2! + 1)\n                   \
    \                     ^\n/tmp/tmpo4n37bmn.swift:23:41: note: found candidate with\
    \ type '(String.Index, Int) -> String.Index'\n    let vowelsArrayIndex3 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex2! + 1)\n                   \
    \                     ^\n/tmp/tmpo4n37bmn.swift:24:41: error: no exact matches\
    \ in call to instance method 'index'\n    let vowelsArrayIndex4 = vowelsArray.index(of:\
    \ vowels.lowercased(), offsetBy: vowelsArrayIndex3! + 1)\n                  "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"A\")\n    vowels.insert(\"E\")\n    vowels.insert(\"I\"\
    )\n    vowels.insert(\"O\")\n    vowels.insert(\"U\")\n    \n    var vowelsCount\
    \ = vowels.count\n    var vowelsIndex = 0\n    var vowelsIndexEnd = word.count\n\
    \    \n    while vowelsIndex < vowelsIndexEnd {\n        let vowel = word[vowelsIndex]\n\
    \        if vowels.contains(vowel) {\n            vowelsIndex += 1\n        }\
    \ else {\n            vowelsIndex += 1\n            vowelsIndexEnd -= 1\n    \
    \    }\n    }\n    \n    if vowelsIndex == vowelsIndexEnd {\n        return \"\
    \"\n    }\n    \n    var vowelsIndex2 = vowelsIndex\n    var vowelsIndex2End =\
    \ vowelsIndexEnd - 1\n    \n    while vowelsIndex2 < vowelsIndex2End {\n     \
    \   let vowel = word[vowelsIndex2]\n        if vowels.contains(vowel) {\n    \
    \        vowelsIndex2 += 1\n        } else {\n            vowelsIndex2 += 1\n\
    \            vowelsIndex2End -= 1\n        }\n    }\n    \n    if vowelsIndex2\
    \ == vowelsIndex2End {\n        return \"\"\n    }\n    \n    var vowelsIndex3\
    \ = vowelsIndex2\n    var vowelsIndex3End = vowelsIndex2End - 1\n    \n    while\
    \ vowelsIndex3 < vowelsIndex3End {\n        let vowel = word[vowelsIndex3]\n \
    \       if vowels.contains(vowel) {\n            vowelsIndex3 += 1\n        }\
    \ else {\n            vowelsIndex3 += 1\n            vowelsIndex3End -= 1\n  \
    \      }\n    }\n    \n    if vowelsIndex3 == vowelsIndex3End {\n        return\
    \ \"\"\n    }\n    \n    var vowelsIndex4 = vowelsIndex3\n    var vowelsIndex4End\
    \ = vowelsIndex3End - 1\n    \n    while vowelsIndex4 < vowelsIndex4End {\n  \
    \      let vowel = word[vowelsIndex4]\n        if vowels.contains(vowel) {\n \
    \           vowelsIndex4 += 1\n        } else {\n            vowelsIndex4 += 1\n\
    \            vowelsIndex4End -= 1\n        }\n    }\n    \n    if vowelsIndex4\
    \ == vowelsIndex4End {\n        return \"\"\n    }\n    \n    var vowelsIndex5\
    \ = vowelsIndex4\n    var vowelsIndex5End = vowelsIndex4End - 1\n    \n    while\
    \ vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp16so3isq.swift:101:16: error: expected '{' after 'while' condition\n\
    \    while vowel\n               ^\n/tmp/tmp16so3isq.swift:34:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let vowel = word[vowelsIndex]\n                    ^~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp16so3isq.swift:51:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let vowel = word[vowelsIndex2]\n      \
    \              ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp16so3isq.swift:68:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let vowel = word[vowelsIndex3]\n                    ^~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp16so3isq.swift:85:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let vowel = word[vowelsIndex4]\n      \
    \              ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp16so3isq.swift:101:11: error: cannot find 'vowel'\
    \ in scope\n    while vowel\n          ^~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    let vowelsArrayCount = vowelsArray.count\n\
    \    let vowelsArraySlice = vowelsArray[vowelsArrayCount - vowelsArrayCount /\
    \ 2 : vowelsArrayCount]\n    let vowelsArraySliceCount = vowelsArraySlice.count\n\
    \    let vowelsArraySliceSlice = vowelsArraySlice[vowelsArraySliceCount - vowelsArraySliceCount\
    \ / 2 : vowelsArraySliceCount]\n    let vowelsArraySliceSliceCount = vowelsArraySliceSlice.count\n\
    \    let vowelsArraySliceSliceSlice = vowelsArraySliceSlice[vowelsArraySliceSliceCount\
    \ - vowelsArraySliceSliceCount / 2 : vowelsArraySliceSliceCount]\n    let vowelsArraySliceSliceSliceCount\
    \ = vowelsArraySliceSliceSlice.count\n    let vowelsArraySliceSliceSliceSlice\
    \ = vowelsArraySliceSliceSlice[vowelsArraySliceSliceSliceCount - vowelsArraySliceSliceSliceCount\
    \ / 2 : vowelsArraySliceSliceSliceCount]\n    let vowelsArraySliceSliceSliceSliceCount\
    \ = vowelsArraySliceSliceSliceSlice.count\n    let vowelsArraySliceSliceSliceSliceSlice\
    \ = vowelsArraySliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceCount - vowelsArraySliceSliceSliceSliceCount\
    \ / 2 : vowelsArraySliceSliceSliceSliceCount]\n    let vowelsArraySliceSliceSliceSliceSliceCount\
    \ = vowelsArraySliceSliceSliceSliceSlice.count\n    let vowelsArraySliceSliceSliceSliceSliceSlice\
    \ = vowelsArraySliceSliceSliceSliceSlice[vowelsArraySliceSliceSliceSliceSliceCount\
    \ - vowelsArraySliceSliceSliceSliceSliceCount / 2 : vowelsArraySliceSliceSliceSliceSliceCount]\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceSlice.count\n\
    \    let vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceCount = vowelsArraySliceSliceSliceSliceSliceSliceSliceSliceSliceSlice.count\n\
    \    let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpi0hhe93j.swift:21:80: error: expected ',' separator\n    let vowelsArraySlice\
    \ = vowelsArray[vowelsArrayCount - vowelsArrayCount / 2 : vowelsArrayCount]\n\
    \                                                                            \
    \   ^\n                                                                      \
    \        ,\n/tmp/tmpi0hhe93j.swift:21:80: error: expected expression in list of\
    \ expressions\n    let vowelsArraySlice = vowelsArray[vowelsArrayCount - vowelsArrayCount\
    \ / 2 : vowelsArrayCount]\n                                                  \
    \                             ^\n/tmp/tmpi0hhe93j.swift:23:100: error: expected\
    \ ',' separator\n    let vowelsArraySliceSlice = vowelsArraySlice[vowelsArraySliceCount\
    \ - vowelsArraySliceCount / 2 : vowelsArraySliceCount]\n                     \
    \                                                                            \
    \  ^\n                                                                       \
    \                           ,\n/tmp/tmpi0hhe93j.swift:23:100: error: expected\
    \ expression in list of expressions\n    let vowelsArraySliceSlice = vowelsArraySlice[vowelsArraySliceCount\
    \ - vowelsArraySliceCount / 2 : vowelsArraySliceCount]\n                     \
    \                                                                            \
    \  ^\n/tmp/tmpi0hhe93j.swift:25:120: error: expected ',' separator\n    let vowelsArraySliceSliceSlice\
    \ = vowelsArraySliceSlice[vowelsArraySliceSliceCount - vowelsArraySliceSliceCount\
    \ / 2 : vowelsArraySliceSliceCount]\n                                        \
    \                                                                            \
    \   ^\n                                                                      \
    \                                                ,\n/tmp/tmpi0hhe93j.swift:25:120:\
    \ error: expected expression in list of expressions\n    let vowelsArraySliceSliceSlice\
    \ = vowelsArraySliceSlice[vowelsArraySliceSliceCount - vowelsArraySliceSliceCount\
    \ / 2 : vowelsArraySliceSliceCount]\n                                        \
    \                                                       "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ find_closest_vowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpihpnyelp.swift:17:12: error: cannot find 'find_closest_vowel' in\
    \ scope\n    return find_closest_vowel(word: word, vowels: vowels)\n         \
    \  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpihpnyelp.swift:17:51: error: cannot find 'vowels'\
    \ in scope\n    return find_closest_vowel(word: word, vowels: vowels)\n      \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014349
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.reversed(), let word = word.characters.reversed()\
    \ else {\n        return \"\"\n    }\n    var vowelIndex = 0\n    var vowelFound\
    \ = false\n    var currentVowelIndex = 0\n    var currentVowelFound = false\n\
    \    var currentVowel = String()\n    var currentVowelFoundIndex = -1\n    \n\
    \    for char in word {\n        if vowels.contains(char) {\n            vowelFound\
    \ = true\n            currentVowelFoundIndex = vowelIndex\n            currentVowelFound\
    \ = true\n        }\n        vowelIndex += 1\n    }\n    \n    if vowelFound {\n\
    \        for char in word {\n            if vowels.contains(char) {\n        \
    \        currentVowelFound = true\n                currentVowelFoundIndex = vowelIndex\n\
    \            }\n            vowelIndex += 1\n        }\n    }\n    \n    if currentVowelFound\
    \ {\n        if currentVowelIndex < vowels.count - 1 {\n            if vowelIndex\
    \ < vowels.count - 1 {\n                currentVowel = vowels[currentVowelIndex..<vowelIndex\
    \ + 1]\n            } else {\n                currentVowel = vowels[currentVowelIndex..<vowels.count]\n\
    \            }\n        } else {\n            currentVowel = vowels[currentVowelIndex..<vowels.count]\n\
    \        }\n    }\n    return currentVowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpb2ee0997.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.reversed(), let word = word.characters.reversed()\
    \ else {\n                       ^~~~~~\n/tmp/tmpb2ee0997.swift:17:70: error:\
    \ 'characters' is unavailable: Please use String directly\n    guard let vowels\
    \ = vowels.characters.reversed(), let word = word.characters.reversed() else {\n\
    \                                                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb2ee0997.swift:17:54:\
    \ error: initializer for conditional binding must have Optional type, not 'ReversedCollection<String>'\n\
    \    guard let vowels = vowels.characters.reversed(), let word = word.characters.reversed()\
    \ else {\n                                                     ^          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    var vowelsArrayCount = vowelsArray.count\n\
    \    var vowelsArrayIndex = 0\n    var vowelsArrayCountIndex = 0\n    var vowelsArrayIndex2\
    \ = 0\n    var vowelsArrayCountIndex2 = 0\n    var vowelsArrayIndex3 = 0\n   \
    \ var vowelsArrayCountIndex3 = 0\n    var vowelsArrayIndex4 = 0\n    var vowelsArrayCountIndex4\
    \ = 0\n    var vowelsArrayIndex5 = 0\n    var vowelsArrayCountIndex5 = 0\n   \
    \ var vowelsArrayIndex6 = 0\n    var vowelsArrayCountIndex6 = 0\n    var vowelsArrayIndex7\
    \ = 0\n    var vowelsArrayCountIndex7 = 0\n    var vowelsArrayIndex8 = 0\n   \
    \ var vowelsArrayCountIndex8 = 0\n    var vowelsArrayIndex9 = 0\n    var vowelsArrayCountIndex9\
    \ = 0\n    var vowelsArrayIndex10 = 0\n    var vowelsArrayCountIndex10 = 0\n \
    \   var vowelsArrayIndex11 = 0\n    var vowelsArrayCountIndex11 = 0\n    var vowelsArrayIndex12\
    \ = 0\n    var vowelsArrayCountIndex12 = 0\n    var vowelsArrayIndex13 = 0\n \
    \   var vowelsArrayCountIndex13 = 0\n    var vowelsArrayIndex14 = 0\n    var vowelsArrayCountIndex14\
    \ = 0\n    var vowelsArrayIndex15 = 0\n    var vowelsArrayCountIndex15 = 0\n \
    \   var vowelsArrayIndex16 = 0\n    var vowelsArrayCountIndex16 = 0\n    var vowelsArrayIndex17\
    \ = 0\n    var vowelsArrayCountIndex17 = 0\n    var vowelsArrayIndex18 = 0\n \
    \   var vowelsArrayCountIndex18 = 0\n    var vowelsArrayIndex19 = 0\n    var vowelsArrayCountIndex19\
    \ = 0\n    var vowelsArrayIndex20 = 0\n    var vowelsArrayCountIndex20 = 0\n \
    \   var vowelsArrayIndex21 = 0\n    var vowelsArrayCountIndex21 = 0\n    var vowelsArrayIndex22\
    \ = 0\n    var vowelsArrayCountIndex22 = 0\n    var vowelsArrayIndex23 = 0\n \
    \   var vowelsArrayCountIndex23 = 0\n    var vowelsArrayIndex24 = 0\n    var vowelsArrayCountIndex24\
    \ = 0\n    var vowelsArrayIndex25 = 0\n    var vowelsArrayCountIndex25 = 0\n \
    \   var vowelsArrayIndex26 = 0\n    var vowelsArrayCountIndex26 = 0\n    var vowelsArrayIndex27\
    \ = 0\n    var vowelsArrayCountIndex27 = 0\n    var vowelsArrayIndex28 = 0\n \
    \   var vowelsArrayCountIndex28 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3tg9s68w.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3tg9s68w.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsArray = vowels.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3tg9s68w.swift:18:9: warning: initialization of immutable value 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let vowelsCount = vowels.characters.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp3tg9s68w.swift:20:9:\
    \ warning: initialization of variable 'vowelsArrayCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsArrayCount =\
    \ vowelsArray.count\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3tg9s68w.swift:21:9:\
    \ warning: initialization of variable 'vowelsArrayIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsArrayIndex =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3tg9s68w.swift:22:9: warning: initialization\
    \ of variable 'vowelsArrayCountIndex' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var vowelsArrayCountIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3tg9s68w.swift:23:9: warning: initialization of variable 'vowelsArrayIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsArrayIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3tg9s68w.swift:24:9:\
    \ warning: initialization of variable 'vowelsArrayCountIndex2' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var vowelsArrayCountIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3tg9s68w.swift:25:9: warning:\
    \ initialization of variable 'vowels"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(String(char)) {\n    \
    \        vowelIndex = vowels.firstIndex(of: String(char))!\n            break\n\
    \        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    \n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n \
    \   \n    var consonantIndex = 0\n    \n    for char in word.characters {\n  \
    \      if consonants.contains(String(char)) {\n            consonantIndex = consonants.firstIndex(of:\
    \ String(char))!\n            break\n        }\n    }\n    \n    let index = word.characters.count\
    \ - vowelIndex - consonantIndex\n    \n    return word.substring(to: index)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfru_b8pr.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpfru_b8pr.swift:24:61:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  vowelIndex = vowels.firstIndex(of: String(char))!\n                       \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpfru_b8pr.swift:24:48: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            vowelIndex = vowels.firstIndex(of: String(char))!\n\
    \                                               ^\n/tmp/tmpfru_b8pr.swift:37:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpfru_b8pr.swift:39:69: error: cannot assign\
    \ value of type 'String.Index' to type 'Int'\n            consonantIndex = consonants.firstIndex(of:\
    \ String(char))!\n                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    /tmp/tmpfru_b8pr.swift:39:56: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n            consonantIndex\
    \ = consonants.firstIndex(of: String(char))!\n                               \
    \                        ^\n/tmp/tmpfru_b8pr.swift:44:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    let index = word.characters.count\
    \ - vowelIndex - consonantIndex\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfru_b8pr.swift:46:17: error: value of\
    \ type 'String' has no member 'substring'\n    return word.substring(to: index)\n\
    \           ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"e\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"i\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"o\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"u\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"y\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"a\"\n    }\n    vowels = vowels.filter {\n        !$0.isEmpty && $0.lowercased()\
    \ != \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxyz5jbg_.swift:76:43: error: unterminated string literal\n    \
    \    !$0.isEmpty && $0.lowercased() != \"\n                                  \
    \        ^\n/tmp/tmpxyz5jbg_.swift:104:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmpxyz5jbg_.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmpxyz5jbg_.swift:80:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ == 1 {\n            vowels.append(char.unicodeScalars.first!.value)\n      \
    \  }\n    }\n    \n    if vowels.count > 0 {\n        let vowelsSet = Set(vowels)\n\
    \        let vowelsArray = vowelsSet.sorted()\n        \n        if vowelsArray.count\
    \ > 0 {\n            let vowelsArrayCount = vowelsArray.count\n            \n\
    \            if vowelsArrayCount > 1 {\n                let vowelsArrayLastIndex\
    \ = vowelsArrayCount - 1\n                let vowelsArrayFirstIndex = vowelsArrayCount\
    \ - 2\n                \n                if vowelsArrayLastIndex > 0 {\n     \
    \               let vowelsArrayLast = vowelsArray[vowelsArrayLastIndex]\n    \
    \                let vowelsArrayFirst = vowelsArray[vowelsArrayFirstIndex]\n \
    \                   \n                    if vowelsArrayLast == vowelsArrayFirst\
    \ {\n                        return vowelsArrayLast\n                    }\n \
    \               }\n            }\n        }\n    }\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzqg853ll.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzqg853ll.swift:25:54:\
    \ error: cannot convert value of type 'UInt32' to expected argument type 'String'\n\
    \            vowels.append(char.unicodeScalars.first!.value)\n               \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ index in word.characters.reversed().indices {\n        if vowels.contains(String(word.characters.reversed()[index]))\
    \ {\n            vowelIndex = index\n            break\n        }\n    }\n   \
    \ \n    if vowelIndex == word.characters.count - 1 {\n        return \"\"\n  \
    \  }\n    \n    let vowelsCount = word.characters.count - vowelIndex - 1\n   \
    \ \n    let consonantsCount = word.characters.count - vowelIndex + 1\n    \n \
    \   if consonantsCount > vowelsCount {\n        return \"\"\n    }\n    \n   \
    \ let consonantIndex = vowelIndex + consonantsCount - 1\n    \n    let consonants\
    \ = String(word.characters.reversed()[consonantIndex..<word.characters.count])\n\
    \    \n    if consonants.contains(\"a\") {\n        return \"a\"\n    }\n    \n\
    \    if consonants.contains(\"e\") {\n        return \"e\"\n    }\n    \n    if\
    \ consonants.contains(\"i\") {\n        return \"i\"\n    }\n    \n    if consonants.contains(\"\
    o\") {\n        return \"o\"\n    }\n    \n    if consonants.contains(\"u\") {\n\
    \        return \"u\"\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpajeays88.swift:22:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in word.characters.reversed().indices {\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpajeays88.swift:23:40: error: 'characters' is unavailable: Please\
    \ use String directly\n        if vowels.contains(String(word.characters.reversed()[index]))\
    \ {\n                                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpajeays88.swift:24:26: error: cannot assign\
    \ value of type 'DefaultIndices<ReversedCollection<String>>.Element' (aka 'ReversedCollection<String>.Index')\
    \ to type 'Int'\n            vowelIndex = index\n                         ^~~~~\n\
    /tmp/tmpajeays88.swift:29:27: error: 'characters' is unavailable: Please use String\
    \ directly\n    if vowelIndex == word.characters.count - 1 {\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpajeays88.swift:33:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    let vowelsCount = word.characters.count - vowelIndex - 1\n   \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpajeays88.swift:35:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let consonantsCount = word.characters.count\
    \ - vowelIndex + 1\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpajeays88.swift:43:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let consonants = String(word.characters.reversed()[consonantIndex..<word.characters.count])\n\
    \                  "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = []\n\
    \    for char in word.unicodeScalars {\n        if let _ = char.properties.isVowel\
    \ {\n            vowels.append(char.value)\n        }\n    }\n    if vowels.count\
    \ < 2 {\n        return \"\"\n    }\n    let first = vowels.first!\n    let last\
    \ = vowels.last!\n    let index = word.unicodeScalars.index(of: last)!\n    let\
    \ nextIndex = word.unicodeScalars.index(of: first)!\n    let nextWord = word.unicodeScalars.suffix(from:\
    \ nextIndex)\n    if nextWord.count < 2 {\n        return \"\"\n    }\n    let\
    \ nextFirst = nextWord.first!\n    let nextLast = nextWord.last!\n    let nextIndex\
    \ = nextWord.unicodeScalars.index(of: nextLast)!\n    let nextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextFirst)!\n    let nextNextWord = nextWord.unicodeScalars.suffix(from: nextNextIndex)\n\
    \    if nextNextWord.count < 2 {\n        return \"\"\n    }\n    let nextNextNextIndex\
    \ = nextWord.unicodeScalars.index(of: nextNextFirst)!\n    let nextNextNextWord\
    \ = nextWord.unicodeScalars.suffix(from: nextNextNextIndex)\n    if nextNextNextWord.count\
    \ < 2 {\n        return \"\"\n    }\n    let nextNextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextNextFirst)!\n    let nextNextNextNextWord = nextWord.unicodeScalars.suffix(from:\
    \ nextNextNextNextIndex)\n    if nextNextNextNextWord.count < 2 {\n        return\
    \ \"\"\n    }\n    let nextNextNextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextNextNextFirst)!\n    let nextNextNextNextNextWord = nextWord.unicodeScalars.suffix(from:\
    \ nextNextNextNextNextIndex)\n    if nextNextNextNextNextWord.count < 2 {\n  \
    \      return \"\"\n    }\n    let nextNextNextNextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextNextNextNextFirst)!\n    let nextNextNextNextNextNextWord = nextWord.unicodeScalars.suffix(from:\
    \ nextNextNextNextNextNextIndex)\n    if nextNextNextNextNextNextWord.count <\
    \ 2 {\n        return \"\"\n    }\n    let nextNextNextNextNextNextNextIndex =\
    \ nextWord.unicodeScalars.index(of: nextNextNextNextNextNextFirst)!\n    let nextNextNextNextNextNextNextWord\
    \ = nextWord.unicodeScalars.suffix(from: nextNextNext\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpau1c6qzp.swift:67:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpau1c6qzp.swift:66:74: note: to match this opening '('\n    let nextNextNextNextNextNextNextWord\
    \ = nextWord.unicodeScalars.suffix(from: nextNextNext\n                      \
    \                                                   ^\n/tmp/tmpau1c6qzp.swift:22:36:\
    \ error: type of expression is ambiguous without more context\n        if let\
    \ _ = char.properties.isVowel {\n                   ~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpau1c6qzp.swift:23:32: error: cannot convert value of type 'UInt32' to\
    \ expected argument type 'String'\n            vowels.append(char.value)\n   \
    \                            ^\n/tmp/tmpau1c6qzp.swift:31:47: error: cannot convert\
    \ value of type 'String' to expected argument type 'Unicode.Scalar'\n    let index\
    \ = word.unicodeScalars.index(of: last)!\n                                   \
    \           ^\n/tmp/tmpau1c6qzp.swift:32:51: error: cannot convert value of type\
    \ 'String' to expected argument type 'Unicode.Scalar'\n    let nextIndex = word.unicodeScalars.index(of:\
    \ first)!\n                                                  ^\n/tmp/tmpau1c6qzp.swift:45:63:\
    \ error: cannot find 'nextNextFirst' in scope\n    let nextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextFirst)!\n                                                          \
    \    ^~~~~~~~~~~~~\n/tmp/tmpau1c6qzp.swift:50:67: error: cannot find 'nextNextNextFirst'\
    \ in scope\n    let nextNextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextNextFirst)!\n                                                      \
    \            ^~~~~~~~~~~~~~~~~\n/tmp/tmpau1c6qzp.swift:55:71: error: cannot find\
    \ 'nextNextNextNextFirst' in scope\n    let nextNextNextNextNextIndex = nextWord.unicodeScalars.index(of:\
    \ nextNextNextNextFirst)!\n                                                  \
    \                    ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpau1c6qzp.swift:60:75: error:\
    \ cannot find 'nextNextNextNextNextFirst' in scope\n    let nextNextNextNextNextNextIndex\
    \ = nextWord.unicodeScalars.index(of: nextNextNextNextNextFirst)!\n        "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.characters.count == 0 {\n        return \"\"\n    }\n    var vowels: [String]\
    \ = []\n    var vowelIndex = 0\n    var vowelIndex2 = 0\n    var vowelIndex3 =\
    \ 0\n    var vowelIndex4 = 0\n    var vowelIndex5 = 0\n    var vowelIndex6 = 0\n\
    \    var vowelIndex7 = 0\n    var vowelIndex8 = 0\n    var vowelIndex9 = 0\n \
    \   var vowelIndex10 = 0\n    var vowelIndex11 = 0\n    var vowelIndex12 = 0\n\
    \    var vowelIndex13 = 0\n    var vowelIndex14 = 0\n    var vowelIndex15 = 0\n\
    \    var vowelIndex16 = 0\n    var vowelIndex17 = 0\n    var vowelIndex18 = 0\n\
    \    var vowelIndex19 = 0\n    var vowelIndex20 = 0\n    var vowelIndex21 = 0\n\
    \    var vowelIndex22 = 0\n    var vowelIndex23 = 0\n    var vowelIndex24 = 0\n\
    \    var vowelIndex25 = 0\n    var vowelIndex26 = 0\n    var vowelIndex27 = 0\n\
    \    var vowelIndex28 = 0\n    var vowelIndex29 = 0\n    var vowelIndex30 = 0\n\
    \    var vowelIndex31 = 0\n    var vowelIndex32 = 0\n    var vowelIndex33 = 0\n\
    \    var vowelIndex34 = 0\n    var vowelIndex35 = 0\n    var vowelIndex36 = 0\n\
    \    var vowelIndex37 = 0\n    var vowelIndex38 = 0\n    var vowelIndex39 = 0\n\
    \    var vowelIndex40 = 0\n    var vowelIndex41 = 0\n    var vowelIndex42 = 0\n\
    \    var vowelIndex43 = 0\n    var vowelIndex44 = 0\n    var vowelIndex45 = 0\n\
    \    var vowelIndex46 = 0\n    var vowelIndex47 = 0\n    var vowelIndex48 = 0\n\
    \    var vowelIndex49 = 0\n    var vowelIndex50 = 0\n    var vowelIndex51 = 0\n\
    \    var vowelIndex52 = 0\n    var vowelIndex53 = 0\n    var vowelIndex54 = 0\n\
    \    var vowelIndex55 = 0\n    var vowelIndex56 = 0\n    var vowelIndex57 = 0\n\
    \    var vowelIndex58 = 0\n    var vowelIndex59 = 0\n    var vowelIndex60 = 0\n\
    \    var vowelIndex61 = 0\n    var vowelIndex62 = 0\n    var vowelIndex63 = 0\n\
    \    var vowelIndex64 = 0\n    var vowelIndex65 = 0\n    var vowelIndex66 = 0\n\
    \    var vowelIndex67 = 0\n    var vowelIndex68 = 0\n    var vowelIndex69 = 0\n\
    \    var vowelIndex70 = 0\n    var vowelIndex71 = 0\n    var vowelIndex72 = 0\n\
    \    var vowelIndex73 = 0\n    var vowelIndex74 = 0\n    var vowelIndex75 = 0\n\
    \    var vowelIndex76 = 0\n    var vowelIndex77 = 0\n    var vowelIndex78 = 0\n\
    \    var vowelIndex79 = 0\n    var vowelIndex80 = 0\n    var vowelIndex81 = 0\n\
    \    var vowelIndex82 = 0\n    var vowelIndex83\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp49966gcb.swift:17:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count == 0 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp49966gcb.swift:103:9:\
    \ error: type annotation missing in pattern\n    var vowelIndex83\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsIndex = word.characters.reversed().enumerate().filter { (index, element)\
    \ -> Bool in\n        element.lowercaseString.rangeOfString(vowels, options: .CaseInsensitiveSearch)\
    \ != nil\n    }.first?.offset\n    if vowelsIndex == nil {\n        return \"\"\
    \n    }\n    let vowelsCount = vowels.characters.count\n    let vowelsIndex =\
    \ word.characters.reversed().enumerate().filter { (index, element) -> Bool in\n\
    \        element.lowercaseString.rangeOfString(vowels, options: .CaseInsensitiveSearch)\
    \ != nil\n    }.first?.offset\n    let vowelsIndex = vowelsIndex!\n    let vowelsCount\
    \ = vowels.characters.count\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n        element.lowercaseString.rangeOfString(vowels,\
    \ options: .CaseInsensitiveSearch) != nil\n    }.first?.offset\n    let vowelsIndex\
    \ = vowelsIndex!\n    let vowelsCount = vowels.characters.count\n    let vowelsIndex\
    \ = word.characters.reversed().enumerate().filter { (index, element) -> Bool in\n\
    \        element.lowercaseString.rangeOfString(vowels, options: .CaseInsensitiveSearch)\
    \ != nil\n    }.first?.offset\n    let vowelsIndex = vowelsIndex!\n    let vowelsCount\
    \ = vowels.characters.count\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n        element.lowercaseString.rangeOfString(vowels,\
    \ options: .CaseInsensitiveSearch) != nil\n    }.first?.offset\n    let vowelsIndex\
    \ = vowelsIndex!\n    let vowelsCount = vowels.characters.count\n    let vowelsIndex\
    \ = word.characters.reversed().enumerate().filter { (index, element) -> Bool in\n\
    \        element.lowercaseString.rangeOfString(vowels, options: .CaseInsensitiveSearch)\
    \ != nil\n    }.first?.offset\n    let vowelsIndex = vowelsIndex!\n    let vowelsCount\
    \ = vowels.characters.count\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n        element.lowercaseString.rangeOfString(vowels,\
    \ options: .CaseInsensitiveSearch) != nil\n    }.first?.offset\n    let vowelsIndex\
    \ = vowelsIndex!\n    let vowelsCount = vowels.characters.count\n    let vowelsIndex\
    \ = word.characters.reversed().enumerate().filter { (index, element) -> Bool in\n\
    \        element.lowercaseString.rangeOfString(vowels, options: .CaseInsensitiveSearch)\
    \ != nil\n    }.first?.offset\n    let vowelsIndex = \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp04pm7nv3.swift:59:22: error: expected initial value after '='\n\
    \    let vowelsIndex = \n                     ^\n/tmp/tmp04pm7nv3.swift:18:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelsCount\
    \ = vowels.characters.count\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp04pm7nv3.swift:21:14: error: type of\
    \ expression is ambiguous without more context\n    }.first?.offset\n~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp04pm7nv3.swift:25:30: error: 'characters' is unavailable: Please use String\
    \ directly\n    let vowelsCount = vowels.characters.count\n                  \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp04pm7nv3.swift:25:9: error: invalid redeclaration of 'vowelsCount'\n \
    \   let vowelsCount = vowels.characters.count\n        ^\n/tmp/tmp04pm7nv3.swift:18:9:\
    \ note: 'vowelsCount' previously declared here\n    let vowelsCount = vowels.characters.count\n\
    \        ^\n/tmp/tmp04pm7nv3.swift:28:14: error: type of expression is ambiguous\
    \ without more context\n    }.first?.offset\n~~~~~~~~~~~~~^~~~~~\n/tmp/tmp04pm7nv3.swift:30:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelsCount\
    \ = vowels.characters.count\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp04pm7nv3.swift:30:9: error: invalid redeclaration\
    \ of 'vowelsCount'\n    let vowelsCount = vowels.characters.count\n        ^\n\
    /tmp/tmp04pm7nv3.swift:18:9: note: 'vowelsCount' previously declared here\n  \
    \  let vowelsCount = vowels.characters.count\n        ^\n/tmp/tmp04pm7nv3.swift:33:14:\
    \ error: type of expression is ambiguous without more context\n    }.first?.offset\n\
    ~~~~~~~~~~~~~^~~~~~\n/tmp/tmp04pm7nv3.swift:35:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    le"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word.characters {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    for vowel in vowels {\n        if vowel.hasPrefix(\"A\") {\n            return\
    \ vowel\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfpd3_7eq.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in word.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfpd3_7eq.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if char.value\
    \ > 0x41 && char.value < 0x7A {\n            vowels.append(char.value)\n     \
    \   }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    var vowelIndex\
    \ = 0\n    var vowelIndexEnd = 0\n    var vowelIndexStart = 0\n    for char in\
    \ word.unicodeScalars {\n        if char.value > 0x41 && char.value < 0x7A {\n\
    \            if vowelIndex == 0 {\n                vowelIndexStart = char.value\
    \ - 0x41\n            }\n            if vowelIndexEnd == 0 {\n               \
    \ vowelIndexEnd = char.value - 0x41\n            }\n            if char.value\
    \ == vowels[vowelIndex] {\n                vowelIndex++\n            } else {\n\
    \                vowelIndex = 0\n                vowelIndexEnd = 0\n         \
    \   }\n        }\n    }\n    if vowelIndex == 0 {\n        return \"\"\n    }\n\
    \    if vowelIndexStart > vowelIndexEnd {\n        return \"\"\n    }\n    if\
    \ vowelIndexStart < vowelIndexEnd {\n        return vowels[vowelIndexStart]\n\
    \    }\n    return vowels[vowelIndexEnd]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpif8vqyxu.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpif8vqyxu.swift:32:46: error: cannot\
    \ assign value of type 'UInt32' to type 'Int'\n                vowelIndexStart\
    \ = char.value - 0x41\n                                  ~~~~~~~~~~~^~~~~~\n \
    \                                 Int(             )\n/tmp/tmpif8vqyxu.swift:35:44:\
    \ error: cannot assign value of type 'UInt32' to type 'Int'\n                vowelIndexEnd\
    \ = char.value - 0x41\n                                ~~~~~~~~~~~^~~~~~\n   \
    \                             Int(             )\n/tmp/tmpif8vqyxu.swift:37:27:\
    \ error: binary operator '==' cannot be applied to operands of type 'UInt32' and\
    \ 'String'\n            if char.value == vowels[vowelIndex] {\n              \
    \ ~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~\n/tmp/tmpif8vqyxu.swift:37:27: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (String, String),\
    \ (UInt32, UInt32)\n            if char.value == vowels[vowelIndex] {\n      \
    \                    ^\n/tmp/tmpif8vqyxu.swift:38:27: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                vowelIndex++\n        \
    \                  ^~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if char.value\
    \ > 0x41 && char.value < 0x5A {\n            vowels.append(String(char))\n   \
    \     }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n    let\
    \ vowelsCount = vowels.count\n    var closestVowelIndex: Int = 0\n    var closestVowelDistance:\
    \ Int = 0\n    for index in 0..<vowelsCount {\n        let distance = abs(vowels[index].unicodeScalars.value\
    \ - 0x41)\n        if distance < closestVowelDistance {\n            closestVowelDistance\
    \ = distance\n            closestVowelIndex = index\n        }\n    }\n    return\
    \ vowels[closestVowelIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4sxhzx4b.swift:30:34: error: no exact matches in call to subscript\
    \ \n        let distance = abs(vowels[index].unicodeScalars.value - 0x41)\n  \
    \                               ^\n/tmp/tmp4sxhzx4b.swift:30:34: note: found candidate\
    \ with type '(Range<Int>) -> @lvalue ArraySlice<String>'\n        let distance\
    \ = abs(vowels[index].unicodeScalars.value - 0x41)\n                         \
    \        ^\n/tmp/tmp4sxhzx4b.swift:30:34: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> ArraySlice<String>'\n        let distance = abs(vowels[index].unicodeScalars.value\
    \ - 0x41)\n                                 ^\n/tmp/tmp4sxhzx4b.swift:30:34: note:\
    \ found candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<String>'\n\
    \        let distance = abs(vowels[index].unicodeScalars.value - 0x41)\n     \
    \                            ^\n/tmp/tmp4sxhzx4b.swift:30:42: error: reference\
    \ to member 'unicodeScalars' cannot be resolved without a contextual type\n  \
    \      let distance = abs(vowels[index].unicodeScalars.value - 0x41)\n       \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelFound = false\n\
    \    var vowelIndex2 = -1\n    var vowelFound2 = false\n    var vowelIndex3 =\
    \ -1\n    var vowelFound3 = false\n    var vowelIndex4 = -1\n    var vowelFound4\
    \ = false\n    var vowelIndex5 = -1\n    var vowelFound5 = false\n    var vowelIndex6\
    \ = -1\n    var vowelFound6 = false\n    var vowelIndex7 = -1\n    var vowelFound7\
    \ = false\n    var vowelIndex8 = -1\n    var vowelFound8 = false\n    var vowelIndex9\
    \ = -1\n    var vowelFound9 = false\n    var vowelIndex10 = -1\n    var vowelFound10\
    \ = false\n    var vowelIndex11 = -1\n    var vowelFound11 = false\n    var vowelIndex12\
    \ = -1\n    var vowelFound12 = false\n    var vowelIndex13 = -1\n    var vowelFound13\
    \ = false\n    var vowelIndex14 = -1\n    var vowelFound14 = false\n    var vowelIndex15\
    \ = -1\n    var vowelFound15 = false\n    var vowelIndex16 = -1\n    var vowelFound16\
    \ = false\n    var vowelIndex17 = -1\n    var vowelFound17 = false\n    var vowelIndex18\
    \ = -1\n    var vowelFound18 = false\n    var vowelIndex19 = -1\n    var vowelFound19\
    \ = false\n    var vowelIndex20 = -1\n    var vowelFound20 = false\n    var vowelIndex21\
    \ = -1\n    var vowelFound21 = false\n    var vowelIndex22 = -1\n    var vowelFound22\
    \ = false\n    var vowelIndex23 = -1\n    var vowelFound23 = false\n    var vowelIndex24\
    \ = -1\n    var vowelFound24 = false\n    var vowelIndex25 = -1\n    var vowelFound25\
    \ = false\n    var vowelIndex26 = -1\n    var vowelFound26 = false\n    var vowelIndex27\
    \ = -1\n    var vowelFound27 = false\n    var vowelIndex28 = -1\n    var vowelFound28\
    \ = false\n    var vowelIndex29 = -1\n    var vowelFound29 = false\n    var vowelIndex30\
    \ = -1\n    var vowelFound30 = false\n    var vowelIndex31 = -1\n    var vowelFound31\
    \ = false\n    var vowelIndex32 = -1\n    var vowelFound32 = false\n    var vowelIndex33\
    \ = -1\n    var vowelFound33 = false\n    var vowelIndex34 = -1\n    var vowelFound34\
    \ = false\n    var vowelIndex35 = -1\n    var vowelFound35 = false\n    var vowelIndex36\
    \ = -1\n    var vowelFound36 = false\n    var vowelIndex37 = -1\n    var vowelFound37\
    \ = false\n    var vowelIndex38 = -1\n    var vowelFound38 = false\n    var vowelIndex39\
    \ = -1\n    var vowelFound39 = false\n    var vowelIndex40 = -1\n    var vowelFound40\
    \ = false\n    var vowelIndex41 = -1\n    var vowelFound41 = false\n    var vowelIndex42\
    \ = -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl0o3jmp4.swift:17:9: warning: initialization of immutable value\
    \ 'vowels' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let vowels = \"aeiouAEIOU\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:18:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:19:9: warning: initialization of variable 'vowelFound'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound = false\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:20:9:\
    \ warning: initialization of variable 'vowelIndex2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex2 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:21:9: warning: initialization of variable 'vowelFound2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound2 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:22:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:23:9: warning: initialization of variable 'vowelFound3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound3 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:24:9:\
    \ warning: initialization of variable 'vowelIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex4 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:25:9: warning: initialization of variable 'vowelFound4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound4 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:26:9:\
    \ warning: initialization of variable 'vowelIndex5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex5 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: false)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpre6tar6a.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: false)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.characters {\n        switch char\
    \ {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case\
    \ \"o\":\n        case \"u\":\n            vowels.append(char)\n        }\n  \
    \  }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    vowels.reverse()\n\
    \    vowels.insert(0, \"a\")\n    vowels.append(\"u\")\n    vowels.insert(\"u\"\
    , at: vowels.endIndex)\n    vowels.reverse()\n    \n    let vowelsCount = vowels.count\n\
    \    \n    if vowelsCount < 2 {\n        return \"\"\n    }\n    \n    let vowelsIndex\
    \ = vowels.firstIndex(of: word[word.startIndex])\n    \n    if vowelsIndex ==\
    \ nil {\n        return \"\"\n    }\n    \n    let vowelsIndex2 = vowels.firstIndex(of:\
    \ word[vowelsIndex!.advanced(by: 1)])\n    \n    if vowelsIndex2 == nil {\n  \
    \      return \"\"\n    }\n    \n    let vowelsIndex3 = vowels.firstIndex(of:\
    \ word[vowelsIndex2!.advanced(by: 1)])\n    \n    if vowelsIndex3 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex4 = vowels.firstIndex(of:\
    \ word[vowelsIndex3!.advanced(by: 1)])\n    \n    if vowelsIndex4 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex5 = vowels.firstIndex(of:\
    \ word[vowelsIndex4!.advanced(by: 1)])\n    \n    if vowelsIndex5 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex6 = vowels.firstIndex(of:\
    \ word[vowelsIndex5!.advanced(by: 1)])\n    \n    if vowelsIndex6 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex7 = vowels.firstIndex(of:\
    \ word[vowelsIndex6!.advanced(by: 1)])\n    \n    if vowelsIndex7 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex8 = vowels.firstIndex(of:\
    \ word[vowelsIndex7!.advanced(by: 1)])\n    \n    if vowelsIndex8 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex9 = vowels.firstIndex(of:\
    \ word[vowelsIndex8!.advanced(by: 1)])\n    \n    if vowelsIndex9 == nil {\n \
    \       return \"\"\n    }\n    \n    let vowelsIndex10 = vowels.firstIndex(of:\
    \ word[vowelsIndex9!.advance\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpiysf3t1v.swift:20:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpiysf3t1v.swift:21:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpiysf3t1v.swift:22:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpiysf3t1v.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpiysf3t1v.swift:98:1:\
    \ error: expected ']' in expression list\n}\n^\n/tmp/tmpiysf3t1v.swift:97:51:\
    \ note: to match this opening '['\n    let vowelsIndex10 = vowels.firstIndex(of:\
    \ word[vowelsIndex9!.advance\n                                               \
    \   ^\n/tmp/tmpiysf3t1v.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpiysf3t1v.swift:25:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(char)\n                          ^\n/tmp/tmpiysf3t1v.swift:19:9:\
    \ error: switch must be exhaustive\n        switch char {\n        ^\n/tmp/tmpiysf3t1v.swift:19:9:\
    \ note: do you want to add a default clause?\n        switch char {\n        ^\n\
    /tmp/tmpiysf3t1v.swift:32:12: error: no exact matches in call to instance method\
    \ 'insert'\n    vowels.insert(0, \"a\")\n           ^\n/tmp/tmpiysf3t1v.swift:32:12:\
    \ note: candidate has partially matching parameter list (__owned String, at: Int)\n\
    \    vowels.insert(0, \"a\")\n           ^\n/tmp/tmpiysf3t1v.swift:32:12: note:\
    \ candidate has partially matching parameter list (__owned String, at: Array<String>.Index)\n\
    \    vowels.insert(0, \"a\")\n           ^\n/tmp/tmpiysf3t1v.swi"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters {\n        if vowels.contains(char) {\n            result\
    \ += char\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp8u8_hxxe.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8u8_hxxe.swift:24:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndex2\
    \ = vowels.count\n    \n    var result = \"\"\n    \n    for char in word.characters\
    \ {\n        if vowelIndex < vowelIndex2 {\n            if vowels[vowelIndex]\
    \ == char {\n                vowelIndex++\n            }\n        } else {\n \
    \           if vowels[vowelIndex2] == char {\n                vowelIndex2--\n\
    \            }\n        }\n    }\n    \n    if vowelIndex == 0 {\n        result\
    \ = \"\"\n    } else {\n        result = vowels[vowelIndex-1]\n    }\n    \n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0i76f8fj.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0i76f8fj.swift:27:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if vowels[vowelIndex] == char {\n \
    \              ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp0i76f8fj.swift:28:27: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                vowelIndex++\n        \
    \                  ^~\n/tmp/tmp0i76f8fj.swift:31:16: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if vowels[vowelIndex2] == char {\n               ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0i76f8fj.swift:32:28:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \      vowelIndex2--\n                           ^~\n/tmp/tmp0i76f8fj.swift:40:24:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        result\
    \ = vowels[vowelIndex-1]\n                 ~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ \n    if word.characters.count < 3 {\n        return \"\"\n    }\n    \n   \
    \ let vowelIndex = word.characters.index(word.startIndex, offsetBy: word.characters.count\
    \ - 3)\n    \n    if vowelIndex < 0 {\n        return \"\"\n    }\n    \n    let\
    \ consonantIndex = word.characters.index(vowelIndex, offsetBy: 1)\n    \n    if\
    \ consonantIndex < 0 {\n        return \"\"\n    }\n    \n    let consonants =\
    \ word.substring(to: consonantIndex).lowercased()\n    \n    if consonants.contains(vowels.lowercased())\
    \ {\n        return vowels[vowelIndex]\n    }\n    \n    if consonants.contains(vowels.lowercased()+\"\
    e\") {\n        return vowels[vowelIndex]\n    }\n    \n    if consonants.contains(vowels.lowercased()+\"\
    i\") {\n        return vowels[vowelIndex]\n    }\n    \n    if consonants.contains(vowels.lowercased()+\"\
    o\") {\n        return vowels[vowelIndex]\n    }\n    \n    if consonants.contains(vowels.lowercased()+\"\
    u\") {\n        return vowels[vowelIndex]\n    }\n    \n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpd1t5qssd.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpd1t5qssd.swift:20:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < 3 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd1t5qssd.swift:24:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelIndex\
    \ = word.characters.index(word.startIndex, offsetBy: word.characters.count - 3)\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpd1t5qssd.swift:24:76: error: 'characters' is unavailable:\
    \ Please use String directly\n    let vowelIndex = word.characters.index(word.startIndex,\
    \ offsetBy: word.characters.count - 3)\n                                     \
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd1t5qssd.swift:26:19: error: referencing operator function\
    \ '<' on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    if vowelIndex < 0 {\n                  ^\nSwift.BinaryInteger:1:11: note:\
    \ where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n/tmp/tmpd1t5qssd.swift:30:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    let consonantIndex\
    \ = word.characters.index(vowelIndex, offsetBy: 1)\n                         \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpd1t5qssd.swift:32:23:\
    \ error: referencing operator function '<' on 'Bina"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndex2 = -1\n\
    \    var vowelIndex3 = -1\n    var vowelIndex4 = -1\n    var vowelIndex5 = -1\n\
    \    var vowelIndex6 = -1\n    var vowelIndex7 = -1\n    var vowelIndex8 = -1\n\
    \    var vowelIndex9 = -1\n    var vowelIndex10 = -1\n    var vowelIndex11 = -1\n\
    \    var vowelIndex12 = -1\n    var vowelIndex13 = -1\n    var vowelIndex14 =\
    \ -1\n    var vowelIndex15 = -1\n    var vowelIndex16 = -1\n    var vowelIndex17\
    \ = -1\n    var vowelIndex18 = -1\n    var vowelIndex19 = -1\n    var vowelIndex20\
    \ = -1\n    var vowelIndex21 = -1\n    var vowelIndex22 = -1\n    var vowelIndex23\
    \ = -1\n    var vowelIndex24 = -1\n    var vowelIndex25 = -1\n    var vowelIndex26\
    \ = -1\n    var vowelIndex27 = -1\n    var vowelIndex28 = -1\n    var vowelIndex29\
    \ = -1\n    var vowelIndex30 = -1\n    var vowelIndex31 = -1\n    var vowelIndex32\
    \ = -1\n    var vowelIndex33 = -1\n    var vowelIndex34 = -1\n    var vowelIndex35\
    \ = -1\n    var vowelIndex36 = -1\n    var vowelIndex37 = -1\n    var vowelIndex38\
    \ = -1\n    var vowelIndex39 = -1\n    var vowelIndex40 = -1\n    var vowelIndex41\
    \ = -1\n    var vowelIndex42 = -1\n    var vowelIndex43 = -1\n    var vowelIndex44\
    \ = -1\n    var vowelIndex45 = -1\n    var vowelIndex46 = -1\n    var vowelIndex47\
    \ = -1\n    var vowelIndex48 = -1\n    var vowelIndex49 = -1\n    var vowelIndex50\
    \ = -1\n    var vowelIndex51 = -1\n    var vowelIndex52 = -1\n    var vowelIndex53\
    \ = -1\n    var vowelIndex54 = -1\n    var vowelIndex55 = -1\n    var vowelIndex56\
    \ = -1\n    var vowelIndex57 = -1\n    var vowelIndex58 = -1\n    var vowelIndex59\
    \ = -1\n    var vowelIndex60 = -1\n    var vowelIndex61 = -1\n    var vowelIndex62\
    \ = -1\n    var vowelIndex63 = -1\n    var vowelIndex64 = -1\n    var vowelIndex65\
    \ = -1\n    var vowelIndex66 = -1\n    var vowelIndex67 = -1\n    var vowelIndex68\
    \ = -1\n    var vowelIndex69 = -1\n    var vowelIndex70 = -1\n    var vowelIndex71\
    \ = -1\n    var vowelIndex72 = -1\n    var vowelIndex73 = -1\n    var vowelIndex74\
    \ = -1\n    var vowelIndex75 = -1\n    var vowelIndex76 = -1\n    var vowelIndex77\
    \ = -1\n    var vowelIndex78 = -1\n    var vowelIndex79 = -1\n    var vowelIndex80\
    \ = -1\n    var vowelIndex81 = -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkp1istqo.swift:17:9: warning: initialization of variable 'vowels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowels = \"aeiouAEIOU\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpkp1istqo.swift:18:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1istqo.swift:19:9: warning: initialization of variable 'vowelIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex2 = -1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpkp1istqo.swift:20:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1istqo.swift:21:9: warning: initialization of variable 'vowelIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex4 = -1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpkp1istqo.swift:22:9:\
    \ warning: initialization of variable 'vowelIndex5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex5 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1istqo.swift:23:9: warning: initialization of variable 'vowelIndex6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex6 = -1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpkp1istqo.swift:24:9:\
    \ warning: initialization of variable 'vowelIndex7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex7 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1istqo.swift:25:9: warning: initialization of variable 'vowelIndex8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelIndex8 = -1\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpkp1istqo.swift:26:9:\
    \ warning: initialization of variable 'vowelIndex9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex9 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpkp1istqo.swift:27:9"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if char.lowercased() == vowels.first {\n       \
    \     return index\n        }\n        return nil\n    }.compactMap { (index)\
    \ -> Int? in\n        return index\n    }.sorted()\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    if vowelsCount == 1 {\n        return vowels[vowelsIndex!]\n\
    \    }\n    if vowelsIndex!.first == vowelsIndex!.last {\n        return vowels[vowelsIndex!.first]\n\
    \    }\n    if vowelsIndex!.first == vowelsIndex!.last-1 {\n        return vowels[vowelsIndex!.first-1]\n\
    \    }\n    if vowelsIndex!.first == vowelsIndex!.last+1 {\n        return vowels[vowelsIndex!.first+1]\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7h_1ub_5.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp7h_1ub_5.swift:21:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                 ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter == \"a\"\
    \ || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\"\
    \ {\n            vowels.append(letter)\n        }\n    }\n    if vowels.count\
    \ < 2 {\n        return \"\"\n    }\n    var vowelIndex = 0\n    var vowelIndex2\
    \ = vowels.count - 1\n    var vowelIndex3 = vowels.count - 2\n    var vowelIndex4\
    \ = vowels.count - 3\n    var vowelIndex5 = vowels.count - 4\n    var vowelIndex6\
    \ = vowels.count - 5\n    var vowelIndex7 = vowels.count - 6\n    var vowelIndex8\
    \ = vowels.count - 7\n    var vowelIndex9 = vowels.count - 8\n    var vowelIndex10\
    \ = vowels.count - 9\n    var vowelIndex11 = vowels.count - 10\n    var vowelIndex12\
    \ = vowels.count - 11\n    var vowelIndex13 = vowels.count - 12\n    var vowelIndex14\
    \ = vowels.count - 13\n    var vowelIndex15 = vowels.count - 14\n    var vowelIndex16\
    \ = vowels.count - 15\n    var vowelIndex17 = vowels.count - 16\n    var vowelIndex18\
    \ = vowels.count - 17\n    var vowelIndex19 = vowels.count - 18\n    var vowelIndex20\
    \ = vowels.count - 19\n    var vowelIndex21 = vowels.count - 20\n    var vowelIndex22\
    \ = vowels.count - 21\n    var vowelIndex23 = vowels.count - 22\n    var vowelIndex24\
    \ = vowels.count - 23\n    var vowelIndex25 = vowels.count - 24\n    var vowelIndex26\
    \ = vowels.count - 25\n    var vowelIndex27 = vowels.count - 26\n    var vowelIndex28\
    \ = vowels.count - 27\n    var vowelIndex29 = vowels.count - 28\n    var vowelIndex30\
    \ = vowels.count - 29\n    var vowelIndex31 = vowels.count - 30\n    var vowelIndex32\
    \ = vowels.count - 31\n    var vowelIndex33 = vowels.count - 32\n    var vowelIndex34\
    \ = vowels.count - 33\n    var vowelIndex35 = vowels.count - 34\n    var vowelIndex36\
    \ = vowels.count - 35\n    var vowelIndex37 = vowels.count - 36\n    var vowelIndex38\
    \ = vowels.count - 37\n    var vowelIndex39 = vowels.count - 38\n    var vowelIndex40\
    \ = vowels.count - 39\n    var vowelIndex41 = vowels.count - 40\n    var vowelIndex42\
    \ = vowels.count - 41\n    var vowelIndex43 = vowels.count - 42\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpc29l1emz.swift:20:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelIndex: Int = 0\n    var vowelIndex2: Int\
    \ = 0\n    var vowelIndex3: Int = 0\n    var vowelIndex4: Int = 0\n    var vowelIndex5:\
    \ Int = 0\n    var vowelIndex6: Int = 0\n    var vowelIndex7: Int = 0\n    var\
    \ vowelIndex8: Int = 0\n    var vowelIndex9: Int = 0\n    var vowelIndex10: Int\
    \ = 0\n    var vowelIndex11: Int = 0\n    var vowelIndex12: Int = 0\n    var vowelIndex13:\
    \ Int = 0\n    var vowelIndex14: Int = 0\n    var vowelIndex15: Int = 0\n    var\
    \ vowelIndex16: Int = 0\n    var vowelIndex17: Int = 0\n    var vowelIndex18:\
    \ Int = 0\n    var vowelIndex19: Int = 0\n    var vowelIndex20: Int = 0\n    var\
    \ vowelIndex21: Int = 0\n    var vowelIndex22: Int = 0\n    var vowelIndex23:\
    \ Int = 0\n    var vowelIndex24: Int = 0\n    var vowelIndex25: Int = 0\n    var\
    \ vowelIndex26: Int = 0\n    var vowelIndex27: Int = 0\n    var vowelIndex28:\
    \ Int = 0\n    var vowelIndex29: Int = 0\n    var vowelIndex30: Int = 0\n    var\
    \ vowelIndex31: Int = 0\n    var vowelIndex32: Int = 0\n    var vowelIndex33:\
    \ Int = 0\n    var vowelIndex34: Int = 0\n    var vowelIndex35: Int = 0\n    var\
    \ vowelIndex36: Int = 0\n    var vowelIndex37: Int = 0\n    var vowelIndex38:\
    \ Int = 0\n    var vowelIndex39: Int = 0\n    var vowelIndex40: Int = 0\n    var\
    \ vowelIndex41: Int = 0\n    var vowelIndex42: Int = 0\n    var vowelIndex43:\
    \ Int = 0\n    var vowelIndex44: Int = 0\n    var vowelIndex45: Int = 0\n    var\
    \ vowelIndex46: Int = 0\n    var vowelIndex47: Int = 0\n    var vowelIndex48:\
    \ Int = 0\n    var vowelIndex49: Int = 0\n    var vowelIndex50: Int = 0\n    var\
    \ vowelIndex51: Int = 0\n    var vowelIndex52: Int = 0\n    var vowelIndex53:\
    \ Int = 0\n    var vowelIndex54: Int = 0\n    var vowelIndex55: Int = 0\n    var\
    \ vowelIndex56: Int = 0\n    var vowelIndex57: Int = 0\n    var vowelIndex58:\
    \ Int = 0\n    var vowelIndex59: Int = 0\n    var vowelIndex60: Int = 0\n    var\
    \ vowelIndex61: Int = 0\n    var vowelIndex62: Int = 0\n    var vowelIndex63:\
    \ Int = 0\n    var vowelIndex64: Int = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpkky1xobv.swift:17:9: warning: variable 'vowels' was never used;\
    \ consider replacing with '_' or removing it\n    var vowels: [String] = []\n\
    \        ^~~~~~\n        _\n/tmp/tmpkky1xobv.swift:18:9: warning: variable 'vowelIndex'\
    \ was never used; consider replacing with '_' or removing it\n    var vowelIndex:\
    \ Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:19:9: warning:\
    \ variable 'vowelIndex2' was never used; consider replacing with '_' or removing\
    \ it\n    var vowelIndex2: Int = 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:20:9:\
    \ warning: variable 'vowelIndex3' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelIndex3: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpkky1xobv.swift:21:9: warning: variable 'vowelIndex4' was never used; consider\
    \ replacing with '_' or removing it\n    var vowelIndex4: Int = 0\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmpkky1xobv.swift:22:9: warning: variable 'vowelIndex5' was never\
    \ used; consider replacing with '_' or removing it\n    var vowelIndex5: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:23:9: warning: variable\
    \ 'vowelIndex6' was never used; consider replacing with '_' or removing it\n \
    \   var vowelIndex6: Int = 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:24:9:\
    \ warning: variable 'vowelIndex7' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelIndex7: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpkky1xobv.swift:25:9: warning: variable 'vowelIndex8' was never used; consider\
    \ replacing with '_' or removing it\n    var vowelIndex8: Int = 0\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmpkky1xobv.swift:26:9: warning: variable 'vowelIndex9' was never\
    \ used; consider replacing with '_' or removing it\n    var vowelIndex9: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:27:9: warning: variable\
    \ 'vowelIndex10' was never used; consider replacing with '_' or removing it\n\
    \    var vowelIndex10: Int = 0\n        ^~~~~~~~~~~~\n        _\n/tmp/tmpkky1xobv.swift:28:9:\
    \ warning: variable 'vowelIndex11' was never used; consider r"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word.characters {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.sortInPlace()\n\
    \    var result: String = \"\"\n    for vowel in vowels {\n        if word.characters.count\
    \ > vowel.characters.count {\n            continue\n        }\n        if word.characters.count\
    \ < vowel.characters.count {\n            break\n        }\n        if word.characters.count\
    \ > vowel.characters.count {\n            result = vowel\n            break\n\
    \        }\n        if word.characters.count < vowel.characters.count {\n    \
    \        result = vowel\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp32vitgc7.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in word.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp32vitgc7.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp32vitgc7.swift:23:12:\
    \ error: value of type '[String]' has no member 'sortInPlace'\n    vowels.sortInPlace()\n\
    \    ~~~~~~ ^~~~~~~~~~~\n/tmp/tmp32vitgc7.swift:26:17: error: 'characters' is\
    \ unavailable: Please use String directly\n        if word.characters.count >\
    \ vowel.characters.count {\n                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp32vitgc7.swift:26:42: error: 'characters'\
    \ is unavailable: Please use String directly\n        if word.characters.count\
    \ > vowel.characters.count {\n                                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp32vitgc7.swift:29:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.count\
    \ < vowel.characters.count {\n                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp32vitgc7.swift:29:42: error: 'characters'\
    \ is unavailable: Please use String directly\n        if word.characters.count\
    \ < vowel.characters.count {\n                                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp32vitgc7.swift:32:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.count\
    \ > vowel.characters.count {\n         "
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountMax:\
    \ Int = vowels.count\n    var vowelsCountMin: Int = vowels.count - 1\n    var\
    \ vowelsCountSum: Int = 0\n    var vowelsCountSumMax: Int = 0\n    var vowelsCountSumMin:\
    \ Int = 0\n    var vowelsCountSumSum: Int = 0\n    var vowelsCountSumSumMax: Int\
    \ = 0\n    var vowelsCountSumSumMin: Int = 0\n    var vowelsCountSumSumSum: Int\
    \ = 0\n    var vowelsCountSumSumSumMax: Int = 0\n    var vowelsCountSumSumSumMin:\
    \ Int = 0\n    var vowelsCountSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumMax:\
    \ Int = 0\n    var vowelsCountSumSumSumSumMin: Int = 0\n    var vowelsCountSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumMax: Int = 0\n    var vowelsCountSumSumSumSumSumMin:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumMax:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumMin: Int = 0\n    var vowelsCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumMax: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumMin:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSum: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumMax:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumMin: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumSumMax: Int = 0\n    var\
    \ vowelsCountSumSumSumSumSumSumSumSumSumMin: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumSumSumMax: Int = 0\n   \
    \ var vowelsCountSumSumSumSumSumSumSumSumSumMin: Int = 0\n    var vowelsCountSumSumSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var vowelsCountSumSumSumSumSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpd658roaj.swift:51:9: error: invalid redeclaration of 'vowelsCountSumSumSumSumSumSumSumSumSumMin'\n\
    \    var vowelsCountSumSumSumSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpd658roaj.swift:48:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumSumSumMin' previously declared here\n\
    \    var vowelsCountSumSumSumSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpd658roaj.swift:52:9:\
    \ error: invalid redeclaration of 'vowelsCountSumSumSumSumSumSumSumSumSumSum'\n\
    \    var vowelsCountSumSumSumSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpd658roaj.swift:49:9:\
    \ note: 'vowelsCountSumSumSumSumSumSumSumSumSumSum' previously declared here\n\
    \    var vowelsCountSumSumSumSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpd658roaj.swift:53:9:\
    \ error: type annotation missing in pattern\n    var vowelsCountSumSumSumSumSum\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    \n    var vowelsCount = 0\n    \n    for char in word.characters {\n    \
    \    if vowels.contains(char) {\n            vowelsCount += 1\n        }\n   \
    \ }\n    \n    if vowelsCount < 2 {\n        return \"\"\n    }\n    \n    var\
    \ vowelsCount = 0\n    \n    for char in word.characters {\n        if vowels.contains(char)\
    \ {\n            vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    \n    var vowelsCount = 0\n    \n   \
    \ for char in word.characters {\n        if vowels.contains(char) {\n        \
    \    vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount < 2 {\n    \
    \    return \"\"\n    }\n    \n    var vowelsCount = 0\n    \n    for char in\
    \ word.characters {\n        if vowels.contains(char) {\n            vowelsCount\
    \ += 1\n        }\n    }\n    \n    if vowelsCount < 2 {\n        return \"\"\n\
    \    }\n    \n    var vowelsCount = 0\n    \n    for char in word.characters {\n\
    \        if vowels.contains(char) {\n            vowelsCount += 1\n        }\n\
    \    }\n    \n    if vowelsCount < 2 {\n        return \"\"\n    }\n    \n   \
    \ var vowelsCount = 0\n    \n    for char in word.characters {\n        if vowels.contains(char)\
    \ {\n            vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    \n    var vowelsCount = 0\n    \n   \
    \ for char in word.characters {\n        if vowels.contains(char) {\n        \
    \    vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount < 2 {\n    \
    \    return \"\"\n    }\n    \n    var vowelsCount = 0\n    \n    for char in\
    \ word.characters {\n        if vowels.contains(char) {\n            vowelsCount\
    \ += 1\n        }\n    }\n    \n    if vowelsCount < 2 {\n        return \"\"\n\
    \    }\n    \n    var vowelsCount = 0\n    \n    for char in word.characters {\n\
    \        if vowels.contains(char) {\n            vowelsCount += 1\n        }\n\
    \    }\n    \n    if vowelsCount < 2 {\n        return \"\"\n    }\n    \n   \
    \ var vowelsCount = 0\n    \n    for char in word.characters {\n        if vowels.contains(char)\
    \ {\n            vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    \n    var vowelsCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp08xr82my.swift:26:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp08xr82my.swift:27:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmp08xr82my.swift:36:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n   \
    \     ^\n/tmp/tmp08xr82my.swift:24:9: note: 'vowelsCount' previously declared\
    \ here\n    var vowelsCount = 0\n        ^\n/tmp/tmp08xr82my.swift:38:22: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in word.characters\
    \ {\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp08xr82my.swift:39:28: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n        if vowels.contains(char)\
    \ {\n                           ^\n/tmp/tmp08xr82my.swift:48:9: error: invalid\
    \ redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n        ^\n/tmp/tmp08xr82my.swift:24:9:\
    \ note: 'vowelsCount' previously declared here\n    var vowelsCount = 0\n    \
    \    ^\n/tmp/tmp08xr82my.swift:50:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp08xr82my.swift:51:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmp08xr82my.swift:60:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n   \
    \     ^\n/tmp/tmp08xr82my.swift:24:9: note: 'vowelsCount' previously declared\
    \ here\n    var vowelsCount = 0\n        ^\n/tmp/"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    let vowelsArrayCount = vowelsArray.count\n\
    \    var vowelIndex = 0\n    var vowelCount = 0\n    var consonantIndex = 0\n\
    \    var consonantCount = 0\n    var consonantArray = word.characters\n    var\
    \ consonantArrayCount = consonantArray.count\n    var closestVowel = \"\"\n  \
    \  var closestVowelIndex = 0\n    var closestVowelCount = 0\n    var closestConsonantIndex\
    \ = 0\n    var closestConsonantCount = 0\n    var closestConsonantArray = word.characters\n\
    \    var closestConsonantArrayCount = closestConsonantArray.count\n    \n    while\
    \ vowelIndex < vowelsArrayCount {\n        if consonantIndex < consonantArrayCount\
    \ {\n            if vowelsArray[vowelIndex] == consonantArray[consonantIndex]\
    \ {\n                vowelIndex += 1\n                consonantIndex += 1\n  \
    \          } else {\n                vowelIndex += 1\n            }\n        }\
    \ else {\n            vowelIndex += 1\n        }\n    }\n    while consonantIndex\
    \ < consonantArrayCount {\n        if vowelIndex < vowelsArrayCount {\n      \
    \      if vowelsArray[vowelIndex] == consonantArray[consonantIndex] {\n      \
    \          consonantIndex += 1\n            } else {\n                consonantIndex\
    \ += 1\n            }\n        } else {\n            consonantIndex += 1\n   \
    \     }\n    }\n    while consonantIndex < consonantArrayCount {\n        if vowelIndex\
    \ < vowelsArrayCount {\n            if vowelsArray[vowelIndex] == consonantArray[consonantIndex]\
    \ {\n                consonantIndex += 1\n            } else {\n             \
    \   consonantIndex += 1\n            }\n        } else {\n            consonantIndex\
    \ += 1\n        }\n    }\n    while consonantIndex < consonantArrayCount {\n \
    \       if vowelIndex < vowelsArrayCount {\n            if vowelsArray[vowelIndex]\
    \ == consonantArray[consonantIndex] {\n                consonantIndex += 1\n \
    \           } else {\n                consonantIndex += 1\n            }\n   \
    \     } else {\n            consonantIndex += 1\n        }\n    }\n    while consonantIndex\
    \ < consonantArrayCount {\n        if vowelIndex < vowelsArrayCount {\n      \
    \      if vowelsArray[vowelIndex] == consonantArray[consonantIndex] {\n      \
    \          consonantIndex += 1\n            } else {\n                consonantIndex\
    \ += 1\n            }\n        } else {\n            consonantIndex += 1\n   \
    \     }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpf0p0stt3.swift:118:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpf0p0stt3.swift:16:48: note: to match this opening\
    \ '{'\nfunc get_closest_vowel(word: String) -> String {\n                    \
    \                           ^\n/tmp/tmpf0p0stt3.swift:18:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    let vowelsCount = vowels.characters.count\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf0p0stt3.swift:19:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    let vowelsArray = vowels.characters\n      \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpf0p0stt3.swift:25:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var consonantArray = word.characters\n     \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpf0p0stt3.swift:32:38: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closestConsonantArray = word.characters\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf0p0stt3.swift:37:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if vowelsArray[vowelIndex] == consonantArray[consonantIndex] {\n         \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpf0p0stt3.swift:37:43: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript Stri"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.index(of: char) {\n      \
    \      return index\n        }\n        return nil\n    }.compactMap { $0 }\n\
    \    guard vowelsIndex.count > 0 else {\n        return \"\"\n    }\n    let vowelsIndex\
    \ = vowelsIndex.sorted()\n    let vowelsCount = vowelsIndex.count\n    if vowelsCount\
    \ > vowelsIndex.count {\n        return \"\"\n    }\n    let vowelsIndex = vowelsIndex.first!\n\
    \    let vowelsIndex = vowelsIndex.last!\n    let vowelsIndex = vowelsIndex.successor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n    let vowelsIndex = vowelsIndex.predecessor()\n\
    \    let vowelsIndex = vowelsIndex.predecessor()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpi1pxbapt.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpi1pxbapt.swift:21:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n                                                 ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    let vowelsArrayCount = vowelsArray.count\n\
    \    let vowelsArrayIndex = vowelsArray.index(of: vowels.characters.last!)!\n\
    \    let vowelsArrayLastIndex = vowelsArray.index(of: vowels.characters.first!)!\n\
    \    let vowelsArrayLast = vowelsArray[vowelsArrayLastIndex]\n    let vowelsArrayFirst\
    \ = vowelsArray[vowelsArrayIndex]\n    let vowelsArrayFirstIndex = vowelsArray.index(of:\
    \ vowelsArrayFirst)!\n    let vowelsArrayFirstLastIndex = vowelsArray.index(of:\
    \ vowelsArrayLast)!\n    let vowelsArrayFirstLast = vowelsArray[vowelsArrayFirstLastIndex]\n\
    \    let vowelsArrayFirstFirstIndex = vowelsArray.index(of: vowelsArrayFirst)!\n\
    \    let vowelsArrayFirstFirstLastIndex = vowelsArray.index(of: vowelsArrayFirstLast)!\n\
    \    let vowelsArrayFirstFirstLast = vowelsArray[vowelsArrayFirstFirstLastIndex]\n\
    \    let vowelsArrayFirstFirstFirstLastIndex = vowelsArray.index(of: vowelsArrayFirstFirstLast)!\n\
    \    let vowelsArrayFirstFirstFirstLast = vowelsArray[vowelsArrayFirstFirstFirstLastIndex]\n\
    \    let vowelsArrayFirstFirstFirstFirstLastIndex = vowelsArray.index(of: vowelsArrayFirstFirstFirstLast)!\n\
    \    let vowelsArrayFirstFirstFirstFirstLast = vowelsArray[vowelsArrayFirstFirstFirstLastIndex]\n\
    \    let vowelsArrayFirstFirstFirstFirstLastFirstIndex = vowelsArray.index(of:\
    \ vowelsArrayFirstFirstFirstLast)!\n    let vowelsArrayFirstFirstFirstFirstLastFirst\
    \ = vowelsArray[vowelsArrayFirstFirstFirstLastIndex]\n    let vowelsArrayFirstFirstFirstFirstLastFirstFirstIndex\
    \ = vowelsArray.index(of: vowelsArrayFirstFirstFirstLast)!\n    let vowelsArrayFirstFirstFirstFirstLastFirstFirst\
    \ = vowelsArray[vowelsArrayFirstFirstFirstLastIndex]\n    let vowelsArrayFirstFirstFirstFirstLastFirstFirstFirstIndex\
    \ = vowelsArray.index(of: vowelsArrayFirstFirstFirstLast)!\n    let vowelsArrayFirstFirstFirstFirstLastFirstFirstFirst\
    \ = vowelsArray[vowelsArrayFirstFirstFirstLastIndex]\n    let vowelsArrayFirstFirstFirstFirstLastFirstFirstFirstFirstIndex\
    \ = vowelsArray.index(of: vowelsArrayFirstFirstFirstLast)!\n    let \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1obs9yx3.swift:42:8: error: expected pattern\n    let \n      \
    \ ^\n/tmp/tmp1obs9yx3.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1obs9yx3.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsArray = vowels.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1obs9yx3.swift:21:40: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let vowelsArrayIndex = vowelsArray.index(of: vowels.characters.last!)!\n\
    \                                       ^\n/tmp/tmp1obs9yx3.swift:21:40: note:\
    \ use 'firstIndex(of:)' instead\n    let vowelsArrayIndex = vowelsArray.index(of:\
    \ vowels.characters.last!)!\n                                       ^~~~~\n  \
    \                                     firstIndex\n/tmp/tmp1obs9yx3.swift:21:57:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowelsArrayIndex\
    \ = vowelsArray.index(of: vowels.characters.last!)!\n                        \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1obs9yx3.swift:22:44: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    let vowelsArrayLastIndex = vowelsArray.index(of:\
    \ vowels.characters.first!)!\n                                           ^\n/tmp/tmp1obs9yx3.swift:22:44:\
    \ note: use 'firstIndex(of:)' instead\n    let vowelsArrayLastIndex = vowelsArray.index(of:\
    \ vowels.characters.first!)!\n                                           ^~~~~\n\
    \                                           firstIndex\n/tmp/tmp1obs9yx3.swift:22:61:\
    \ error: 'characters' is unavailable: Please use String dire"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    for\
    \ char in word.characters {\n        if vowels.contains(char) {\n            vowelIndex\
    \ = vowels.firstIndex(of: char)\n            break\n        }\n    }\n    \n \
    \   if vowelIndex == 0 {\n        return \"\"\n    }\n    \n    let vowelIndex\
    \ = vowelIndex - 1\n    \n    let consonantIndex = (word.characters.count - 1)\
    \ - vowelIndex\n    \n    let consonants = word.characters[consonantIndex..<word.characters.count]\n\
    \    \n    let vowels = vowels[vowelIndex..<vowels.count]\n    \n    if consonants.contains(vowels.first!)\
    \ {\n        return vowels.first!\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpdcbrbru_.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdcbrbru_.swift:24:33:\
    \ error: cannot assign value of type 'String.Index?' to type 'Int'\n         \
    \   vowelIndex = vowels.firstIndex(of: char)\n                         ~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdcbrbru_.swift:33:9: error: invalid redeclaration of 'vowelIndex'\n  \
    \  let vowelIndex = vowelIndex - 1\n        ^\n/tmp/tmpdcbrbru_.swift:20:9: note:\
    \ 'vowelIndex' previously declared here\n    var vowelIndex = 0\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels = vowels.filter{ (vowel) -> Bool in\n      \
    \  let vowel = vowel.lowercaseString\n        let index = word.lowercaseString.index(vowel,\
    \ range: NSMakeRange(0, word.characters.count))\n        return index != nil\n\
    \    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    let vowel = vowels.sorted().first!\n\
    \    let index = word.lowercaseString.index(vowel, range: NSMakeRange(0, word.characters.count))\n\
    \    return word.substringToIndex(index)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjl54a3if.swift:20:62: error: cannot find 'NSMakeRange' in scope\n\
    \        let index = word.lowercaseString.index(vowel, range: NSMakeRange(0, word.characters.count))\n\
    \                                                             ^~~~~~~~~~~\n/tmp/tmpjl54a3if.swift:27:58:\
    \ error: cannot find 'NSMakeRange' in scope\n    let index = word.lowercaseString.index(vowel,\
    \ range: NSMakeRange(0, word.characters.count))\n                            \
    \                             ^~~~~~~~~~~\n/tmp/tmpjl54a3if.swift:27:22: error:\
    \ value of type 'String' has no member 'lowercaseString'\n    let index = word.lowercaseString.index(vowel,\
    \ range: NSMakeRange(0, word.characters.count))\n                ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpjl54a3if.swift:28:17: error: value of type 'String' has no member 'substringToIndex'\n\
    \    return word.substringToIndex(index)\n           ~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"A\")\n    vowels.insert(\"E\")\n    vowels.insert(\"I\"\
    )\n    vowels.insert(\"O\")\n    vowels.insert(\"U\")\n    \n    var vowelsCount\
    \ = vowels.count\n    \n    var index = word.characters.count - 1\n    \n    var\
    \ currentVowel = \"\"\n    \n    while index >= 0 {\n        let char = word.characters[index]\n\
    \        \n        if vowels.contains(char) {\n            currentVowel = char\n\
    \            \n            if vowelsCount > 1 {\n                vowelsCount -=\
    \ 1\n            }\n            \n            if vowelsCount == 0 {\n        \
    \        break\n            }\n            \n            index -= 1\n        }\
    \ else {\n            index -= 1\n        }\n    }\n    \n    return currentVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnll0cpor.swift:31:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var index = word.characters.count - 1\n           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpnll0cpor.swift:36:20: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let char = word.characters[index]\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpnll0cpor.swift:36:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        let char = word.characters[index]\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnll0cpor.swift:39:28: error: cannot assign value of type\
    \ 'Character' to type 'String'\n            currentVowel = char\n            \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let vowelsCount = vowels.count\n    let vowelsIndexes\
    \ = vowels.indices.sorted()\n    var vowelIndex = 0\n    var vowelsCount = 0\n\
    \    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowelsIndexes = [Int]()\n    var vowelsCount\
    \ = 0\n    var vowelsIndex = 0\n    var vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmnm9smeb.swift:21:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    var vowelsCount = 0\n        ^\n/tmp/tmpmnm9smeb.swift:18:9: note: 'vowelsCount'\
    \ previously declared here\n    let vowelsCount = vowels.count\n        ^\n/tmp/tmpmnm9smeb.swift:23:9:\
    \ error: invalid redeclaration of 'vowelsIndexes'\n    var vowelsIndexes = [Int]()\n\
    \        ^\n/tmp/tmpmnm9smeb.swift:19:9: note: 'vowelsIndexes' previously declared\
    \ here\n    let vowelsIndexes = vowels.indices.sorted()\n        ^\n/tmp/tmpmnm9smeb.swift:24:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n   \
    \     ^\n/tmp/tmpmnm9smeb.swift:18:9: note: 'vowelsCount' previously declared\
    \ here\n    let vowelsCount = vowels.count\n        ^\n/tmp/tmpmnm9smeb.swift:25:9:\
    \ error: invalid redeclaration of 'vowelsIndex'\n    var vowelsIndex = 0\n   \
    \     ^\n/tmp/tmpmnm9smeb.swift:22:9: note: 'vowelsIndex' previously declared\
    \ here\n    var vowelsIndex = 0\n        ^\n/tmp/tmpmnm9smeb.swift:26:9: error:\
    \ invalid redeclaration of 'vowelsIndexes'\n    var vowelsIndexes = [Int]()\n\
    \        ^\n/tmp/tmpmnm9smeb.swift:19:9: note: 'vowelsIndexes' previously declared\
    \ here\n    let vowelsIndexes = vowels.indices.sorted()\n        ^\n/tmp/tmpmnm9smeb.swift:27:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n   \
    \     ^\n/tmp/tmpmnm9smeb.swift:18:9: note: 'vowelsCount' previously declared\
    \ here\n    let vowelsCount = vowels.count\n        ^\n/tmp/tmpmnm9smeb.swift:28:9:\
    \ error: invalid redeclaration of 'vowelsIndex'\n    var vowelsIndex = 0\n   \
    \     ^\n/tmp/tmpmnm9smeb.swift:22:9: note: 'vowelsIndex' previously declared\
    \ here\n    var vowelsIndex = 0\n        ^\n/tmp/tmpmnm9smeb.swift:29:9: error:\
    \ invalid redeclaration of 'vowelsIndexes'\n    var vowelsIndexes = [Int]()\n\
    \        ^\n/tmp/tmpmnm9smeb.swift:19:9: note: 'vowelsIndexes' previously declared\
    \ here\n    let vowelsIndexes = vowels.indices.sorted()\n        ^\n/tmp/tmpmnm9smeb.swift:30:9:\
    \ error: invalid redeclaration of 'vowelsCount'\n    var vowelsCount = 0\n   \
    \     ^\n/tmp/tmpmnm9smeb.swift:18:9: note: 'vowelsCount' previously de"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.characters {\n        if char.unicodeScalars.contains(.vowel)\
    \ {\n            vowels.append(char.unicodeScalars.first!)\n        }\n    }\n\
    \    if vowels.isEmpty {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n\
    \    if vowelsCount == 1 {\n        return vowels[0]\n    }\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount\
    \ = vowels.count\n    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n\
    \    let vowelsCount = vowels.count\n    let vowelsCount = vowels.count\n    let\
    \ vowelsCount = vowels.count\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2c40dtla.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp2c40dtla.swift:19:42:\
    \ error: type 'Unicode.Scalar' has no member 'vowel'\n        if char.unicodeScalars.contains(.vowel)\
    \ {\n                                        ~^~~~~\n/tmp/tmp2c40dtla.swift:20:20:\
    \ error: no exact matches in call to instance method 'append'\n            vowels.append(char.unicodeScalars.first!)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public\
    \ mutating func append(_ newElement: __owned Self.Element)\n                 \
    \                   ^\n/tmp/tmp2c40dtla.swift:20:20: note: found candidate with\
    \ type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char.unicodeScalars.first!)\n\
    \                   ^\n/tmp/tmp2c40dtla.swift:30:9: error: invalid redeclaration\
    \ of 'vowelsCount'\n    let vowelsCount = vowels.count\n        ^\n/tmp/tmp2c40dtla.swift:26:9:\
    \ note: 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp2c40dtla.swift:31:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp2c40dtla.swift:26:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp2c40dtla.swift:32:9: error: invalid redeclaration of 'vowelsCount'\n\
    \    let vowelsCount = vowels.count\n        ^\n/tmp/tmp2c40dtla.swift:26:9: note:\
    \ 'vowelsCount' previously declared here\n    let vowelsCount = vowels.count\n\
    \        ^\n/tmp/tmp2c40dtla.swift:33:9: error: invalid redeclaration of 'vowelsCou"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount: Int = 0\n    \n  \
    \  for char in word.characters {\n        if vowels.contains(char) {\n       \
    \     vowelsCount += 1\n        }\n    }\n    \n    if vowelsCount < 2 {\n   \
    \     return \"\"\n    }\n    \n    var vowelsIndex: Int = 0\n    var vowelsCountIndex:\
    \ Int = 0\n    \n    for char in word.characters {\n        if vowels.contains(char)\
    \ {\n            if vowelsCount > vowelsIndex {\n                vowelsIndex =\
    \ vowelsCountIndex\n            }\n            vowelsCountIndex += 1\n       \
    \ }\n    }\n    \n    if vowelsCount > vowelsIndex {\n        return \"\"\n  \
    \  }\n    \n    if vowelsIndex == 0 {\n        return vowels[vowelsIndex - 1]\n\
    \    }\n    \n    if vowelsIndex == vowels.count - 1 {\n        return vowels[vowelsIndex\
    \ + 1]\n    }\n    \n    if vowelsIndex == vowels.count - 2 {\n        return\
    \ vowels[vowelsIndex + 2]\n    }\n    \n    if vowelsIndex == vowels.count - 3\
    \ {\n        return vowels[vowelsIndex + 3]\n    }\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpppfz1ogo.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpppfz1ogo.swift:25:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpppfz1ogo.swift:37:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in word.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpppfz1ogo.swift:38:28: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        if vowels.contains(char)\
    \ {\n                           ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelsCount = vowels.characters.count\n\
    \    \n    if word.characters.count < vowelsCount {\n        return \"\"\n   \
    \ }\n    \n    let vowelsIndex = word.characters.reversed().index(of: vowels)\n\
    \    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n    let vowelsCount\
    \ = word.characters.count - vowelsIndex\n    \n    if vowelsCount < 2 {\n    \
    \    return \"\"\n    }\n    \n    let vowelsIndex = word.characters.reversed().index(of:\
    \ vowels, in: vowelsIndex..<vowelsIndex + vowelsCount)\n    \n    if vowelsIndex\
    \ == word.characters.count - 1 {\n        return \"\"\n    }\n    \n    return\
    \ word.substring(to: vowelsIndex + vowelsCount)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vxlosyc.swift:20:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1vxlosyc.swift:22:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count < vowelsCount {\n        \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp1vxlosyc.swift:26:60:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    let vowelsIndex = word.characters.reversed().index(of:\
    \ vowels)\n                                                           ^\n/tmp/tmp1vxlosyc.swift:38:83:\
    \ error: extra argument 'in' in call\n    let vowelsIndex = word.characters.reversed().index(of:\
    \ vowels, in: vowelsIndex..<vowelsIndex + vowelsCount)\n                     \
    \                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1vxlosyc.swift:38:60: error: cannot convert value of type 'String' to\
    \ expected argument type 'ReversedCollection<String>.Element' (aka 'Character')\n\
    \    let vowelsIndex = word.characters.reversed().index(of: vowels, in: vowelsIndex..<vowelsIndex\
    \ + vowelsCount)\n                                                           ^\n\
    /tmp/tmp1vxlosyc.swift:44:17: error: value of type 'String' has no member 'substring'\n\
    \    return word.substring(to: vowelsIndex + vowelsCount)\n           ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = word.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowelsIndex = word.characters.reversed().filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsIndex == 0 {\n        return \"\"\n    }\n    \n\
    \    let vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpnoavf13p.swift:17:24: error: use of local variable 'vowels' before\
    \ its declaration\n    guard let vowels = vowels.characters.map(String.init) else\
    \ {\n                       ^\n/tmp/tmpnoavf13p.swift:105:9: note: 'vowels' declared\
    \ here\n    let vowels\n        ^\n/tmp/tmpnoavf13p.swift:105:9: error: type annotation\
    \ missing in pattern\n    let vowels\n        ^\n"
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelsCount = vowels.characters.count\n\
    \    \n    var vowelIndex = 0\n    \n    var currentIndex = 0\n    \n    var currentChar\
    \ = word.characters.last!\n    \n    while currentIndex < word.characters.count\
    \ {\n        \n        if currentChar == vowels[vowelIndex] {\n            \n\
    \            vowelIndex += 1\n            \n            if vowelIndex == vowelsCount\
    \ {\n                \n                return \"\"\n            }\n        }\n\
    \        \n        currentIndex += 1\n        \n        currentChar = word.characters.last!\n\
    \    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpush66h4n.swift:20:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpush66h4n.swift:26:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    var currentChar = word.characters.last!\n         \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpush66h4n.swift:28:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    while currentIndex < word.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpush66h4n.swift:30:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ currentChar == vowels[vowelIndex] {\n                          ^~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpush66h4n.swift:42:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        currentChar\
    \ = word.characters.last!\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n        if char.lowercased() == \"a\" || char.lowercased()\
    \ == \"e\" || char.lowercased() == \"i\" || char.lowercased() == \"o\" || char.lowercased()\
    \ == \"u\" {\n            return index\n        }\n        return -1\n    }.min()\n\
    \    if vowelsIndex == -1 {\n        return \"\"\n    }\n    let vowelsIndex2\
    \ = vowelsIndex + 1\n    let vowelsIndex3 = vowelsIndex2 + 1\n    let vowelsIndex4\
    \ = vowelsIndex3 + 1\n    let vowelsIndex5 = vowelsIndex4 + 1\n    let vowelsIndex6\
    \ = vowelsIndex5 + 1\n    let vowelsIndex7 = vowelsIndex6 + 1\n    let vowelsIndex8\
    \ = vowelsIndex7 + 1\n    let vowelsIndex9 = vowelsIndex8 + 1\n    let vowelsIndex10\
    \ = vowelsIndex9 + 1\n    let vowelsIndex11 = vowelsIndex10 + 1\n    let vowelsIndex12\
    \ = vowelsIndex11 + 1\n    let vowelsIndex13 = vowelsIndex12 + 1\n    let vowelsIndex14\
    \ = vowelsIndex13 + 1\n    let vowelsIndex15 = vowelsIndex14 + 1\n    let vowelsIndex16\
    \ = vowelsIndex15 + 1\n    let vowelsIndex17 = vowelsIndex16 + 1\n    let vowelsIndex18\
    \ = vowelsIndex17 + 1\n    let vowelsIndex19 = vowelsIndex18 + 1\n    let vowelsIndex20\
    \ = vowelsIndex19 + 1\n    let vowelsIndex21 = vowelsIndex20 + 1\n    let vowelsIndex22\
    \ = vowelsIndex21 + 1\n    let vowelsIndex23 = vowelsIndex22 + 1\n    let vowelsIndex24\
    \ = vowelsIndex23 + 1\n    let vowelsIndex25 = vowelsIndex24 + 1\n    let vowelsIndex26\
    \ = vowelsIndex25 + 1\n    let vowelsIndex27 = vowelsIndex26 + 1\n    let vowelsIndex28\
    \ = vowelsIndex27 + 1\n    let vowelsIndex29 = vowelsIndex28 + 1\n    let vowelsIndex30\
    \ = vowelsIndex29 + 1\n    let vowelsIndex31 = vowelsIndex30 + 1\n    let vowelsIndex32\
    \ = vowelsIndex31 + 1\n    let vowelsIndex33 = vowelsIndex32 + 1\n    let vowelsIndex34\
    \ = vowelsIndex33 + 1\n    let vowelsIndex35 = vowelsIndex34 + 1\n    let vowelsIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp32rf13da.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmp32rf13da.swift:21:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) -> Int in\n                                                \
    \ ^\n/tmp/tmp32rf13da.swift:64:9: error: type annotation missing in pattern\n\
    \    let vowelsIndex\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ String($0) }),\n        let vowelsCount\
    \ = vowels.count, let word = word.characters.map({ String($0) }) else { return\
    \ \"\" }\n    \n    let vowelsCount = vowels.count\n    let wordCount = word.count\n\
    \    \n    let maxCount = wordCount - vowelsCount\n    \n    var closestVowel\
    \ = \"\"\n    \n    if maxCount > 0 {\n        let maxIndex = word.index(word.startIndex,\
    \ offsetBy: maxCount)\n        let maxVowel = String(word[maxIndex])\n       \
    \ \n        for vowel in vowels {\n            if maxVowel == vowel {\n      \
    \          closestVowel = vowel\n                break\n            }\n      \
    \  }\n    }\n    \n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwsi1667x.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map({ String($0) }),\n               \
    \        ^~~~~~\n/tmp/tmpwsi1667x.swift:18:57: error: 'characters' is unavailable:\
    \ Please use String directly\n        let vowelsCount = vowels.count, let word\
    \ = word.characters.map({ String($0) }) else { return \"\" }\n               \
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpwsi1667x.swift:18:41: error: initializer\
    \ for conditional binding must have Optional type, not '[String]'\n        let\
    \ vowelsCount = vowels.count, let word = word.characters.map({ String($0) }) else\
    \ { return \"\" }\n                                        ^          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndex2\
    \ = vowels.count - 1\n    \n    var closestVowel = \"\"\n    \n    for char in\
    \ word.characters {\n        \n        if vowels.contains(String(char)) {\n  \
    \          \n            if vowelIndex < vowelIndex2 {\n                \n   \
    \             closestVowel = String(char)\n                vowelIndex = vowelIndex\
    \ + 1\n                \n            } else {\n                \n            \
    \    closestVowel = String(char)\n                vowelIndex2 = vowelIndex2 -\
    \ 1\n                \n            }\n            \n        } else {\n       \
    \     \n            closestVowel = \"\"\n            \n        }\n        \n \
    \   }\n    \n    return closestVowel\n    \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpydiu6tmy.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n    \n    if vowelIndex == -1 {\n        return \"\"\n    }\n    \n\
    \    let vowelRange = word.characters.reversed().suffix(from: vowelIndex).reversed()\n\
    \    \n    let vowelRangeLength = vowelRange.count\n    \n    if vowelRangeLength\
    \ == 0 {\n        return \"\"\n    }\n    \n    let consonantIndex = word.characters.reversed().firstIndex(of:\
    \ consonants)\n    \n    if consonantIndex == -1 {\n        return \"\"\n    }\n\
    \    \n    let consonantRange = word.characters.reversed().suffix(from: consonantIndex).reversed()\n\
    \    \n    let consonantRangeLength = consonantRange.count\n    \n    if consonantRangeLength\
    \ == 0 {\n        return \"\"\n    }\n    \n    let vowelRangeStartIndex = vowelIndex\
    \ + vowelRangeLength - 1\n    \n    let consonantRangeStartIndex = consonantIndex\
    \ + consonantRangeLength - 1\n    \n    let vowelRangeEndIndex = vowelIndex +\
    \ vowelRangeLength\n    \n    let consonantRangeEndIndex = consonantIndex + consonantRangeLength\n\
    \    \n    if vowelRangeStartIndex > consonantRangeStartIndex {\n        return\
    \ vowelRange[vowelRangeStartIndex - 1]\n    }\n    \n    if vowelRangeEndIndex\
    \ > consonantRangeStartIndex {\n        return vowelRange[vowelRangeEndIndex -\
    \ 1]\n    }\n    \n    if vowelRangeStartIndex < consonantRangeStartIndex {\n\
    \        return consonantRange[consonantRangeStartIndex - 1]\n    }\n    \n  \
    \  if vowelRangeEndIndex < consonantRangeStartIndex {\n        return consonantRange[consonantRangeEndIndex\
    \ - 1]\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmps0glvgjk.swift:20:64: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let vowelIndex\
    \ = word.characters.reversed().firstIndex(of: vowels)\n                      \
    \                                         ^\n/tmp/tmps0glvgjk.swift:34:68: error:\
    \ cannot find 'consonants' in scope\n    let consonantIndex = word.characters.reversed().firstIndex(of:\
    \ consonants)\n                                                              \
    \     ^~~~~~~~~~\n/tmp/tmps0glvgjk.swift:48:43: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n    let vowelRangeStartIndex\
    \ = vowelIndex + vowelRangeLength - 1\n                                      \
    \    ^\n/tmp/tmps0glvgjk.swift:50:51: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    let consonantRangeStartIndex = consonantIndex\
    \ + consonantRangeLength - 1\n                                               \
    \   ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var\
    \ vowelsCount = vowels.count\n    var vowelIndex = 0\n    var vowelsCountIndex\
    \ = 0\n    var vowelsCountIndex2 = 0\n    var vowelsCountIndex3 = 0\n    var vowelsCountIndex4\
    \ = 0\n    var vowelsCountIndex5 = 0\n    var vowelsCountIndex6 = 0\n    var vowelsCountIndex7\
    \ = 0\n    var vowelsCountIndex8 = 0\n    var vowelsCountIndex9 = 0\n    var vowelsCountIndex10\
    \ = 0\n    var vowelsCountIndex11 = 0\n    var vowelsCountIndex12 = 0\n    var\
    \ vowelsCountIndex13 = 0\n    var vowelsCountIndex14 = 0\n    var vowelsCountIndex15\
    \ = 0\n    var vowelsCountIndex16 = 0\n    var vowelsCountIndex17 = 0\n    var\
    \ vowelsCountIndex18 = 0\n    var vowelsCountIndex19 = 0\n    var vowelsCountIndex20\
    \ = 0\n    var vowelsCountIndex21 = 0\n    var vowelsCountIndex22 = 0\n    var\
    \ vowelsCountIndex23 = 0\n    var vowelsCountIndex24 = 0\n    var vowelsCountIndex25\
    \ = 0\n    var vowelsCountIndex26 = 0\n    var vowelsCountIndex27 = 0\n    var\
    \ vowelsCountIndex28 = 0\n    var vowelsCountIndex29 = 0\n    var vowelsCountIndex30\
    \ = 0\n    var vowelsCountIndex31 = 0\n    var vowelsCountIndex32 = 0\n    var\
    \ vowelsCountIndex33 = 0\n    var vowelsCountIndex34 = 0\n    var vowelsCountIndex35\
    \ = 0\n    var vowelsCountIndex36 = 0\n    var vowelsCountIndex37 = 0\n    var\
    \ vowelsCountIndex38 = 0\n    var vowelsCountIndex39 = 0\n    var vowelsCountIndex40\
    \ = 0\n    var vowelsCountIndex41 = 0\n    var vowelsCountIndex42 = 0\n    var\
    \ vowelsCountIndex43 = 0\n    var vowelsCountIndex44 = 0\n    var vowelsCountIndex45\
    \ = 0\n    var vowelsCountIndex46 = 0\n    var vowelsCountIndex47 = 0\n    var\
    \ vowelsCountIndex48 = 0\n    var vowelsCountIndex49 = 0\n    var vowelsCountIndex50\
    \ = 0\n    var vowelsCountIndex51 = 0\n    var vowelsCountIndex52 = 0\n    var\
    \ vowelsCountIndex53 = 0\n    var vowelsCountIndex54 = 0\n    var vowelsCountIndex55\
    \ = 0\n    var vowelsCountIndex56 = 0\n    var vowelsCountIndex57 = 0\n    var\
    \ vowelsCountIndex58 = 0\n    var vowelsCountIndex59 = 0\n    var vowelsCountIndex60\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpviuwh3gm.swift:19:9: warning: initialization of variable 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCount = vowels.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:20:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpviuwh3gm.swift:21:9: warning: initialization of variable 'vowelsCountIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCountIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:22:9:\
    \ warning: initialization of variable 'vowelsCountIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsCountIndex2 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:23:9: warning: initialization\
    \ of variable 'vowelsCountIndex3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelsCountIndex3 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpviuwh3gm.swift:24:9: warning: initialization of variable 'vowelsCountIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCountIndex4 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:25:9:\
    \ warning: initialization of variable 'vowelsCountIndex5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsCountIndex5 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:26:9: warning: initialization\
    \ of variable 'vowelsCountIndex6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelsCountIndex6 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpviuwh3gm.swift:27:9: warning: initialization of variable 'vowelsCountIndex7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCountIndex7 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpviuwh3gm.swift:28:9:\
    \ warning: initialization of variable 'vowelsCountIndex8' was never used"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndex2\
    \ = word.count\n    \n    while vowelIndex2 < word.count {\n        if vowels[vowelIndex]\
    \ == word[vowelIndex2] {\n            vowelIndex += 1\n            vowelIndex2\
    \ -= 1\n        } else {\n            vowelIndex2 = vowelIndex\n            vowelIndex\
    \ += 1\n        }\n    }\n    \n    if vowelIndex == 0 {\n        return \"\"\n\
    \    }\n    \n    if vowelIndex == word.count - 1 {\n        return vowels[vowelIndex\
    \ - 1]\n    }\n    \n    if vowelIndex == word.count - 2 {\n        return vowels[vowelIndex\
    \ - 2]\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpn04g3v0i.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels[vowelIndex]\
    \ == word[vowelIndex2] {\n           ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpn04g3v0i.swift:24:34: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if vowels[vowelIndex] == word[vowelIndex2] {\n           \
    \                      ^~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpn04g3v0i.swift:38:22: error: cannot\
    \ convert return expression of type 'Character' to return type 'String'\n    \
    \    return vowels[vowelIndex - 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpn04g3v0i.swift:42:22:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \        return vowels[vowelIndex - 2]\n               ~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels = [String]()\n\
    \    \n    for char in word.characters {\n        if char.unicodeScalars.count\
    \ > 0 {\n            vowels.append(char.unicodeScalars.first!)\n        }\n  \
    \  }\n    \n    if vowels.count < 2 {\n        return \"\"\n    }\n    \n    var\
    \ vowelIndex = 0\n    var consonantIndex = word.characters.count - 1\n    \n \
    \   while vowelIndex < vowels.count && consonantIndex >= 0 {\n        if vowels[vowelIndex]\
    \ == word.characters[consonantIndex] {\n            vowelIndex += 1\n        }\
    \ else {\n            consonantIndex -= 1\n        }\n    }\n    \n    if vowelIndex\
    \ == vowels.count {\n        return \"\"\n    }\n    \n    return vowels[vowelIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qth7tgt.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5qth7tgt.swift:25:20:\
    \ error: no exact matches in call to instance method 'append'\n            vowels.append(char.unicodeScalars.first!)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public\
    \ mutating func append(_ newElement: __owned Self.Element)\n                 \
    \                   ^\n/tmp/tmp5qth7tgt.swift:25:20: note: found candidate with\
    \ type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char.unicodeScalars.first!)\n\
    \                   ^\n/tmp/tmp5qth7tgt.swift:34:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var consonantIndex = word.characters.count -\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5qth7tgt.swift:37:49: error: no exact matches in call\
    \ to subscript \n        if vowels[vowelIndex] == word.characters[consonantIndex]\
    \ {\n                                                ^\nSwift.String:3:12: note:\
    \ candidate expects value of type 'Range<String.Index>' for parameter #1 (got\
    \ 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get }\n\
    \           ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.unicodeScalars {\n        if char.value > 0x41\
    \ && char.value < 0x5A {\n            vowels.append(char.value)\n        }\n \
    \   }\n    \n    if vowels.isEmpty {\n        return \"\"\n    }\n    \n    var\
    \ vowelIndex = 0\n    var vowelIndexEnd = vowels.count - 1\n    \n    for char\
    \ in word.unicodeScalars {\n        if char.value > 0x41 && char.value < 0x5A\
    \ {\n            if vowelIndex == vowelIndexEnd {\n                return \"\"\
    \n            }\n            \n            if char.value == vowels[vowelIndex]\
    \ {\n                vowelIndex++\n            } else {\n                vowelIndex\
    \ = 0\n                vowelIndexEnd = vowels.count - 1\n            }\n     \
    \   }\n    }\n    \n    return vowels[vowelIndex] ?? \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ppqxyfk.swift:25:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmp5ppqxyfk.swift:42:27: error: binary\
    \ operator '==' cannot be applied to operands of type 'UInt32' and 'String'\n\
    \            if char.value == vowels[vowelIndex] {\n               ~~~~~~~~~~\
    \ ^  ~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ppqxyfk.swift:42:27: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (String, String), (UInt32,\
    \ UInt32)\n            if char.value == vowels[vowelIndex] {\n               \
    \           ^\n/tmp/tmp5ppqxyfk.swift:43:27: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                vowelIndex++\n             \
    \             ^~\n/tmp/tmp5ppqxyfk.swift:51:31: warning: left side of nil coalescing\
    \ operator '??' has non-optional type 'String', so the right side is never used\n\
    \    return vowels[vowelIndex] ?? \"\"\n           ~~~~~~~~~~~~~~~~~~ ^~~~~\n\
    \                              \n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        } else if letter.isLower() {\n\
    \            vowels.append(letter)\n        } else if letter.isDigit() {\n   \
    \         vowels.append(letter)\n        } else if letter == \" \" {\n       \
    \     vowels.append(letter)\n        } else {\n            vowels.append(letter)\n\
    \        }\n    }\n    var vowelsCount = vowels.count\n    if vowelsCount == 0\
    \ {\n        return \"\"\n    }\n    var vowelIndex: Int = 0\n    var vowelsCount2:\
    \ Int = 0\n    var vowelsCount3: Int = 0\n    var vowelsCount4: Int = 0\n    var\
    \ vowelsCount5: Int = 0\n    var vowelsCount6: Int = 0\n    var vowelsCount7:\
    \ Int = 0\n    var vowelsCount8: Int = 0\n    var vowelsCount9: Int = 0\n    var\
    \ vowelsCount10: Int = 0\n    var vowelsCount11: Int = 0\n    var vowelsCount12:\
    \ Int = 0\n    var vowelsCount13: Int = 0\n    var vowelsCount14: Int = 0\n  \
    \  var vowelsCount15: Int = 0\n    var vowelsCount16: Int = 0\n    var vowelsCount17:\
    \ Int = 0\n    var vowelsCount18: Int = 0\n    var vowelsCount19: Int = 0\n  \
    \  var vowelsCount20: Int = 0\n    var vowelsCount21: Int = 0\n    var vowelsCount22:\
    \ Int = 0\n    var vowelsCount23: Int = 0\n    var vowelsCount24: Int = 0\n  \
    \  var vowelsCount25: Int = 0\n    var vowelsCount26: Int = 0\n    var vowelsCount27:\
    \ Int = 0\n    var vowelsCount28: Int = 0\n    var vowelsCount29: Int = 0\n  \
    \  var vowelsCount30: Int = 0\n    var vowelsCount31: Int = 0\n    var vowelsCount32:\
    \ Int = 0\n    var vowelsCount33: Int = 0\n    var vowelsCount34: Int = 0\n  \
    \  var vowelsCount35: Int = 0\n    var vowelsCount36: Int = 0\n    var vowelsCount37:\
    \ Int = 0\n    var vowelsCount38: Int = 0\n    var vowelsCount39: Int = 0\n  \
    \  var vowelsCount40: Int = 0\n    var vowelsCount41: Int = 0\n    var vowelsCount42:\
    \ Int = 0\n    var vowelsCount43: Int = 0\n    var vowelsCount44: Int = 0\n  \
    \  var vowelsCount45: Int = 0\n    var vowelsCount46: Int = 0\n    var vowelsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mg46qaf.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp5mg46qaf.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp5mg46qaf.swift:21:26:\
    \ error: value of type 'Character' has no member 'isLower'\n        } else if\
    \ letter.isLower() {\n                  ~~~~~~ ^~~~~~~\n/tmp/tmp5mg46qaf.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp5mg46qaf.swift:23:26:\
    \ error: value of type 'Character' has no member 'isDigit'\n        } else if\
    \ letter.isDigit() {\n                  ~~~~~~ ^~~~~~~\n/tmp/tmp5mg46qaf.swift:24:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp5mg46qaf.swift:26:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp5mg46qaf.swift:28:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp5mg46qaf.swift:81:9:\
    \ error: type annotation missing in pattern\n    var vowelsCount\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgsfhk8r_.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, isVowel: isVowel)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpgsfhk8r_.swift:17:43: error: cannot find 'isVowel' in scope\n    return\
    \ getClosestVowel(word, isVowel: isVowel)\n                                  \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelFound = false\n\
    \    var vowelIndex2 = -1\n    var vowelFound2 = false\n    var vowelIndex3 =\
    \ -1\n    var vowelFound3 = false\n    var vowelIndex4 = -1\n    var vowelFound4\
    \ = false\n    var vowelIndex5 = -1\n    var vowelFound5 = false\n    var vowelIndex6\
    \ = -1\n    var vowelFound6 = false\n    var vowelIndex7 = -1\n    var vowelFound7\
    \ = false\n    var vowelIndex8 = -1\n    var vowelFound8 = false\n    var vowelIndex9\
    \ = -1\n    var vowelFound9 = false\n    var vowelIndex10 = -1\n    var vowelFound10\
    \ = false\n    var vowelIndex11 = -1\n    var vowelFound11 = false\n    var vowelIndex12\
    \ = -1\n    var vowelFound12 = false\n    var vowelIndex13 = -1\n    var vowelFound13\
    \ = false\n    var vowelIndex14 = -1\n    var vowelFound14 = false\n    var vowelIndex15\
    \ = -1\n    var vowelFound15 = false\n    var vowelIndex16 = -1\n    var vowelFound16\
    \ = false\n    var vowelIndex17 = -1\n    var vowelFound17 = false\n    var vowelIndex18\
    \ = -1\n    var vowelFound18 = false\n    var vowelIndex19 = -1\n    var vowelFound19\
    \ = false\n    var vowelIndex20 = -1\n    var vowelFound20 = false\n    var vowelIndex21\
    \ = -1\n    var vowelFound21 = false\n    var vowelIndex22 = -1\n    var vowelFound22\
    \ = false\n    var vowelIndex23 = -1\n    var vowelFound23 = false\n    var vowelIndex24\
    \ = -1\n    var vowelFound24 = false\n    var vowelIndex25 = -1\n    var vowelFound25\
    \ = false\n    var vowelIndex26 = -1\n    var vowelFound26 = false\n    var vowelIndex27\
    \ = -1\n    var vowelFound27 = false\n    var vowelIndex28 = -1\n    var vowelFound28\
    \ = false\n    var vowelIndex29 = -1\n    var vowelFound29 = false\n    var vowelIndex30\
    \ = -1\n    var vowelFound30 = false\n    var vowelIndex31 = -1\n    var vowelFound31\
    \ = false\n    var vowelIndex32 = -1\n    var vowelFound32 = false\n    var vowelIndex33\
    \ = -1\n    var vowelFound33 = false\n    var vowelIndex34 = -1\n    var vowelFound34\
    \ = false\n    var vowelIndex35 = -1\n    var vowelFound35 = false\n    var vowelIndex36\
    \ = -1\n    var vowelFound36 = false\n    var vowelIndex37 = -1\n    var vowelFound37\
    \ = false\n    var vowelIndex38 = -1\n    var vowelFound38 = false\n    var vowelIndex39\
    \ = -1\n    var vowelFound39 = false\n    var vowelIndex40 = -1\n    var vowelFound40\
    \ = false\n    var vowelIndex41 = -1\n    var vowelFound41 = false\n    var vowelIndex42\
    \ = -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpl0o3jmp4.swift:17:9: warning: initialization of immutable value\
    \ 'vowels' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let vowels = \"aeiouAEIOU\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:18:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:19:9: warning: initialization of variable 'vowelFound'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound = false\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:20:9:\
    \ warning: initialization of variable 'vowelIndex2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex2 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:21:9: warning: initialization of variable 'vowelFound2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound2 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:22:9:\
    \ warning: initialization of variable 'vowelIndex3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex3 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:23:9: warning: initialization of variable 'vowelFound3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound3 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:24:9:\
    \ warning: initialization of variable 'vowelIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex4 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o3jmp4.swift:25:9: warning: initialization of variable 'vowelFound4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelFound4 = false\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpl0o3jmp4.swift:26:9:\
    \ warning: initialization of variable 'vowelIndex5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex5 = -1\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpl0o"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelsCount = vowels.characters.count\n\
    \    \n    let vowelsIndex = word.characters.reversed().enumerate().filter { (index,\
    \ element) -> Bool in\n        \n        let element = element.lowercased()\n\
    \        \n        return vowels.contains(element)\n    }.minElement { (first,\
    \ second) -> Bool in\n        \n        let firstIndex = first.1\n        let\
    \ secondIndex = second.1\n        \n        return firstIndex < secondIndex\n\
    \    }.1\n    \n    if vowelsIndex < vowelsCount {\n        return vowels[vowelsIndex]\n\
    \    } else {\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy6r0zrj.swift:20:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpyy6r0zrj.swift:22:50: error: reference to member 'enumerate' cannot\
    \ be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().filter\
    \ { (index, element) -> Bool in\n                                            \
    \     ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount\
    \ = [Int]()\n    var vowelsIndex = [Int]()\n    vowelsIndex.append(0)\n    vowelsCount.append(0)\n\
    \    for char in word.characters {\n        if vowels.contains(char) {\n     \
    \       vowelsIndex.append(vowels.indexOf(char))\n            vowelsCount.append(vowelsIndex.count)\n\
    \        }\n    }\n    if vowelsCount.count > 1 {\n        var minIndex = vowelsCount.index(of:\
    \ vowelsCount.min())\n        return vowels[minIndex]\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpluc70tz8.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpluc70tz8.swift:23:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpluc70tz8.swift:24:39:\
    \ error: value of type '[String]' has no member 'indexOf'\n            vowelsIndex.append(vowels.indexOf(char))\n\
    \                               ~~~~~~ ^~~~~~~\n/tmp/tmpluc70tz8.swift:29:58:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        var minIndex = vowelsCount.index(of: vowelsCount.min())\n           \
    \                                              ^\n/tmp/tmpluc70tz8.swift:29:58:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        var minIndex = vowelsCount.index(of: vowelsCount.min())\n   \
    \                                                      ^\n                   \
    \                                            ?? <#default value#>\n/tmp/tmpluc70tz8.swift:29:58:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        var minIndex = vowelsCount.index(of: vowelsCount.min())\n   \
    \                                                      ^\n                   \
    \                                           !\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.count\n    var vowelIndex\
    \ = 0\n    var vowelCount = 0\n    var vowelFound = false\n    var currentIndex\
    \ = 0\n    var currentCount = 0\n    var currentVowel = \"\"\n    \n    for currentIndex\
    \ in 0..<word.count {\n        if vowels.contains(word[currentIndex]) {\n    \
    \        vowelFound = true\n            vowelIndex = currentIndex\n          \
    \  vowelCount = 1\n        }\n        \n        if vowelFound {\n            if\
    \ currentIndex == word.count - 1 {\n                if vowelIndex == word.count\
    \ - 1 {\n                    if vowelsCount == 1 {\n                        return\
    \ \"\"\n                    }\n                    \n                    currentCount\
    \ = vowelsCount - 1\n                    currentVowel = vowels[vowelIndex]\n \
    \               } else {\n                    currentCount = vowelsCount\n   \
    \                 currentVowel = vowels[vowelIndex + 1]\n                }\n \
    \           } else {\n                currentCount = vowelsCount\n           \
    \     currentVowel = vowels[vowelIndex + 1]\n            }\n            \n   \
    \         if currentCount > vowelsCount {\n                vowelFound = false\n\
    \            }\n        }\n    }\n    \n    return currentVowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxeua0bpw.swift:27:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels.contains(word[currentIndex])\
    \ {\n                           ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpxeua0bpw.swift:41:42: error: cannot\
    \ assign value of type 'Character' to type 'String'\n                    currentVowel\
    \ = vowels[vowelIndex]\n                                   ~~~~~~^~~~~~~~~~~~\n\
    /tmp/tmpxeua0bpw.swift:44:42: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                    currentVowel = vowels[vowelIndex + 1]\n \
    \                                  ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpxeua0bpw.swift:48:38:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      currentVowel = vowels[vowelIndex + 1]\n                               ~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    if word.characters.count\
    \ < 3 {\n        return \"\"\n    }\n    \n    let vowelsIndex = word.characters.reversed().index(of:\
    \ vowels.last!)\n    \n    let consonantsIndex = word.characters.reversed().index(of:\
    \ consonants.last!)\n    \n    let consonantsCount = word.characters.count - consonantsIndex\n\
    \    \n    if consonantsCount < 3 {\n        return \"\"\n    }\n    \n    let\
    \ consonantsIndex = consonantsIndex + consonantsCount\n    \n    if consonantsIndex\
    \ < 0 {\n        return \"\"\n    }\n    \n    let consonantsIndex = consonantsIndex\
    \ + consonantsCount\n    \n    if consonantsIndex < 0 {\n        return \"\"\n\
    \    }\n    \n    let consonantsIndex = consonantsIndex + consonantsCount\n  \
    \  \n    if consonantsIndex < 0 {\n        return \"\"\n    }\n    \n    let consonantsIndex\
    \ = consonantsIndex + consonantsCount\n    \n    if consonantsIndex < 0 {\n  \
    \      return \"\"\n    }\n    \n    let consonantsIndex = consonantsIndex + consonantsCount\n\
    \    \n    if consonantsIndex < 0 {\n        return \"\"\n    }\n    \n    let\
    \ consonantsIndex = consonantsIndex + consonantsCount\n    \n    if consonantsIndex\
    \ < 0 {\n        return \"\"\n    }\n    \n    let consonantsIndex = consonantsIndex\
    \ + consonantsCount\n    \n    if consonantsIndex < 0 {\n        return \"\"\n\
    \    }\n    \n    let consonantsIndex = consonantsIndex + consonantsCount\n  \
    \  \n    if consonantsIndex < 0 {\n        return \"\"\n    }\n    \n    let consonantsIndex\
    \ = consonantsIndex + consonantsCount\n    \n    if consonantsIndex < 0 {\n  \
    \      return \"\"\n    }\n    \n    let consonantsIndex = consonantsIndex + consonantsCount\n\
    \    \n    if consonantsIndex < 0 {\n        return \"\"\n    }\n    \n    let\
    \ consonantsIndex = consonantsIndex + consonantsCount\n    \n    if consonantsIndex\
    \ < 0 {\n        return \"\"\n    }\n    \n    let consonantsIndex = consonantsIndex\
    \ + consonantsCount\n    \n    if consonantsIndex < 0 {\n        return \"\"\n\
    \    }\n    \n    let consonantsIndex = consonants\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpah9fhnke.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpah9fhnke.swift:23:13: error: 'characters' is unavailable:\
    \ Please use String directly\n    if word.characters.count < 3 {\n           \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpah9fhnke.swift:29:64:\
    \ error: cannot find 'consonants' in scope\n    let consonantsIndex = word.characters.reversed().index(of:\
    \ consonants.last!)\n                                                        \
    \       ^~~~~~~~~~\n/tmp/tmpah9fhnke.swift:109:27: error: cannot find 'consonants'\
    \ in scope\n    let consonantsIndex = consonants\n                          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word: word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjy0n3nwn.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word: word, vowels: vowels)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpjy0n3nwn.swift:17:48: error: cannot find 'vowels' in scope\n    return\
    \ getClosestVowel(word: word, vowels: vowels)\n                              \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels.last!)\n    \n    if vowelIndex == nil {\n        return \"\"\n    }\n\
    \    \n    let vowelsCount = vowels.count\n    \n    let vowelIndex = word.characters.reversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpha43d5a1.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpha43d5a1.swift:111:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let vowelIndex = word.characters.reversed\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    \n    if word.hasPrefix(\"a\") {\n        vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    }\n    \n    if word.hasPrefix(\"\
    e\") {\n        vowels = [\"e\", \"i\", \"o\", \"u\"]\n    }\n    \n    if word.hasPrefix(\"\
    i\") {\n        vowels = [\"i\", \"o\", \"u\"]\n    }\n    \n    if word.hasPrefix(\"\
    o\") {\n        vowels = [\"o\", \"u\"]\n    }\n    \n    if word.hasPrefix(\"\
    u\") {\n        vowels = [\"u\", \"a\"]\n    }\n    \n    if word.hasSuffix(\"\
    a\") {\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    }\n    \n  \
    \  if word.hasSuffix(\"e\") {\n        vowels = [\"e\", \"i\", \"o\", \"u\"]\n\
    \    }\n    \n    if word.hasSuffix(\"i\") {\n        vowels = [\"i\", \"o\",\
    \ \"u\"]\n    }\n    \n    if word.hasSuffix(\"o\") {\n        vowels = [\"o\"\
    , \"u\"]\n    }\n    \n    if word.hasSuffix(\"u\") {\n        vowels = [\"u\"\
    , \"a\"]\n    }\n    \n    if vowels.isEmpty() {\n        return \"\"\n    }\n\
    \    \n    let vowel = vowels.sorted()[vowels.count - 1]\n    \n    if word.hasSuffix(vowel)\
    \ {\n        return vowel\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpb0lqi3lf.swift:59:15: error: cannot call value of non-function\
    \ type 'Bool'\n    if vowels.isEmpty() {\n              ^      ~~\n          \
    \           \n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount\
    \ = [Int]()\n    var vowelsIndex = [Int]()\n    var vowelsIndexCount = [Int]()\n\
    \    var vowelsIndexCountMin = [Int]()\n    var vowelsIndexCountMax = [Int]()\n\
    \    var vowelsIndexCountMinIndex = 0\n    var vowelsIndexCountMaxIndex = 0\n\
    \    var vowelsIndexCountMinIndexMax = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex = 0\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n    var vowelsIndexCountMinIndexMaxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwheclitm.swift:28:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndexMax'\n\
    \    var vowelsIndexCountMaxIndexMax = 0\n        ^\n/tmp/tmpwheclitm.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndexMax' previously declared here\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:29:9: error: invalid redeclaration of\
    \ 'vowelsIndexCountMinIndexMaxIndex'\n    var vowelsIndexCountMinIndexMaxIndex\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:27:9: note: 'vowelsIndexCountMinIndexMaxIndex'\
    \ previously declared here\n    var vowelsIndexCountMinIndexMaxIndex = 0\n   \
    \     ^\n/tmp/tmpwheclitm.swift:30:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndexMax'\n\
    \    var vowelsIndexCountMaxIndexMax = 0\n        ^\n/tmp/tmpwheclitm.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndexMax' previously declared here\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:31:9: error: invalid redeclaration of\
    \ 'vowelsIndexCountMinIndexMaxIndex'\n    var vowelsIndexCountMinIndexMaxIndex\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:27:9: note: 'vowelsIndexCountMinIndexMaxIndex'\
    \ previously declared here\n    var vowelsIndexCountMinIndexMaxIndex = 0\n   \
    \     ^\n/tmp/tmpwheclitm.swift:32:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndexMax'\n\
    \    var vowelsIndexCountMaxIndexMax = 0\n        ^\n/tmp/tmpwheclitm.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndexMax' previously declared here\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:33:9: error: invalid redeclaration of\
    \ 'vowelsIndexCountMinIndexMaxIndex'\n    var vowelsIndexCountMinIndexMaxIndex\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swift:27:9: note: 'vowelsIndexCountMinIndexMaxIndex'\
    \ previously declared here\n    var vowelsIndexCountMinIndexMaxIndex = 0\n   \
    \     ^\n/tmp/tmpwheclitm.swift:34:9: error: invalid redeclaration of 'vowelsIndexCountMaxIndexMax'\n\
    \    var vowelsIndexCountMaxIndexMax = 0\n        ^\n/tmp/tmpwheclitm.swift:26:9:\
    \ note: 'vowelsIndexCountMaxIndexMax' previously declared here\n    var vowelsIndexCountMaxIndexMax\
    \ = 0\n        ^\n/tmp/tmpwheclitm.swif"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [Character] = []\n    for letter in word {\n        if letter.isUppercase\
    \ {\n            vowels.append(letter)\n        }\n    }\n    vowels.reverse()\n\
    \    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\"\
    )))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n  \
    \  vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\"\
    )))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n  \
    \  vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\"\
    )))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n  \
    \  vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\"\
    )))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n  \
    \  vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\"\
    )))\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n  \
    \  vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n    vowels.insert(vowels.end(),\
    \ Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_xu_3ryi.swift:51:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_xu_3ryi.swift:50:18: note: to match this opening '('\n    vowels.insert(vowels.end(),\
    \ Charact\n                 ^\n/tmp/tmp_xu_3ryi.swift:24:18: error: missing argument\
    \ label 'at:' in call\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n                 ^\n                                at: \n/tmp/tmp_xu_3ryi.swift:24:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n      \
    \                          ^\n/tmp/tmp_xu_3ryi.swift:24:26: error: value of type\
    \ '[Character]' has no member 'end'\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n                  ~~~~~~ ^~~\n/tmp/tmp_xu_3ryi.swift:24:43: error:\
    \ value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must\
    \ be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n   \
    \ vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n         \
    \                                 ^\n/tmp/tmp_xu_3ryi.swift:24:43: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n         \
    \                                 ^\n                                        \
    \                         ?? <#default value#>\n/tmp/tmp_xu_3ryi.swift:24:43:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"AEIOU\")))\n\
    \                                          ^\n                               \
    \                                 !\n/tmp/tmp_xu_3ryi.swift:25:18: error: missing\
    \ argument label 'at:' in call\n    vowels.insert(vowels.end(), Character(UnicodeScalar(\"\
    AEIOU\")))\n                 ^\n                                at: \n/tmp/tmp_xu_3ryi.swift:25:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \    vowels.insert(vowels.end(), Character(UnicodeScalar(\""
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let vowelsCount = vowels.characters.count\n   \
    \ let vowelsArray = vowels.characters\n    var vowelIndex = 0\n    var vowelsArrayIndex\
    \ = 0\n    var vowelsArrayIndex2 = 0\n    var vowelsArrayIndex3 = 0\n    var vowelsArrayIndex4\
    \ = 0\n    var vowelsArrayIndex5 = 0\n    var vowelsArrayIndex6 = 0\n    var vowelsArrayIndex7\
    \ = 0\n    var vowelsArrayIndex8 = 0\n    var vowelsArrayIndex9 = 0\n    var vowelsArrayIndex10\
    \ = 0\n    var vowelsArrayIndex11 = 0\n    var vowelsArrayIndex12 = 0\n    var\
    \ vowelsArrayIndex13 = 0\n    var vowelsArrayIndex14 = 0\n    var vowelsArrayIndex15\
    \ = 0\n    var vowelsArrayIndex16 = 0\n    var vowelsArrayIndex17 = 0\n    var\
    \ vowelsArrayIndex18 = 0\n    var vowelsArrayIndex19 = 0\n    var vowelsArrayIndex20\
    \ = 0\n    var vowelsArrayIndex21 = 0\n    var vowelsArrayIndex22 = 0\n    var\
    \ vowelsArrayIndex23 = 0\n    var vowelsArrayIndex24 = 0\n    var vowelsArrayIndex25\
    \ = 0\n    var vowelsArrayIndex26 = 0\n    var vowelsArrayIndex27 = 0\n    var\
    \ vowelsArrayIndex28 = 0\n    var vowelsArrayIndex29 = 0\n    var vowelsArrayIndex30\
    \ = 0\n    var vowelsArrayIndex31 = 0\n    var vowelsArrayIndex32 = 0\n    var\
    \ vowelsArrayIndex33 = 0\n    var vowelsArrayIndex34 = 0\n    var vowelsArrayIndex35\
    \ = 0\n    var vowelsArrayIndex36 = 0\n    var vowelsArrayIndex37 = 0\n    var\
    \ vowelsArrayIndex38 = 0\n    var vowelsArrayIndex39 = 0\n    var vowelsArrayIndex40\
    \ = 0\n    var vowelsArrayIndex41 = 0\n    var vowelsArrayIndex42 = 0\n    var\
    \ vowelsArrayIndex43 = 0\n    var vowelsArrayIndex44 = 0\n    var vowelsArrayIndex45\
    \ = 0\n    var vowelsArrayIndex46 = 0\n    var vowelsArrayIndex47 = 0\n    var\
    \ vowelsArrayIndex48 = 0\n    var vowelsArrayIndex49 = 0\n    var vowelsArrayIndex50\
    \ = 0\n    var vowelsArrayIndex51 = 0\n    var vowelsArrayIndex52 = 0\n    var\
    \ vowelsArrayIndex53 = 0\n    var vowelsArrayIndex54 = 0\n    var vowelsArrayIndex55\
    \ = 0\n    var vowelsArrayIndex56 = 0\n    var vowelsArrayIndex57 = 0\n    var\
    \ vowelsArrayIndex58 = 0\n    var vowelsArrayIndex59 = 0\n    var vowelsArrayIndex60\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3dcbd1w9.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3dcbd1w9.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsArray = vowels.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3dcbd1w9.swift:18:9: warning: initialization of immutable value 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let vowelsCount = vowels.characters.count\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp3dcbd1w9.swift:19:9:\
    \ warning: initialization of immutable value 'vowelsArray' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    let vowelsArray = vowels.characters\n\
    \    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmp3dcbd1w9.swift:20:9: warning: initialization\
    \ of variable 'vowelIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp3dcbd1w9.swift:21:9:\
    \ warning: initialization of variable 'vowelsArrayIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var vowelsArrayIndex =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3dcbd1w9.swift:22:9: warning: initialization\
    \ of variable 'vowelsArrayIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var vowelsArrayIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3dcbd1w9.swift:23:9: warning: initialization of variable 'vowelsArrayIndex3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsArrayIndex3 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3dcbd1w9.swift:24:9:\
    \ warning: initialization of variable 'vowelsArrayIndex4' was never used; consider\
    \ replacing with ass"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    vowels.append(\"A\")\n    vowels.append(\"E\")\n    vowels.append(\"I\")\n\
    \    vowels.append(\"O\")\n    vowels.append(\"U\")\n    \n    var vowelsCount\
    \ = [String: Int]()\n    vowelsCount[\"a\"] = 1\n    vowelsCount[\"e\"] = 1\n\
    \    vowelsCount[\"i\"] = 1\n    vowelsCount[\"o\"] = 1\n    vowelsCount[\"u\"\
    ] = 1\n    vowelsCount[\"A\"] = 1\n    vowelsCount[\"E\"] = 1\n    vowelsCount[\"\
    I\"] = 1\n    vowelsCount[\"O\"] = 1\n    vowelsCount[\"U\"] = 1\n    \n    var\
    \ vowelsCountReverse = [String: Int]()\n    vowelsCountReverse[\"A\"] = 1\n  \
    \  vowelsCountReverse[\"E\"] = 1\n    vowelsCountReverse[\"I\"] = 1\n    vowelsCountReverse[\"\
    O\"] = 1\n    vowelsCountReverse[\"U\"] = 1\n    \n    var vowelsCountReverseReverse\
    \ = [String: Int]()\n    vowelsCountReverseReverse[\"A\"] = 1\n    vowelsCountReverseReverse[\"\
    E\"] = 1\n    vowelsCountReverseReverse[\"I\"] = 1\n    vowelsCountReverseReverse[\"\
    O\"] = 1\n    vowelsCountReverseReverse[\"U\"] = 1\n    \n    var vowelsCountReverseReverseReverse\
    \ = [String: Int]()\n    vowelsCountReverseReverseReverse[\"A\"] = 1\n    vowelsCountReverseReverseReverse[\"\
    E\"] = 1\n    vowelsCountReverseReverseReverse[\"I\"] = 1\n    vowelsCountReverseReverseReverse[\"\
    O\"] = 1\n    vowelsCountReverseReverseReverse[\"U\"] = 1\n    \n    var vowelsCountReverseReverseReverseReverse\
    \ = [String: Int]()\n    vowelsCountReverseReverseReverseReverse[\"A\"] = 1\n\
    \    vowelsCountReverseReverseReverseReverse[\"E\"] = 1\n    vowelsCountReverseReverseReverseReverse[\"\
    I\"] = 1\n    vowelsCountReverseReverseReverseReverse[\"O\"] = 1\n    vowelsCountReverseReverseReverseReverse[\"\
    U\"] = 1\n    \n    var vowelsCountReverseReverseReverseReverseReverse = [String:\
    \ Int]()\n    vowelsCountReverseReverseReverseReverseReverse[\"A\"] = 1\n    vowelsCountReverseReverseReverseReverseReverse[\"\
    E\"] = 1\n    vowelsCountReverseReverse\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6zuo_db.swift:72:5: warning: variable is unused\n    vowelsCountReverseReverse\n\
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpy6zuo_db.swift:73:1: error: missing return\
    \ in global function expected to return 'String'\n}\n^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if char.value\
    \ > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n     \
    \   }\n    }\n    vowels.sort()\n    if vowels.count > 0 {\n        return vowels[vowels.count\
    \ - 1]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3on9hmy5.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [Character]\
    \ = []\n    \n    for char in word.unicodeScalars {\n        if char.value > 0x41\
    \ && char.value < 0x5A {\n            vowels.append(char)\n        }\n    }\n\
    \    \n    if vowels.count == 0 {\n        return \"\"\n    }\n    \n    var vowelIndex:\
    \ Int = 0\n    var vowelCount: Int = 0\n    \n    for char in vowels {\n     \
    \   if char.value > 0x41 && char.value < 0x5A {\n            vowelIndex += 1\n\
    \            vowelCount += 1\n        }\n    }\n    \n    if vowelIndex == 0 {\n\
    \        return \"\"\n    }\n    \n    if vowelIndex == vowels.count {\n     \
    \   return \"\"\n    }\n    \n    var vowelIndex2: Int = 0\n    var vowelCount2:\
    \ Int = 0\n    \n    for char in vowels {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowelIndex2 += 1\n            vowelCount2 += 1\n     \
    \   }\n    }\n    \n    if vowelIndex2 == 0 {\n        return \"\"\n    }\n  \
    \  \n    if vowelIndex2 == vowels.count {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex3: Int = 0\n    var vowelCount3: Int = 0\n    \n    for char\
    \ in vowels {\n        if char.value > 0x41 && char.value < 0x5A {\n         \
    \   vowelIndex3 += 1\n            vowelCount3 += 1\n        }\n    }\n    \n \
    \   if vowelIndex3 == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex3\
    \ == vowels.count {\n        return \"\"\n    }\n    \n    var vowelIndex4: Int\
    \ = 0\n    var vowelCount4: Int = 0\n    \n    for char in vowels {\n        if\
    \ char.value > 0x41 && char.value < 0x5A {\n            vowelIndex4 += 1\n   \
    \         vowelCount4 += 1\n        }\n    }\n    \n    if vowelIndex4 == 0 {\n\
    \        return \"\"\n    }\n    \n    if vowelIndex4 == vowels.count {\n    \
    \    return \"\"\n    }\n    \n    var vowelIndex5: Int = 0\n    var vowelCount5:\
    \ Int = 0\n    \n    for char in vowels {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowelIndex5 += 1\n            vowelCount5 += 1\n     \
    \   }\n    }\n    \n    if vowelIndex5 == 0 {\n        return \"\"\n    }\n  \
    \  \n    if vowelIndex5 == vowels.count {\n        return \"\"\n    }\n    \n\
    \    var vowelIndex6: Int = 0\n    var vowelCount6: Int = 0\n    \n    for char\
    \ in vowels {\n        if char.value > 0x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphut5ahe1.swift:127:27: error: '\n' is not a valid hexadecimal digit\
    \ (0-9, A-F) in integer literal\n        if char.value > 0x\n                \
    \          ^\n/tmp/tmphut5ahe1.swift:155:48: error: expected '}' at end of brace\
    \ statement\nassert(get_closest_vowel(word: \"Above\") == \"o\")\n           \
    \                                    ^\n/tmp/tmphut5ahe1.swift:16:48: note: to\
    \ match this opening '{'\nfunc get_closest_vowel(word: String) -> String {\n \
    \                                              ^\n/tmp/tmphut5ahe1.swift:25:20:\
    \ error: no exact matches in call to instance method 'append'\n            vowels.append(char)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmphut5ahe1.swift:25:20: note: found candidate\
    \ with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n/tmp/tmphut5ahe1.swift:37:17: error: value of type 'Character'\
    \ has no member 'value'\n        if char.value > 0x41 && char.value < 0x5A {\n\
    \           ~~~~ ^~~~~\n/tmp/tmphut5ahe1.swift:37:38: error: value of type 'Character'\
    \ has no member 'value'\n        if char.value > 0x41 && char.value < 0x5A {\n\
    \                                ~~~~ ^~~~~\n/tmp/tmphut5ahe1.swift:55:17: error:\
    \ value of type 'Character' has no member 'value'\n        if char.value > 0x41\
    \ && char.value < 0x5A {\n           ~~~~ ^~~~~\n/tmp/tmphut5ahe1.swift:55:38:\
    \ error: value of type 'Character' has no member 'value'\n        if char.value\
    \ > 0x41 && char.value < 0x5A {\n                                ~~~~ ^~~~~\n\
    /tmp/tmphut5ahe1.swift:73:17: error: value of type 'Character' has no member 'value'\n\
    \        if char.value > 0x41 && ch"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelCount\
    \ = 0\n    \n    for char in word.characters {\n        if vowels.contains(String(char))\
    \ {\n            vowelCount += 1\n        }\n    }\n    \n    if vowelCount >\
    \ 0 {\n        vowelIndex = (word.characters.count - vowelCount) / 2\n    }\n\
    \    \n    if vowelIndex < 0 {\n        vowelIndex = 0\n    }\n    \n    return\
    \ String(word.characters[vowelIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4g9mut8f.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp4g9mut8f.swift:30:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        vowelIndex\
    \ = (word.characters.count - vowelCount) / 2\n                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4g9mut8f.swift:37:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    return String(word.characters[vowelIndex])\n\
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4g9mut8f.swift:37:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    return String(word.characters[vowelIndex])\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = []\n\
    \    for letter in word {\n        if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n            vowels.append(letter)\n\
    \        }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n   \
    \ var vowelIndex = 0\n    var vowelCount = 0\n    for letter in word {\n     \
    \   if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\" {\n            vowelIndex += 1\n            if vowelIndex\
    \ == vowels.count {\n                vowelIndex = 0\n            }\n         \
    \   vowelCount += 1\n        }\n    }\n    if vowelCount < 2 {\n        return\
    \ \"\"\n    }\n    if vowelIndex == 0 {\n        return \"\"\n    }\n    if vowelIndex\
    \ == vowels.count - 1 {\n        return vowels[vowelIndex - 1]\n    }\n    if\
    \ vowelIndex == vowels.count - 2 {\n        return vowels[vowelIndex - 2]\n  \
    \  }\n    if vowelIndex == vowels.count - 3 {\n        return vowels[vowelIndex\
    \ - 3]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplrb62abz.swift:23:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            vowels.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowelIndex = 0\n \
    \   var vowel = \"\"\n    \n    for index in 0..<word.characters.count {\n   \
    \     let char = word.characters[index]\n        \n        if char.caseInsensitiveCompare(\"\
    a\") == .orderedSame {\n            vowelIndex = 0\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    e\") == .orderedSame {\n            vowelIndex = 1\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    i\") == .orderedSame {\n            vowelIndex = 2\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    o\") == .orderedSame {\n            vowelIndex = 3\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    u\") == .orderedSame {\n            vowelIndex = 4\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    A\") == .orderedSame {\n            vowelIndex = 0\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    E\") == .orderedSame {\n            vowelIndex = 1\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    I\") == .orderedSame {\n            vowelIndex = 2\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    O\") == .orderedSame {\n            vowelIndex = 3\n            vowel = char\n\
    \            break\n        }\n        \n        if char.caseInsensitiveCompare(\"\
    U\") == .orderedSame {\n            vowelIndex = 4\n            vowel = char\n\
    \            break\n        }\n    }\n    \n    if vowelIndex == 0 {\n       \
    \ return \"\"\n    }\n    \n    if vowelIndex < word.characters.count - 1 {\n\
    \        let nextChar = word.characters[vowelIndex + 1]\n        \n        if\
    \ nextChar.caseInsensitiveCompare(\"a\") == .orderedSame {\n            return\
    \ vowel\n        }\n        \n        if nextChar.caseInsensitiveCompare(\"e\"\
    ) == .orderedSame {\n            return vowel\n        }\n        \n        if\
    \ nextChar.caseInsensitiveCompare(\"i\") == .orderedSame {\n            return\
    \ vowel\n        }\n        \n        if nextChar.caseInsensitiveCompare(\"o\"\
    ) == .orderedSame {\n            return vowel\n        }\n        \n        if\
    \ nextChar.caseInsensitiveCompare(\"u\") == .orderedSame {\n            return\
    \ vowel\n        }\n        \n        if nextChar.caseInsensitive\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmph1hqwn3r.swift:115:36: error: expected '{' after 'if' condition\n\
    \        if nextChar.caseInsensitive\n                                   ^\n/tmp/tmph1hqwn3r.swift:143:48:\
    \ error: expected '}' at end of brace statement\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")\n                                               ^\n/tmp/tmph1hqwn3r.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmph1hqwn3r.swift:24:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in 0..<word.characters.count {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph1hqwn3r.swift:25:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = word.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph1hqwn3r.swift:25:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = word.characters[index]\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph1hqwn3r.swift:27:17: error: value of\
    \ type 'Character' has no member 'caseInsensitiveCompare'\n        if char.caseInsensitiveCompare(\"\
    a\") == .orderedSame {\n           ~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph1hqwn3r.swift:29:21:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  vowel = char\n                    ^~~~\n/tmp/tmph1hqwn3r.swift:33:17: error:\
    \ value of type 'Character' has no member 'caseInsensitiveCompare'\n        if\
    \ char.caseInsensitiveCompare(\"e\") == .orderedSame {\n           ~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph1hqwn3r.swift:35:21: error: cannot assign v"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [Character] = []\n\
    \    for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(char)\n        }\n    }\n    if vowels.count\
    \ < 2 {\n        return \"\"\n    }\n    var minDistance = Int.max\n    var minVowel:\
    \ Character?\n    for vowel in vowels {\n        let distance = vowel.value -\
    \ word.unicodeScalars.last!.value\n        if distance < minDistance {\n     \
    \       minDistance = distance\n            minVowel = vowel\n        }\n    }\n\
    \    return minVowel?.description\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmparmhse11.swift:23:20: error: no exact matches in call to instance\
    \ method 'append'\n            vowels.append(char)\n                   ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmparmhse11.swift:23:20: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            vowels.append(char)\n\
    \                   ^\n/tmp/tmparmhse11.swift:32:30: error: value of type 'Character'\
    \ has no member 'value'\n        let distance = vowel.value - word.unicodeScalars.last!.value\n\
    \                       ~~~~~ ^~~~~\n/tmp/tmparmhse11.swift:38:22: error: value\
    \ of optional type 'String?' must be unwrapped to a value of type 'String'\n \
    \   return minVowel?.description\n                     ^\n/tmp/tmparmhse11.swift:38:22:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return minVowel?.description\n                     ^\n          \
    \                       ?? <#default value#>\n/tmp/tmparmhse11.swift:38:22: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    return minVowel?.description\n                   ~ ^\n                  \
    \ !\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.unicodeScalars {\n        if char.value\
    \ > 0x41 && char.value < 0x5A {\n            vowels.append(char.value)\n     \
    \   }\n    }\n    if vowels.isEmpty {\n        return \"\"\n    }\n    vowels.sortInPlace()\n\
    \    if vowels.last == 0x5A {\n        return vowels.last\n    }\n    if vowels.first\
    \ == 0x41 {\n        return vowels.first\n    }\n    return vowels[vowels.count\
    \ - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpii6r0dwo.swift:20:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpii6r0dwo.swift:26:12: error: value\
    \ of type '[String]' has no member 'sortInPlace'\n    vowels.sortInPlace()\n \
    \   ~~~~~~ ^~~~~~~~~~~\n/tmp/tmpii6r0dwo.swift:27:20: error: type '((String) throws\
    \ -> Bool) throws -> String?' cannot conform to 'BinaryInteger'\n    if vowels.last\
    \ == 0x5A {\n                   ^\n/tmp/tmpii6r0dwo.swift:27:20: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n    if vowels.last\
    \ == 0x5A {\n                   ^\n/tmp/tmpii6r0dwo.swift:27:20: note: required\
    \ by referencing operator function '==' on 'BinaryInteger' where 'Self' = '((String)\
    \ throws -> Bool) throws -> String?'\n    if vowels.last == 0x5A {\n         \
    \          ^\n/tmp/tmpii6r0dwo.swift:28:23: error: value of optional type 'String?'\
    \ must be unwrapped to a value of type 'String'\n        return vowels.last\n\
    \                      ^\n/tmp/tmpii6r0dwo.swift:28:23: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        return\
    \ vowels.last\n                      ^\n                           ?? <#default\
    \ value#>\n/tmp/tmpii6r0dwo.swift:28:23: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return vowels.last\n\
    \                      ^\n                          !\n/tmp/tmpii6r0dwo.swift:30:21:\
    \ error: type '((String) throws -> Bool) throws -> String?' cannot conform to\
    \ 'BinaryInteger'\n    if vowels.first == 0x41 {\n                    ^\n/tmp/tmpii6r0dwo.swift:30:21:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n    if vowels.first == 0x41 {\n                    ^\n/tmp/tmpii6r0dwo.swift:30:21:\
    \ note: required by referencing operator function '==' on 'BinaryInteger' where\
    \ 'Self' = '((String) throws -> Bool) throws -> String?'\n    if vowels.first\
    \ == 0x41 {\n                    ^\n/tmp/tmpii6r0dwo.swift:31:23: error: value\
    \ of"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var result = \"\"\n    \n    for char\
    \ in word.characters {\n        if vowels.contains(char.lowercaseString) {\n \
    \           if char == char.lowercaseString.reversed().first {\n             \
    \   result = char.lowercaseString\n                break\n            }\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoki8f6qq.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpoki8f6qq.swift:23:33:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n        if\
    \ vowels.contains(char.lowercaseString) {\n                           ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpoki8f6qq.swift:24:29: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            if char == char.lowercaseString.reversed().first {\n            \
    \           ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpoki8f6qq.swift:25:31: error: value of\
    \ type 'Character' has no member 'lowercaseString'\n                result = char.lowercaseString\n\
    \                         ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowelIndex = 0\n \
    \   var vowel = \"\"\n    \n    for index in 0..<word.count {\n        if word[index]\
    \ == vowel {\n            vowelIndex += 1\n            if vowelIndex == 2 {\n\
    \                return vowel\n            }\n        }\n    }\n    \n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ti_axuf.swift:25:16: error: no exact matches in call to subscript\
    \ \n        if word[index] == vowel {\n               ^\nSwift.String:3:12: note:\
    \ candidate expects value of type 'Range<String.Index>' for parameter #1 (got\
    \ 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get }\n\
    \           ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var index = word.characters.count\
    \ - 1\n    \n    while index >= 0 {\n        \n        let char = word.characters[index]\n\
    \        \n        if vowels.contains(char) {\n            \n            return\
    \ char\n        }\n        \n        index--\n    }\n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpd1348mba.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var index = word.characters.count - 1\n           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpd1348mba.swift:24:20: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let char = word.characters[index]\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpd1348mba.swift:24:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        let char = word.characters[index]\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpd1348mba.swift:28:20: error: cannot convert return expression\
    \ of type 'Character' to return type 'String'\n            return char\n     \
    \              ^~~~\n/tmp/tmpd1348mba.swift:31:14: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n        index--\n             ^~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word.characters {\n        if letter\
    \ == \".\" || letter == \"?\" || letter == \"!\" || letter == \"'\" {\n      \
    \      continue\n        }\n        vowels.append(letter)\n    }\n    vowels.sortInPlace()\n\
    \    if vowels.count < 2 {\n        return \"\"\n    }\n    if vowels.count >\
    \ 2 {\n        return vowels[vowels.count - 2]\n    }\n    return vowels[0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpe7wb6wgv.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in word.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpe7wb6wgv.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        vowels.append(letter)\n                      ^\n/tmp/tmpe7wb6wgv.swift:24:12:\
    \ error: value of type '[String]' has no member 'sortInPlace'\n    vowels.sortInPlace()\n\
    \    ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelCount\
    \ = 0\n    var vowelFound = false\n    \n    for char in word.characters {\n \
    \       if vowels.contains(char) {\n            vowelFound = true\n          \
    \  vowelCount += 1\n        }\n        if vowelFound && vowelCount > 1 {\n   \
    \         vowelIndex += 1\n            vowelCount = 0\n        }\n    }\n    \n\
    \    if vowelIndex == 0 {\n        return \"\"\n    }\n    \n    if vowelIndex\
    \ == word.characters.count - 1 {\n        return vowels[vowelIndex - 1]\n    }\n\
    \    \n    if vowelIndex == word.characters.count - 2 {\n        return vowels[vowelIndex\
    \ - 2]\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjnhwfynp.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpjnhwfynp.swift:39:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    if vowelIndex\
    \ == word.characters.count - 1 {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjnhwfynp.swift:40:22: error: cannot convert\
    \ return expression of type 'Character' to return type 'String'\n        return\
    \ vowels[vowelIndex - 1]\n               ~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpjnhwfynp.swift:43:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    if vowelIndex\
    \ == word.characters.count - 2 {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjnhwfynp.swift:44:22: error: cannot convert\
    \ return expression of type 'Character' to return type 'String'\n        return\
    \ vowels[vowelIndex - 2]\n               ~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    let vowelsCount = vowels.count\n    \n    let vowelsIndex =\
    \ word.characters.reversed().enumerate().map { (index, character) -> Int in\n\
    \        if character == \"a\" || character == \"e\" || character == \"i\" ||\
    \ character == \"o\" || character == \"u\" {\n            return index\n     \
    \   }\n        return -1\n    }.max() ?? -1\n    \n    if vowelsIndex == -1 {\n\
    \        return \"\"\n    }\n    \n    let vowelsRange = vowelsIndex..<vowelsIndex\
    \ + vowelsCount\n    \n    let vowelsRangeCount = vowelsRange.count\n    \n  \
    \  let vowelsRangeIndex = word.characters.reversed().enumerate().map { (index,\
    \ character) -> Int in\n        if character == \"a\" || character == \"e\" ||\
    \ character == \"i\" || character == \"o\" || character == \"u\" {\n         \
    \   return index\n        }\n        return -1\n    }.max() ?? -1\n    \n    if\
    \ vowelsRangeIndex == -1 {\n        return \"\"\n    }\n    \n    let vowelsRangeCount\
    \ = vowelsRangeIndex + vowelsCount - vowelsIndex\n    \n    let vowelsRangeIndex2\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex\n    \n    let vowelsRangeIndex3\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex2\n    \n    let vowelsRangeIndex4\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex3\n    \n    let vowelsRangeIndex5\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex4\n    \n    let vowelsRangeIndex6\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex5\n    \n    let vowelsRangeIndex7\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex6\n    \n    let vowelsRangeIndex8\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex7\n    \n    let vowelsRangeIndex9\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex8\n    \n    let vowelsRangeIndex10\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex9\n    \n    let vowelsRangeIndex11\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex10\n    \n    let vowelsRangeIndex12\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex11\n    \n    let vowelsRangeIndex13\
    \ = vowelsIndex + vowelsCount - vowelsRangeIndex12\n    \n    let vowelsRangeIndex14\
    \ = vowelsIndex + \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpm4vap4j_.swift:76:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpm4vap4j_.swift:17:24: error: cannot find 'vowels' in scope\n   \
    \ guard let vowels = vowels.characters.map(String.init) else {\n             \
    \          ^~~~~~\n/tmp/tmpm4vap4j_.swift:23:50: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, character) -> Int in\n                                           \
    \      ^\n/tmp/tmpm4vap4j_.swift:38:55: error: reference to member 'enumerate'\
    \ cannot be resolved without a contextual type\n    let vowelsRangeIndex = word.characters.reversed().enumerate().map\
    \ { (index, character) -> Int in\n                                           \
    \           ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    \n    var vowelsCount = vowels.count\n    \n    var vowelsIndex = 0\n   \
    \ var vowelsCountIndex = 0\n    \n    var consonantsIndex = 0\n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCount = 0\n    \n    var consonantsCountIndex =\
    \ 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var consonantsCountIndex\
    \ = 0\n    \n    var consonantsCountIndex = 0\n    \n    var conson\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp15hos33.swift:34:9: error: invalid redeclaration of 'consonantsCountIndex'\n\
    \    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9: note:\
    \ 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:36:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:38:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:40:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:42:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:44:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:46:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:48:9: error: invalid redeclaration of\
    \ 'consonantsCountIndex'\n    var consonantsCountIndex = 0\n        ^\n/tmp/tmpp15hos33.swift:30:9:\
    \ note: 'consonantsCountIndex' previously declared here\n    var consonantsCountIndex\
    \ = 0\n        ^\n/tmp/tmpp15hos33.swift:5"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount:\
    \ [Int] = [0, 1, 2, 3, 4]\n    var vowelsCountIndex: Int = 0\n    var vowelsCountIndex2:\
    \ Int = 0\n    var vowelsCountIndex3: Int = 0\n    var vowelsCountIndex4: Int\
    \ = 0\n    var vowelsCountIndex5: Int = 0\n    var vowelsCountIndex6: Int = 0\n\
    \    var vowelsCountIndex7: Int = 0\n    var vowelsCountIndex8: Int = 0\n    var\
    \ vowelsCountIndex9: Int = 0\n    var vowelsCountIndex10: Int = 0\n    var vowelsCountIndex11:\
    \ Int = 0\n    var vowelsCountIndex12: Int = 0\n    var vowelsCountIndex13: Int\
    \ = 0\n    var vowelsCountIndex14: Int = 0\n    var vowelsCountIndex15: Int =\
    \ 0\n    var vowelsCountIndex16: Int = 0\n    var vowelsCountIndex17: Int = 0\n\
    \    var vowelsCountIndex18: Int = 0\n    var vowelsCountIndex19: Int = 0\n  \
    \  var vowelsCountIndex20: Int = 0\n    var vowelsCountIndex21: Int = 0\n    var\
    \ vowelsCountIndex22: Int = 0\n    var vowelsCountIndex23: Int = 0\n    var vowelsCountIndex24:\
    \ Int = 0\n    var vowelsCountIndex25: Int = 0\n    var vowelsCountIndex26: Int\
    \ = 0\n    var vowelsCountIndex27: Int = 0\n    var vowelsCountIndex28: Int =\
    \ 0\n    var vowelsCountIndex29: Int = 0\n    var vowelsCountIndex30: Int = 0\n\
    \    var vowelsCountIndex31: Int = 0\n    var vowelsCountIndex32: Int = 0\n  \
    \  var vowelsCountIndex33: Int = 0\n    var vowelsCountIndex34: Int = 0\n    var\
    \ vowelsCountIndex35: Int = 0\n    var vowelsCountIndex36: Int = 0\n    var vowelsCountIndex37:\
    \ Int = 0\n    var vowelsCountIndex38: Int = 0\n    var vowelsCountIndex39: Int\
    \ = 0\n    var vowelsCountIndex40: Int = 0\n    var vowelsCountIndex41: Int =\
    \ 0\n    var vowelsCountIndex42: Int = 0\n    var vowelsCountIndex43: Int = 0\n\
    \    var vowelsCountIndex44: Int = 0\n    var vowelsCountIndex45: Int = 0\n  \
    \  var vowelsCountIndex46: Int = 0\n    var vowelsCountIndex47: Int = 0\n    var\
    \ vowelsCountIndex48: Int = 0\n    var vowelsCountIndex49: Int = 0\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpuvs82162.swift:17:9: warning: variable 'vowels' was never used;\
    \ consider replacing with '_' or removing it\n    var vowels: [String] = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n        ^~~~~~\n        _\n/tmp/tmpuvs82162.swift:18:9:\
    \ warning: variable 'vowelsCount' was never used; consider replacing with '_'\
    \ or removing it\n    var vowelsCount: [Int] = [0, 1, 2, 3, 4]\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmpuvs82162.swift:19:9: warning: variable 'vowelsCountIndex'\
    \ was never used; consider replacing with '_' or removing it\n    var vowelsCountIndex:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~\n        _\n/tmp/tmpuvs82162.swift:20:9: warning:\
    \ variable 'vowelsCountIndex2' was never used; consider replacing with '_' or\
    \ removing it\n    var vowelsCountIndex2: Int = 0\n        ^~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpuvs82162.swift:21:9: warning: variable 'vowelsCountIndex3'\
    \ was never used; consider replacing with '_' or removing it\n    var vowelsCountIndex3:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpuvs82162.swift:22:9:\
    \ warning: variable 'vowelsCountIndex4' was never used; consider replacing with\
    \ '_' or removing it\n    var vowelsCountIndex4: Int = 0\n        ^~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpuvs82162.swift:23:9: warning: variable 'vowelsCountIndex5'\
    \ was never used; consider replacing with '_' or removing it\n    var vowelsCountIndex5:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpuvs82162.swift:24:9:\
    \ warning: variable 'vowelsCountIndex6' was never used; consider replacing with\
    \ '_' or removing it\n    var vowelsCountIndex6: Int = 0\n        ^~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpuvs82162.swift:25:9: warning: variable 'vowelsCountIndex7'\
    \ was never used; consider replacing with '_' or removing it\n    var vowelsCountIndex7:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpuvs82162.swift:26:9:\
    \ warning: variable 'vowelsCountIndex8' was never used; consider replacing with\
    \ '_' or removing it\n    var vowelsCountIndex8: Int = 0\n        ^~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpuvs82162.swift:27:9: warning: variable 'vowelsCountIndex9'\
    \ was never used; cons"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels: [String] =\
    \ []\n    \n    for char in word.characters {\n        if char.unicodeScalars.filter({\
    \ $0.isUppercase }).count > 0 {\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n        }\n    }\n    \n    if vowels.count < 2 {\n\
    \        return \"\"\n    }\n    \n    var result: String = vowels.last!\n   \
    \ \n    if vowels.count > 2 {\n        for char in vowels.dropLast() {\n     \
    \       if char.unicodeScalars.filter({ $0.isUppercase }).count > 0 {\n      \
    \          result = char\n                break\n            }\n        }\n  \
    \  }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmps1tqlzv5.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmps1tqlzv5.swift:24:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUppercase'\n        if\
    \ char.unicodeScalars.filter({ $0.isUppercase }).count > 0 {\n               \
    \                         ~~ ^~~~~~~~~~~\n/tmp/tmps1tqlzv5.swift:25:20: error:\
    \ no exact matches in call to instance method 'append'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                   ^\n/tmp/tmps1tqlzv5.swift:25:20:\
    \ note: found candidate with type '(__owned String) -> ()'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                   ^\n/tmp/tmps1tqlzv5.swift:25:20:\
    \ note: found candidate with type '(__owned Unicode.Scalar) -> ()'\n         \
    \   vowels.append(char.unicodeScalars.filter({ $0.isUppercase }).first!)\n   \
    \                ^\n/tmp/tmps1tqlzv5.swift:25:59: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                                                \
    \       ~~ ^~~~~~~~~~~\n/tmp/tmps1tqlzv5.swift:37:48: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            if char.unicodeScalars.filter({ $0.isUppercase\
    \ }).count > 0 {\n                                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var\
    \ vowelIndex = 0\n    var vowelCount = 0\n    var vowelIndex2 = 0\n    var vowelCount2\
    \ = 0\n    var vowelIndex3 = 0\n    var vowelCount3 = 0\n    var vowelIndex4 =\
    \ 0\n    var vowelCount4 = 0\n    var vowelIndex5 = 0\n    var vowelCount5 = 0\n\
    \    var vowelIndex6 = 0\n    var vowelCount6 = 0\n    var vowelIndex7 = 0\n \
    \   var vowelCount7 = 0\n    var vowelIndex8 = 0\n    var vowelCount8 = 0\n  \
    \  var vowelIndex9 = 0\n    var vowelCount9 = 0\n    var vowelIndex10 = 0\n  \
    \  var vowelCount10 = 0\n    var vowelIndex11 = 0\n    var vowelCount11 = 0\n\
    \    var vowelIndex12 = 0\n    var vowelCount12 = 0\n    var vowelIndex13 = 0\n\
    \    var vowelCount13 = 0\n    var vowelIndex14 = 0\n    var vowelCount14 = 0\n\
    \    var vowelIndex15 = 0\n    var vowelCount15 = 0\n    var vowelIndex16 = 0\n\
    \    var vowelCount16 = 0\n    var vowelIndex17 = 0\n    var vowelCount17 = 0\n\
    \    var vowelIndex18 = 0\n    var vowelCount18 = 0\n    var vowelIndex19 = 0\n\
    \    var vowelCount19 = 0\n    var vowelIndex20 = 0\n    var vowelCount20 = 0\n\
    \    var vowelIndex21 = 0\n    var vowelCount21 = 0\n    var vowelIndex22 = 0\n\
    \    var vowelCount22 = 0\n    var vowelIndex23 = 0\n    var vowelCount23 = 0\n\
    \    var vowelIndex24 = 0\n    var vowelCount24 = 0\n    var vowelIndex25 = 0\n\
    \    var vowelCount25 = 0\n    var vowelIndex26 = 0\n    var vowelCount26 = 0\n\
    \    var vowelIndex27 = 0\n    var vowelCount27 = 0\n    var vowelIndex28 = 0\n\
    \    var vowelCount28 = 0\n    var vowelIndex29 = 0\n    var vowelCount29 = 0\n\
    \    var vowelIndex30 = 0\n    var vowelCount30 = 0\n    var vowelIndex31 = 0\n\
    \    var vowelCount31 = 0\n    var vowelIndex32 = 0\n    var vowelCount32 = 0\n\
    \    var vowelIndex33 = 0\n    var vowelCount33 = 0\n    var vowelIndex34 = 0\n\
    \    var vowelCount34 = 0\n    var vowelIndex35 = 0\n    var vowelCount35 = 0\n\
    \    var vowelIndex36 = 0\n    var vowelCount36 = 0\n    var vowelIndex37 = 0\n\
    \    var vowelCount37 = 0\n    var vowelIndex38 = 0\n    var vowelCount38 = 0\n\
    \    var vowelIndex39 = 0\n    var vowelCount39 = 0\n    var vowelIndex40 = 0\n\
    \    var vowelCount40 = 0\n    var vowelIndex41 = 0\n    var vowelCount41 = 0\n\
    \    var vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpi0zmmj6j.swift:101:9: error: type annotation missing in pattern\n\
    \    var vowel\n        ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.characters {\n        if char.unicodeScalars.filter({\
    \ $0.isVowel }).count > 0 {\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).last!.value)\n        }\n    }\n    return vowels.reduce(\"\"\
    ) { (result, current) -> String in\n        if current == \"\" {\n           \
    \ return result\n        }\n        if current == \"a\" || current == \"e\" ||\
    \ current == \"i\" || current == \"o\" || current == \"u\" {\n            return\
    \ result\n        }\n        if current == \"A\" || current == \"E\" || current\
    \ == \"I\" || current == \"O\" || current == \"U\" {\n            return result\n\
    \        }\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_rzcpsge.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_rzcpsge.swift:19:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isVowel'\n        if char.unicodeScalars.filter({\
    \ $0.isVowel }).count > 0 {\n                                        ~~ ^~~~~~~\n\
    /tmp/tmp_rzcpsge.swift:20:76: error: cannot convert value of type 'UInt32' to\
    \ expected argument type 'String'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).last!.value)\n                                               \
    \                            ^\n/tmp/tmp_rzcpsge.swift:20:59: error: value of\
    \ type 'Unicode.Scalar' has no member 'isVowel'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).last!.value)\n                                               \
    \        ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    var vowelsCount = 0\n    var vowelIndex = 0\n   \
    \ var consonantIndex = 0\n    var consonantCount = 0\n    var consonantIndex2\
    \ = 0\n    var consonantCount2 = 0\n    var consonantIndex3 = 0\n    var consonantCount3\
    \ = 0\n    var consonantIndex4 = 0\n    var consonantCount4 = 0\n    var consonantIndex5\
    \ = 0\n    var consonantCount5 = 0\n    var consonantIndex6 = 0\n    var consonantCount6\
    \ = 0\n    var consonantIndex7 = 0\n    var consonantCount7 = 0\n    var consonantIndex8\
    \ = 0\n    var consonantCount8 = 0\n    var consonantIndex9 = 0\n    var consonantCount9\
    \ = 0\n    var consonantIndex10 = 0\n    var consonantCount10 = 0\n    var consonantIndex11\
    \ = 0\n    var consonantCount11 = 0\n    var consonantIndex12 = 0\n    var consonantCount12\
    \ = 0\n    var consonantIndex13 = 0\n    var consonantCount13 = 0\n    var consonantIndex14\
    \ = 0\n    var consonantCount14 = 0\n    var consonantIndex15 = 0\n    var consonantCount15\
    \ = 0\n    var consonantIndex16 = 0\n    var consonantCount16 = 0\n    var consonantIndex17\
    \ = 0\n    var consonantCount17 = 0\n    var consonantIndex18 = 0\n    var consonantCount18\
    \ = 0\n    var consonantIndex19 = 0\n    var consonantCount19 = 0\n    var consonantIndex20\
    \ = 0\n    var consonantCount20 = 0\n    var consonantIndex21 = 0\n    var consonantCount21\
    \ = 0\n    var consonantIndex22 = 0\n    var consonantCount22 = 0\n    var consonantIndex23\
    \ = 0\n    var consonantCount23 = 0\n    var consonantIndex24 = 0\n    var consonantCount24\
    \ = 0\n    var consonantIndex25 = 0\n    var consonantCount25 = 0\n    var consonantIndex26\
    \ = 0\n    var consonantCount26 = 0\n    var consonantIndex27 = 0\n    var consonantCount27\
    \ = 0\n    var consonantIndex28 = 0\n    var consonantCount28 = 0\n    var consonantIndex29\
    \ = 0\n    var consonantCount29 = 0\n    var consonantIndex30 = 0\n    var consonantCount30\
    \ = 0\n    var consonantIndex31 = 0\n    var consonantCount31 = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwx6ls0fh.swift:82:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpwx6ls0fh.swift:17:9: warning: variable 'vowels' was never used; consider\
    \ replacing with '_' or removing it\n    var vowels: [String] = []\n        ^~~~~~\n\
    \        _\n/tmp/tmpwx6ls0fh.swift:18:9: warning: initialization of variable 'vowelsCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelsCount = 0\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpwx6ls0fh.swift:19:9:\
    \ warning: initialization of variable 'vowelIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var vowelIndex = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpwx6ls0fh.swift:20:9: warning: initialization of variable 'consonantIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantIndex = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpwx6ls0fh.swift:21:9:\
    \ warning: initialization of variable 'consonantCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpwx6ls0fh.swift:22:9: warning: initialization\
    \ of variable 'consonantIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpwx6ls0fh.swift:23:9: warning: initialization of variable 'consonantCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var consonantCount2 = 0\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpwx6ls0fh.swift:24:9:\
    \ warning: initialization of variable 'consonantIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var consonantIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpwx6ls0fh.swift:25:9: warning: initialization\
    \ of variable 'consonantCount3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var consonantCount3 = 0\n    ~~~~^~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpwx6ls0fh.swift:26:9: warning: initialization of variable 'consonantIndex4'\
    \ was never used; consider replacing with assig"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var vowelIndex = 0\n    var vowelIndexEnd = 0\n\
    \    var vowelIndexStart = 0\n    var vowelIndexEndStart = 0\n    var vowelIndexStartEnd\
    \ = 0\n    var vowelIndexEndEnd = 0\n    var vowelIndexStartEndStart = 0\n   \
    \ var vowelIndexStartEndEnd = 0\n    var vowelIndexStartEndStartEnd = 0\n    var\
    \ vowelIndexStartEndStartEndEnd = 0\n    var vowelIndexStartEndStartEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEnd = 0\n    var vowelIndexStartEndStartEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEnd = 0\n   \
    \ var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEnd = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n    var vowelIndexStartEndStartEndEndEnd\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9gfg58c_.swift:42:9: error: invalid redeclaration of 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:41:9: note: 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:43:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:41:9: note: 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:45:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:44:9: note: 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:46:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:44:9: note: 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\
    \ previously declared here\n    var vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd\
    \ = 0\n        ^\n/tmp/tmp9gfg58c_.swift:48:9: error: invalid redeclaration of\
    \ 'vowelIndexStartEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd'\n\
    \    var vowelIndexStartEndStartEndEndEndEndEndEndEndEnd"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    guard let vowelsCount = vowels.count else {\n        return \"\"\n\
    \    }\n    let vowelsCount = vowels.count\n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = vowels.sorted()\n\
    \    let vowelsArrayCount = vowelsArray.count\n    \n    let vowelsArray = \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpikzu6tv8.swift:87:22: error: expected initial value after '='\n\
    \    let vowelsArray = \n                     ^\n/tmp/tmpikzu6tv8.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map(String.init)\
    \ else {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvm1h47tu/tmpvm1h47tu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc1ffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc1cf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc1cf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc1cf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm1h47tu                        0x000055c5bb383307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7dc21e7460 __libc_start_main +
    245

    6    tmpvm1h47tu                        0x000055c5bb382f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013628
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsCount\
    \ = [Int]()\n    for char in word.characters {\n        if vowels.contains(char)\
    \ {\n            vowelsCount[vowels.indexOf(char)]++\n        }\n    }\n    if\
    \ vowelsCount.contains(0) {\n        return \"\"\n    }\n    if vowelsCount.contains(1)\
    \ {\n        return vowels[0]\n    }\n    if vowelsCount.contains(2) {\n     \
    \   return vowels[1]\n    }\n    if vowelsCount.contains(3) {\n        return\
    \ vowels[2]\n    }\n    if vowelsCount.contains(4) {\n        return vowels[3]\n\
    \    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpzjrqlll1.swift:19:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzjrqlll1.swift:20:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if vowels.contains(char) {\n                           ^\n/tmp/tmpzjrqlll1.swift:21:46:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  vowelsCount[vowels.indexOf(char)]++\n                                     \
    \        ^~\n/tmp/tmpzjrqlll1.swift:21:32: error: value of type '[String]' has\
    \ no member 'indexOf'\n            vowelsCount[vowels.indexOf(char)]++\n     \
    \                   ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    var vowels: [String] = []\n\
    \    for char in word.unicodeScalars {\n        if char.value > 0x41 && char.value\
    \ < 0x5A {\n            vowels.append(char.value)\n        }\n    }\n    if vowels.count\
    \ == 0 {\n        return \"\"\n    }\n    var vowelsCount = vowels.count\n   \
    \ var vowelIndex = 0\n    var vowelsIndex = 0\n    var vowelsCountIndex = 0\n\
    \    var consonantsIndex = 0\n    var consonantsCountIndex = 0\n    var consonantsCount\
    \ = 0\n    var consonantsCountMinusOne = 0\n    var consonantsCountMinusTwo =\
    \ 0\n    var consonantsCountMinusThree = 0\n    var consonantsCountMinusFour =\
    \ 0\n    var consonantsCountMinusFive = 0\n    var consonantsCountMinusSix = 0\n\
    \    var consonantsCountMinusSeven = 0\n    var consonantsCountMinusEight = 0\n\
    \    var consonantsCountMinusNine = 0\n    var consonantsCountMinusTen = 0\n \
    \   var consonantsCountMinusEleven = 0\n    var consonantsCountMinusTwelve = 0\n\
    \    var consonantsCountMinusThirteen = 0\n    var consonantsCountMinusFourteen\
    \ = 0\n    var consonantsCountMinusFifteen = 0\n    var consonantsCountMinusSixteen\
    \ = 0\n    var consonantsCountMinusSeventeen = 0\n    var consonantsCountMinusEighteen\
    \ = 0\n    var consonantsCountMinusNineteen = 0\n    var consonantsCountMinusTwenty\
    \ = 0\n    var consonantsCountMinusTwentyOne = 0\n    var consonantsCountMinusTwentyTwo\
    \ = 0\n    var consonantsCountMinusTwentyThree = 0\n    var consonantsCountMinusTwentyFour\
    \ = 0\n    var consonantsCountMinusTwentyFive = 0\n    var consonantsCountMinusTwentySix\
    \ = 0\n    var consonantsCountMinusTwentySeven = 0\n    var consonantsCountMinusTwentyEight\
    \ = 0\n    var consonantsCountMinusTwentyNine = 0\n    var consonantsCountMinusTwentyTen\
    \ = 0\n    var consonantsCountMinusTwentyEleven = 0\n    var consonantsCountMinusTwentyTwelve\
    \ = 0\n    var consonantsCountMinusTwentyThirteen = 0\n    var conson\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpw6219hw_.swift:23:32: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'String'\n            vowels.append(char.value)\n\
    \                               ^\n/tmp/tmpw6219hw_.swift:69:9: error: type annotation\
    \ missing in pattern\n    var conson\n        ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    let vowelIndex = word.characters.reversed().firstIndex(of:\
    \ vowels)\n    \n    if vowelIndex == -1 {\n        return \"\"\n    }\n    \n\
    \    let vowelsCount = word.characters.count - vowelIndex - 1\n    \n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    \n    let vowelsCount = vowelsCount /\
    \ 2\n    \n    let vowelIndex = vowelIndex + vowelsCount\n    \n    let consonantIndex\
    \ = word.characters.reversed().firstIndex(of: consonants)\n    \n    if consonantIndex\
    \ == -1 {\n        return \"\"\n    }\n    \n    let consonantCount = word.characters.count\
    \ - consonantIndex - 1\n    \n    let consonantCount = consonantCount / 2\n  \
    \  \n    let consonantIndex = consonantIndex + consonantCount\n    \n    if consonantIndex\
    \ == word.characters.count {\n        return \"\"\n    }\n    \n    return word.substring(to:\
    \ consonantIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplbilcej9.swift:20:64: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let vowelIndex\
    \ = word.characters.reversed().firstIndex(of: vowels)\n                      \
    \                                         ^\n/tmp/tmplbilcej9.swift:36:68: error:\
    \ cannot find 'consonants' in scope\n    let consonantIndex = word.characters.reversed().firstIndex(of:\
    \ consonants)\n                                                              \
    \     ^~~~~~~~~~\n/tmp/tmplbilcej9.swift:52:17: error: value of type 'String'\
    \ has no member 'substring'\n    return word.substring(to: consonantIndex)\n \
    \          ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    var vowels: [String] = []\n    \n    for char in word.characters {\n    \
    \    if char.unicodeScalars.filter({ $0.isVowel }).count > 0 {\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).first!.value)\n        }\n    }\n    \n    if vowels.count > 0\
    \ {\n        return vowels.sorted().first!\n    }\n    \n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgiq4uonm.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpgiq4uonm.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isVowel'\n        if char.unicodeScalars.filter({\
    \ $0.isVowel }).count > 0 {\n                                        ~~ ^~~~~~~\n\
    /tmp/tmpgiq4uonm.swift:22:77: error: cannot convert value of type 'UInt32' to\
    \ expected argument type 'String'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).first!.value)\n                                              \
    \                              ^\n/tmp/tmpgiq4uonm.swift:22:59: error: value of\
    \ type 'Unicode.Scalar' has no member 'isVowel'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isVowel }).first!.value)\n                                              \
    \         ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for char in word.characters {\n        if char.unicodeScalars.filter({\
    \ $0.isUppercase }).count > 0 {\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n        }\n    }\n    if vowels.count > 0 {\n   \
    \     return vowels.sorted().first!\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4h1cu3rr.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp4h1cu3rr.swift:19:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUppercase'\n        if\
    \ char.unicodeScalars.filter({ $0.isUppercase }).count > 0 {\n               \
    \                         ~~ ^~~~~~~~~~~\n/tmp/tmp4h1cu3rr.swift:20:20: error:\
    \ no exact matches in call to instance method 'append'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                   ^\n/tmp/tmp4h1cu3rr.swift:20:20:\
    \ note: found candidate with type '(__owned String) -> ()'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                   ^\n/tmp/tmp4h1cu3rr.swift:20:20:\
    \ note: found candidate with type '(__owned Unicode.Scalar) -> ()'\n         \
    \   vowels.append(char.unicodeScalars.filter({ $0.isUppercase }).first!)\n   \
    \                ^\n/tmp/tmp4h1cu3rr.swift:20:59: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            vowels.append(char.unicodeScalars.filter({\
    \ $0.isUppercase }).first!)\n                                                \
    \       ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    \n    var\
    \ vowelIndexEnd = word.characters.count - 1\n    \n    var vowelIndexStart = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp2 = word.characters.count - 1\n    \n    var vowelIndexTemp3 =\
    \ word.characters.count - 1\n    \n    var vowelIndexTemp4 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp5 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp6 = word.characters.count - 1\n    \n    var vowelIndexTemp7 =\
    \ word.characters.count - 1\n    \n    var vowelIndexTemp8 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp9 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp10 = word.characters.count - 1\n    \n    var vowelIndexTemp11\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp12 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp13 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp14 = word.characters.count - 1\n    \n    var vowelIndexTemp15\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp16 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp17 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp18 = word.characters.count - 1\n    \n    var vowelIndexTemp19\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp20 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp21 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp22 = word.characters.count - 1\n    \n    var vowelIndexTemp23\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp24 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp25 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp26 = word.characters.count - 1\n    \n    var vowelIndexTemp27\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp28 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp29 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp30 = word.characters.count - 1\n    \n    var vowelIndexTemp31\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp32 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp33 = word.characters.count - 1\n    \n    var\
    \ vowelIndexTemp34 = word.characters.count - 1\n    \n    var vowelIndexTemp35\
    \ = word.characters.count - 1\n    \n    var vowelIndexTemp36 = word.characters.count\
    \ - 1\n    \n    var vowelIndexTemp37 = word.characters.count - 1\n    \n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpedhypm29.swift:22:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowelIndexEnd = word.characters.count - 1\n   \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpedhypm29.swift:24:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexStart = word.characters.count\
    \ - 1\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpedhypm29.swift:26:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexTemp = word.characters.count -\
    \ 1\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpedhypm29.swift:28:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexTemp2 = word.characters.count\
    \ - 1\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpedhypm29.swift:30:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexTemp3 = word.characters.count\
    \ - 1\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpedhypm29.swift:32:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexTemp4 = word.characters.count\
    \ - 1\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpedhypm29.swift:34:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    var vowelIndexTemp5 = word.characters.count\
    \ - 1\n                   "
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelCount\
    \ = 0\n    \n    for char in word.characters {\n        if vowels.contains(String(char))\
    \ {\n            vowelCount += 1\n        }\n    }\n    \n    if vowelCount >\
    \ 0 {\n        vowelIndex = (word.characters.count - vowelCount) / 2\n    }\n\
    \    \n    if vowelIndex < 0 {\n        vowelIndex = 0\n    }\n    \n    return\
    \ String(word.characters[vowelIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4g9mut8f.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp4g9mut8f.swift:30:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        vowelIndex\
    \ = (word.characters.count - vowelCount) / 2\n                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4g9mut8f.swift:37:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    return String(word.characters[vowelIndex])\n\
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4g9mut8f.swift:37:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    return String(word.characters[vowelIndex])\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660028454
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map({ $0.lowercased() }),\n        let vowelsCount\
    \ = vowels.count else {\n            return \"\"\n    }\n    let vowelsCount =\
    \ vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.index(of: char) {\n      \
    \      return index\n        }\n        return -1\n    }.min()\n    guard vowelsIndex\
    \ != -1 else {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n\
    \    let vowelsIndex = word.characters.reversed().enumerate().map { (index, char)\
    \ in\n        if let index = vowels.index(of: char) {\n            return index\n\
    \        }\n        return -1\n    }.max()\n    guard vowelsIndex != -1 else {\n\
    \        return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsIndex\
    \ = word.characters.reversed().enumerate().map { (index, char) in\n        if\
    \ let index = vowels.index(of: char) {\n            return index\n        }\n\
    \        return -1\n    }.max()\n    guard vowelsIndex != -1 else {\n        return\
    \ \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.index(of: char) {\n      \
    \      return index\n        }\n        return -1\n    }.min()\n    guard vowelsIndex\
    \ != -1 else {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n\
    \    let vowelsIndex = word.characters.reversed().enumerate().map { (index, char)\
    \ in\n        if let index = vowels.index(of: char) {\n            return index\n\
    \        }\n        return -1\n    }.min()\n    guard vowelsIndex != -1 else {\n\
    \        return \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsIndex\
    \ = word.characters.reversed().enumerate().map { (index, char) in\n        if\
    \ let index = vowels.index(of: char) {\n            return index\n        }\n\
    \        return -1\n    }.max()\n    guard vowelsIndex != -1 else {\n        return\
    \ \"\"\n    }\n    let vowelsCount = vowels.count\n    let vowelsIndex = word.characters.reversed().enumerate().map\
    \ { (index, char) in\n        if let index = vowels.index(of: char) {\n      \
    \      return index\n        }\n        return -1\n    }.min()\n    guard vowelsIndex\
    \ != -1 else {\n        return \"\"\n    }\n    let vowelsCount = vowels.count\n\
    \    let vowelsIndex = word.characters.reversed().enumerate().map { (index, char)\
    \ in\n        if let index = vowels.index(of\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpmh5l557j.swift:94:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmh5l557j.swift:93:36: note: to match this opening '('\n        if let\
    \ index = vowels.index(of\n                                   ^\n/tmp/tmpmh5l557j.swift:93:39:\
    \ error: expected '{' after 'if' condition\n        if let index = vowels.index(of\n\
    \                                      ^\n/tmp/tmpmh5l557j.swift:121:48: error:\
    \ expected '}' at end of brace statement\nassert(get_closest_vowel(word: \"Above\"\
    ) == \"o\")\n                                               ^\n/tmp/tmpmh5l557j.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmpmh5l557j.swift:17:24:\
    \ error: cannot find 'vowels' in scope\n    guard let vowels = vowels.characters.map({\
    \ $0.lowercased() }),\n                       ^~~~~~\n/tmp/tmpmh5l557j.swift:22:50:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsIndex = word.characters.reversed().enumerate().map { (index,\
    \ char) in\n                                                 ^\n/tmp/tmpmh5l557j.swift:32:50:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsIndex = word.characters.reversed().enumerate().map { (index,\
    \ char) in\n                                                 ^\n/tmp/tmpmh5l557j.swift:42:50:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsIndex = word.characters.reversed().enumerate().map { (index,\
    \ char) in\n                                                 ^\n/tmp/tmpmh5l557j.swift:52:50:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsIndex = word.characters.reversed().enumerate().map { (index,\
    \ char) in\n                                                 ^\n/tmp/tmpmh5l557j.swift:62:50:\
    \ error: reference to member 'enumerate' cannot be resolved without a contextual\
    \ type\n    let vowelsIndex = word.characters.reversed().enumerate().map { (index,\
    \ char)"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    vowels.append(\"A\")\n    vowels.append(\"E\")\n    vowels.append(\"I\")\n\
    \    vowels.append(\"O\")\n    vowels.append(\"U\")\n    \n    var vowelsCount\
    \ = vowels.count\n    \n    var vowelIndex = 0\n    var vowelIndexEnd = vowels.count\
    \ - 1\n    \n    var vowelIndexStart = 0\n    var vowelIndexStartEnd = vowels.count\
    \ - 1\n    \n    var vowelIndexStart1 = vowels.count - 1\n    var vowelIndexStart2\
    \ = vowels.count - 1\n    \n    var vowelIndexStart3 = vowels.count - 1\n    var\
    \ vowelIndexStart4 = vowels.count - 1\n    \n    var vowelIndexStart5 = vowels.count\
    \ - 1\n    var vowelIndexStart6 = vowels.count - 1\n    \n    var vowelIndexStart7\
    \ = vowels.count - 1\n    var vowelIndexStart8 = vowels.count - 1\n    \n    var\
    \ vowelIndexStart9 = vowels.count - 1\n    var vowelIndexStart10 = vowels.count\
    \ - 1\n    \n    var vowelIndexStart11 = vowels.count - 1\n    var vowelIndexStart12\
    \ = vowels.count - 1\n    \n    var vowelIndexStart13 = vowels.count - 1\n   \
    \ var vowelIndexStart14 = vowels.count - 1\n    \n    var vowelIndexStart15 =\
    \ vowels.count - 1\n    var vowelIndexStart16 = vowels.count - 1\n    \n    var\
    \ vowelIndexStart17 = vowels.count - 1\n    var vowelIndexStart18 = vowels.count\
    \ - 1\n    \n    var vowelIndexStart19 = vowels.count - 1\n    var vowelIndexStart20\
    \ = vowels.count - 1\n    \n    var vowelIndexStart21 = vowels.count - 1\n   \
    \ var vowelIndexStart22 = vowels.count - 1\n    \n    var vowelIndexStart23 =\
    \ vowels.count - 1\n    var vowelIndexStart24 = vowels.count - 1\n    \n    var\
    \ vowelIndexStart25 = vowels.count - 1\n    var vowelIndexStart26 = vowels.count\
    \ - 1\n    \n    var vowelIndexStart27 = vowels.count - 1\n    var vowelIndexStart28\
    \ = vowels.count - 1\n    \n    var vowelIndexStart29 = vowels.count - 1\n   \
    \ var vowelIndexStart30 = vowels.count - 1\n    \n    var vowelIndexStart31 =\
    \ vowels.count - 1\n    var vowelIndexStart32 = vowels.count - 1\n    \n    var\
    \ vowelIndexStart33 = vowels.count - 1\n    var vowelIndexStart34 = vowels.count\
    \ - 1\n    \n    var vowelIndexStart\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpp6s67nbo.swift:88:9: error: type annotation missing in pattern\n\
    \    var vowelIndexStart\n        ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word == \"\" {\n        return \"\"\n    }\n    \n    var vowels = [String]()\n\
    \    \n    for char in word.characters {\n        if char.unicodeScalars.contains(.vowel)\
    \ {\n            vowels.append(char)\n        }\n    }\n    \n    if vowels.isEmpty\
    \ {\n        return \"\"\n    }\n    \n    let vowel = vowels.sorted().first!\n\
    \    \n    if vowel.unicodeScalars.contains(.consonant) {\n        return vowel\n\
    \    }\n    \n    let index = word.characters.index(of: vowel)\n    \n    if index\
    \ == word.characters.endIndex {\n        return \"\"\n    }\n    \n    let start\
    \ = index + 1\n    \n    if start == word.characters.endIndex {\n        return\
    \ \"\"\n    }\n    \n    let end = word.characters.index(of: vowel, in: start!,\
    \ offsetBy: 1)\n    \n    if end == word.characters.endIndex {\n        return\
    \ \"\"\n    }\n    \n    let range = start..<end\n    \n    return word.substring(with:\
    \ range)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphu1adgbf.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmphu1adgbf.swift:24:42:\
    \ error: type 'Unicode.Scalar' has no member 'vowel'\n        if char.unicodeScalars.contains(.vowel)\
    \ {\n                                        ~^~~~~\n/tmp/tmphu1adgbf.swift:25:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(char)\n                          ^\n/tmp/tmphu1adgbf.swift:35:39:\
    \ error: type 'Unicode.Scalar' has no member 'consonant'\n    if vowel.unicodeScalars.contains(.consonant)\
    \ {\n                                     ~^~~~~~~~~\n/tmp/tmphu1adgbf.swift:39:43:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    let index = word.characters.index(of: vowel)\n      \
    \                                    ^\n/tmp/tmphu1adgbf.swift:51:57: error: extra\
    \ argument 'in' in call\n    let end = word.characters.index(of: vowel, in: start!,\
    \ offsetBy: 1)\n                                   ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmphu1adgbf.swift:51:41: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Index'\n    let end = word.characters.index(of:\
    \ vowel, in: start!, offsetBy: 1)\n                                        ^\n\
    /tmp/tmphu1adgbf.swift:59:17: error: value of type 'String' has no member 'substring'\n\
    \    return word.substring(with: range)\n           ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ let vowels = vowels.characters.map(String.init) else {\n        return \"\"\n\
    \    }\n    \n    var vowelIndex = 0\n    var vowelCount = 0\n    \n    for char\
    \ in word.characters.reversed() {\n        if vowels[vowelIndex] == char {\n \
    \           vowelCount += 1\n        }\n        \n        if vowelCount > 1 {\n\
    \            vowelIndex += 1\n            vowelCount = 0\n        }\n    }\n \
    \   \n    if vowelIndex == vowels.count {\n        return \"\"\n    }\n    \n\
    \    return vowels[vowelIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpop4v1ws5.swift:17:24: error: cannot find 'vowels' in scope\n  \
    \  guard let vowels = vowels.characters.map(String.init) else {\n            \
    \           ^~~~~~\n/tmp/tmpop4v1ws5.swift:24:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in word.characters.reversed() {\n \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = \"aeiouAEIOU\"\n    \n    var vowelIndex = 0\n    var vowelIndexEnd\
    \ = word.count\n    \n    while vowelIndex < vowelIndexEnd {\n        \n     \
    \   let index = word.index(vowels[vowelIndex], offsetBy: vowelIndex + 1)\n   \
    \     \n        if index != nil {\n            vowelIndex = index!\n        }\
    \ else {\n            vowelIndex += 1\n        }\n    }\n    \n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ywn1eng.swift:25:38: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String.Index'\n        let index = word.index(vowels[vowelIndex],\
    \ offsetBy: vowelIndex + 1)\n                                     ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    vowels.append(\"a\")\n    vowels.append(\"e\")\n  \
    \  vowels.append(\"i\")\n    vowels.append(\"o\")\n    vowels.append(\"u\")\n\
    \    vowels.append(\"A\")\n    vowels.append(\"E\")\n    vowels.append(\"I\")\n\
    \    vowels.append(\"O\")\n    vowels.append(\"U\")\n    \n    var vowelsCount\
    \ = vowels.count\n    \n    var vowelIndex = 0\n    var vowelsCountIndex = 0\n\
    \    \n    var vowelsCountMinusOne = vowelsCount - 1\n    \n    var vowelsCountMinusTwo\
    \ = vowelsCount - 2\n    \n    var vowelsCountMinusThree = vowelsCount - 3\n \
    \   \n    var vowelsCountMinusFour = vowelsCount - 4\n    \n    var vowelsCountMinusFive\
    \ = vowelsCount - 5\n    \n    var vowelsCountMinusSix = vowelsCount - 6\n   \
    \ \n    var vowelsCountMinusSeven = vowelsCount - 7\n    \n    var vowelsCountMinusEight\
    \ = vowelsCount - 8\n    \n    var vowelsCountMinusNine = vowelsCount - 9\n  \
    \  \n    var vowelsCountMinusTen = vowelsCount - 10\n    \n    var vowelsCountMinusEleven\
    \ = vowelsCount - 11\n    \n    var vowelsCountMinusTwelve = vowelsCount - 12\n\
    \    \n    var vowelsCountMinusThirteen = vowelsCount - 13\n    \n    var vowelsCountMinusFourteen\
    \ = vowelsCount - 14\n    \n    var vowelsCountMinusFifteen = vowelsCount - 15\n\
    \    \n    var vowelsCountMinusSixteen = vowelsCount - 16\n    \n    var vowelsCountMinusSeventeen\
    \ = vowelsCount - 17\n    \n    var vowelsCountMinusEighteen = vowelsCount - 18\n\
    \    \n    var vowelsCountMinusNineteen = vowelsCount - 19\n    \n    var vowelsCountMinusTwenty\
    \ = vowelsCount - 20\n    \n    var vowelsCountMinusTwentyOne = vowelsCount -\
    \ 21\n    \n    var vowelsCountMinusTwentyTwo = vowelsCount - 22\n    \n    var\
    \ vowelsCountMinusTwentyThree = vowelsCount - 23\n    \n    var vowelsCountMinusTwentyFour\
    \ = vowelsCount - 24\n    \n    var vowelsCountMin\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ldqsjqa.swift:82:9: error: type annotation missing in pattern\n\
    \    var vowelsCountMin\n        ^\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ getClosestVowel(word, vowels: vowels)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplchr4zq6.swift:17:12: error: cannot find 'getClosestVowel' in scope\n\
    \    return getClosestVowel(word, vowels: vowels)\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmplchr4zq6.swift:17:42: error: cannot find 'vowels' in scope\n    return\
    \ getClosestVowel(word, vowels: vowels)\n                                    \
    \     ^~~~~~\n"
  stdout: ''
  timestamp: 1660028455
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: [String] = []\n    for letter in word {\n        if letter.isUpper()\
    \ {\n            vowels.append(letter)\n        } else if letter.isLower() {\n\
    \            vowels.append(letter)\n        }\n    }\n    vowels.sortInPlace()\n\
    \    if vowels.count > 0 {\n        return vowels[vowels.count - 1]\n    }\n \
    \   return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp46gfmasv.swift:19:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp46gfmasv.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp46gfmasv.swift:21:26:\
    \ error: value of type 'Character' has no member 'isLower'\n        } else if\
    \ letter.isLower() {\n                  ~~~~~~ ^~~~~~~\n/tmp/tmp46gfmasv.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            vowels.append(letter)\n                          ^\n/tmp/tmp46gfmasv.swift:25:12:\
    \ error: value of type '[String]' has no member 'sortInPlace'\n    vowels.sortInPlace()\n\
    \    ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028455
