language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69\
    \ = 0\n    var factorizationIndex70 = 0\n    var factorizationIndex71 = 0\n  \
    \  var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjzaoiszy.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var isPrime: Bool = false\n  \
    \  var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeIndex2 = 0\n\
    \    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n    var isPrimeCount3 =\
    \ 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 = 0\n    var isPrimeCount6\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9 = 0\n    var isPrimeCount9\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10 = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12 = 0\n    var isPrimeCount12\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13 = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15 = 0\n    var isPrimeCount15\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16 = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18 = 0\n    var isPrimeCount18\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19 = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21 = 0\n    var isPrimeCount21\
    \ = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24 = 0\n    var isPrimeCount24\
    \ = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25 = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27 = 0\n    var isPrimeCount27\
    \ = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28 = 0\n    var isPrimeIndex29\
    \ = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30 = 0\n    var isPrimeCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp94d7b712.swift:76:9: error: type annotation missing in pattern\n\
    \    var isPrimeCount\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var primeFactorization = [Int]()\n    var\
    \ primeFactors = [Int]()\n    var primeFactorsCount = 0\n    var primeFactorsSum\
    \ = 0\n    var primeFactorsSum2 = 0\n    var primeFactorsSum3 = 0\n    var primeFactorsSum4\
    \ = 0\n    var primeFactorsSum5 = 0\n    var primeFactorsSum6 = 0\n    var primeFactorsSum7\
    \ = 0\n    var primeFactorsSum8 = 0\n    var primeFactorsSum9 = 0\n    var primeFactorsSum10\
    \ = 0\n    var primeFactorsSum11 = 0\n    var primeFactorsSum12 = 0\n    var primeFactorsSum13\
    \ = 0\n    var primeFactorsSum14 = 0\n    var primeFactorsSum15 = 0\n    var primeFactorsSum16\
    \ = 0\n    var primeFactorsSum17 = 0\n    var primeFactorsSum18 = 0\n    var primeFactorsSum19\
    \ = 0\n    var primeFactorsSum20 = 0\n    var primeFactorsSum21 = 0\n    var primeFactorsSum22\
    \ = 0\n    var primeFactorsSum23 = 0\n    var primeFactorsSum24 = 0\n    var primeFactorsSum25\
    \ = 0\n    var primeFactorsSum26 = 0\n    var primeFactorsSum27 = 0\n    var primeFactorsSum28\
    \ = 0\n    var primeFactorsSum29 = 0\n    var primeFactorsSum30 = 0\n    var primeFactorsSum31\
    \ = 0\n    var primeFactorsSum32 = 0\n    var primeFactorsSum33 = 0\n    var primeFactorsSum34\
    \ = 0\n    var primeFactorsSum35 = 0\n    var primeFactorsSum36 = 0\n    var primeFactorsSum37\
    \ = 0\n    var primeFactorsSum38 = 0\n    var primeFactorsSum39 = 0\n    var primeFactorsSum40\
    \ = 0\n    var primeFactorsSum41 = 0\n    var primeFactorsSum42 = 0\n    var primeFactorsSum43\
    \ = 0\n    var primeFactorsSum44 = 0\n    var primeFactorsSum45 = 0\n    var primeFactorsSum46\
    \ = 0\n    var primeFactorsSum47 = 0\n    var primeFactorsSum48 = 0\n    var primeFactorsSum49\
    \ = 0\n    var primeFactorsSum50 = 0\n    var primeFactorsSum51 = 0\n    var primeFactorsSum52\
    \ = 0\n    var primeFactorsSum53 = 0\n    var primeFactorsSum54 = 0\n    var primeFactorsSum55\
    \ = 0\n    var primeFactorsSum56 = 0\n    var primeFactorsSum57 = 0\n    var primeFactorsSum58\
    \ = 0\n    var primeFactorsSum59 = 0\n    var prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt8yh72e3.swift:76:9: error: type annotation missing in pattern\n\
    \    var prime\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factor != 1 {\n         \
    \   factors.append(factor)\n            factorizationCount *= factor\n       \
    \ }\n    }\n    if factorizationCount == 1 {\n        return factors\n    }\n\
    \    var primeFactors = [Int]()\n    var primeFactorization = factorizationOfNumber(n)\n\
    \    var primeFactorizationCount = 1\n    for primeFactor in primeFactorization\
    \ {\n        if primeFactor != 1 {\n            primeFactors.append(primeFactor)\n\
    \            primeFactorizationCount *= primeFactor\n        }\n    }\n    var\
    \ primeFactorizationCount = 1\n    for primeFactorIndex in 0..<primeFactors.count\
    \ {\n        let primeFactor = primeFactors[primeFactorIndex]\n        if primeFactorizationCount\
    \ != 1 {\n            factors.append(primeFactor)\n            factorizationCount\
    \ *= primeFactor\n        }\n        if factorizationCount != 1 {\n          \
    \  factors.append(factorizationCount)\n            factorizationCount = 1\n  \
    \      }\n        primeFactorizationCount *= primeFactor\n    }\n    if factorizationCount\
    \ != 1 {\n        factors.append(factorizationCount)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpko9ff6zh.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpko9ff6zh.swift:25:30: error: cannot find\
    \ 'factorizationOfNumber' in scope\n    var primeFactorization = factorizationOfNumber(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpko9ff6zh.swift:33:9:\
    \ error: invalid redeclaration of 'primeFactorizationCount'\n    var primeFactorizationCount\
    \ = 1\n        ^\n/tmp/tmpko9ff6zh.swift:26:9: note: 'primeFactorizationCount'\
    \ previously declared here\n    var primeFactorizationCount = 1\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ojb6t8.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberRemainder = 0\n    var factorizationNumberRemainderCount\
    \ = 0\n    var factorizationNumberRemainderIndex = 0\n    var factorizationNumberRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainder = 0\n    var factorizationNumberRemainderRemainderRemainderCount\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainder = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \  var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \  var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemain\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7rbf5hnj.swift:31:9: error: invalid redeclaration of 'factorizationNumberRemainderRemainderRemainderRemainderCount'\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \      ^\n/tmp/tmp7rbf5hnj.swift:28:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderCount'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:32:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:29:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:33:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderRemainder'\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n     \
    \   ^\n/tmp/tmp7rbf5hnj.swift:30:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderRemainder'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:34:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderCount'\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:28:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderCount'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:35:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:29:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemai"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var k = n\n    while i * j <= k {\n       \
    \ if n % i == 0 {\n            factors.append(i)\n            n /= i\n       \
    \ }\n        if n % j == 0 {\n            factors.append(j)\n            n /=\
    \ j\n        }\n        i += 1\n        j += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsoveb22z.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpsoveb22z.swift:23:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexCount = 0\n    var factorizationIndexCountMax = Int(IntMax)\n\
    \    var factorizationIndexCountMin = Int(IntMin)\n    var factorizationIndexCountMaxInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinInt = Int(IntMin)\n    var\
    \ factorizationIndexCountMaxFloat = Float(FloatMax)\n    var factorizationIndexCountMinFloat\
    \ = Float(FloatMin)\n    var factorizationIndexCountMaxDouble = Double(DoubleMax)\n\
    \    var factorizationIndexCountMinDouble = Double(DoubleMin)\n    var factorizationIndexCountMaxBool\
    \ = Bool(BoolMax)\n    var factorizationIndexCountMinBool = Bool(BoolMin)\n  \
    \  var factorizationIndexCountMaxString = String(StringMax)\n    var factorizationIndexCountMinString\
    \ = String(StringMin)\n    var factorizationIndexCountMaxArray = Array<Int>(ArrayMax)\n\
    \    var factorizationIndexCountMinArray = Array<Int>(ArrayMin)\n    var factorizationIndexCountMaxDictionary\
    \ = Dictionary<Int, Int>(DictionaryMax)\n    var factorizationIndexCountMinDictionary\
    \ = Dictionary<Int, Int>(DictionaryMin)\n    var factorizationIndexCountMaxSet\
    \ = Set<Int>(SetMax)\n    var factorizationIndexCountMinSet = Set<Int>(SetMin)\n\
    \    var factorizationIndexCountMaxArraySlice = ArraySlice<Int>(ArraySliceMax)\n\
    \    var factorizationIndexCountMinArraySlice = ArraySlice<Int>(ArraySliceMin)\n\
    \    var factorizationIndexCountMaxDictionarySlice = DictionarySlice<Int, Int>(DictionarySliceMax)\n\
    \    var factorizationIndexCountMinDictionarySlice = DictionarySlice<Int, Int>(DictionarySliceMin)\n\
    \    var factorizationIndexCountMaxSetSlice = SetSlice<Int>(SetSliceMax)\n   \
    \ var factorizationIndexCountMinSetSlice = SetSlice<Int>(SetSliceMin)\n    var\
    \ factorizationIndexCountMaxArraySliceFromIndex = ArraySliceFromIndex<Int>(ArraySliceFromIndexMax)\n\
    \    var factorizationIndexCountMinArraySliceFromIndex = ArraySliceFromIndex<Int>(ArraySliceFromIndexMin)\n\
    \    var factorizationIndexCountMaxDictionarySliceFromIndex = DictionarySliceFromIndex<Int,\
    \ Int>(DictionarySliceFromIndexMax)\n    var factorizationIndexCountMinDictionarySliceFromIndex\
    \ = DictionarySliceFromIndex<Int, Int>(DictionarySliceFromIndexMin)\n    var factorizationIndexCountMaxSetSliceFromIndex\
    \ = SetSlice\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe7t5rvvx.swift:16:42: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationIndexCountMax = Int(IntMax)\n                            \
    \             ^~~~~~\n/tmp/tmpe7t5rvvx.swift:17:42: error: cannot find 'IntMin'\
    \ in scope\n    var factorizationIndexCountMin = Int(IntMin)\n               \
    \                          ^~~~~~\n/tmp/tmpe7t5rvvx.swift:18:45: error: cannot\
    \ find 'IntMax' in scope\n    var factorizationIndexCountMaxInt = Int(IntMax)\n\
    \                                            ^~~~~~\n/tmp/tmpe7t5rvvx.swift:19:45:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinInt\
    \ = Int(IntMin)\n                                            ^~~~~~\n/tmp/tmpe7t5rvvx.swift:20:49:\
    \ error: cannot find 'FloatMax' in scope\n    var factorizationIndexCountMaxFloat\
    \ = Float(FloatMax)\n                                                ^~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:21:49: error: cannot find 'FloatMin' in scope\n    var\
    \ factorizationIndexCountMinFloat = Float(FloatMin)\n                        \
    \                        ^~~~~~~~\n/tmp/tmpe7t5rvvx.swift:22:51: error: cannot\
    \ find 'DoubleMax' in scope\n    var factorizationIndexCountMaxDouble = Double(DoubleMax)\n\
    \                                                  ^~~~~~~~~\n/tmp/tmpe7t5rvvx.swift:23:51:\
    \ error: cannot find 'DoubleMin' in scope\n    var factorizationIndexCountMinDouble\
    \ = Double(DoubleMin)\n                                                  ^~~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:24:47: error: cannot find 'BoolMax' in scope\n    var factorizationIndexCountMaxBool\
    \ = Bool(BoolMax)\n                                              ^~~~~~~\n/tmp/tmpe7t5rvvx.swift:25:47:\
    \ error: cannot find 'BoolMin' in scope\n    var factorizationIndexCountMinBool\
    \ = Bool(BoolMin)\n                                              ^~~~~~~\n/tmp/tmpe7t5rvvx.swift:26:51:\
    \ error: cannot find 'StringMax' in scope\n    var factorizationIndexCountMaxString\
    \ = String(StringMax)\n                                                  ^~~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:27:51: error: cannot find 'StringMin' in scope\n    var\
    \ factori"
  stdout: ''
  timestamp: 1659825016
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorCount = 0\n    var isPrime = true\n\
    \    var isDivisible = false\n    while factor <= n {\n        if n % factor ==\
    \ 0 {\n            factorCount += 1\n            if factor > 2 {\n           \
    \     factorization[factorCount] = factor\n            }\n            if isPrime\
    \ {\n                isPrime = false\n            }\n            if isDivisible\
    \ {\n                factorization[factorCount] = factor\n            }\n    \
    \        isDivisible = true\n        } else {\n            isPrime = true\n  \
    \          if factor > 2 {\n                factorization[factorCount] = factor\n\
    \            }\n            if isDivisible {\n                factorization[factorCount]\
    \ = factor\n            }\n            isDivisible = false\n        }\n      \
    \  factor += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpwvdtg7rn/tmpwvdtg7rn.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31f4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31c41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a31c41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a31c407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwvdtg7rn                        0x0000558039bc6462 <unavailable> + 5218

    5    libc.so.6                          0x00002b1a32136460 __libc_start_main +
    245

    6    tmpwvdtg7rn                        0x0000558039bc60b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var factorization\
    \ = [Int]()\n    var factorizationCount = [Int]()\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6kxu6sdb.swift:24:9: error: invalid redeclaration of 'isPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationIndex = false\n        ^\n/tmp/tmp6kxu6sdb.swift:21:9:\
    \ note: 'isPrimeFactorizationIndex' previously declared here\n    var isPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:25:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationCountIndex'\n    var isPrimeFactorizationCountIndex = false\n\
    \        ^\n/tmp/tmp6kxu6sdb.swift:23:9: note: 'isPrimeFactorizationCountIndex'\
    \ previously declared here\n    var isPrimeFactorizationCountIndex = 0\n     \
    \   ^\n/tmp/tmp6kxu6sdb.swift:26:9: error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n\
    \    var isPrimeFactorizationCountIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9:\
    \ note: 'isPrimeFactorizationCountIndex' previously declared here\n    var isPrimeFactorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:27:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = false\n   \
    \     ^\n/tmp/tmp6kxu6sdb.swift:21:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n    var isPrimeFactorizationCountIndex\
    \ = false\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9: note: 'isPrimeFactorizationCountIndex'\
    \ previously declared here\n    var isPrimeFactorizationCountIndex = 0\n     \
    \   ^\n/tmp/tmp6kxu6sdb.swift:29:9: error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n\
    \    var isPrimeFactorizationCountIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9:\
    \ note: 'isPrimeFactorizationCountIndex' previously declared here\n    var isPrimeFactorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:30:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = false\n   \
    \     ^\n/tmp/tmp6kxu6sdb.swift:21:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:31:9:\
    \ error: i"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            i\
    \ += 1\n            factors.append(i)\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpxhufa8s3/tmpxhufa8s3.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcf88fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcf85f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcf85f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcf85f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxhufa8s3                        0x0000557f5d76a4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002adcf8ae6460 __libc_start_main +
    245

    6    tmpxhufa8s3                        0x0000557f5d76a119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > factors.count\
    \ {\n            factors.append(factor)\n        } else {\n            factors[factors.count-1]\
    \ *= factor\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1rnbkk01.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ factorizationCountIndex = 0\n    var isPrime = true\n    var isPrimeIndex =\
    \ 0\n    var isPrimeCount = 0\n    var isPrimeCountIndex = 0\n    var isPrimeCountMax\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMin = 0\n    var\
    \ isPrimeCountMinIndex = 0\n    var isPrimeCountMaxMin = 0\n    var isPrimeCountMaxMinIndex\
    \ = 0\n    var isPrimeCountMinMax = 0\n    var isPrimeCountMinMaxIndex = 0\n \
    \   var isPrimeCountMaxMinMax = 0\n    var isPrimeCountMaxMinMaxIndex = 0\n  \
    \  var isPrimeCountMinMaxMinMax = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4mnksiyj.swift:60:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp4mnksiyj.swift:32:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:34:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:36:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:38:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n   "
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = factorization(n)\n    for prime in primes {\n        factors.append(prime)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkemebmpx.swift:13:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n\
    \    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n    var isPrime4:\
    \ Bool = false\n    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n\
    \    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n    var isPrime9:\
    \ Bool = false\n    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n\
    \    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n    var isPrime14:\
    \ Bool = false\n    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n\
    \    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n    var isPrime19:\
    \ Bool = false\n    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n\
    \    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n    var isPrime24:\
    \ Bool = false\n    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n\
    \    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n    var isPrime29:\
    \ Bool = false\n    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n\
    \    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n    var isPrime34:\
    \ Bool = false\n    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n\
    \    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n    var isPrime39:\
    \ Bool = false\n    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n\
    \    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n    var isPrime44:\
    \ Bool = false\n    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n\
    \    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n    var isPrime49:\
    \ Bool = false\n    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n\
    \    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n    var isPrime54:\
    \ Bool = false\n    var isPrime55: Bool = false\n    var isPrime56: Bool\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp14cigtuu.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:13:9: warning:\
    \ variable 'primeFactorization' was never used; consider replacing with '_' or\
    \ removing it\n    var primeFactorization: [Int] = []\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp14cigtuu.swift:14:9: warning: variable 'isPrime' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime: Bool = false\n\
    \        ^~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:15:9: warning: variable 'isPrime2'\
    \ was never used; consider replacing with '_' or removing it\n    var isPrime2:\
    \ Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:16:9: warning:\
    \ variable 'isPrime3' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:17:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:18:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:19:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:20:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:21:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:22:9:\
    \ warning: variable 'isPrime9' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime9: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:23:9:\
    \ warning: variable 'isPrime10' was never used; consider r"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMaxInt\
    \ = Int(ceil(sqrt(Double(isPrimeCountMax))))\n    var isPrimeCountMaxDouble =\
    \ Double(isPrimeCountMaxInt)\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6901wv48.swift:38:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp6901wv48.swift:16:31: error: cannot find 'ceil' in scope\n    var\
    \ isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                             \
    \ ^~~~\n/tmp/tmp6901wv48.swift:16:36: error: cannot find 'sqrt' in scope\n   \
    \ var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                         \
    \          ^~~~\n/tmp/tmp6901wv48.swift:17:34: error: cannot find 'ceil' in scope\n\
    \    var isPrimeCountMaxInt = Int(ceil(sqrt(Double(isPrimeCountMax))))\n     \
    \                            ^~~~\n/tmp/tmp6901wv48.swift:17:39: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMaxInt = Int(ceil(sqrt(Double(isPrimeCountMax))))\n\
    \                                      ^~~~\n/tmp/tmp6901wv48.swift:19:40: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:19:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:20:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:20:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:21:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:21:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:22:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCo"
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n    var isPrimeCountMin: Int = 1\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_3m9552n.swift:20:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:23:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:19:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:17:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:26:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primes = [Int]()\n    var factor = 2\n    var prime = 1\n    var isPrime\
    \ = true\n    var isFactor = false\n    var isPrimeFactor = false\n    var isPrimeFactor2\
    \ = false\n    var isPrimeFactor3 = false\n    var isPrimeFactor4 = false\n  \
    \  var isPrimeFactor5 = false\n    var isPrimeFactor6 = false\n    var isPrimeFactor7\
    \ = false\n    var isPrimeFactor8 = false\n    var isPrimeFactor9 = false\n  \
    \  var isPrimeFactor10 = false\n    var isPrimeFactor11 = false\n    var isPrimeFactor12\
    \ = false\n    var isPrimeFactor13 = false\n    var isPrimeFactor14 = false\n\
    \    var isPrimeFactor15 = false\n    var isPrimeFactor16 = false\n    var isPrimeFactor17\
    \ = false\n    var isPrimeFactor18 = false\n    var isPrimeFactor19 = false\n\
    \    var isPrimeFactor20 = false\n    var isPrimeFactor21 = false\n    var isPrimeFactor22\
    \ = false\n    var isPrimeFactor23 = false\n    var isPrimeFactor24 = false\n\
    \    var isPrimeFactor25 = false\n    var isPrimeFactor26 = false\n    var isPrimeFactor27\
    \ = false\n    var isPrimeFactor28 = false\n    var isPrimeFactor29 = false\n\
    \    var isPrimeFactor30 = false\n    var isPrimeFactor31 = false\n    var isPrimeFactor32\
    \ = false\n    var isPrimeFactor33 = false\n    var isPrimeFactor34 = false\n\
    \    var isPrimeFactor35 = false\n    var isPrimeFactor36 = false\n    var isPrimeFactor37\
    \ = false\n    var isPrimeFactor38 = false\n    var isPrimeFactor39 = false\n\
    \    var isPrimeFactor40 = false\n    var isPrimeFactor41 = false\n    var isPrimeFactor42\
    \ = false\n    var isPrimeFactor43 = false\n    var isPrimeFactor44 = false\n\
    \    var isPrimeFactor45 = false\n    var isPrimeFactor46 = false\n    var isPrimeFactor47\
    \ = false\n    var isPrimeFactor48 = false\n    var isPrimeFactor49 = false\n\
    \    var isPrimeFactor50 = false\n    var isPrimeFactor51 = false\n    var isPrimeFactor52\
    \ = false\n    var isPrimeFactor53 = false\n    var isPrimeFactor54 = false\n\
    \    var isPrimeFactor55 = false\n    var isPrimeFactor56 = false\n    var isPrimeFactor57\
    \ = false\n    var isPrimeFactor58 = false\n    var isPrimeFactor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu0j9yfq_.swift:76:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimePrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimeFactorizationIndex = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimeFactorization = false\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpysum917d.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \        ^\n/tmp/tmpysum917d.swift:30:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpysum917d.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpysum917d.swift:34:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpysum917d.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpysum917d.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpysum917d.swift:39:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factor = 1\n    var prime = 1\n    var isPrime = true\n    var isPrime2\
    \ = true\n    var isPrime3 = true\n    var isPrime4 = true\n    var isPrime5 =\
    \ true\n    var isPrime6 = true\n    var isPrime7 = true\n    var isPrime8 = true\n\
    \    var isPrime9 = true\n    var isPrime10 = true\n    var isPrime11 = true\n\
    \    var isPrime12 = true\n    var isPrime13 = true\n    var isPrime14 = true\n\
    \    var isPrime15 = true\n    var isPrime16 = true\n    var isPrime17 = true\n\
    \    var isPrime18 = true\n    var isPrime19 = true\n    var isPrime20 = true\n\
    \    var isPrime21 = true\n    var isPrime22 = true\n    var isPrime23 = true\n\
    \    var isPrime24 = true\n    var isPrime25 = true\n    var isPrime26 = true\n\
    \    var isPrime27 = true\n    var isPrime28 = true\n    var isPrime29 = true\n\
    \    var isPrime30 = true\n    var isPrime31 = true\n    var isPrime32 = true\n\
    \    var isPrime33 = true\n    var isPrime34 = true\n    var isPrime35 = true\n\
    \    var isPrime36 = true\n    var isPrime37 = true\n    var isPrime38 = true\n\
    \    var isPrime39 = true\n    var isPrime40 = true\n    var isPrime41 = true\n\
    \    var isPrime42 = true\n    var isPrime43 = true\n    var isPrime44 = true\n\
    \    var isPrime45 = true\n    var isPrime46 = true\n    var isPrime47 = true\n\
    \    var isPrime48 = true\n    var isPrime49 = true\n    var isPrime50 = true\n\
    \    var isPrime51 = true\n    var isPrime52 = true\n    var isPrime53 = true\n\
    \    var isPrime54 = true\n    var isPrime55 = true\n    var isPrime56 = true\n\
    \    var isPrime57 = true\n    var isPrime58 = true\n    var isPrime59 = true\n\
    \    var isPrime60 = true\n    var isPrime61 = true\n    var isPrime62 = true\n\
    \    var isPrime63 = true\n    var isPrime64 = true\n    var isPrime65 = true\n\
    \    var isPrime66 = true\n    var isPrime67 = true\n    var isPrime68 = true\n\
    \    var isPrime69 = true\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp699r1fd8.swift:84:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp699r1fd8.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp699r1fd8.swift:13:9:\
    \ warning: initialization of variable 'factor' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factor = 1\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp699r1fd8.swift:14:9: warning: initialization of variable 'prime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime = 1\n    ~~~~^~~~~\n    _\n/tmp/tmp699r1fd8.swift:15:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmp699r1fd8.swift:16:9: warning: initialization of variable 'isPrime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime2 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp699r1fd8.swift:17:9:\
    \ warning: initialization of variable 'isPrime3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime3 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp699r1fd8.swift:18:9: warning: initialization of variable 'isPrime4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime4 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp699r1fd8.swift:19:9:\
    \ warning: initialization of variable 'isPrime5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime5 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp699r1fd8.swift:20:9: warning: initialization of variable 'isPrime6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime6 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp699r1fd8.swift:21:9:\
    \ warning: initialization of variable 'isPrime7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime7 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp699r1fd8.swift:"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var factorizationCount = 0\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberNumber = 0\n    var factorizationNumberNumberIndex\
    \ = 0\n    var factorizationNumberNumberCount = 0\n    var factorizationNumberNumberNumber\
    \ = 0\n    var factorizationNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumber = 0\n    var factorizationNumberNumberNumberNumberIndex\
    \ = 0\n    var factorizationNumberNumberNumberNumberCount = 0\n    var factorizationNumberNumberNumberNumberNumber\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumber = 0\n    var\
    \ factorizationNumberNumberNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumber = 0\n    var\
    \ factorizationNumberNumberNumberNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumber = 0\n \
    \   var factorizationNumberNumberNumberNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumber = 0\n \
    \   var factorizationNumberNumberNumberNumberNumberNumberIndex = 0\n    var factorizationNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumber =\
    \ 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberIndex = 0\n\
    \    var factorizationNumberNumberNumberNumberNumberNumberNumberCount = 0\n  \
    \  var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumber = 0\n\
    \    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberIndex =\
    \ 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumber\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberIndex\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumber\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberIndex\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumberNumber\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumberIndex\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n    var factorizationNumberNumberNumberNumberNumberNumberNumberNumberNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsuvbdwns.swift:31:9: error: invalid redeclaration of 'factorizationNumberNumberNumberNumberNumberIndex'\n\
    \    var factorizationNumberNumberNumberNumberNumberIndex = 0\n        ^\n/tmp/tmpsuvbdwns.swift:28:9:\
    \ note: 'factorizationNumberNumberNumberNumberNumberIndex' previously declared\
    \ here\n    var factorizationNumberNumberNumberNumberNumberIndex = 0\n       \
    \ ^\n/tmp/tmpsuvbdwns.swift:32:9: error: invalid redeclaration of 'factorizationNumberNumberNumberNumberNumberCount'\n\
    \    var factorizationNumberNumberNumberNumberNumberCount = 0\n        ^\n/tmp/tmpsuvbdwns.swift:29:9:\
    \ note: 'factorizationNumberNumberNumberNumberNumberCount' previously declared\
    \ here\n    var factorizationNumberNumberNumberNumberNumberCount = 0\n       \
    \ ^\n/tmp/tmpsuvbdwns.swift:33:9: error: invalid redeclaration of 'factorizationNumberNumberNumberNumberNumberNumber'\n\
    \    var factorizationNumberNumberNumberNumberNumberNumber = 0\n        ^\n/tmp/tmpsuvbdwns.swift:30:9:\
    \ note: 'factorizationNumberNumberNumberNumberNumberNumber' previously declared\
    \ here\n    var factorizationNumberNumberNumberNumberNumberNumber = 0\n      \
    \  ^\n/tmp/tmpsuvbdwns.swift:37:9: error: invalid redeclaration of 'factorizationNumberNumberNumberNumberNumberNumberIndex'\n\
    \    var factorizationNumberNumberNumberNumberNumberNumberIndex = 0\n        ^\n\
    /tmp/tmpsuvbdwns.swift:34:9: note: 'factorizationNumberNumberNumberNumberNumberNumberIndex'\
    \ previously declared here\n    var factorizationNumberNumberNumberNumberNumberNumberIndex\
    \ = 0\n        ^\n/tmp/tmpsuvbdwns.swift:38:9: error: invalid redeclaration of\
    \ 'factorizationNumberNumberNumberNumberNumberNumberCount'\n    var factorizationNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n        ^\n/tmp/tmpsuvbdwns.swift:35:9: note: 'factorizationNumberNumberNumberNumberNumberNumberCount'\
    \ previously declared here\n    var factorizationNumberNumberNumberNumberNumberNumberCount\
    \ = 0\n        ^\n/tmp/tmpsuvbdwns.swift:39:9: error: invalid redeclaration of\
    \ 'factorizationNumberNumberNumberNumberNumberNumberNumber'\n    var factorizationNumberNumberNumberNumberNumberN"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorizationCount2 = [Int]()\n\
    \    var factorizationCount2 = [Int]()\n    var primeFactorizationCount3 = [Int]()\n\
    \    var factorizationCount3 = [Int]()\n    var primeFactorizationCount4 = [Int]()\n\
    \    var factorizationCount4 = [Int]()\n    var primeFactorizationCount5 = [Int]()\n\
    \    var factorizationCount5 = [Int]()\n    var primeFactorizationCount6 = [Int]()\n\
    \    var factorizationCount6 = [Int]()\n    var primeFactorizationCount7 = [Int]()\n\
    \    var factorizationCount7 = [Int]()\n    var primeFactorizationCount8 = [Int]()\n\
    \    var factorizationCount8 = [Int]()\n    var primeFactorizationCount9 = [Int]()\n\
    \    var factorizationCount9 = [Int]()\n    var primeFactorizationCount10 = [Int]()\n\
    \    var factorizationCount10 = [Int]()\n    var primeFactorizationCount11 = [Int]()\n\
    \    var factorizationCount11 = [Int]()\n    var primeFactorizationCount12 = [Int]()\n\
    \    var factorizationCount12 = [Int]()\n    var primeFactorizationCount13 = [Int]()\n\
    \    var factorizationCount13 = [Int]()\n    var primeFactorizationCount14 = [Int]()\n\
    \    var factorizationCount14 = [Int]()\n    var primeFactorizationCount15 = [Int]()\n\
    \    var factorizationCount15 = [Int]()\n    var primeFactorizationCount16 = [Int]()\n\
    \    var factorizationCount16 = [Int]()\n    var primeFactorizationCount17 = [Int]()\n\
    \    var factorizationCount17 = [Int]()\n    var primeFactorizationCount18 = [Int]()\n\
    \    var factorizationCount18 = [Int]()\n    var primeFactorizationCount19 = [Int]()\n\
    \    var factorizationCount19 = [Int]()\n    var primeFactorizationCount20 = [Int]()\n\
    \    var factorizationCount20 = [Int]()\n    var primeFactorizationCount21 = [Int]()\n\
    \    var factorizationCount21 = [Int]()\n    var primeFactorizationCount22 = [Int]()\n\
    \    var factorizationCount22 = [Int]()\n    var primeFactorizationCount23 = [Int]()\n\
    \    var factorizationCount23 = [Int]()\n    var primeFactorizationCount24 = [Int]()\n\
    \    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6yxsuixt.swift:61:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var factorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex =\
    \ 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex2 = 0\n    var isPrimeFactorizationIndex3 =\
    \ 0\n    var isPrimeFactorizationIndex4 = 0\n    var isPrimeFactorizationIndex5\
    \ = 0\n    var isPrimeFactorizationIndex6 = 0\n    var isPrimeFactorizationIndex7\
    \ = 0\n    var isPrimeFactorizationIndex8 = 0\n    var isPrimeFactorizationIndex9\
    \ = 0\n    var isPrimeFactorizationIndex10 = 0\n    var isPrimeFactorizationIndex11\
    \ = 0\n    var isPrimeFactorizationIndex12 = 0\n    var isPrimeFactorizationIndex13\
    \ = 0\n    var isPrimeFactorizationIndex14 = 0\n    var isPrimeFactorizationIndex15\
    \ = 0\n    var isPrimeFactorizationIndex16 = 0\n    var isPrimeFactorizationIndex17\
    \ = 0\n    var isPrimeFactorizationIndex18 = 0\n    var isPrimeFactorizationIndex19\
    \ = 0\n    var isPrimeFactorizationIndex20 = 0\n    var isPrimeFactorizationIndex21\
    \ = 0\n    var isPrimeFactorizationIndex22 = 0\n    var isPrimeFactorizationIndex23\
    \ = 0\n    var isPrimeFactorizationIndex24 = 0\n    var isPrimeFactorizationIndex25\
    \ = 0\n    var isPrimeFactorizationIndex26 = 0\n    var isPrimeFactorizationIndex27\
    \ = 0\n    var isPrimeFactorizationIndex28 = 0\n    var isPrimeFactorizationIndex29\
    \ = 0\n    var isPrimeFactorizationIndex30 = 0\n    var isPrimeFactorizationIndex31\
    \ = 0\n    var isPrimeFactorizationIndex32 = 0\n    var isPrimeFactorizationIndex33\
    \ = 0\n    var isPrimeFactorizationIndex34 = 0\n    var isPrimeFactorizationIndex35\
    \ = 0\n    var isPrimeFactorizationIndex36 = 0\n    var isPrimeFactorizationIndex37\
    \ = 0\n    var isPrimeFactorizationIndex38 = 0\n    var isPrimeFactorizationIndex39\
    \ = 0\n    var isPrimeFactorizationIndex40 = 0\n    var isPrimeFactorizationIndex41\
    \ = 0\n    var isPrimeFactorizationIndex42 = 0\n    var isPrimeFactorizationIndex43\
    \ = 0\n    var isPrimeFactorizationIndex44 = 0\n    var isPrimeFactorizationIndex45\
    \ = 0\n    var isPrimeFactorizationIndex46 = 0\n    var is\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz53c503k.swift:65:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpz53c503k.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpz53c503k.swift:13:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpz53c503k.swift:14:9: warning:\
    \ initialization of variable 'primeFactorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpz53c503k.swift:15:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpz53c503k.swift:16:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmpz53c503k.swift:17:9: warning:\
    \ initialization of variable 'isPrimeIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpz53c503k.swift:18:9: warning: initialization of variable 'isPrimeFactorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpz53c503k.swift:19:9: warning: initialization of variable 'isPrimeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization = true\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpz53c503k.swift:20:9:\
    \ warning: initialization of variable 'isPrimeFactorizationIndex2' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var isPrimeFactorizationI"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactorization = [Int]()\n    var isPrime\
    \ = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationIndex\
    \ = [Int]()\n    var isPrimeFactorizationIndexCount = [Int]()\n    var isPrimeFactorizationIndexCountMax\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex = Int()\n    var isPrimeFactorizationIndexCountMin\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMinIndex = Int()\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk_ipwn7j.swift:53:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpk_ipwn7j.swift:23:9: error: invalid redeclaration of 'isPrimeFactorizationIndexCountMaxIndex'\n\
    \    var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:20:9:\
    \ note: 'isPrimeFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndexCountMinIndex'\n \
    \   var isPrimeFactorizationIndexCountMinIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:22:9:\
    \ note: 'isPrimeFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMinIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndexCountMaxIndex'\n \
    \   var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:20:9:\
    \ note: 'isPrimeFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndexCountMinIndex'\n \
    \   var isPrimeFactorizationIndexCountMinIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:22:9:\
    \ note: 'isPrimeFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMinIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndexCountMaxIndex'\n \
    \   var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:20:9:\
    \ note: 'isPrimeFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMaxIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndexCountMinIndex'\n \
    \   var isPrimeFactorizationIndexCountMinIndex = Int()\n        ^\n/tmp/tmpk_ipwn7j.swift:22:9:\
    \ note: 'isPrimeFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var isPrimeFactorizationIndexCountMinInd"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n    var factorizationMin = factorizationMax\n\
    \    var factorizationMaxIndex = 0\n    var factorizationMinIndex = 0\n    var\
    \ factorizationMaxCount = Int(sqrt(Double(n)))\n    var factorizationMinCount\
    \ = factorizationMaxCount\n    var factorizationMaxCountIndex = 0\n    var factorizationMinCountIndex\
    \ = 0\n    var factorizationMaxCountValue = factorizationMaxCount\n    var factorizationMinCountValue\
    \ = factorizationMinCount\n    var factorizationMaxCountValueIndex = 0\n    var\
    \ factorizationMinCountValueIndex = 0\n    var factorizationMaxCountValueValue\
    \ = factorizationMaxCountValue\n    var factorizationMinCountValueValue = factorizationMinCountValue\n\
    \    var factorizationMaxCountValueValueIndex = 0\n    var factorizationMinCountValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValue = factorizationMaxCountValueValue\n\
    \    var factorizationMinCountValueValueValue = factorizationMinCountValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValueValue = factorizationMaxCountValueValueValue\n\
    \    var factorizationMinCountValueValueValueValue = factorizationMinCountValueValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValueValue = factorizationMaxCountValueValueValueValue\n\
    \    var factorizationMinCountValueValueValueValue = factorizationMinCountValueValueValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValueValue = factorizationMaxCountValueValueValueValue\n\
    \    var factorizationMinCountValueValueValueValue = factorizationMinCountValueValueValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValueValue = factorizationMaxCountValueValueValueValue\n\
    \    var factorizationMinCountValueValueValueValue = factorizationMinCountValueValueValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValueValueIndex\
    \ = 0\n    var factorizationMaxCountValueValueValueValue = factorizationMaxCountValueValueValueValue\n\
    \    var factorizationMinCountValueValueValueValue = factorizationMinCountValueValueValueValue\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n    var factorizationMinCountValueValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp44_ihfjh.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp44_ihfjh.swift:19:37: error: cannot find 'sqrt' in scope\n    var factorizationMaxCount\
    \ = Int(sqrt(Double(n)))\n                                    ^~~~\n/tmp/tmp44_ihfjh.swift:37:9:\
    \ error: invalid redeclaration of 'factorizationMaxCountValueValueValueIndex'\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:33:9:\
    \ note: 'factorizationMaxCountValueValueValueIndex' previously declared here\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:38:9:\
    \ error: invalid redeclaration of 'factorizationMinCountValueValueValueIndex'\n\
    \    var factorizationMinCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:34:9:\
    \ note: 'factorizationMinCountValueValueValueIndex' previously declared here\n\
    \    var factorizationMinCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:41:9:\
    \ error: invalid redeclaration of 'factorizationMaxCountValueValueValueIndex'\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:33:9:\
    \ note: 'factorizationMaxCountValueValueValueIndex' previously declared here\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:42:9:\
    \ error: invalid redeclaration of 'factorizationMinCountValueValueValueIndex'\n\
    \    var factorizationMinCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:34:9:\
    \ note: 'factorizationMinCountValueValueValueIndex' previously declared here\n\
    \    var factorizationMinCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:45:9:\
    \ error: invalid redeclaration of 'factorizationMaxCountValueValueValueIndex'\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:33:9:\
    \ note: 'factorizationMaxCountValueValueValueIndex' previously declared here\n\
    \    var factorizationMaxCountValueValueValueIndex = 0\n        ^\n/tmp/tmp44_ihfjh.swift:46:9:\
    \ error: invalid redeclarati"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = Int(n)\n    while p > 1 {\n        while p % i ==\
    \ 0 {\n            factors.append(i)\n            p /= i\n        }\n        i\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var factorCount: Int = 0\n    var isPrime:\
    \ Bool = false\n    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n\
    \    var isPrime4: Bool = false\n    var isPrime5: Bool = false\n    var isPrime6:\
    \ Bool = false\n    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n\
    \    var isPrime9: Bool = false\n    var isPrime10: Bool = false\n    var isPrime11:\
    \ Bool = false\n    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n\
    \    var isPrime14: Bool = false\n    var isPrime15: Bool = false\n    var isPrime16:\
    \ Bool = false\n    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n\
    \    var isPrime19: Bool = false\n    var isPrime20: Bool = false\n    var isPrime21:\
    \ Bool = false\n    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n\
    \    var isPrime24: Bool = false\n    var isPrime25: Bool = false\n    var isPrime26:\
    \ Bool = false\n    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n\
    \    var isPrime29: Bool = false\n    var isPrime30: Bool = false\n    var isPrime31:\
    \ Bool = false\n    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n\
    \    var isPrime34: Bool = false\n    var isPrime35: Bool = false\n    var isPrime36:\
    \ Bool = false\n    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n\
    \    var isPrime39: Bool = false\n    var isPrime40: Bool = false\n    var isPrime41:\
    \ Bool = false\n    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n\
    \    var isPrime44: Bool = false\n    var isPrime45: Bool = false\n    var isPrime46:\
    \ Bool = false\n    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n\
    \    var isPrime49: Bool = false\n    var isPrime50: Bool = false\n    var isPrime51:\
    \ Bool = false\n    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n\
    \    var isPrime54: Bool = false\n    var isPrime55: Bool = false\n    var is\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3kp0l5pe.swift:70:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp3kp0l5pe.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:14:9:\
    \ warning: variable 'factorCount' was never used; consider replacing with '_'\
    \ or removing it\n    var factorCount: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmp3kp0l5pe.swift:15:9: warning: variable 'isPrime' was never used; consider\
    \ replacing with '_' or removing it\n    var isPrime: Bool = false\n        ^~~~~~~\n\
    \        _\n/tmp/tmp3kp0l5pe.swift:16:9: warning: variable 'isPrime2' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime2: Bool = false\n\
    \        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:17:9: warning: variable 'isPrime3'\
    \ was never used; consider replacing with '_' or removing it\n    var isPrime3:\
    \ Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:18:9: warning:\
    \ variable 'isPrime4' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:19:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:20:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:21:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:22:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp3kp0l5pe.swift:23:9:\
    \ warning: variable"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var\
    \ isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n  \
    \  var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n\
    \    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 =\
    \ 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var isPrimeIndex31 = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk6m07ij_.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpk6m07ij_.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpk6m07ij_.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpk6m07ij_.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpk6m07ij_.swift:16:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:17:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:18:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpk6m07ij_.swift:19:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:20:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:21:9: warning: initialization\
    \ of variable 'isPrimeCount3' was never used; consider replacing "
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var primeFactorsCount = [Int]()\n    var\
    \ primeFactorsCountMax = Int(math.ceil(sqrt(Double(n))))\n    var primeFactorsCountMax2\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax))))\n    var primeFactorsCountMax3\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax2))))\n    var primeFactorsCountMax4\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax3))))\n    var primeFactorsCountMax5\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax4))))\n    var primeFactorsCountMax6\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax5))))\n    var primeFactorsCountMax7\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax6))))\n    var primeFactorsCountMax8\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax7))))\n    var primeFactorsCountMax9\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax8))))\n    var primeFactorsCountMax10\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax9))))\n    var primeFactorsCountMax11\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax10))))\n    var primeFactorsCountMax12\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax11))))\n    var primeFactorsCountMax13\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax12))))\n    var primeFactorsCountMax14\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax13))))\n    var primeFactorsCountMax15\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax14))))\n    var primeFactorsCountMax16\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax15))))\n    var primeFactorsCountMax17\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax16))))\n    var primeFactorsCountMax18\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax17))))\n    var primeFactorsCountMax19\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax18))))\n    var primeFactorsCountMax20\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax19))))\n    var primeFactorsCountMax21\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax20))))\n    var primeFactorsCountMax22\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax21))))\n    var primeFactorsCountMax23\
    \ = Int(math.ceil(sqrt(Double(primeFactorsCountMax22))))\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxsyudc5w.swift:15:36: error: cannot find 'math' in scope\n    var\
    \ primeFactorsCountMax = Int(math.ceil(sqrt(Double(n))))\n                   \
    \                ^~~~\n/tmp/tmpxsyudc5w.swift:15:46: error: cannot find 'sqrt'\
    \ in scope\n    var primeFactorsCountMax = Int(math.ceil(sqrt(Double(n))))\n \
    \                                            ^~~~\n/tmp/tmpxsyudc5w.swift:16:37:\
    \ error: cannot find 'math' in scope\n    var primeFactorsCountMax2 = Int(math.ceil(sqrt(Double(primeFactorsCountMax))))\n\
    \                                    ^~~~\n/tmp/tmpxsyudc5w.swift:16:47: error:\
    \ cannot find 'sqrt' in scope\n    var primeFactorsCountMax2 = Int(math.ceil(sqrt(Double(primeFactorsCountMax))))\n\
    \                                              ^~~~\n/tmp/tmpxsyudc5w.swift:17:37:\
    \ error: cannot find 'math' in scope\n    var primeFactorsCountMax3 = Int(math.ceil(sqrt(Double(primeFactorsCountMax2))))\n\
    \                                    ^~~~\n/tmp/tmpxsyudc5w.swift:17:47: error:\
    \ cannot find 'sqrt' in scope\n    var primeFactorsCountMax3 = Int(math.ceil(sqrt(Double(primeFactorsCountMax2))))\n\
    \                                              ^~~~\n/tmp/tmpxsyudc5w.swift:18:37:\
    \ error: cannot find 'math' in scope\n    var primeFactorsCountMax4 = Int(math.ceil(sqrt(Double(primeFactorsCountMax3))))\n\
    \                                    ^~~~\n/tmp/tmpxsyudc5w.swift:18:47: error:\
    \ cannot find 'sqrt' in scope\n    var primeFactorsCountMax4 = Int(math.ceil(sqrt(Double(primeFactorsCountMax3))))\n\
    \                                              ^~~~\n/tmp/tmpxsyudc5w.swift:19:37:\
    \ error: cannot find 'math' in scope\n    var primeFactorsCountMax5 = Int(math.ceil(sqrt(Double(primeFactorsCountMax4))))\n\
    \                                    ^~~~\n/tmp/tmpxsyudc5w.swift:19:47: error:\
    \ cannot find 'sqrt' in scope\n    var primeFactorsCountMax5 = Int(math.ceil(sqrt(Double(primeFactorsCountMax4))))\n\
    \                                              ^~~~\n/tmp/tmpxsyudc5w.swift:20:37:\
    \ error: cannot find 'math' in scope\n    var primeFactorsCountMax6 = Int(math.ceil(sqrt(Double(primeFactorsCountMax5"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount = 0\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3qwjzbtc.swift:31:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:29:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:32:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFacto"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationCountMax = Int()\n\
    \    var factorizationCountMin = Int()\n    var factorizationCountSum = Int()\n\
    \    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin =\
    \ Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int()\n    var factorizationCountSumMin\
    \ = Int()\n    var factorizationCountSumMax = Int\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpan02ouip.swift:19:9: error: invalid redeclaration of 'factorizationCountSumMax'\n\
    \    var factorizationCountSumMax = Int()\n        ^\n/tmp/tmpan02ouip.swift:17:9:\
    \ note: 'factorizationCountSumMax' previously declared here\n    var factorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmpan02ouip.swift:20:9: error: invalid redeclaration\
    \ of 'factorizationCountSumMin'\n    var factorizationCountSumMin = Int()\n  \
    \      ^\n/tmp/tmpan02ouip.swift:18:9: note: 'factorizationCountSumMin' previously\
    \ declared here\n    var factorizationCountSumMin = Int()\n        ^\n/tmp/tmpan02ouip.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationCountSumMax'\n    var factorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmpan02ouip.swift:17:9: note: 'factorizationCountSumMax'\
    \ previously declared here\n    var factorizationCountSumMax = Int()\n       \
    \ ^\n/tmp/tmpan02ouip.swift:22:9: error: invalid redeclaration of 'factorizationCountSumMin'\n\
    \    var factorizationCountSumMin = Int()\n        ^\n/tmp/tmpan02ouip.swift:18:9:\
    \ note: 'factorizationCountSumMin' previously declared here\n    var factorizationCountSumMin\
    \ = Int()\n        ^\n/tmp/tmpan02ouip.swift:23:9: error: invalid redeclaration\
    \ of 'factorizationCountSumMax'\n    var factorizationCountSumMax = Int()\n  \
    \      ^\n/tmp/tmpan02ouip.swift:17:9: note: 'factorizationCountSumMax' previously\
    \ declared here\n    var factorizationCountSumMax = Int()\n        ^\n/tmp/tmpan02ouip.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationCountSumMin'\n    var factorizationCountSumMin\
    \ = Int()\n        ^\n/tmp/tmpan02ouip.swift:18:9: note: 'factorizationCountSumMin'\
    \ previously declared here\n    var factorizationCountSumMin = Int()\n       \
    \ ^\n/tmp/tmpan02ouip.swift:25:9: error: invalid redeclaration of 'factorizationCountSumMax'\n\
    \    var factorizationCountSumMax = Int()\n        ^\n/tmp/tmpan02ouip.swift:17:9:\
    \ note: 'factorizationCountSumMax' previously declared here\n    var factorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmpan02ouip.swift:26:9: error: invalid redeclaration\
    \ of 'factorizationCountSumMin'\n    var factorization"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumbersArray = [Int]()\n    var factorizationNumbersArrayIndex\
    \ = 0\n    var factorizationNumbersArrayCount = 0\n    var factorizationNumbersArrayCountIndex\
    \ = 0\n    var factorizationNumbersArrayCountMax = 0\n    var factorizationNumbersArrayCountMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMin = 0\n    var factorizationNumbersArrayCountMinIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMin = 0\n    var factorizationNumbersArrayCountMaxMinIndex\
    \ = 0\n    var factorizationNumbersArrayCountMinMax = 0\n    var factorizationNumbersArrayCountMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMax = 0\n    var factorizationNumbersArrayCountMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMinMaxMin = 0\n    var factorizationNumbersArrayCountMinMaxMinIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMin = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinIndex\
    \ = 0\n    var factorizationNumbersArrayCountMinMaxMinMax = 0\n    var factorizationNumbersArrayCountMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMax = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMinMaxMinMaxMinMax = 0\n    var factorizationNumbersArrayCountMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMax = 0\n    var\
    \ factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxIndex = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumbersArrayCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyivmrsxs.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpyivmrsxs.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:13:9:\
    \ warning: initialization of variable 'factorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:14:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpyivmrsxs.swift:15:9: warning: initialization of variable 'factorizationNumber'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumber = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:16:9:\
    \ warning: initialization of variable 'factorizationNumberIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:17:9: warning:\
    \ initialization of variable 'factorizationNumberCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:18:9: warning:\
    \ initialization of variable 'factorizationNumbersArray' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumbersArray\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:19:9:\
    \ warning: initialization of variable 'factorizationNumbersArrayIndex' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationNumbersArrayIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyivmrsxs.swift:20:9:\
    \ warning: initialization of variable 'factorizationNumbersArrayCount' wa"
  stdout: ''
  timestamp: 1660009224
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var i = 2\n    var factor: Int\n    while i < n {\n        factor = 1\n \
    \       while i < n && n % i == 0 {\n            factor *= i\n            i +=\
    \ 1\n        }\n        factors.append(factor)\n    }\n    return factors\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpg_i2uwdj/tmpg_i2uwdj.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55a1352c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55a1049b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55a1049988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55a10487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg_i2uwdj                        0x000055659a4d5462 <unavailable> + 5218

    5    libc.so.6                          0x00002b55a153e460 __libc_start_main +
    245

    6    tmpg_i2uwdj                        0x000055659a4d50b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var factorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4\
    \ = 0\n    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6\
    \ = 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprbyh2132.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmprbyh2132.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmprbyh2132.swift:13:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmprbyh2132.swift:14:9: warning: initialization\
    \ of variable 'factorizationCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmprbyh2132.swift:15:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmprbyh2132.swift:16:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmprbyh2132.swift:17:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmprbyh2132.swift:18:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmprbyh2132.swift:19:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmprbyh2132.swift:20:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmprbyh2132.swift:21:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consi"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n    var factorizationIndexMin\
    \ = factorizationIndexMax\n    var factorizationIndexMaxInt = Int(factorizationIndexMax)\n\
    \    var factorizationIndexMinInt = Int(factorizationIndexMin)\n    var factorizationIndexMaxDouble\
    \ = Double(factorizationIndexMax)\n    var factorizationIndexMinDouble = Double(factorizationIndexMin)\n\
    \    var factorizationIndexMaxDoubleInt = Int(factorizationIndexMaxDouble)\n \
    \   var factorizationIndexMinDoubleInt = Int(factorizationIndexMinDouble)\n  \
    \  var factorizationIndexMaxDoubleDouble = Double(factorizationIndexMaxDouble)\n\
    \    var factorizationIndexMinDoubleDouble = Double(factorizationIndexMinDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleInt = Int(factorizationIndexMaxDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleInt = Int(factorizationIndexMinDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDouble = Double(factorizationIndexMaxDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDouble = Double(factorizationIndexMinDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleInt = Int(factorizationIndexMaxDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleInt = Int(factorizationIndexMinDoubleDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleDouble = Double(factorizationIndexMaxDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDouble = Double(factorizationIndexMinDoubleDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleDoubleInt = Int(factorizationIndexMaxDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDoubleInt = Int(factorizationIndexMinDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleDoubleDouble = Double(factorizationIndexMaxDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDoubleDouble = Double(factorizationIndexMinDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationIndexMaxDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationIndexMinDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMaxDoubleDoubleDoubleDoubleDoubleDouble = Double(factorizationIndexMaxDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble = Double(factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble)\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcgaz13j7.swift:41:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpcgaz13j7.swift:15:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmpcgaz13j7.swift:40:76: error: use of local variable 'factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble'\
    \ before its declaration\n    var factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble\
    \ = Double(factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble)\n      \
    \                                                                     ^\n/tmp/tmpcgaz13j7.swift:40:9:\
    \ note: 'factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble' declared here\n\
    \    var factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble = Double(factorizationIndexMinDoubleDoubleDoubleDoubleDoubleDouble)\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMaxMin: Int\
    \ = 1\n    var isPrimeCountMinMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n  \
    \  var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int =\
    \ 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n  \
    \  var isPrimeCountMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiij7feko.swift:25:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:27:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n \
    \   var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:27:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n \
    \   var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:30:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:32:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpiij7feko.swift:32:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxM"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var isPrime: Bool = false\n    var\
    \ isPrimeCount = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd6_bf72l.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpd6_bf72l.swift:24:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpd6_bf72l.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpd6_bf72l.swift:25:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpd6_bf72l.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpd6_bf72l.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpd6_bf72l.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpd6_bf72l.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpd6_bf72l.swift:41:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n     \
    \   ^\n/tmp/tmpd6_bf72l.swift:39:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpd6_bf72l.swift:42:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpd6_bf72l.swift:40:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePr"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = Int(n)\n    while p > 1 {\n        if p % i == 0 {\n\
    \            factors.append(i)\n            p /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var factorizationCount = 0\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv6kt8ega.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpv6kt8ega.swift:24:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpv6kt8ega.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpv6kt8ega.swift:25:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpv6kt8ega.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpv6kt8ega.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpv6kt8ega.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpv6kt8ega.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpv6kt8ega.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpv6kt8ega.swift:35:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpv6kt8ega.swift:38:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n     \
    \   ^\n/tmp/tmpv6kt8ega.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpv6kt8ega.swift:42:9: error: invali"
  stdout: ''
  timestamp: 1660009224
- exit_code: -1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factors = [1]\n    var i = 2\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            factorization = factorization\
    \ + factors\n            factors = [1]\n        } else {\n            i += 1\n\
    \        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactorization = [Int]()\n    var primeFactorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = -1\n    var isPrimeFactorization\
    \ = true\n    var isPrimeFactorizationIndex = -1\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeIndex = -1\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationIndex = -1\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = -1\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuzw5_3om.swift:43:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpuzw5_3om.swift:33:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmpuzw5_3om.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmpuzw5_3om.swift:36:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuzw5_3om.swift:34:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuzw5_3om.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = -1\n        ^\n/tmp/tmpuzw5_3om.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = -1\n        ^\n/tmp/tmpuzw5_3om.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuzw5_3om.swift:34:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared h"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var i = 2\n    while i <= n {\n        while n\
    \ % i == 0 {\n            factorization.append(i)\n            n /= i\n      \
    \  }\n        i += 1\n    }\n    if n > 1 {\n        factorization.append(n)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpewqo9jsn.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpl76zje6i.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpl76zje6i.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpl76zje6i.swift:40:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberSum = 0\n    var factorizationNumberSumCount\
    \ = 0\n    var factorizationNumberSumIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n    var factorizationNumberSumCountIndex\
    \ = 0\n    var factorizationNumberSumCountIndex = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8yoan1q_.swift:22:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmp8yoan1q_.swift:24:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmp8yoan1q_.swift:26:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared here\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationNumberSumCountIndex'\n    var factorizationNumberSumCountIndex\
    \ = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9: note: 'factorizationNumberSumCountIndex'\
    \ previously declared here\n    var factorizationNumberSumCountIndex = 0\n   \
    \     ^\n/tmp/tmp8yoan1q_.swift:28:9: error: invalid redeclaration of 'factorizationNumberSumCountIndex'\n\
    \    var factorizationNumberSumCountIndex = 0\n        ^\n/tmp/tmp8yoan1q_.swift:21:9:\
    \ note: 'factorizationNumberSumCountIndex' previously declared h"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n\
    \    var isPrimeFactorization: Bool = false\n    var isPrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx52v6t58.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \      ^\n/tmp/tmpx52v6t58.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpx52v6t58.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n        ^\n/tmp/tmpx52v6t58.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpx52v6t58.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpx52v6t58.swift:30:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpx52v6t58.swift:34:9: error: type annotation\
    \ missing in pattern\n    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var k = 0\n    var factorization = [Int]()\n\
    \    var factorizationCount = 0\n\n    while i < n {\n        if n % i == 0 {\n\
    \            factors.append(i)\n            factorizationCount += 1\n        }\n\
    \        i += 1\n    }\n\n    for factor in factors {\n        factorization[k]\
    \ = factor\n        k += 1\n    }\n\n    for factor in factors {\n        for\
    \ _ in 0..<factorizationCount {\n            if factor == factorization[k] {\n\
    \                factorization.removeAtIndex(k)\n                k -= 1\n    \
    \        }\n        }\n    }\n\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0ci203pk.swift:35:31: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n                factorization.removeAtIndex(k)\n          \
    \      ~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndex = 0\n    var isPrimeFactorsCountMaxIndexMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeFactorsCountMaxIndexMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndexMaxMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndexMaxMax = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeFactorsCountMaxIndexMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndexMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax = 0\n    var\
    \ isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmputg_k08s.swift:18:38: error: cannot find 'arc4random_uniform' in\
    \ scope\n    var isPrimeFactorsCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:20:46:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                 ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:22:49: error: cannot\
    \ find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                    ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:24:52: error:\
    \ cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                       ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:26:55: error:\
    \ cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                          ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:28:58: error:\
    \ cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                             ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:30:61:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                                ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:32:61:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n                            \
    \                                ^~~~~~~~~~~~~~~~~~\n/tmp/tmputg_k08s.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax'\n\
    \    var isP"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7ll04xt1.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isP"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationValue = 1\n    var isPrime = true\n    var isPrimeIndex = 0\n \
    \   var isPrimeValue = 1\n    var isPrimeValueIndex = 0\n    var isPrimeValueIndex2\
    \ = 0\n    var isPrimeValueIndex3 = 0\n    var isPrimeValueIndex4 = 0\n    var\
    \ isPrimeValueIndex5 = 0\n    var isPrimeValueIndex6 = 0\n    var isPrimeValueIndex7\
    \ = 0\n    var isPrimeValueIndex8 = 0\n    var isPrimeValueIndex9 = 0\n    var\
    \ isPrimeValueIndex10 = 0\n    var isPrimeValueIndex11 = 0\n    var isPrimeValueIndex12\
    \ = 0\n    var isPrimeValueIndex13 = 0\n    var isPrimeValueIndex14 = 0\n    var\
    \ isPrimeValueIndex15 = 0\n    var isPrimeValueIndex16 = 0\n    var isPrimeValueIndex17\
    \ = 0\n    var isPrimeValueIndex18 = 0\n    var isPrimeValueIndex19 = 0\n    var\
    \ isPrimeValueIndex20 = 0\n    var isPrimeValueIndex21 = 0\n    var isPrimeValueIndex22\
    \ = 0\n    var isPrimeValueIndex23 = 0\n    var isPrimeValueIndex24 = 0\n    var\
    \ isPrimeValueIndex25 = 0\n    var isPrimeValueIndex26 = 0\n    var isPrimeValueIndex27\
    \ = 0\n    var isPrimeValueIndex28 = 0\n    var isPrimeValueIndex29 = 0\n    var\
    \ isPrimeValueIndex30 = 0\n    var isPrimeValueIndex31 = 0\n    var isPrimeValueIndex32\
    \ = 0\n    var isPrimeValueIndex33 = 0\n    var isPrimeValueIndex34 = 0\n    var\
    \ isPrimeValueIndex35 = 0\n    var isPrimeValueIndex36 = 0\n    var isPrimeValueIndex37\
    \ = 0\n    var isPrimeValueIndex38 = 0\n    var isPrimeValueIndex39 = 0\n    var\
    \ isPrimeValueIndex40 = 0\n    var isPrimeValueIndex41 = 0\n    var isPrimeValueIndex42\
    \ = 0\n    var isPrimeValueIndex43 = 0\n    var isPrimeValueIndex44 = 0\n    var\
    \ isPrimeValueIndex45 = 0\n    var isPrimeValueIndex46 = 0\n    var isPrimeValueIndex47\
    \ = 0\n    var isPrimeValueIndex48 = 0\n    var isPrimeValueIndex49 = 0\n    var\
    \ isPrimeValueIndex50 = 0\n    var isPrimeValueIndex51 = 0\n    var isPrimeValueIndex52\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdmmo26vz.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpdmmo26vz.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpdmmo26vz.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpdmmo26vz.swift:15:9:\
    \ warning: initialization of variable 'factorizationValue' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationValue\
    \ = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpdmmo26vz.swift:16:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpdmmo26vz.swift:17:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpdmmo26vz.swift:18:9:\
    \ warning: initialization of variable 'isPrimeValue' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeValue = 1\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpdmmo26vz.swift:19:9: warning: initialization\
    \ of variable 'isPrimeValueIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeValueIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpdmmo26vz.swift:20:9: warning: initialization of variable 'isPrimeValueIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeValueIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpdmmo26vz.swift:21:9:\
    \ warning: initialization of variable 'isPrimeValueIndex3' was never used; consider\
    \ replacing with assignment to '_' o"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndex = 0\n    var isPrimeIndexMax = 0\n    var isPrimeIndexMaxIndex\
    \ = 0\n    var isPrimeIndexMin = 0\n    var isPrimeIndexMinIndex = 0\n    var\
    \ isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMax = 0\n    var isPrimeIndexMinIndexMax\
    \ = 0\n    var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMin =\
    \ 0\n    var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMaxIndexMin = 0\n\
    \    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin = 0\n  \
    \  var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMinIndexMin = 0\n    var\
    \ isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin\
    \ = 0\n    var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMinIndexMin =\
    \ 0\n    var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMax = 0\n\
    \    var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMin = 0\n  \
    \  var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMaxIndexMin = 0\n    var\
    \ isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMin\
    \ = 0\n    var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMaxIndexMin =\
    \ 0\n    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin = 0\n\
    \    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin = 0\n  \
    \  var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMinIndexMin = 0\n    var\
    \ isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin\
    \ = 0\n    var isPrimeIndexMinIndexMax = 0\n    var isPrimeIndexMaxIndexMin =\
    \ 0\n    var isPrimeIndexMinIndexMin = 0\n    var isPrimeIndexMinIndexMin = 0\n\
    \    var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMax = 0\n  \
    \  var isPrimeIndexMaxIndexMin = 0\n    var isPrimeIndexMinIndexMax = 0\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5pn07zw8.swift:23:9: error: invalid redeclaration of 'isPrimeIndexMinIndexMax'\n\
    \    var isPrimeIndexMinIndexMax = 0\n        ^\n/tmp/tmp5pn07zw8.swift:21:9:\
    \ note: 'isPrimeIndexMinIndexMax' previously declared here\n    var isPrimeIndexMinIndexMax\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:26:9: error: invalid redeclaration of\
    \ 'isPrimeIndexMinIndexMin'\n    var isPrimeIndexMinIndexMin = 0\n        ^\n\
    /tmp/tmp5pn07zw8.swift:25:9: note: 'isPrimeIndexMinIndexMin' previously declared\
    \ here\n    var isPrimeIndexMinIndexMin = 0\n        ^\n/tmp/tmp5pn07zw8.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMaxIndexMin'\n    var isPrimeIndexMaxIndexMin\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:24:9: note: 'isPrimeIndexMaxIndexMin'\
    \ previously declared here\n    var isPrimeIndexMaxIndexMin = 0\n        ^\n/tmp/tmp5pn07zw8.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMinIndexMax'\n    var isPrimeIndexMinIndexMax\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:21:9: note: 'isPrimeIndexMinIndexMax'\
    \ previously declared here\n    var isPrimeIndexMinIndexMax = 0\n        ^\n/tmp/tmp5pn07zw8.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMaxIndexMin'\n    var isPrimeIndexMaxIndexMin\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:24:9: note: 'isPrimeIndexMaxIndexMin'\
    \ previously declared here\n    var isPrimeIndexMaxIndexMin = 0\n        ^\n/tmp/tmp5pn07zw8.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMinIndexMin'\n    var isPrimeIndexMinIndexMin\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:25:9: note: 'isPrimeIndexMinIndexMin'\
    \ previously declared here\n    var isPrimeIndexMinIndexMin = 0\n        ^\n/tmp/tmp5pn07zw8.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMinIndexMin'\n    var isPrimeIndexMinIndexMin\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:25:9: note: 'isPrimeIndexMinIndexMin'\
    \ previously declared here\n    var isPrimeIndexMinIndexMin = 0\n        ^\n/tmp/tmp5pn07zw8.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeIndexMaxIndexMin'\n    var isPrimeIndexMaxIndexMin\
    \ = 0\n        ^\n/tmp/tmp5pn07zw8.swift:24:9: note: 'isPrimeIndexMaxIndexMin'"
  stdout: ''
  timestamp: 1660009224
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i < n {\n        if n % i == 0 {\n\
    \            factors.append(factor)\n            factor = 1\n        } else {\n\
    \            factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpn80h9efx/tmpn80h9efx.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2179cfec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21799f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21799f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21799f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn80h9efx                        0x000055ece01e74c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b2179eea460 __libc_start_main +
    245

    6    tmpn80h9efx                        0x000055ece01e7119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsIndex = [Int]()\n  \
    \  var isPrimeFactorsIndexCount = [Int]()\n    var isPrimeFactorsIndexCountMax\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndex = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCount\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndex = [Int]()\n  \
    \  var isPrimeFactorsIndexCountMaxIndexCountIndexIndex = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var isPrimeFactorsIndexCountMaxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfxs031uz.swift:26:9: error: invalid redeclaration of 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex'\n\
    \    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex = [Int]()\n\
    \        ^\n/tmp/tmpfxs031uz.swift:25:9: note: 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex'\
    \ previously declared here\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex'\n    var\
    \ isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex = [Int]()\n \
    \       ^\n/tmp/tmpfxs031uz.swift:27:9: note: 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex'\
    \ previously declared here\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex'\n    var\
    \ isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex = [Int]()\n \
    \       ^\n/tmp/tmpfxs031uz.swift:27:9: note: 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex'\
    \ previously declared here\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex'\n\
    \    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:31:9: note: 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex'\
    \ previously declared here\n    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex'\n\
    \    var isPrimeFactorsIndexCountMaxIndexCountIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n        ^\n/tmp/tmpfxs031uz.swift:31:9: note: 'isPrimeFactorsIndexCoun"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69\
    \ = 0\n    var factorizationIndex70 = 0\n    var factorizationIndex71 = 0\n  \
    \  var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjzaoiszy.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyify4ykv.swift:25:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:27:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:29:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n      \
    \  ^\n/tmp/tmpyify4ykv.swift:32:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:32:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpyify4ykv.swift:36:9"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var current: Int = 0\n    var factor:\
    \ Int = 0\n    var isPrime: Bool = false\n    var isPrimeCount: Int = 0\n    var\
    \ isPrimeFactor: Bool = false\n    var isPrimeFactorCount: Int = 0\n    var isPrimeFactor2:\
    \ Bool = false\n    var isPrimeFactor2Count: Int = 0\n    var isPrimeFactor3:\
    \ Bool = false\n    var isPrimeFactor3Count: Int = 0\n    var isPrimeFactor4:\
    \ Bool = false\n    var isPrimeFactor4Count: Int = 0\n    var isPrimeFactor5:\
    \ Bool = false\n    var isPrimeFactor5Count: Int = 0\n    var isPrimeFactor6:\
    \ Bool = false\n    var isPrimeFactor6Count: Int = 0\n    var isPrimeFactor7:\
    \ Bool = false\n    var isPrimeFactor7Count: Int = 0\n    var isPrimeFactor8:\
    \ Bool = false\n    var isPrimeFactor8Count: Int = 0\n    var isPrimeFactor9:\
    \ Bool = false\n    var isPrimeFactor9Count: Int = 0\n    var isPrimeFactor10:\
    \ Bool = false\n    var isPrimeFactor10Count: Int = 0\n    var isPrimeFactor11:\
    \ Bool = false\n    var isPrimeFactor11Count: Int = 0\n    var isPrimeFactor12:\
    \ Bool = false\n    var isPrimeFactor12Count: Int = 0\n    var isPrimeFactor13:\
    \ Bool = false\n    var isPrimeFactor13Count: Int = 0\n    var isPrimeFactor14:\
    \ Bool = false\n    var isPrimeFactor14Count: Int = 0\n    var isPrimeFactor15:\
    \ Bool = false\n    var isPrimeFactor15Count: Int = 0\n    var isPrimeFactor16:\
    \ Bool = false\n    var isPrimeFactor16Count: Int = 0\n    var isPrimeFactor17:\
    \ Bool = false\n    var isPrimeFactor17Count: Int = 0\n    var isPrimeFactor18:\
    \ Bool = false\n    var isPrimeFactor18Count: Int = 0\n    var isPrimeFactor19:\
    \ Bool = false\n    var isPrimeFactor19Count: Int = 0\n    var isPrimeFactor20:\
    \ Bool = false\n    var isPrimeFactor20Count: Int = 0\n    var isPrimeFactor21:\
    \ Bool = false\n    var isPrimeFactor21Count: Int = 0\n    var isPrimeFactor22:\
    \ Bool = false\n    var isPrimeFactor22Count: Int = 0\n    var isPrimeFactor23:\
    \ Bool = false\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpku53ca7s.swift:63:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = [1]\n    var i: Int = 0\n    var j: Int = 0\n\
    \    var factor: Int = 0\n    var factorizationCount: Int = 0\n    var isPrime:\
    \ Bool = false\n    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n\
    \    var isPrime4: Bool = false\n    var isPrime5: Bool = false\n    var isPrime6:\
    \ Bool = false\n    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n\
    \    var isPrime9: Bool = false\n    var isPrime10: Bool = false\n    var isPrime11:\
    \ Bool = false\n    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n\
    \    var isPrime14: Bool = false\n    var isPrime15: Bool = false\n    var isPrime16:\
    \ Bool = false\n    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n\
    \    var isPrime19: Bool = false\n    var isPrime20: Bool = false\n    var isPrime21:\
    \ Bool = false\n    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n\
    \    var isPrime24: Bool = false\n    var isPrime25: Bool = false\n    var isPrime26:\
    \ Bool = false\n    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n\
    \    var isPrime29: Bool = false\n    var isPrime30: Bool = false\n    var isPrime31:\
    \ Bool = false\n    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n\
    \    var isPrime34: Bool = false\n    var isPrime35: Bool = false\n    var isPrime36:\
    \ Bool = false\n    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n\
    \    var isPrime39: Bool = false\n    var isPrime40: Bool = false\n    var isPrime41:\
    \ Bool = false\n    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n\
    \    var isPrime44: Bool = false\n    var isPrime45: Bool = false\n    var isPrime46:\
    \ Bool = false\n    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n\
    \    var isPrime49: Bool = false\n    var isPrime50: Bool = false\n    var isPrime51:\
    \ Bool = false\n    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfqmt28pj.swift:71:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpfqmt28pj.swift:12:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:13:9: warning: variable 'factorization'\
    \ was never used; consider replacing with '_' or removing it\n    var factorization:\
    \ [Int] = [1]\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:14:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int = 0\n        ^\n        _\n/tmp/tmpfqmt28pj.swift:15:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmpfqmt28pj.swift:16:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:17:9:\
    \ warning: variable 'factorizationCount' was never used; consider replacing with\
    \ '_' or removing it\n    var factorizationCount: Int = 0\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpfqmt28pj.swift:18:9: warning: variable 'isPrime' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime: Bool = false\n\
    \        ^~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:19:9: warning: variable 'isPrime2'\
    \ was never used; consider replacing with '_' or removing it\n    var isPrime2:\
    \ Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:20:9: warning:\
    \ variable 'isPrime3' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:21:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:22:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfqmt28pj.swift:23:9:\
    \ warning: variable 'isPrime6' was never used; consider r"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcld02nb.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = [1]\n    var factorizationIndex = 0\n    var factorizationIndexMax\
    \ = factorizationIndex\n    var factorizationIndexMin = factorizationIndex\n \
    \   var factorizationIndexMaxMin = factorizationIndex\n    var factorizationIndexMinMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMin = factorizationIndex\n\
    \    var factorizationIndexMinMaxMinMax = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMin\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMax = factorizationIndex\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMin = factorizationIndex\n    var\
    \ factorizationIndexMinMaxMinMaxMinMaxMinMax = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMin\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpn2_7bcel.swift:33:9: error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax'\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax =\
    \ factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:32:9: note: 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:36:9: error: invalid\
    \ redeclaration of 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:35:9: note: 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:38:9: error: invalid\
    \ redeclaration of 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:37:9: note: 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:39:9: error: invalid\
    \ redeclaration of 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:37:9: note: 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = factorizationIndex\n        ^\n/tmp/tmpn2_7bcel.swift:40:9: error: type annotation\
    \ missing in patte"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var factorizationCountMax = Int(sqrt(Double(n)))\n\
    \    var factorizationCountMaxInt = Int(factorizationCountMax)\n    var factorizationCountMaxDouble\
    \ = Double(factorizationCountMax)\n    var factorizationCountMaxDoubleInt = Int(factorizationCountMaxDouble)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxFloatInt\
    \ = Int(factorizationCountMaxFloat)\n    var factorizationCountMaxInt = Int(factorizationCountMax)\n\
    \    var factorizationCountMaxIntInt = Int(factorizationCountMax)\n    var factorizationCountMaxDouble\
    \ = Double(factorizationCountMax)\n    var factorizationCountMaxDoubleInt = Int(factorizationCountMaxDouble)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxFloatInt\
    \ = Int(factorizationCountMaxFloat)\n    var factorizationCountMaxInt = Int(factorizationCountMax)\n\
    \    var factorizationCountMaxIntInt = Int(factorizationCountMax)\n    var factorizationCountMaxDouble\
    \ = Double(factorizationCountMax)\n    var factorizationCountMaxDoubleInt = Int(factorizationCountMaxDouble)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxFloatInt\
    \ = Int(factorizationCountMaxFloat)\n    var factorizationCountMaxInt = Int(factorizationCountMax)\n\
    \    var factorizationCountMaxIntInt = Int(factorizationCountMax)\n    var factorizationCountMaxDouble\
    \ = Double(factorizationCountMax)\n    var factorizationCountMaxDoubleInt = Int(factorizationCountMaxDouble)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxFloatInt\
    \ = Int(factorizationCountMaxFloat)\n    var factorizationCountMaxInt = Int(factorizationCountMax)\n\
    \    var factorizationCountMaxIntInt = Int(factorizationCountMax)\n    var factorizationCountMaxDouble\
    \ = Double(factorizationCountMax)\n    var factorizationCountMaxDoubleInt = Int(factorizationCountMaxDouble)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxFloatInt\
    \ = Int(factorizationCountMaxFloat)\n    var factorizationCountMaxInt = Int(factorizationCountMax)\n\
    \    var factorizationCountMaxIntInt = Int(factorizationCountMax)\n    var factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9xtqp1su.swift:16:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationCountMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmp9xtqp1su.swift:48:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    while factor <= n {\n        if n % factor ==\
    \ 0 {\n            factorization[factor] = factorization[factor] + 1\n       \
    \     n /= factor\n        } else {\n            factor++\n        }\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2shkpg7v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmp2shkpg7v.swift:19:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            factor++\n                  ^~\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime: Bool = false\n    var isPrimeCount = 0\n    var isPrimePrime:\
    \ Bool = false\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi89p0rz7.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpi89p0rz7.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpi89p0rz7.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpi89p0rz7.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpi89p0rz7.swift:42:9:\
    \ error: type annotation missing in pattern\n    var isPrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ factorizationCount: Int = 0\n    var factorizationSum: Int = 0\n    var isPrime:\
    \ Bool = false\n    var isPrimeSum: Int = 0\n    var isPrimeSum2: Int = 0\n  \
    \  var isPrimeSum3: Int = 0\n    var isPrimeSum4: Int = 0\n    var isPrimeSum5:\
    \ Int = 0\n    var isPrimeSum6: Int = 0\n    var isPrimeSum7: Int = 0\n    var\
    \ isPrimeSum8: Int = 0\n    var isPrimeSum9: Int = 0\n    var isPrimeSum10: Int\
    \ = 0\n    var isPrimeSum11: Int = 0\n    var isPrimeSum12: Int = 0\n    var isPrimeSum13:\
    \ Int = 0\n    var isPrimeSum14: Int = 0\n    var isPrimeSum15: Int = 0\n    var\
    \ isPrimeSum16: Int = 0\n    var isPrimeSum17: Int = 0\n    var isPrimeSum18:\
    \ Int = 0\n    var isPrimeSum19: Int = 0\n    var isPrimeSum20: Int = 0\n    var\
    \ isPrimeSum21: Int = 0\n    var isPrimeSum22: Int = 0\n    var isPrimeSum23:\
    \ Int = 0\n    var isPrimeSum24: Int = 0\n    var isPrimeSum25: Int = 0\n    var\
    \ isPrimeSum26: Int = 0\n    var isPrimeSum27: Int = 0\n    var isPrimeSum28:\
    \ Int = 0\n    var isPrimeSum29: Int = 0\n    var isPrimeSum30: Int = 0\n    var\
    \ isPrimeSum31: Int = 0\n    var isPrimeSum32: Int = 0\n    var isPrimeSum33:\
    \ Int = 0\n    var isPrimeSum34: Int = 0\n    var isPrimeSum35: Int = 0\n    var\
    \ isPrimeSum36: Int = 0\n    var isPrimeSum37: Int = 0\n    var isPrimeSum38:\
    \ Int = 0\n    var isPrimeSum39: Int = 0\n    var isPrimeSum40: Int = 0\n    var\
    \ isPrimeSum41: Int = 0\n    var isPrimeSum42: Int = 0\n    var isPrimeSum43:\
    \ Int = 0\n    var isPrimeSum44: Int = 0\n    var isPrimeSum45: Int = 0\n    var\
    \ isPrimeSum46: Int = 0\n    var isPrimeSum47: Int = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_4j32ip9.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:14:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int = 0\n        ^\n        _\n/tmp/tmp_4j32ip9.swift:15:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmp_4j32ip9.swift:16:9: warning:\
    \ variable 'factorizationCount' was never used; consider replacing with '_' or\
    \ removing it\n    var factorizationCount: Int = 0\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp_4j32ip9.swift:17:9: warning: variable 'factorizationSum'\
    \ was never used; consider replacing with '_' or removing it\n    var factorizationSum:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:18:9: warning:\
    \ variable 'isPrime' was never used; consider replacing with '_' or removing it\n\
    \    var isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:19:9:\
    \ warning: variable 'isPrimeSum' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrimeSum: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:20:9:\
    \ warning: variable 'isPrimeSum2' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimeSum2: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmp_4j32ip9.swift:21:9: warning: variable 'isPrimeSum3' was never used; consider\
    \ replacing with '_' or removing it\n    var isPrimeSum3: Int = 0\n        ^~~~~~~~~~~\n\
    \        _\n/tmp/tmp_4j32ip9.swift:22:9: warning: variable 'isPrimeSum4' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrimeSum4: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmp_4j32ip9.swift:23:9: warning: variable\
    \ 'isPrimeSum5' was never used; consider replacing with '_' or removing it"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int\n    var i: Int\n    var j: Int\n    for i = 2; i\
    \ <= n / 2; i += 1 {\n        factorization = factorization[..]\n        factor\
    \ = i\n        for j = i; j < n / i; j += 1 {\n            if n % j == 0 {\n \
    \               factor *= j\n                factorization = append(factorization,\
    \ factor)\n                break\n            }\n        }\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnin48tpa.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i <= n / 2; i += 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnin48tpa.swift:19:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for j = i; j < n / i; j += 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Bool]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplzrml2zo.swift:29:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:35:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrime"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var i = 2\n    while i < n {\n        if n % i == 0 {\n          \
    \  factorization = append(factorization, i)\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        factorization\
    \ = append(factorization, n)\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbwlzo76h.swift:16:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, i)\n                        \
    \    ^~~~~~\n/tmp/tmpbwlzo76h.swift:17:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n\
    /tmp/tmpbwlzo76h.swift:23:25: error: cannot find 'append' in scope\n        factorization\
    \ = append(factorization, n)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n    var isPrimeCountMaxIndex2: Int = 0\n    var isPrimeCountMaxIndex3:\
    \ Int = 0\n    var isPrimeCountMaxIndex4: Int = 0\n    var isPrimeCountMaxIndex5:\
    \ Int = 0\n    var isPrimeCountMaxIndex6: Int = 0\n    var isPrimeCountMaxIndex7:\
    \ Int = 0\n    var isPrimeCountMaxIndex8: Int = 0\n    var isPrimeCountMaxIndex9:\
    \ Int = 0\n    var isPrimeCountMaxIndex10: Int = 0\n    var isPrimeCountMaxIndex11:\
    \ Int = 0\n    var isPrimeCountMaxIndex12: Int = 0\n    var isPrimeCountMaxIndex13:\
    \ Int = 0\n    var isPrimeCountMaxIndex14: Int = 0\n    var isPrimeCountMaxIndex15:\
    \ Int = 0\n    var isPrimeCountMaxIndex16: Int = 0\n    var isPrimeCountMaxIndex17:\
    \ Int = 0\n    var isPrimeCountMaxIndex18: Int = 0\n    var isPrimeCountMaxIndex19:\
    \ Int = 0\n    var isPrimeCountMaxIndex20: Int = 0\n    var isPrimeCountMaxIndex21:\
    \ Int = 0\n    var isPrimeCountMaxIndex22: Int = 0\n    var isPrimeCountMaxIndex23:\
    \ Int = 0\n    var isPrimeCountMaxIndex24: Int = 0\n    var isPrimeCountMaxIndex25:\
    \ Int = 0\n    var isPrimeCountMaxIndex26: Int = 0\n    var isPrimeCountMaxIndex27:\
    \ Int = 0\n    var isPrimeCountMaxIndex28: Int = 0\n    var isPrimeCountMaxIndex29:\
    \ Int = 0\n    var isPrimeCountMaxIndex30: Int = 0\n    var isPrimeCountMaxIndex31:\
    \ Int = 0\n    var isPrimeCountMaxIndex32: Int = 0\n    var isPrimeCountMaxIndex33:\
    \ Int = 0\n    var isPrimeCountMaxIndex34: Int = 0\n    var isPrimeCountMaxIndex35:\
    \ Int = 0\n    var isPrimeCountMaxIndex36: Int = 0\n    var isPrimeCountMaxIndex37:\
    \ Int = 0\n    var isPrimeCountMaxIndex38: Int = 0\n    var isPrimeCountMaxIndex39:\
    \ Int = 0\n    var isPrimeCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx1y1re10.swift:56:9: error: type annotation missing in pattern\n\
    \    var isPrimeCountMax\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationIndex\
    \ = 0\n    var primeFactorizationCount = 0\n    var primeFactorizationIsPrime\
    \ = true\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorizationIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIndex = -1\n    var primeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp58gd8nmp.swift:19:9: error: invalid redeclaration of 'primeFactorizationIsPrimeIndex'\n\
    \    var primeFactorizationIsPrimeIndex = -1\n        ^\n/tmp/tmp58gd8nmp.swift:17:9:\
    \ note: 'primeFactorizationIsPrimeIndex' previously declared here\n    var primeFactorizationIsPrimeIndex\
    \ = -1\n        ^\n/tmp/tmp58gd8nmp.swift:20:9: error: invalid redeclaration of\
    \ 'primeFactorizationIsPrimeCount'\n    var primeFactorizationIsPrimeCount = 0\n\
    \        ^\n/tmp/tmp58gd8nmp.swift:18:9: note: 'primeFactorizationIsPrimeCount'\
    \ previously declared here\n    var primeFactorizationIsPrimeCount = 0\n     \
    \   ^\n/tmp/tmp58gd8nmp.swift:21:9: error: invalid redeclaration of 'primeFactorizationIsPrimeIndex'\n\
    \    var primeFactorizationIsPrimeIndex = -1\n        ^\n/tmp/tmp58gd8nmp.swift:17:9:\
    \ note: 'primeFactorizationIsPrimeIndex' previously declared here\n    var primeFactorizationIsPrimeIndex\
    \ = -1\n        ^\n/tmp/tmp58gd8nmp.swift:22:9: error: invalid redeclaration of\
    \ 'primeFactorizationIsPrimeCount'\n    var primeFactorizationIsPrimeCount = 0\n\
    \        ^\n/tmp/tmp58gd8nmp.swift:18:9: note: 'primeFactorizationIsPrimeCount'\
    \ previously declared here\n    var primeFactorizationIsPrimeCount = 0\n     \
    \   ^\n/tmp/tmp58gd8nmp.swift:23:9: error: invalid redeclaration of 'primeFactorizationIsPrimeIndex'\n\
    \    var primeFactorizationIsPrimeIndex = -1\n        ^\n/tmp/tmp58gd8nmp.swift:17:9:\
    \ note: 'primeFactorizationIsPrimeIndex' previously declared here\n    var primeFactorizationIsPrimeIndex\
    \ = -1\n        ^\n/tmp/tmp58gd8nmp.swift:24:9: error: invalid redeclaration of\
    \ 'primeFactorizationIsPrimeCount'\n    var primeFactorizationIsPrimeCount = 0\n\
    \        ^\n/tmp/tmp58gd8nmp.swift:18:9: note: 'primeFactorizationIsPrimeCount'\
    \ previously declared here\n    var primeFactorizationIsPrimeCount = 0\n     \
    \   ^\n/tmp/tmp58gd8nmp.swift:25:9: error: invalid redeclaration of 'primeFactorizationIsPrimeIndex'\n\
    \    var primeFactorizationIsPrimeIndex = -1\n        ^\n/tmp/tmp58gd8nmp.swift:17:9:\
    \ note: 'primeFactorizationIsPrimeIndex' previously declared here\n    var primeFactorizationIsPrimeIndex\
    \ = -1"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimeFactorization\
    \ = true\n    var isPrimePrimeFactorizationCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = true\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnltowim4.swift:36:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpnltowim4.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpnltowim4.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpnltowim4.swift:33:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpnltowim4.swift:38:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimeFactorization = true\n        ^\n/tmp/tmpnltowim4.swift:34:9:\
    \ note: 'isPrimePrimePrimePrimePrimeFactorization' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimeFactorization = true\n        ^\n/tmp/tmpnltowim4.swift:39:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeFactorizationCount'\n\
    \    var isPrimePrimePrimePrimePrimeFactorizationCount = 0\n        ^\n/tmp/tmpnltowim4.swift:35:9:\
    \ note: 'isPrimePrimePrimePrimePrimeFactorizationCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimeFactorizationCount = 0\n        ^\n/tmp/tmpnltowim4.swift:48:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpnltowim4.swift:44:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpnltowim4.swift:49:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpnltowim4.swift:45:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpnltowim4.swift:50:9:\
    \ error: type annotation missing in pattern\n    var isPrimePrimePri\n     "
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var p = 2\n    var q = 2\n    var r = 2\n    var s = 2\n \
    \   var t = 2\n    var u = 2\n    var v = 1\n    var w = 1\n    var x = 1\n  \
    \  var y = 1\n    var z = 1\n    var a = 2\n    var b = 2\n    var c = 2\n   \
    \ var d = 2\n    var e = 2\n    var f = 2\n    var g = 2\n    var h = 2\n    var\
    \ i = 2\n    var j = 2\n    var k = 2\n    var l = 2\n    var m = 2\n    var n\
    \ = 2\n    var o = 2\n    var p = 2\n    var q = 2\n    var r = 2\n    var s =\
    \ 2\n    var t = 2\n    var u = 2\n    var v = 1\n    var w = 1\n    var x = 1\n\
    \    var y = 1\n    var z = 1\n    var a = 2\n    var b = 2\n    var c = 2\n \
    \   var d = 2\n    var e = 2\n    var f = 2\n    var g = 2\n    var h = 2\n  \
    \  var i = 2\n    var j = 2\n    var k = 2\n    var l = 2\n    var m = 2\n   \
    \ var n = 2\n    var o = 2\n    var p = 2\n    var q = 2\n    var r = 2\n    var\
    \ s = 2\n    var t = 2\n    var u = 2\n    var v = 1\n    var w = 1\n    var x\
    \ = 1\n    var y = 1\n    var z = 1\n    var a = 2\n    var b = 2\n    var c =\
    \ 2\n    var d = 2\n    var e = 2\n    var f = 2\n    var g = 2\n    var h = 2\n\
    \    var i = 2\n    var j = 2\n    var k = 2\n    var l = 2\n    var m = 2\n \
    \   var n = 2\n    var o = 2\n    var p = 2\n    var q = 2\n    var r = 2\n  \
    \  var s = 2\n    var t = 2\n    var u = 2\n    var v = 1\n    var w = 1\n   \
    \ var x = 1\n    var y = 1\n    var z = 1\n    var a = 2\n    var b = 2\n    var\
    \ c = 2\n    var d = 2\n    var e = 2\n    var f = 2\n    var g = 2\n    var h\
    \ = 2\n    var i = 2\n    var j = 2\n    var k = 2\n    var l = 2\n    var m =\
    \ 2\n    var n = 2\n    var o = 2\n    var p = 2\n    var q = 2\n    var r = 2\n\
    \    var s = 2\n    var t = 2\n    var u = 2\n    var v = 1\n    var w = 1\n \
    \   var x = 1\n    var y = 1\n    var z = 1\n    var a = 2\n    var b = 2\n  \
    \  var c = 2\n    var d = 2\n    var e = 2\n    var f = 2\n    var g = 2\n   \
    \ var h = 2\n    var i = 2\n    var j = 2\n    var \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp89eflpxe.swift:139:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmp89eflpxe.swift:33:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 2\n        ^\n/tmp/tmp89eflpxe.swift:13:9: note: 'i' previously declared\
    \ here\n    var i = 2\n        ^\n/tmp/tmp89eflpxe.swift:40:9: error: invalid\
    \ redeclaration of 'p'\n    var p = 2\n        ^\n/tmp/tmp89eflpxe.swift:14:9:\
    \ note: 'p' previously declared here\n    var p = 2\n        ^\n/tmp/tmp89eflpxe.swift:41:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 2\n        ^\n/tmp/tmp89eflpxe.swift:15:9:\
    \ note: 'q' previously declared here\n    var q = 2\n        ^\n/tmp/tmp89eflpxe.swift:42:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 2\n        ^\n/tmp/tmp89eflpxe.swift:16:9:\
    \ note: 'r' previously declared here\n    var r = 2\n        ^\n/tmp/tmp89eflpxe.swift:43:9:\
    \ error: invalid redeclaration of 's'\n    var s = 2\n        ^\n/tmp/tmp89eflpxe.swift:17:9:\
    \ note: 's' previously declared here\n    var s = 2\n        ^\n/tmp/tmp89eflpxe.swift:44:9:\
    \ error: invalid redeclaration of 't'\n    var t = 2\n        ^\n/tmp/tmp89eflpxe.swift:18:9:\
    \ note: 't' previously declared here\n    var t = 2\n        ^\n/tmp/tmp89eflpxe.swift:45:9:\
    \ error: invalid redeclaration of 'u'\n    var u = 2\n        ^\n/tmp/tmp89eflpxe.swift:19:9:\
    \ note: 'u' previously declared here\n    var u = 2\n        ^\n/tmp/tmp89eflpxe.swift:46:9:\
    \ error: invalid redeclaration of 'v'\n    var v = 1\n        ^\n/tmp/tmp89eflpxe.swift:20:9:\
    \ note: 'v' previously declared here\n    var v = 1\n        ^\n/tmp/tmp89eflpxe.swift:47:9:\
    \ error: invalid redeclaration of 'w'\n    var w = 1\n        ^\n/tmp/tmp89eflpxe.swift:21:9:\
    \ note: 'w' previously declared here\n    var w = 1\n        ^\n/tmp/tmp89eflpxe.swift:48:9:\
    \ error: invalid redeclaration of 'x'\n    var x = 1\n        ^\n/tmp/tmp89eflpxe.swift:22:9:\
    \ note: 'x' previously declared here\n    var x = 1\n        ^\n/tmp/tmp89eflpxe.swift:49:9:\
    \ error: invalid redeclaration of 'y'\n    var y = 1\n        ^\n/tmp/tmp89eflpxe.swift:23:9:\
    \ note: 'y' previously declared here\n    var y = 1\n        ^\n/tmp/tmp89eflpxe.swift:50:9: "
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4\
    \ = 0\n    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6\
    \ = 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm0yv1mfc.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpm0yv1mfc.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:13:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:14:9: warning: initialization\
    \ of variable 'factorizationCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationCount = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpm0yv1mfc.swift:15:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:16:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpm0yv1mfc.swift:17:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:18:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:19:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpm0yv1mfc.swift:20:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpm0yv1mfc.swift:21:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consi"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationIndex = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndex = 0\n    var isPrimeFactorization = false\n    var\
    \ isPrimeFactorizationCount = 0\n    var isPrimeFactorizationIndex = 0\n    var\
    \ isPrimePrimeFactorization = false\n    var isPrimePrimeFactorizationCount =\
    \ 0\n    var isPrimePrimeFactorizationIndex = 0\n    var isPrimePrimeFactorizationPrime\
    \ = false\n    var isPrimePrimeFactorizationPrimeCount = 0\n    var isPrimePrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimePrime = false\n    var isPrimePrimeFactorizationPrimePrimeCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimePrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimeFactorizationPrimePrimePrimePrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex = 0\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex = 0\n \
    \   var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmrh1u4gx.swift:41:9: error: invalid redeclaration of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n       \
    \ ^\n/tmp/tmpmrh1u4gx.swift:38:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpmrh1u4gx.swift:42:9: error: invalid redeclaration of\
    \ 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex\
    \ = 0\n        ^\n/tmp/tmpmrh1u4gx.swift:39:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex\
    \ = 0\n        ^\n/tmp/tmpmrh1u4gx.swift:43:9: error: invalid redeclaration of\
    \ 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpmrh1u4gx.swift:40:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpmrh1u4gx.swift:46:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\n   \
    \     ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            i\
    \ += 1\n            factors.append(i)\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpxhufa8s3/tmpxhufa8s3.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcf88fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcf85f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcf85f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcf85f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxhufa8s3                        0x0000557f5d76a4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002adcf8ae6460 __libc_start_main +
    245

    6    tmpxhufa8s3                        0x0000557f5d76a119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeCountMin = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountSum = 0\n    var isPrimeCountSumMax = 0\n    var isPrimeCountSumMin\
    \ = 0\n    var isPrimeCountSumMaxMax = 0\n    var isPrimeCountSumMinMax = 0\n\
    \    var isPrimeCountSumMaxMin = 0\n    var isPrimeCountSumMinMin = 0\n    var\
    \ isPrimeCountSumMaxMaxMin = 0\n    var isPrimeCountSumMinMinMax = 0\n    var\
    \ isPrimeCountSumMaxMinMin = 0\n    var isPrimeCountSumMinMinMin = 0\n    var\
    \ isPrimeCountSumMaxMaxMinMin = 0\n    var isPrimeCountSumMinMinMinMax = 0\n \
    \   var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMaxMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSumMinMinMinMinMax = 0\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n    var isPrimeCountSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpalbx338t.swift:17:31: error: cannot find 'arc4random_uniform' in\
    \ scope\n    var isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmpalbx338t.swift:18:31:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalbx338t.swift:34:9: error: invalid redeclaration of 'isPrimeCountSumMinMinMinMinMax'\n\
    \    var isPrimeCountSumMinMinMinMinMax = 0\n        ^\n/tmp/tmpalbx338t.swift:32:9:\
    \ note: 'isPrimeCountSumMinMinMinMinMax' previously declared here\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n        ^\n/tmp/tmpalbx338t.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumMinMinMinMinMax'\n    var isPrimeCountSumMinMinMinMinMax = 0\n\
    \        ^\n/tmp/tmpalbx338t.swift:32:9: note: 'isPrimeCountSumMinMinMinMinMax'\
    \ previously declared here\n    var isPrimeCountSumMinMinMinMinMax = 0\n     \
    \   ^\n/tmp/tmpalbx338t.swift:36:9: error: invalid redeclaration of 'isPrimeCountSumMinMinMinMinMax'\n\
    \    var isPrimeCountSumMinMinMinMinMax = 0\n        ^\n/tmp/tmpalbx338t.swift:32:9:\
    \ note: 'isPrimeCountSumMinMinMinMinMax' previously declared here\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n        ^\n/tmp/tmpalbx338t.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumMinMinMinMinMax'\n    var isPrimeCountSumMinMinMinMinMax = 0\n\
    \        ^\n/tmp/tmpalbx338t.swift:32:9: note: 'isPrimeCountSumMinMinMinMinMax'\
    \ previously declared here\n    var isPrimeCountSumMinMinMinMinMax = 0\n     \
    \   ^\n/tmp/tmpalbx338t.swift:38:9: error: invalid redeclaration of 'isPrimeCountSumMinMinMinMinMax'\n\
    \    var isPrimeCountSumMinMinMinMinMax = 0\n        ^\n/tmp/tmpalbx338t.swift:32:9:\
    \ note: 'isPrimeCountSumMinMinMinMinMax' previously declared here\n    var isPrimeCountSumMinMinMinMinMax\
    \ = 0\n        ^\n/tmp/tmpalbx338t.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumMinMinMinMinMax'\n    var isPrimeCountSumMinMinMinMinMax = 0\n\
    \        ^\n/tmp/tmpalbx338t.swift:32:9: note: 'isPr"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var currentFactorization = [1]\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorizationValue = 1\n    var\
    \ currentFactorizationValueIndex = 0\n    var currentFactorizationValueIndexMax\
    \ = 0\n    var currentFactorizationValueIndexMin = 0\n    var currentFactorizationValueMax\
    \ = 0\n    var currentFactorizationValueMin = 0\n    var currentFactorizationValueSum\
    \ = 0\n    var currentFactorizationValueSumMax = 0\n    var currentFactorizationValueSumMin\
    \ = 0\n    var currentFactorizationValueSumSum = 0\n    var currentFactorizationValueSumSumMax\
    \ = 0\n    var currentFactorizationValueSumSumMin = 0\n    var currentFactorizationValueSumSumSum\
    \ = 0\n    var currentFactorizationValueSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSum = 0\n    var currentFactorizationValueSumSumSumSumMax\
    \ = 0\n    var currentFactorizationValueSumSumSumSumMin = 0\n    var currentFactorizationValueSumSumSumSumSum\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSum = 0\n    var currentFactorizationValueSumSumSumSumSumMax\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumMin = 0\n    var currentFactorizationValueSumSumSumSumSumSum\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSum = 0\n    var\
    \ currentFactorizationValueSumSumSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSum = 0\n    var\
    \ currentFactorizationValueSumSumSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSumSum = 0\n    var\
    \ currentFactorizationValueSumSumSumSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSumSum = 0\n    var\
    \ currentFactorizationValueSumSumSumSumSumSumSumSumMax = 0\n    var currentFactorizationValueSumSumSumSumSumSumSumSumMin\
    \ = 0\n    var currentFactorizationValueSumSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpixnp4wx7.swift:38:9: error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumMax'\n\
    \    var currentFactorizationValueSumSumSumSumSumMax = 0\n        ^\n/tmp/tmpixnp4wx7.swift:35:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumMax' previously declared here\n\
    \    var currentFactorizationValueSumSumSumSumSumMax = 0\n        ^\n/tmp/tmpixnp4wx7.swift:39:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumMin'\n\
    \    var currentFactorizationValueSumSumSumSumSumMin = 0\n        ^\n/tmp/tmpixnp4wx7.swift:36:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumMin' previously declared here\n\
    \    var currentFactorizationValueSumSumSumSumSumMin = 0\n        ^\n/tmp/tmpixnp4wx7.swift:40:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumSum'\n\
    \    var currentFactorizationValueSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpixnp4wx7.swift:37:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumSum' previously declared here\n\
    \    var currentFactorizationValueSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpixnp4wx7.swift:46:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumSumSumSum'\n\
    \    var currentFactorizationValueSumSumSumSumSumSumSumSum = 0\n        ^\n/tmp/tmpixnp4wx7.swift:43:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumSumSumSum' previously declared\
    \ here\n    var currentFactorizationValueSumSumSumSumSumSumSumSum = 0\n      \
    \  ^\n/tmp/tmpixnp4wx7.swift:47:9: error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumSumSumMax'\n\
    \    var currentFactorizationValueSumSumSumSumSumSumSumMax = 0\n        ^\n/tmp/tmpixnp4wx7.swift:44:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumSumSumMax' previously declared\
    \ here\n    var currentFactorizationValueSumSumSumSumSumSumSumMax = 0\n      \
    \  ^\n/tmp/tmpixnp4wx7.swift:48:9: error: invalid redeclaration of 'currentFactorizationValueSumSumSumSumSumSumSumMin'\n\
    \    var currentFactorizationValueSumSumSumSumSumSumSumMin = 0\n        ^\n/tmp/tmpixnp4wx7.swift:45:9:\
    \ note: 'currentFactorizationValueSumSumSumSumSumSumSumMin' pre"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationIsPrime\
    \ = true\n    var primeFactorizationIsPrimeCount = 0\n    var primeFactorizationIsPrimeIndex\
    \ = 0\n    var primeFactorizationIsPrimeIsPrime = true\n    var primeFactorizationIsPrimeIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIndex = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrime\
    \ = true\n    var primeFactorizationIsPrimeIsPrimeIsPrimeCount = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrime = true\n    var\
    \ primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeCount = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrime = true\n\
    \    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeCount = 0\n    var\
    \ primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeCount\
    \ = 0\n    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwjvpmc1c.swift:39:9: error: type annotation missing in pattern\n\
    \    var primeFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPri\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount = 0\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3qwjzbtc.swift:31:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:29:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:32:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp3qwjzbtc.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp3qwjzbtc.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFacto"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationSum = [Int]()\n    var primeFactorizationSumCount =\
    \ [Int]()\n    var primeFactorizationSumCountMax = Int()\n    var primeFactorizationSumCountMaxIndex\
    \ = Int()\n    var primeFactorizationSumCountMin = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var primeFactorizationSumCountMaxIndex = Int()\n    var primeFactorizationSumCountMinIndex\
    \ = Int()\n    var prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplsyu1ex0.swift:21:9: error: invalid redeclaration of 'primeFactorizationSumCountMaxIndex'\n\
    \    var primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:18:9:\
    \ note: 'primeFactorizationSumCountMaxIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMinIndex'\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:20:9:\
    \ note: 'primeFactorizationSumCountMinIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMaxIndex'\n    var\
    \ primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:18:9:\
    \ note: 'primeFactorizationSumCountMaxIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:24:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMinIndex'\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:20:9:\
    \ note: 'primeFactorizationSumCountMinIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:25:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMaxIndex'\n    var\
    \ primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:18:9:\
    \ note: 'primeFactorizationSumCountMaxIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:26:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMinIndex'\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:20:9:\
    \ note: 'primeFactorizationSumCountMinIndex' previously declared here\n    var\
    \ primeFactorizationSumCountMinIndex = Int()\n        ^\n/tmp/tmplsyu1ex0.swift:27:9:\
    \ error: invalid redeclaration of 'primeFactorizationSumCountMaxIndex'\n    var\
    \ primeFactorizationSumCountMaxIndex = Int"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount:\
    \ Int = 0\n    var factorizationCount: Int = 0\n    var factorizationSum: Int\
    \ = 0\n    var factorizationSumOfPrimeFactors: Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactors:\
    \ Int = 0\n    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOf\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu1f00s_g.swift:28:9: error: type annotation missing in pattern\n\
    \    var factorizationSumOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOfPrimeFactorsOf\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumCountMax = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMin = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMinIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx4lli2j3.swift:20:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpx4lli2j3.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpx4lli2j3.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpx4lli2j3.swift:19:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpx4lli2j3.swift:22:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpx4lli2j3.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpx4lli2j3.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpx4lli2j3.swift:19:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpx4lli2j3.swift:24:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpx4lli2j3.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpx4lli2j3.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpx4lli2j3.swift:19:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpx4lli2j3.swift:26:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpx4lli2j3.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpx4lli2j3.swift:27"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSum = 0\n    var isPrimeSumPrimeSumCount = 0\n \
    \   var isPrimeSumPrimeSumPrimeCount = 0\n    var isPrimeSumPrimeSumPrimeSum =\
    \ 0\n    var isPrimeSumPrimeSumPrimeSumCount = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSum = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSum\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumCount = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSum = 0\n    var\
    \ isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumCount = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSum\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSum\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSum\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwl_38ye2.swift:37:9: error: invalid redeclaration of 'isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount'\n\
    \    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n        ^\n/tmp/tmpwl_38ye2.swift:35:9: note: 'isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeCount\
    \ = 0\n        ^\n/tmp/tmpwl_38ye2.swift:40:9: error: type annotation missing\
    \ in pattern\n    var isPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPrimeSumPri\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = factorize(n: n)\n    var primeFactors = primes.reduce(into:\
    \ [Int](), {$0 += $1})\n    var factorization = primeFactors.reduce(into: [Int](),\
    \ {$0 += $1})\n    var factorizationCount = factorization.count\n    var factorizationSum\
    \ = factorization.reduce(into: 0) {$0 + $1} / factorizationCount\n    var factorizationSumInt\
    \ = Int(factorizationSum)\n    var factorizationSumInt64 = Int64(factorizationSum)\n\
    \    var factorizationSumFloat = Float(factorizationSum)\n    var factorizationSumDouble\
    \ = Double(factorizationSum)\n    var factorizationSumFloat64 = Float64(factorizationSum)\n\
    \    var factorizationSumInt = Int(factorizationSumInt64)\n    var factorizationSumInt64\
    \ = Int64(factorizationSumInt64)\n    var factorizationSumFloat = Float(factorizationSumInt64)\n\
    \    var factorizationSumDouble = Double(factorizationSumInt64)\n    var factorizationSumFloat64\
    \ = Float64(factorizationSumInt64)\n    var factorizationSumInt = Int(factorizationSumFloat64)\n\
    \    var factorizationSumInt64 = Int64(factorizationSumFloat64)\n    var factorizationSumFloat\
    \ = Float(factorizationSumFloat64)\n    var factorizationSumDouble = Double(factorizationSumFloat64)\n\
    \    var factorizationSumFloat64 = Float64(factorizationSumFloat64)\n    var factorizationSumInt\
    \ = Int(factorizationSumDouble)\n    var factorizationSumInt64 = Int64(factorizationSumDouble)\n\
    \    var factorizationSumFloat = Float(factorizationSumDouble)\n    var factorizationSumDouble\
    \ = Double(factorizationSumDouble)\n    var factorizationSumFloat64 = Float64(factorizationSumDouble)\n\
    \    var factorizationSumInt = Int(factorizationSumFloat64)\n    var factorizationSumInt64\
    \ = Int64(factorizationSumFloat64)\n    var factorizationSumFloat = Float(factorizationSumFloat64)\n\
    \    var factorizationSumDouble = Double(factorizationSumFloat64)\n    var factorizationSumFloat64\
    \ = Float64(factorizationSumFloat64)\n    var factorizationSumInt = Int(factorizationSumDouble)\n\
    \    var factorizationSumInt64 = Int64(factorizationSumDouble)\n    var factorizationSumFloat\
    \ = Float(factorizationSumDouble)\n    var factorizationSumDouble = Double(factorizationSumDouble)\n\
    \    var factorizationSumFloat64 = Float64(factorizationSumDouble)\n    var factorizationSumInt\
    \ = Int(factorizationSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp17uoufa8.swift:49:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp17uoufa8.swift:48:34: note: to match this opening '('\n    var factorizationSumInt\
    \ = Int(factorizationSum\n                                 ^\n/tmp/tmp17uoufa8.swift:14:60:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \    var primeFactors = primes.reduce(into: [Int](), {$0 += $1})\n           \
    \                                                ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var primeFactorizationIndex =\
    \ [Int]()\n    var primeFactorizationIndexCount = [Int]()\n    var primeFactorizationIndexCountMax\
    \ = Int()\n    var primeFactorizationIndexCountMin = Int()\n    var primeFactorizationIndexCountMaxIndex\
    \ = Int()\n    var primeFactorizationIndexCountMinIndex = Int()\n    var primeFactorizationIndexCountMaxValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValue = Int()\n    var primeFactorizationIndexCountMaxValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMinValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValue = Int()\n    var primeFactorizationIndexCountMinValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueIndex = Int()\n  \
    \  var primeFactorizationIndexCountMinValueValueIndex = Int()\n    var primeFactorizationIndexCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValueValueValue = Int()\n  \
    \  var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValue\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzcibu5oc.swift:36:9: error: invalid redeclaration of 'primeFactorizationIndexCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n       \
    \ ^\n/tmp/tmpzcibu5oc.swift:32:9: note: 'primeFactorizationIndexCountMaxValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:37:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueIndex'\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:33:9: note: 'primeFactorizationIndexCountMinValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:38:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValue'\n    var primeFactorizationIndexCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:34:9: note: 'primeFactorizationIndexCountMaxValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:39:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueValue'\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:35:9: note: 'primeFactorizationIndexCountMinValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:40:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueIndex'\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:32:9: note: 'primeFactorizationIndexCountMaxValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpzcibu5oc.swift:41:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueIndex'\n    var "
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int()\n    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMaxValue\
    \ = Int()\n    var isPrimeCountMaxValueIndex = Int()\n    var isPrimeCountMaxValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueValueValue\
    \ = Int()\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyuw9amlp.swift:28:9: error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueIndex'\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:26:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueValue'\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:27:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueValue' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueIndex'\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:26:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueValue'\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:27:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueValue' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueIndex'\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:26:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueIndex = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueValueValue'\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmpyuw9amlp.swift:27:9:\
    \ note: 'isPrimeCountMaxValueValueValueValueValue' previously declared here\n\
    \    var isPrimeCountMaxValueValueValueValueValue = Int()\n        ^\n/t"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd8pb8zxf.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var isPrime: Bool = false\n    var\
    \ isPrimeCount = 0\n    var isPrimeFactorization: Bool = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorization: Bool = false\n    var isPrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorization: Bool = false\n   \
    \ var isPrimePrimeFactorizationPrimeFactorizationCount = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrime\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxrty15za.swift:33:9: error: invalid redeclaration of 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpxrty15za.swift:31:9: note: 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpxrty15za.swift:34:9: error: invalid redeclaration of\
    \ 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpxrty15za.swift:32:9: note: 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmpxrty15za.swift:37:9: error: type annotation\
    \ missing in pattern\n    var isPrimePrimeFactorizationPrimeFactorizationPrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationProductSum = 0\n    var factorizationProductProduct\
    \ = 1\n    var factorizationProductProductSum = 0\n    var factorizationProductProductProduct\
    \ = 1\n    var factorizationProductProductProductSum = 0\n    var factorizationProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductSum = 0\n    var factorizationProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductSum = 0\n    var\
    \ factorizationProductProductProductProductProductProduct = 1\n    var factorizationProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiwp77b_p.swift:36:9: error: invalid redeclaration of 'factorizationProductProductProductProductProductProductProductProductProductProductSum'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpiwp77b_p.swift:34:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductSum'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpiwp77b_p.swift:39:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProduct'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpiwp77b_p.swift:37:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductProductProduct'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpiwp77b_p.swift:42:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpiwp77b_p.swift:40:9: note: 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum'\
    \ previously declared here\n    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductSum\
    \ = 0\n        ^\n/tmp/tmpiwp77b_p.swift:43:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct'\n\
    \    var factorizationProductProductProductProductProductProductProductProductProductProductProductProductProduct\
    \ = 1\n        ^\n/tmp/tmpiwp77b_p.swift:41:9: note: 'factorizationProductProductProductProductProductProductProductProd"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var i = 2\n    var j = 0\n    var factor: Int\n    var isPrime: Bool\n  \
    \  var isPrime2: Bool\n    var isPrime3: Bool\n    var isPrime4: Bool\n    var\
    \ isPrime5: Bool\n    var isPrime6: Bool\n    var isPrime7: Bool\n    var isPrime8:\
    \ Bool\n    var isPrime9: Bool\n    var isPrime10: Bool\n    var isPrime11: Bool\n\
    \    var isPrime12: Bool\n    var isPrime13: Bool\n    var isPrime14: Bool\n \
    \   var isPrime15: Bool\n    var isPrime16: Bool\n    var isPrime17: Bool\n  \
    \  var isPrime18: Bool\n    var isPrime19: Bool\n    var isPrime20: Bool\n   \
    \ var isPrime21: Bool\n    var isPrime22: Bool\n    var isPrime23: Bool\n    var\
    \ isPrime24: Bool\n    var isPrime25: Bool\n    var isPrime26: Bool\n    var isPrime27:\
    \ Bool\n    var isPrime28: Bool\n    var isPrime29: Bool\n    var isPrime30: Bool\n\
    \    var isPrime31: Bool\n    var isPrime32: Bool\n    var isPrime33: Bool\n \
    \   var isPrime34: Bool\n    var isPrime35: Bool\n    var isPrime36: Bool\n  \
    \  var isPrime37: Bool\n    var isPrime38: Bool\n    var isPrime39: Bool\n   \
    \ var isPrime40: Bool\n    var isPrime41: Bool\n    var isPrime42: Bool\n    var\
    \ isPrime43: Bool\n    var isPrime44: Bool\n    var isPrime45: Bool\n    var isPrime46:\
    \ Bool\n    var isPrime47: Bool\n    var isPrime48: Bool\n    var isPrime49: Bool\n\
    \    var isPrime50: Bool\n    var isPrime51: Bool\n    var isPrime52: Bool\n \
    \   var isPrime53: Bool\n    var isPrime54: Bool\n    var isPrime55: Bool\n  \
    \  var isPrime56: Bool\n    var isPrime57: Bool\n    var isPrime58: Bool\n   \
    \ var isPrime59: Bool\n    var isPrime60: Bool\n    var isPrime61: Bool\n    var\
    \ isPrime62: Bool\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpid2642vn.swift:78:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpid2642vn.swift:12:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmpid2642vn.swift:13:9: warning: initialization\
    \ of variable 'i' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var i = 2\n    ~~~~^\n    _\n/tmp/tmpid2642vn.swift:14:9: warning:\
    \ initialization of variable 'j' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpid2642vn.swift:15:9:\
    \ warning: variable 'factor' was never used; consider replacing with '_' or removing\
    \ it\n    var factor: Int\n        ^~~~~~\n        _\n/tmp/tmpid2642vn.swift:16:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: Bool\n        ^~~~~~~\n        _\n/tmp/tmpid2642vn.swift:17:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:18:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:19:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:20:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:21:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:22:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpid2642vn.swift:23:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8:"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc1_cgov0.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeCountMin = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin3 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin4\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin5 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin7 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin8\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin9 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin10 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin11 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin12 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin13\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin14 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin15 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin16 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin17 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin18\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin19 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin20 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin21 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin22 = Int(arc4random_uniform(UInt32(UInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpghnn5rb2.swift:40:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpghnn5rb2.swift:39:58: note: to match this opening '('\n    var isPrimeCountMin22\
    \ = Int(arc4random_uniform(UInt32(UInt\n                                     \
    \                    ^\n/tmp/tmpghnn5rb2.swift:17:31: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:18:31:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpghnn5rb2.swift:19:32: error: cannot find 'arc4random_uniform' in scope\n\
    \    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    \
    \                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:20:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin3 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:21:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin4 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:22:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin5 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:23:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:24:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin7 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpghnn5rb2.swift:25:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin8 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0\
    \ {\n            factorization[factor] = i\n            factor += 1\n        }\n\
    \        i += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b8b872c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b8b569561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9b8b569286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9b8b56913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9b8b568bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9b8b3687ec <unavailable> + 186348

    6    tmpfj83o76t                        0x0000562d66a2fd7b <unavailable> + 7547

    7    tmpfj83o76t                        0x0000562d66a2f3eb <unavailable> + 5099

    8    libc.so.6                          0x00002b9b8ba5e460 __libc_start_main +
    245

    9    tmpfj83o76t                        0x0000562d66a2f109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var\
    \ isPrimeIndex2 = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n  \
    \  var isPrimeCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n\
    \    var isPrimeIndex5 = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 =\
    \ 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeCount30 = 0\n    var isPrimeIndex31 = 0\n    var \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk6m07ij_.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpk6m07ij_.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpk6m07ij_.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpk6m07ij_.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpk6m07ij_.swift:16:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:17:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:18:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpk6m07ij_.swift:19:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:20:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpk6m07ij_.swift:21:9: warning: initialization\
    \ of variable 'isPrimeCount3' was never used; consider replacing "
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        if factors.contains(factor) {\n            factors[factor] += 1\n\
    \        } else {\n            factors.append(factor)\n        }\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwjf4t01w.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationNumber = 0\n    var\
    \ factorizationNumberIndex = 0\n    var factorizationNumberCount = 0\n    var\
    \ factorizationNumberCountIndex = 0\n    var factorizationNumberCountMax = 0\n\
    \    var factorizationNumberCountMaxIndex = 0\n    var factorizationNumberCountMax2\
    \ = 0\n    var factorizationNumberCountMax2Index = 0\n    var factorizationNumberCountMax3\
    \ = 0\n    var factorizationNumberCountMax3Index = 0\n    var factorizationNumberCountMax4\
    \ = 0\n    var factorizationNumberCountMax4Index = 0\n    var factorizationNumberCountMax5\
    \ = 0\n    var factorizationNumberCountMax5Index = 0\n    var factorizationNumberCountMax6\
    \ = 0\n    var factorizationNumberCountMax6Index = 0\n    var factorizationNumberCountMax7\
    \ = 0\n    var factorizationNumberCountMax7Index = 0\n    var factorizationNumberCountMax8\
    \ = 0\n    var factorizationNumberCountMax8Index = 0\n    var factorizationNumberCountMax9\
    \ = 0\n    var factorizationNumberCountMax9Index = 0\n    var factorizationNumberCountMax10\
    \ = 0\n    var factorizationNumberCountMax10Index = 0\n    var factorizationNumberCountMax11\
    \ = 0\n    var factorizationNumberCountMax11Index = 0\n    var factorizationNumberCountMax12\
    \ = 0\n    var factorizationNumberCountMax12Index = 0\n    var factorizationNumberCountMax13\
    \ = 0\n    var factorizationNumberCountMax13Index = 0\n    var factorizationNumberCountMax14\
    \ = 0\n    var factorizationNumberCountMax14Index = 0\n    var factorizationNumberCountMax15\
    \ = 0\n    var factorizationNumberCountMax15Index = 0\n    var factorizationNumberCountMax16\
    \ = 0\n    var factorizationNumberCountMax16Index = 0\n    var factorizationNumberCountMax17\
    \ = 0\n    var factorizationNumberCountMax17Index = 0\n    var factorizationNumberCountMax18\
    \ = 0\n    var factorizationNumberCountMax18Index = 0\n    var factorizationNumberCountMax19\
    \ = 0\n    var factorizationNumberCountMax19Index = 0\n    var factorizationNumberCountMax20\
    \ = 0\n    var factorizationNumberCountMax20Index = 0\n    var factorizationNumberCountMax21\
    \ = 0\n    var factorizationNumberCountMax21Index = 0\n    var factorizationNumberCountMax22\
    \ = 0\n    var factorizationNumberCountMax22Index = 0\n    var factorizationNumberCountMax23\
    \ = 0\n    var factorizationNumberCountMax23Index = 0\n    var factorizationNumberCountMax24\
    \ = 0\n    var factorizationNumberCountMax24Index = 0\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpltrhioq1.swift:68:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpltrhioq1.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex\
    \ = 0\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax2 = Int(sqrt(Double(n)))\n    var isPrimeMax2 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n    var isPrimeMax3 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    var isPrimeMax4 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n    var isPrimeMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    var isPrimeMax6 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n    var isPrimeMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    var isPrimeMax8 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n    var isPrimeMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n    var isPrimeMax10 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax11 = Int(sqrt(Double(n)))\n    var isPrimeMax11 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n    var isPrimeMax12 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n    var isPrimeMax13 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax14 = Int(sqrt(Double(n)))\n    var isPrimeMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax15 = Int(sqrt(Double(n)))\n    var isPrimeMax15 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax16 = Int(sqrt(Double(n)))\n    var isPrimeMax16 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax17 = Int(sqrt(Double(n)))\n    var isPrimeMax17 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax18 = Int(sqrt(Double(n)))\n    var isPrimeMax18 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax19 = Int(sqrt(Double(n)))\n    var isPri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz11kn4y5.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeIndexMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpz11kn4y5.swift:17:26: error: cannot find 'sqrt' in scope\n    var isPrimeMax\
    \ = Int(sqrt(Double(n)))\n                         ^~~~\n/tmp/tmpz11kn4y5.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax2 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmpz11kn4y5.swift:19:27: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeMax2 = Int(sqrt(Double(n)))\n         \
    \                 ^~~~\n/tmp/tmpz11kn4y5.swift:20:32: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n                \
    \               ^~~~\n/tmp/tmpz11kn4y5.swift:21:27: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeMax3 = Int(sqrt(Double(n)))\n                     \
    \     ^~~~\n/tmp/tmpz11kn4y5.swift:22:32: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n                           \
    \    ^~~~\n/tmp/tmpz11kn4y5.swift:23:27: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeMax4 = Int(sqrt(Double(n)))\n                          ^~~~\n\
    /tmp/tmpz11kn4y5.swift:24:32: error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax5\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpz11kn4y5.swift:25:27:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeMax5 = Int(sqrt(Double(n)))\n\
    \                          ^~~~\n/tmp/tmpz11kn4y5.swift:26:32: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n         \
    \                      ^~~~\n/tmp/tmpz11kn4y5.swift:27:27: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeMax6 = Int(sqrt(Double(n)))\n              \
    \            ^~~~\n/tmp/tmpz11kn4y5.swift:28:32: error: cannot find 'sqrt' in\
    \ scope\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n                   \
    \            ^~~~\n/tmp/tmpz11kn4y5.swift:29:27: error: cannot find 'sqrt' in\
    \ scope\n    var isPrimeMax7 = Int(sqrt(Double(n)))\n                        \
    \  ^~~~\n/tmp/tmpz11kn4y5.swift:30:32: error:"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n \
    \   var factorizationCount = 0\n    var factorizationIndex2 = 0\n    var factorizationCount2\
    \ = 0\n    var factorizationIndex3 = 0\n    var factorizationCount3 = 0\n    var\
    \ factorizationIndex4 = 0\n    var factorizationCount4 = 0\n    var factorizationIndex5\
    \ = 0\n    var factorizationCount5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationCount6 = 0\n    var factorizationIndex7 = 0\n    var factorizationCount7\
    \ = 0\n    var factorizationIndex8 = 0\n    var factorizationCount8 = 0\n    var\
    \ factorizationIndex9 = 0\n    var factorizationCount9 = 0\n    var factorizationIndex10\
    \ = 0\n    var factorizationCount10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationCount11 = 0\n    var factorizationIndex12 = 0\n    var factorizationCount12\
    \ = 0\n    var factorizationIndex13 = 0\n    var factorizationCount13 = 0\n  \
    \  var factorizationIndex14 = 0\n    var factorizationCount14 = 0\n    var factorizationIndex15\
    \ = 0\n    var factorizationCount15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationCount16 = 0\n    var factorizationIndex17 = 0\n    var factorizationCount17\
    \ = 0\n    var factorizationIndex18 = 0\n    var factorizationCount18 = 0\n  \
    \  var factorizationIndex19 = 0\n    var factorizationCount19 = 0\n    var factorizationIndex20\
    \ = 0\n    var factorizationCount20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationCount21 = 0\n    var factorizationIndex22 = 0\n    var factorizationCount22\
    \ = 0\n    var factorizationIndex23 = 0\n    var factorizationCount23 = 0\n  \
    \  var factorizationIndex24 = 0\n    var factorizationCount24 = 0\n    var factorizationIndex25\
    \ = 0\n    var factorizationCount25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationCount26 = 0\n    var factorizationIndex27 = 0\n    var factorizationCount27\
    \ = 0\n    var factorizationIndex28 = 0\n    var factorizationCount28 = 0\n  \
    \  var factorizationIndex29 = 0\n    var factorizationCount29 = 0\n    var factorizationIndex30\
    \ = 0\n    var factorizationCount30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationCount31 = 0\n    var factorizationIndex32 = 0\n    var factorizationCount32\
    \ = 0\n    var factorizationIndex33 = 0\n    var factorizationCount33 = 0\n  \
    \  var factorizationIndex34 = 0\n    var factorizationCount34 = 0\n    var factorizationIndex35\
    \ = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3fiy_lst.swift:85:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcld02nb.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var primes: [Int] = []\n    var factorization: [Int] = []\n    var primeFactorization:\
    \ [Int] = []\n    var factorizationCount = 0\n    var primeFactorizationCount\
    \ = 0\n    var factorizationSum = 0\n    var primeFactorizationSum = 0\n    var\
    \ isPrime = true\n    var isPrimeSum = 0\n    var isPrimeSum2 = 0\n    var isPrimeSum3\
    \ = 0\n    var isPrimeSum4 = 0\n    var isPrimeSum5 = 0\n    var isPrimeSum6 =\
    \ 0\n    var isPrimeSum7 = 0\n    var isPrimeSum8 = 0\n    var isPrimeSum9 = 0\n\
    \    var isPrimeSum10 = 0\n    var isPrimeSum11 = 0\n    var isPrimeSum12 = 0\n\
    \    var isPrimeSum13 = 0\n    var isPrimeSum14 = 0\n    var isPrimeSum15 = 0\n\
    \    var isPrimeSum16 = 0\n    var isPrimeSum17 = 0\n    var isPrimeSum18 = 0\n\
    \    var isPrimeSum19 = 0\n    var isPrimeSum20 = 0\n    var isPrimeSum21 = 0\n\
    \    var isPrimeSum22 = 0\n    var isPrimeSum23 = 0\n    var isPrimeSum24 = 0\n\
    \    var isPrimeSum25 = 0\n    var isPrimeSum26 = 0\n    var isPrimeSum27 = 0\n\
    \    var isPrimeSum28 = 0\n    var isPrimeSum29 = 0\n    var isPrimeSum30 = 0\n\
    \    var isPrimeSum31 = 0\n    var isPrimeSum32 = 0\n    var isPrimeSum33 = 0\n\
    \    var isPrimeSum34 = 0\n    var isPrimeSum35 = 0\n    var isPrimeSum36 = 0\n\
    \    var isPrimeSum37 = 0\n    var isPrimeSum38 = 0\n    var isPrimeSum39 = 0\n\
    \    var isPrimeSum40 = 0\n    var isPrimeSum41 = 0\n    var isPrimeSum42 = 0\n\
    \    var isPrimeSum43 = 0\n    var isPrimeSum44 = 0\n    var isPrimeSum45 = 0\n\
    \    var isPrimeSum46 = 0\n    var isPrimeSum47 = 0\n    var isPrimeSum48 = 0\n\
    \    var isPrimeSum49 = 0\n    var isPrimeSum50 = 0\n    var isPrimeSum51 = 0\n\
    \    var isPrimeSum52 = 0\n    var isPrimeSum53 = 0\n    var isPrimeSum54 = 0\n\
    \    var isPrimeSum55 = 0\n    var isPrimeSum56 = 0\n    var isPrimeSum57\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkycszhhn.swift:77:9: error: type annotation missing in pattern\n\
    \    var isPrimeSum57\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax2\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax5\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax7 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax8\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax9 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax10 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax11\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax12 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax13 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax14\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax15 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax16 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax17\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax18 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax19 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax20\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax21 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax22 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax23\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax24 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax25 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax26\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax27 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax28 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax29\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax30 = Int(ceil(sqrt(Double(n))))\n\
    \    var isPrimeCountMax31 = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax32\
    \ = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMax33 = Int(ceil(sqrt(\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpin8ncj96.swift:49:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpin8ncj96.swift:16:31: error: cannot find 'ceil' in scope\n    var\
    \ isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                             \
    \ ^~~~\n/tmp/tmpin8ncj96.swift:16:36: error: cannot find 'sqrt' in scope\n   \
    \ var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                         \
    \          ^~~~\n/tmp/tmpin8ncj96.swift:17:32: error: cannot find 'ceil' in scope\n\
    \    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n                     \
    \          ^~~~\n/tmp/tmpin8ncj96.swift:17:37: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeCountMax2 = Int(ceil(sqrt(Double(n))))\n                     \
    \               ^~~~\n/tmp/tmpin8ncj96.swift:18:32: error: cannot find 'ceil'\
    \ in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n          \
    \                     ^~~~\n/tmp/tmpin8ncj96.swift:18:37: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeCountMax3 = Int(ceil(sqrt(Double(n))))\n          \
    \                          ^~~~\n/tmp/tmpin8ncj96.swift:19:32: error: cannot find\
    \ 'ceil' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n   \
    \                            ^~~~\n/tmp/tmpin8ncj96.swift:19:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpin8ncj96.swift:20:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpin8ncj96.swift:20:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpin8ncj96.swift:21:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \                               ^~~~\n/tmp/tmpin8ncj96.swift:21:37: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(ceil(sqrt(Double(n))))\n\
    \                                    ^~~~\n/tmp/tmpin8ncj96.swift:22:32: error:\
    \ cannot find 'ceil' in scope\n    var isPrim"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = false\n   \
    \ var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorFactorFactorFactor = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactor = false\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex = 0\n  \
    \  var isPrimeFactorizationPrimeFactorFactorFactorFactorFactor = false\n    var\
    \ isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor =\
    \ false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpib6yiofr.swift:31:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactor'\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactor = false\n   \
    \     ^\n/tmp/tmpib6yiofr.swift:29:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactor'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpib6yiofr.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex'\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpib6yiofr.swift:30:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpib6yiofr.swift:34:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex'\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpib6yiofr.swift:30:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpib6yiofr.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor'\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpib6yiofr.swift:33:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpib6yiofr.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex'\n  \
    \  var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex = 0\n\
    \        ^\n/tmp/tmpib6yiofr.swift:36:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFac"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime: Bool = false\n    var isPrimeCount = 0\n    var isPrimePrime:\
    \ Bool = false\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool =\
    \ false\n    var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwh0avm94.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpwh0avm94.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpwh0avm94.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpwh0avm94.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpwh0avm94.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpwh0avm94.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpwh0avm94.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpwh0avm94.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpwh0avm94.swift:42:9:\
    \ error: type annotation missing in pattern\n    var isPrimePri\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexCount = 0\n    var factorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMax = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMinMaxMin = Int(ceil(sqrt(Double(n))))\n    var\
    \ factorizationIndexCountMinMaxMinMax = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpesjjbbjn.swift:16:42: error: cannot find 'ceil' in scope\n    var\
    \ factorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n                  \
    \                       ^~~~\n/tmp/tmpesjjbbjn.swift:16:47: error: cannot find\
    \ 'sqrt' in scope\n    var factorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                              ^~~~\n/tmp/tmpesjjbbjn.swift:17:42:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                         ^~~~~\n/tmp/tmpesjjbbjn.swift:17:48:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                               ^~~~\n/tmp/tmpesjjbbjn.swift:18:45:\
    \ error: cannot find 'ceil' in scope\n    var factorizationIndexCountMaxMin =\
    \ Int(ceil(sqrt(Double(n))))\n                                            ^~~~\n\
    /tmp/tmpesjjbbjn.swift:18:50: error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \    ^~~~\n/tmp/tmpesjjbbjn.swift:19:45: error: cannot find 'floor' in scope\n\
    \    var factorizationIndexCountMinMax = Int(floor(sqrt(Double(n))))\n       \
    \                                     ^~~~~\n/tmp/tmpesjjbbjn.swift:19:51: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationIndexCountMinMax = Int(floor(sqrt(Double(n))))\n\
    \                                                  ^~~~\n/tmp/tmpesjjbbjn.swift:20:48:\
    \ error: cannot find 'ceil' in scope\n    var factorizationIndexCountMinMaxMin\
    \ = Int(ceil(sqrt(Double(n))))\n                                             \
    \  ^~~~\n/tmp/tmpesjjbbjn.swift:20:53: error: cannot find 'sqrt' in scope\n  \
    \  var factorizationIndexCountMinMaxMin = Int(ceil(sqrt(Double(n))))\n       \
    \                                             ^~~~\n/tmp/tmpesjjbbjn.swift:21:51:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMinMaxMinMax\
    \ = Int(floor(sqrt(Double(n))))\n                                            \
    \      ^~~~~\n/tmp/tmpesjjbbjn.sw"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var primeFactorsCount\
    \ = [Int]()\n    var primeFactorsCountMax = Int()\n    var primeFactorsCountMaxIndex\
    \ = -1\n    var primeFactorsCountMaxValue = Int()\n    var primeFactorsCountMaxValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValue = Int()\n    var primeFactorsCountMaxValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValueValue = Int()\n    var\
    \ primeFactorsCountMaxValueValueValueValueIndex = -1\n    var primeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n    var primeFactorsCountMaxValueValueValueValueIndex = -1\n    var\
    \ primeFactorsCountMaxValueValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n \
    \   var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n    var primeFactorsCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n \
    \   var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n \
    \   var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n    var primeFactorsCountMaxValueValueValueValueValueValueValue\
    \ = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n \
    \   var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex\
    \ = -1\n    var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n \
    \   var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n    var primeFactorsCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex = -1\n \
    \   var primeFactorsCountMaxValueValueValueValueValueValue = Int()\n    var primeFactorsCountMaxValueValueValueValueValueIndex\
    \ = -1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0q56yv0o.swift:25:9: error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueIndex'\n\
    \    var primeFactorsCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:23:9:\
    \ note: 'primeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorsCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:26:9:\
    \ error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueValue'\n\
    \    var primeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0q56yv0o.swift:24:9:\
    \ note: 'primeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var primeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0q56yv0o.swift:29:9:\
    \ error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueValueIndex'\n\
    \    var primeFactorsCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:27:9:\
    \ note: 'primeFactorsCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var primeFactorsCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:30:9:\
    \ error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueValueValue'\n\
    \    var primeFactorsCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp0q56yv0o.swift:28:9:\
    \ note: 'primeFactorsCountMaxValueValueValueValueValue' previously declared here\n\
    \    var primeFactorsCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp0q56yv0o.swift:31:9:\
    \ error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueValueIndex'\n\
    \    var primeFactorsCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:27:9:\
    \ note: 'primeFactorsCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var primeFactorsCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp0q56yv0o.swift:32:9:\
    \ error: invalid redeclaration of 'primeFactorsCountMaxValueValueValueValueValue'\n\
    \    var primeFactorsCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp0q56yv0o.swift:28:9:\
    \ note: 'primeFactorsCountMaxValueValueValueValueValue' previously declared here\n\
    \    var prim"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n   \
    \ var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n\
    \    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int =\
    \ 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int\
    \ = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e:\
    \ Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var\
    \ i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n   \
    \ var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n\
    \    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int =\
    \ 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int\
    \ = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c:\
    \ Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var\
    \ g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n   \
    \ var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n\
    \    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\
    \ 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int\
    \ = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a:\
    \ Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var\
    \ e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n   \
    \ var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n\
    \    var m: Int = 0\n    var n: Int = 0\n    var p: Int = 0\n    var q: Int =\
    \ 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int\
    \ = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y:\
    \ Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var\
    \ c: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9jbd6n4p.swift:39:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:14:9: note: 'i' previously declared\
    \ here\n    var i: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:40:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int = 0\n        ^\n/tmp/tmp9jbd6n4p.swift:24:9:\
    \ note: 't' previously declared here\n    var t: Int = 0\n "
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factors = [1]\n    var i = 2\n    while i < n {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            factorization = factorization\
    \ + factors\n            factors = [1]\n            i += 1\n        } else {\n\
    \            i += 1\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpeozeu2_a/tmpeozeu2_a.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06c88e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06c85dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06c85df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06c85de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeozeu2_a                        0x0000564de9a41512 <unavailable> + 5394

    5    libc.so.6                          0x00002b06c8ad4460 __libc_start_main +
    245

    6    tmpeozeu2_a                        0x0000564de9a41169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMaxMin: Int = 1\n    var isPrimeCountMaxMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMin: Int = 1\n    var isPrimeCountMaxMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin: Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMinMinMinMinMinMin: In\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjiu7sevf.swift:20:9: error: invalid redeclaration of 'isPrimeCountMaxMinMin'\n\
    \    var isPrimeCountMaxMinMin: Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:19:9:\
    \ note: 'isPrimeCountMaxMinMin' previously declared here\n    var isPrimeCountMaxMinMin:\
    \ Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMin'\n    var isPrimeCountMaxMinMin: Int = 1\n       \
    \ ^\n/tmp/tmpjiu7sevf.swift:19:9: note: 'isPrimeCountMaxMinMin' previously declared\
    \ here\n    var isPrimeCountMaxMinMin: Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxMinMinMin'\n    var isPrimeCountMaxMinMinMin:\
    \ Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:22:9: note: 'isPrimeCountMaxMinMinMin'\
    \ previously declared here\n    var isPrimeCountMaxMinMinMin: Int = 1\n      \
    \  ^\n/tmp/tmpjiu7sevf.swift:24:9: error: invalid redeclaration of 'isPrimeCountMaxMinMinMin'\n\
    \    var isPrimeCountMaxMinMinMin: Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:22:9:\
    \ note: 'isPrimeCountMaxMinMinMin' previously declared here\n    var isPrimeCountMaxMinMinMin:\
    \ Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMinMinMin'\n    var isPrimeCountMaxMinMinMinMin: Int =\
    \ 1\n        ^\n/tmp/tmpjiu7sevf.swift:25:9: note: 'isPrimeCountMaxMinMinMinMin'\
    \ previously declared here\n    var isPrimeCountMaxMinMinMinMin: Int = 1\n   \
    \     ^\n/tmp/tmpjiu7sevf.swift:27:9: error: invalid redeclaration of 'isPrimeCountMaxMinMinMinMin'\n\
    \    var isPrimeCountMaxMinMinMinMin: Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:25:9:\
    \ note: 'isPrimeCountMaxMinMinMinMin' previously declared here\n    var isPrimeCountMaxMinMinMinMin:\
    \ Int = 1\n        ^\n/tmp/tmpjiu7sevf.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMinMinMin'\n    var isPrimeCountMaxMinMinMinMin: Int =\
    \ 1\n        ^\n/tmp/tmpjiu7sevf.swift:25:9: note: 'isPrimeCountMaxMinMinMinMin'\
    \ previously declared here\n    var isPrimeCountMaxMinMinMinMin: Int = 1\n   \
    \     ^\n/tmp/tmpjiu7sevf.swift:30:9: error: invalid redeclaration of 'isPrimeCountMaxMinMin"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeCountMax = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMin = Int()\n    var\
    \ isPrimeCountMinIndex = Int()\n    var isPrimeCountMinValue = Int()\n    var\
    \ isPrimeCountSum = Int()\n    var isPrimeCountSumIndex = Int()\n    var isPrimeCountSumValue\
    \ = Int()\n    var isPrimeCountSumMax = Int()\n    var isPrimeCountSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumMaxValue = Int()\n    var isPrimeCountSumMin\
    \ = Int()\n    var isPrimeCountSumMinIndex = Int()\n    var isPrimeCountSumMinValue\
    \ = Int()\n    var isPrimeCountSumSum = Int()\n    var isPrimeCountSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumValue = Int()\n    var isPrimeCountSumSumMax\
    \ = Int()\n    var isPrimeCountSumSumMaxIndex = Int()\n    var isPrimeCountSumSumMaxValue\
    \ = Int()\n    var isPrimeCountSumSumMin = Int()\n    var isPrimeCountSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumMinValue = Int()\n    var isPrimeCountSumSumSum\
    \ = Int()\n    var isPrimeCountSumSumSumIndex = Int()\n    var isPrimeCountSumSumSumValue\
    \ = Int()\n    var isPrimeCountSumSumSumMax = Int()\n    var isPrimeCountSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMaxValue = Int()\n    var isPrimeCountSumSumSumMin\
    \ = Int()\n    var isPrimeCountSumSumSumMinIndex = Int()\n    var isPrimeCountSumSumSumMinValue\
    \ = Int()\n    var isPrimeCountSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumValue = Int()\n    var isPrimeCountSumSumSumSumMax\
    \ = Int()\n    var isPrimeCountSumSumSumSumMaxIndex = Int()\n    var isPrimeCountSumSumSumSumMaxValue\
    \ = Int()\n    var isPrimeCountSumSumSumSumMin = Int()\n    var isPrimeCountSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnt9qoyc6.swift:56:9: error: type annotation missing in pattern\n\
    \    var isPrimeCountSum\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime\
    \ = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n  \
    \  var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpijz0zmlx.swift:37:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n  \
    \      ^\n/tmp/tmpijz0zmlx.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpijz0zmlx.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n       \
    \ ^\n/tmp/tmpijz0zmlx.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpijz0zmlx.swift:41:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcld02nb.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 0\n    var isPrimeCountSum: Int = 0\n    var isPrimeCountSumMax: Int =\
    \ 0\n    var isPrimeCountSumMin: Int = 0\n    var isPrimeCountSumSum: Int = 0\n\
    \    var isPrimeCountSumSumMax: Int = 0\n    var isPrimeCountSumSumMin: Int =\
    \ 0\n    var isPrimeCountSumSumSum: Int = 0\n    var isPrimeCountSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsk42h2w1.swift:34:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumMax'\n\
    \    var isPrimeCountSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:31:9:\
    \ note: 'isPrimeCountSumSumSumSumSumMax' previously declared here\n    var isPrimeCountSumSumSumSumSumMax:\
    \ Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumSumMin'\n    var isPrimeCountSumSumSumSumSumMin:\
    \ Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:32:9: note: 'isPrimeCountSumSumSumSumSumMin'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSumMin: Int = 0\n\
    \        ^\n/tmp/tmpsk42h2w1.swift:36:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSum'\n\
    \    var isPrimeCountSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:33:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSum' previously declared here\n    var isPrimeCountSumSumSumSumSumSum:\
    \ Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumSumSumMax'\n    var isPrimeCountSumSumSumSumSumSumMax:\
    \ Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:37:9: note: 'isPrimeCountSumSumSumSumSumSumMax'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n\
    \        ^\n/tmp/tmpsk42h2w1.swift:41:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumMin'\n\
    \    var isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:38:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumMin' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:42:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSum'\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:39:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSum' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:47:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSumMin'\n   \
    \ var isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpsk42h2w1.swift:44:9:\
    \ n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var k = 0\n    var m = 1\n    var n = n\n \
    \   var prime = true\n    var primeFactors = [Int]()\n    var primeFactorsCount\
    \ = 0\n    var factorization = [Int]()\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isPrimeCount = 0\n \
    \   var isPrimeIndex = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeCount = 0\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex = 0\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount = 0\n    var\
    \ isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex = 0\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp07z9zhfz.swift:49:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount = 0\n    \
    \    ^\n/tmp/tmp07z9zhfz.swift:46:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmp07z9zhfz.swift:50:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmp07z9zhfz.swift:47:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmp07z9zhfz.swift:51:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tmp07z9zhfz.swift:48:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tmp07z9zhfz.swift:53:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmp07z9zhfz.swift:47:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmp07z9zhfz.swift:54:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tmp07z9zhfz.swift:48:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tm"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var factorization\
    \ = [Int]()\n    var factorizationIndex = 0\n    var isPrime = true\n    var isFactorization\
    \ = false\n    var isPrimeFactorization = false\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimePrime = false\n    var isPrimeFactorizationPrimePrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrime = false\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimeIndex = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdnw3jr88.swift:32:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n        ^\n\
    /tmp/tmpdnw3jr88.swift:31:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:31:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:35:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:35:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpdnw3jr88.swift:39:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n   \
    \ var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \        ^\n/tmp/tmpdnw3jr88.swift:38:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tm"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumCount = 0\n    var factorizationSumCountMax = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMaxIndex2 = 0\n    var factorizationSumCountMaxIndex3\
    \ = 0\n    var factorizationSumCountMaxIndex4 = 0\n    var factorizationSumCountMaxIndex5\
    \ = 0\n    var factorizationSumCountMaxIndex6 = 0\n    var factorizationSumCountMaxIndex7\
    \ = 0\n    var factorizationSumCountMaxIndex8 = 0\n    var factorizationSumCountMaxIndex9\
    \ = 0\n    var factorizationSumCountMaxIndex10 = 0\n    var factorizationSumCountMaxIndex11\
    \ = 0\n    var factorizationSumCountMaxIndex12 = 0\n    var factorizationSumCountMaxIndex13\
    \ = 0\n    var factorizationSumCountMaxIndex14 = 0\n    var factorizationSumCountMaxIndex15\
    \ = 0\n    var factorizationSumCountMaxIndex16 = 0\n    var factorizationSumCountMaxIndex17\
    \ = 0\n    var factorizationSumCountMaxIndex18 = 0\n    var factorizationSumCountMaxIndex19\
    \ = 0\n    var factorizationSumCountMaxIndex20 = 0\n    var factorizationSumCountMaxIndex21\
    \ = 0\n    var factorizationSumCountMaxIndex22 = 0\n    var factorizationSumCountMaxIndex23\
    \ = 0\n    var factorizationSumCountMaxIndex24 = 0\n    var factorizationSumCountMaxIndex25\
    \ = 0\n    var factorizationSumCountMaxIndex26 = 0\n    var factorizationSumCountMaxIndex27\
    \ = 0\n    var factorizationSumCountMaxIndex28 = 0\n    var factorizationSumCountMaxIndex29\
    \ = 0\n    var factorizationSumCountMaxIndex30 = 0\n    var factorizationSumCountMaxIndex31\
    \ = 0\n    var factorizationSumCountMaxIndex32 = 0\n    var factorizationSumCountMaxIndex33\
    \ = 0\n    var factorizationSumCountMaxIndex34 = 0\n    var factorizationSumCountMaxIndex35\
    \ = 0\n    var factorizationSumCountMaxIndex36 = 0\n    var factorizationSumCountMaxIndex37\
    \ = 0\n    var factorizationSumCountMaxIndex38 = 0\n    var factorizationSumCountMaxIndex39\
    \ = 0\n    var factorizationSumCountMaxIndex40 = 0\n    var factorizationSumCountMaxIndex41\
    \ = 0\n    var factorizationSumCountMaxIndex42 = 0\n    var factorizationSumCountMaxIndex43\
    \ = 0\n    var factorizationSumCountMaxIndex44 = 0\n    var factorizationSumCountMaxIndex45\
    \ = 0\n    var factorizationSumCountMaxIndex46 = 0\n    var factorizationSumCountMaxIndex47\
    \ = 0\n    var factorizationSumCountMaxIndex48 = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe4sura8z.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpe4sura8z.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpe4sura8z.swift:14:9: warning: initialization of variable 'factorizationSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationSum = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:15:9:\
    \ warning: initialization of variable 'factorizationSumCount' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationSumCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:16:9: warning:\
    \ initialization of variable 'factorizationSumCountMax' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationSumCountMax\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:17:9: warning:\
    \ initialization of variable 'factorizationSumCountMaxIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationSumCountMaxIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:18:9:\
    \ warning: initialization of variable 'factorizationSumCountMaxIndex2' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationSumCountMaxIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:19:9:\
    \ warning: initialization of variable 'factorizationSumCountMaxIndex3' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationSumCountMaxIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpe4sura8z.swift:20:9:\
    \ warning: initialization of variable 'factorizationSumCountMaxIndex4' was never\
    \ used; consider replacing with assignment to '_' or removing it\n  "
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var isPrime: [Bool] = []\n    var isPrimeCount:\
    \ Int = 0\n    var isPrimeCountMax: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMin: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqgoujc7q.swift:20:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpqgoujc7q.swift:19:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:17:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmpqgoujc7q.swift:23:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:19:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmpqgoujc7q.swift:17:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:19:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpqgoujc7q.swift:26:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpqgoujc7q.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpqgoujc7q.swift:19:9: note: 'isPrimeCountMinIndex' previously declar"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvge0egq7.swift:131:11: error: expected type\n    var a: \n    \
    \      ^\n           <#type#>\n/tmp/tmpvge0egq7.swift:39:9: error: invalid redeclaration\
    \ of 'i'\n    var i: Int\n        ^\n/tmp/tmpvge0egq7.swift:14:9: note: 'i' previously\
    \ declared here\n    var i: Int\n        ^\n/tmp/tmpvge0egq7.swift:40:9: error:\
    \ invalid redeclaration of 'j'\n    var j: Int\n        ^\n/tmp/tmpvge0egq7.swift:15:9:\
    \ note: 'j' previously declared here\n    var j: Int\n        ^\n/tmp/tmpvge0egq7.swift:41:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int\n        ^\n/tmp/tmpvge0egq7.swift:16:9:\
    \ note: 'k' previously declared here\n    var k: Int\n        ^\n/tmp/tmpvge0egq7.swift:42:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int\n        ^\n/tmp/tmpvge0egq7.swift:17:9:\
    \ note: 'l' previously declared here\n    var l: Int\n        ^\n/tmp/tmpvge0egq7.swift:43:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int\n        ^\n/tmp/tmpvge0egq7.swift:18:9:\
    \ note: 'm' previously declared here\n    var m: Int\n        ^\n/tmp/tmpvge0egq7.swift:44:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int\n        ^\n/tmp/tmpvge0egq7.swift:19:9:\
    \ note: 'n' previously declared here\n    var n: Int\n        ^\n/tmp/tmpvge0egq7.swift:45:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int\n        ^\n/tmp/tmpvge0egq7.swift:20:9:\
    \ note: 'p' previously declared here\n    var p: Int\n        ^\n/tmp/tmpvge0egq7.swift:46:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int\n        ^\n/tmp/tmpvge0egq7.swift:21:9:\
    \ note: 'q' previously declared here\n    var q: Int\n        ^\n/tmp/tmpvge0egq7.swift:47:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int\n        ^\n/tmp/tmpvge0egq7.swift:22:9:\
    \ note: 'r' previously declared here\n    var r: Int\n        ^\n/tmp/tmpvge0egq7.swift:48:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int\n        ^\n/tmp/tmpvge0egq7.swift:23:9:\
    \ note: 's' previously declared here\n    var s: Int\n        ^\n/tmp/tmpvge0egq7.swift:49:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int\n        ^\n/tmp/tmpvge0egq7.swift:24:9:\
    \ note: 't' previously declared here\n    var "
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0\
    \ {\n            factors.append(factor)\n            factor = 1\n        } else\
    \ {\n            factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmptz0_k3r6/tmptz0_k3r6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49ff44ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49ff145b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49ff145988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49ff1447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptz0_k3r6                        0x000055dd5f1f24c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b49ff63a460 __libc_start_main +
    245

    6    tmptz0_k3r6                        0x000055dd5f1f2119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var primeFactorization\
    \ = factorizationOfNumber(n)\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var factorizationCountMax = factorizationCount\n\n    while factorizationCount\
    \ < factorizationCountMax {\n        if primeFactorizationCount == 0 {\n     \
    \       break\n        }\n        if factorizationCount == factorizationCountMax\
    \ {\n            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 1 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 2 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 3 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 4 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 5 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 6 {\n   \
    \         factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            factors.append(primeFactorization)\n            factors.append(factorization)\n\
    \            break\n        }\n        if primeFactorizationCount == 7 {\n   \
    \         factors.append(primeFactorization)\n            factor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp53ebzboa.swift:113:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmp53ebzboa.swift:19:54: note: to match this opening '{'\n    while factorizationCount\
    \ < factorizationCountMax {\n                                                \
    \     ^\n/tmp/tmp53ebzboa.swift:113:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmp53ebzboa.swift:11:33: note: to match this opening '{'\nfunc factorize(n:\
    \ Int) -> [Int] {\n                                ^\n/tmp/tmp53ebzboa.swift:13:25:\
    \ error: cannot find 'factorizationOfNumber' in scope\n    var factorization =\
    \ factorizationOfNumber(n)\n                        ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp53ebzboa.swift:14:30:\
    \ error: cannot find 'factorizationOfNumber' in scope\n    var primeFactorization\
    \ = factorizationOfNumber(n)\n                             ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp53ebzboa.swift:90:13: error: cannot find 'factor' in scope\n         \
    \   factor\n            ^~~~~~\n/tmp/tmp53ebzboa.swift:94:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeSum = [Int]()\n    var isPrimeSumCount = [Int]()\n\
    \    var isPrimeSumPrime = [Int]()\n    var isPrimeSumPrimeCount = [Int]()\n \
    \   var isPrimeSumPrimePrime = [Int]()\n    var isPrimeSumPrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n    var\
    \ isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4sywzuq_.swift:29:9: error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:27:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:28:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmp4sywzuq_.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp4sywzuq_.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrim"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount =\
    \ [Int]()\n    var isPrimeCountMax = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx0njlzbi.swift:19:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:20:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxValue'\n    var isPrimeCountMaxValue = Int()\n        ^\n\
    /tmp/tmpx0njlzbi.swift:18:9: note: 'isPrimeCountMaxValue' previously declared\
    \ here\n    var isPrimeCountMaxValue = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:21:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:17:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex = Int()\n        ^\n\
    /tmp/tmpx0njlzbi.swift:22:9: error: invalid redeclaration of 'isPrimeCountMaxValue'\n\
    \    var isPrimeCountMaxValue = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:18:9:\
    \ note: 'isPrimeCountMaxValue' previously declared here\n    var isPrimeCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = Int()\n        ^\n\
    /tmp/tmpx0njlzbi.swift:17:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValue'\n    var isPrimeCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:18:9: note: 'isPrimeCountMaxValue'\
    \ previously declared here\n    var isPrimeCountMaxValue = Int()\n        ^\n\
    /tmp/tmpx0njlzbi.swift:25:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpx0njlzbi.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxValue'\n    var isPrimeCountMaxValue = Int()\n        ^\n\
    /tmp/tmpx0njlzbi.swift:18:9: note: 'isPrimeCountMaxValue' previously declared\
    \ here\n    var"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Bool]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplzrml2zo.swift:29:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:35:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmplzrml2zo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrime"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var factorizationIndex = 0\n    var currentFactor\
    \ = 1\n    var currentFactorIndex = 0\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactor = false\n    var isPrimeFactorizationPrimeFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactor = false\n    var isPrimeFactorizationPrimeFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactor = false\n   \
    \ var isPrimeFactorizationPrimeFactorFactorFactorFactorIndex = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactor =\
    \ false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorFactorFactorFactor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsgcd8pyi.swift:40:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex'\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpsgcd8pyi.swift:38:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpsgcd8pyi.swift:41:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor'\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpsgcd8pyi.swift:39:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpsgcd8pyi.swift:44:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex'\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpsgcd8pyi.swift:42:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpsgcd8pyi.swift:45:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor'\n\
    \    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpsgcd8pyi.swift:43:9: note: 'isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorFactorFactorFactorFactorFactorFactorFactorFactorFactor\
    \ = false\n        ^\n/tmp/tmpsgcd8pyi.swift:46:9: error: "
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMaxMin: Int = 1\n    var isPrimeCountMinMax: Int\
    \ = 1\n    var isPrimeCountMaxMinMax: Int = 1\n    var isPrimeCountMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpylv5r29q.swift:23:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:22:9:\
    \ note: 'isPrimeCountMinMaxMaxMax' previously declared here\n    var isPrimeCountMinMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMax: Int =\
    \ 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9: note: 'isPrimeCountMinMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n   \
    \     ^\n/tmp/tmpylv5r29q.swift:26:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMax' previously declared here\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMax: Int =\
    \ 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9: note: 'isPrimeCountMinMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n   \
    \     ^\n/tmp/tmpylv5r29q.swift:28:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMax' previously declared here\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMax: Int =\
    \ 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9: note: 'isPrimeCountMinMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n   \
    \     ^\n/tmp/tmpylv5r29q.swift:30:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMax' previously declared here\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmpylv5r29q.swift:"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorCount = 0\n    var isPrime = true\n\
    \    var isPrimeCount = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrime = false\n    var isPrimeFactorizationPrimeFactorPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrime = false\n    var\
    \ isPrimeFactorizationPrimeFactorPrimeFactorPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount = 0\n    var\
    \ isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime = false\n    var\
    \ isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu2798z62.swift:32:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\n\
    \    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount = 0\n    \
    \    ^\n/tmp/tmpu2798z62.swift:30:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmpu2798z62.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tmpu2798z62.swift:31:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrime\
    \ = false\n        ^\n/tmp/tmpu2798z62.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmpu2798z62.swift:30:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmpu2798z62.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount'\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n        ^\n/tmp/tmpu2798z62.swift:36:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeCount\
    \ = 0\n        ^\n/tmp/tmpu2798z62.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime'\n  \
    \  var isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime =\
    \ false\n        ^\n/tmp/tmpu2798z62.swift:37:9: note: 'isPrimeFactorizationPrimeFactorPrimeFactorPrimeFactorPrimeFactorPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactor"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex =\
    \ 0\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax15 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax18 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax20 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax23 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax25 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax28 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax30 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax33 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax35 = Int(sqrt(Double(n)))\n    var isPrime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuvfu9aq0.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeIndexMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpuvfu9aq0.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpuvfu9aq0.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmpuvfu9aq0.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpuvfu9aq0.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpuvfu9aq0.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpuvfu9aq0.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpuvfu9aq0.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpuvfu9aq0.swift:29:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax14 = Int(sqrt(Dou"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var isPrime: Bool = false\n    var isPrimeCount = 0\n    var isPrimePrime:\
    \ Bool = false\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi89p0rz7.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpi89p0rz7.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpi89p0rz7.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpi89p0rz7.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpi89p0rz7.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpi89p0rz7.swift:42:9:\
    \ error: type annotation missing in pattern\n    var isPrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprtvfun2c.swift:29:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmprtvfun2c.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrime"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for i in 0..<factorization.count\
    \ {\n        if factorization[i] > 1 {\n            factors.append(factorization[i])\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkdoq6adz.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationProduct = 1\n    var factorizationProductSum = 0\n    var factorizationProductSum2\
    \ = 0\n    var factorizationProductSum3 = 0\n    var factorizationProductSum4\
    \ = 0\n    var factorizationProductSum5 = 0\n    var factorizationProductSum6\
    \ = 0\n    var factorizationProductSum7 = 0\n    var factorizationProductSum8\
    \ = 0\n    var factorizationProductSum9 = 0\n    var factorizationProductSum10\
    \ = 0\n    var factorizationProductSum11 = 0\n    var factorizationProductSum12\
    \ = 0\n    var factorizationProductSum13 = 0\n    var factorizationProductSum14\
    \ = 0\n    var factorizationProductSum15 = 0\n    var factorizationProductSum16\
    \ = 0\n    var factorizationProductSum17 = 0\n    var factorizationProductSum18\
    \ = 0\n    var factorizationProductSum19 = 0\n    var factorizationProductSum20\
    \ = 0\n    var factorizationProductSum21 = 0\n    var factorizationProductSum22\
    \ = 0\n    var factorizationProductSum23 = 0\n    var factorizationProductSum24\
    \ = 0\n    var factorizationProductSum25 = 0\n    var factorizationProductSum26\
    \ = 0\n    var factorizationProductSum27 = 0\n    var factorizationProductSum28\
    \ = 0\n    var factorizationProductSum29 = 0\n    var factorizationProductSum30\
    \ = 0\n    var factorizationProductSum31 = 0\n    var factorizationProductSum32\
    \ = 0\n    var factorizationProductSum33 = 0\n    var factorizationProductSum34\
    \ = 0\n    var factorizationProductSum35 = 0\n    var factorizationProductSum36\
    \ = 0\n    var factorizationProductSum37 = 0\n    var factorizationProductSum38\
    \ = 0\n    var factorizationProductSum39 = 0\n    var factorizationProductSum40\
    \ = 0\n    var factorizationProductSum41 = 0\n    var factorizationProductSum42\
    \ = 0\n    var factorizationProductSum43 = 0\n    var factorizationProductSum44\
    \ = 0\n    var factorizationProductSum45 = 0\n    var factorizationProductSum46\
    \ = 0\n    var factorizationProductSum47 = 0\n    var factorizationProductSum48\
    \ = 0\n    var factorizationProductSum49 = 0\n    var factorizationProductSum50\
    \ = 0\n    var factorizationProductSum51 = 0\n    var factorizationProductSum52\
    \ = 0\n    var factorizationProductSum53 = 0\n    var factorizationProductSum54\
    \ = 0\n    var factorizationProductSum55 = 0\n    var factorizationProductSum56\
    \ = 0\n    var factorizationProductSum57 = 0\n    var factorizationProductSum58\
    \ = 0\n    var factorizationProductSum59 = 0\n    var factorizationProductSum60\
    \ = 0\n    var factorizationProductSum61 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp264buqe4.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp264buqe4.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp264buqe4.swift:14:9: warning: initialization of variable 'factorizationSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationSum = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:15:9:\
    \ warning: initialization of variable 'factorizationProduct' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProduct\
    \ = 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:16:9: warning:\
    \ initialization of variable 'factorizationProductSum' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:17:9: warning:\
    \ initialization of variable 'factorizationProductSum2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:18:9: warning:\
    \ initialization of variable 'factorizationProductSum3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:19:9: warning:\
    \ initialization of variable 'factorizationProductSum4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp264buqe4.swift:20:9: warning:\
    \ initialization of variable 'factorizationProductSum5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum5\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcld02nb.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc1_cgov0.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7ll04xt1.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isP"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    while i <= n {\n        while n % i ==\
    \ 0 {\n            factors.append(factor)\n            n /= i\n        }\n   \
    \     i += 1\n        factor = 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzhg095gr.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var currentFactorization = [1]\n    var\
    \ currentFactor = 1\n    var currentFactorizationIndex = 0\n    var currentFactorizationIndexMax\
    \ = 0\n    var currentFactorizationIndexMaxIndex = 0\n    var currentFactorizationIndexMin\
    \ = 0\n    var currentFactorizationIndexMinIndex = 0\n    var currentFactorizationIndexMaxValue\
    \ = 0\n    var currentFactorizationIndexMinValue = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMaxValueIndex\
    \ = 0\n    var currentFactorizationIndexMinValueIndex = 0\n    var currentFactorizationIndexMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6vcmi0lg.swift:25:9: error: invalid redeclaration of 'currentFactorizationIndexMaxValueIndex'\n\
    \    var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:23:9:\
    \ note: 'currentFactorizationIndexMaxValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:26:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMinValueIndex'\n \
    \   var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:24:9:\
    \ note: 'currentFactorizationIndexMinValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:27:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMaxValueIndex'\n \
    \   var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:23:9:\
    \ note: 'currentFactorizationIndexMaxValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:28:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMinValueIndex'\n \
    \   var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:24:9:\
    \ note: 'currentFactorizationIndexMinValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:29:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMaxValueIndex'\n \
    \   var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:23:9:\
    \ note: 'currentFactorizationIndexMaxValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMaxValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:30:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMinValueIndex'\n \
    \   var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:24:9:\
    \ note: 'currentFactorizationIndexMinValueIndex' previously declared here\n  \
    \  var currentFactorizationIndexMinValueIndex = 0\n        ^\n/tmp/tmp6vcmi0lg.swift:31:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMaxValueInd"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for i in factorization\
    \ {\n        if factors.contains(i) {\n            factors.append(i)\n       \
    \ } else {\n            factors.append(1)\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppqsmdho5.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = [1]\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = true\n    var\
    \ isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime = true\n  \
    \  var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPri\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsdwzc408.swift:32:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpsdwzc408.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpsdwzc408.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpsdwzc408.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpsdwzc408.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpsdwzc408.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpsdwzc408.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpsdwzc408.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactoriz"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 2\n    var isPrimeCountMaxMin: Int = 2\n    var isPrimeCountMinMax: Int\
    \ = 2\n    var isPrimeCountMinMaxMin: Int = 2\n    var isPrimeCountMinMaxMinMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMin: Int = 2\n    var isPrimeCountMinMaxMinMaxMinMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMin: Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n  \
    \  var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int =\
    \ 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n   \
    \ var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n \
    \   var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int =\
    \ 2\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 2\n    var isPrimeCountMinMaxMinMaxMin\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiceiitfk.swift:30:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 2\n        ^\n\
    /tmp/tmpiceiitfk.swift:29:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:32:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:32:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n \
    \       ^\n/tmp/tmpiceiitfk.swift:37:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 2\n        ^\n/tmp/tmpiceiitfk.swift:39:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 2\n \
    \       ^\n/tmp/tmpiceiitfk.swift:37:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 2\n        ^\n/tmp/"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex\
    \ = 0\n    var isPrimeCount = 0\n    var isPrimeCountIndex = 0\n    var isPrimeCountMax\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMin = 0\n    var\
    \ isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n  \
    \  var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n  \
    \  var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n  \
    \  var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n  \
    \  var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n  \
    \  var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n  \
    \  var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n  \
    \  var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n  \
    \  var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n  \
    \  var isPrimeCountMaxIndex = 0\n    var isPrimeCountMinIndex = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMinIndex = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnp0uue8h.swift:22:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:19:9: note:\
    \ 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:23:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:21:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:24:9: error: invalid redeclaration of\
    \ 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:19:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:25:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:21:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:26:9: error: invalid redeclaration of\
    \ 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:19:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:27:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:21:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:28:9: error: invalid redeclaration of\
    \ 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:19:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:29:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = 0\n        ^\n/tmp/tmpnp0uue8h.swift:21:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpnp0uue8h.swift:3"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var primeFactorization = [Int]()\n    var\
    \ primeFactors = [Int]()\n    var primeFactorsCount = 0\n    var isPrime = [Bool]()\n\
    \    var isPrimeCount = 0\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppj0oorkf.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmppj0oorkf.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmppj0oorkf.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmppj0oorkf.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmppj0oorkf.swift:41:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \        ^\n/tmp/tmppj0oorkf.swift:39:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmppj0oorkf.swift:42:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: Int = 0\n    var isPrimeIndex: Int = 0\n    var isPrimeCountIndex:\
    \ Int = 0\n    var isPrimeCountMax: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMin: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int = 0\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpafbxkvd8.swift:60:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpafbxkvd8.swift:22:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:19:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpafbxkvd8.swift:21:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:21:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpafbxkvd8.swift:25:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:19:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmpafbxkvd8.swift:21:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:19:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmpafbxkvd8.swift:28:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:21:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmpafbxkvd8.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var factorizationCount = 0\n    var primeFactorizationIndex = 0\n \
    \   var factorizationIndex = 0\n    var primeFactorizationArray: [Int] = []\n\
    \    var factorizationArray: [Int] = []\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5tfw41kv.swift:24:9: error: invalid redeclaration of 'primeFactorizationArrayIndex'\n\
    \    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp5tfw41kv.swift:20:9:\
    \ note: 'primeFactorizationArrayIndex' previously declared here\n    var primeFactorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp5tfw41kv.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationArrayIndex'\n    var factorizationArrayIndex = 0\n        ^\n\
    /tmp/tmp5tfw41kv.swift:21:9: note: 'factorizationArrayIndex' previously declared\
    \ here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp5tfw41kv.swift:26:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp5tfw41kv.swift:22:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp5tfw41kv.swift:27:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArrayCount = 0\n        ^\n/tmp/tmp5tfw41kv.swift:23:9:\
    \ note: 'factorizationArrayCount' previously declared here\n    var factorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp5tfw41kv.swift:28:9: error: invalid redeclaration of\
    \ 'primeFactorizationArrayIndex'\n    var primeFactorizationArrayIndex = 0\n \
    \       ^\n/tmp/tmp5tfw41kv.swift:20:9: note: 'primeFactorizationArrayIndex' previously\
    \ declared here\n    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp5tfw41kv.swift:29:9:\
    \ error: invalid redeclaration of 'factorizationArrayIndex'\n    var factorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp5tfw41kv.swift:21:9: note: 'factorizationArrayIndex'\
    \ previously declared here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp5tfw41kv.swift:30:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp5tfw41kv.swift:22:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp5tfw41kv.swift:31:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArray"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var factorization\
    \ = [Int]()\n    var factorizationCount = 0\n    var isPrime = true\n    var isPrimeFactorization\
    \ = true\n    var isPrimeFactorizationCount = true\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeCount = true\n    var isPrimeFactorizationPrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimeCount = true\n    var isPrimeFactorizationPrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimeCount = true\n    var isPrimeFactorizationPrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimeCount = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimeCount = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = true\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkz1cnq9p.swift:42:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpkz1cnq9p.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:13:9:\
    \ warning: initialization of variable 'primes' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primes = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpkz1cnq9p.swift:14:9: warning: initialization of variable 'primeFactors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactors = [Int]()\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:15:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:16:9: warning: initialization\
    \ of variable 'factorizationCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpkz1cnq9p.swift:17:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:18:9: warning:\
    \ initialization of variable 'isPrimeFactorization' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeFactorization = true\n\
    \    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:19:9: warning: initialization\
    \ of variable 'isPrimeFactorizationCount' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrimeFactorizationCount = true\n\
    \    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpkz1cnq9p.swift:20:9: warning:\
    \ initialization of variable 'isPrimeFactorizationPrime' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactorizationPrime\
    \ = true\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpkz1cnq9p.s"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n         \
    \   factorization = append(factorization, i)\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return factorization\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnqin05so.swift:16:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, i)\n                        \
    \    ^~~~~~\n/tmp/tmpnqin05so.swift:17:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for i in 0..<factorization.count\
    \ {\n        if factorization[i] == 1 {\n            factors.append(i)\n     \
    \   }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphtbqlm_d.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var prime: Int = 0\n    var primeFactorization:\
    \ [Int] = []\n    var primeFactor: Int = 0\n    var isPrime: Bool = false\n  \
    \  var isPrimeFactorization: Bool = false\n    var isPrimeFactor: Bool = false\n\
    \    var isPrimeFactorizationPrime: Bool = false\n    var isPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorization: Bool = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrime: Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppvmao34d.swift:39:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmppvmao34d.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int = 0\n        ^~~~~~\n        _\n/tmp/tmppvmao34d.swift:14:9:\
    \ warning: variable 'prime' was never used; consider replacing with '_' or removing\
    \ it\n    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmppvmao34d.swift:15:9:\
    \ warning: variable 'primeFactorization' was never used; consider replacing with\
    \ '_' or removing it\n    var primeFactorization: [Int] = []\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmppvmao34d.swift:16:9: warning: variable 'primeFactor' was never\
    \ used; consider replacing with '_' or removing it\n    var primeFactor: Int =\
    \ 0\n        ^~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:17:9: warning: variable\
    \ 'isPrime' was never used; consider replacing with '_' or removing it\n    var\
    \ isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmppvmao34d.swift:18:9:\
    \ warning: variable 'isPrimeFactorization' was never used; consider replacing\
    \ with '_' or removing it\n    var isPrimeFactorization: Bool = false\n      \
    \  ^~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:19:9: warning: variable\
    \ 'isPrimeFactor' was never used; consider replacing with '_' or removing it\n\
    \    var isPrimeFactor: Bool = false\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:20:9:\
    \ warning: variable 'isPrimeFactorizationPrime' was never used; consider replacing\
    \ with '_' or removing it\n    var isPrimeFactorizationPrime: Bool = false\n \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:21:9: warning:\
    \ variable 'isPrimeFactorizationPrimeFactor' was never used; consider replacing\
    \ with '_' or removing it\n    var isPrimeFactorizationPrimeFactor: Bool = false\n\
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmppvmao34d.swift:22:9:\
    \ warning: v"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = [1]\n    var factorizationIndex = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = factorization[currentFactorizationIndex]\n\
    \    var currentFactorizationIndexInFactorization = 0\n    var currentFactorizationIndexInFactorizationMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMin\
    \ = 0\n    var currentFactorizationIndexInFactorizationMinMax = factorization.count\
    \ - 1\n    var currentFactorizationIndexInFactorizationMaxMin = 0\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpf4sfk574.swift:23:9: error: invalid redeclaration of 'currentFactorizationIndexInFactorizationMaxMinMax'\n\
    \    var currentFactorizationIndexInFactorizationMaxMinMax = factorization.count\
    \ - 1\n        ^\n/tmp/tmpf4sfk574.swift:22:9: note: 'currentFactorizationIndexInFactorizationMaxMinMax'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n        ^\n/tmp/tmpf4sfk574.swift:24:9: error: invalid\
    \ redeclaration of 'currentFactorizationIndexInFactorizationMaxMinMax'\n    var\
    \ currentFactorizationIndexInFactorizationMaxMinMax = factorization.count - 1\n\
    \        ^\n/tmp/tmpf4sfk574.swift:22:9: note: 'currentFactorizationIndexInFactorizationMaxMinMax'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n        ^\n/tmp/tmpf4sfk574.swift:25:9: error: invalid\
    \ redeclaration of 'currentFactorizationIndexInFactorizationMaxMinMax'\n    var\
    \ currentFactorizationIndexInFactorizationMaxMinMax = factorization.count - 1\n\
    \        ^\n/tmp/tmpf4sfk574.swift:22:9: note: 'currentFactorizationIndexInFactorizationMaxMinMax'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n        ^\n/tmp/tmpf4sfk574.swift:26:9: error: invalid\
    \ redeclaration of 'currentFactorizationIndexInFactorizationMaxMinMax'\n    var\
    \ currentFactorizationIndexInFactorizationMaxMinMax = factorization.count - 1\n\
    \        ^\n/tmp/tmpf4sfk574.swift:22:9: note: 'currentFactorizationIndexInFactorizationMaxMinMax'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.count - 1\n        ^\n/tmp/tmpf4sfk574.swift:27:9: error: invalid\
    \ redeclaration of 'currentFactorizationIndexInFactorizationMaxMinMax'\n    var\
    \ currentFactorizationIndexInFactorizationMaxMinMax = factorization.count - 1\n\
    \        ^\n/tmp/tmpf4sfk574.swift:22:9: note: 'currentFactorizationIndexInFactorizationMaxMinMax'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationMaxMinMax\
    \ = factorization.cou"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n    var factorizationMin = factorizationMax\n\
    \    var factorizationMaxIndex = 0\n    var factorizationMinIndex = 0\n    var\
    \ factorizationMaxCount = 0\n    var factorizationMinCount = 0\n    var factorizationMaxSum\
    \ = 0\n    var factorizationMinSum = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSumCount = 0\n    var factorizationSumIndex = 0\n    var factorizationSumMax\
    \ = 0\n    var factorizationSumMin = 0\n    var factorizationSumMaxIndex = 0\n\
    \    var factorizationSumMinIndex = 0\n    var factorizationSumMaxCount = 0\n\
    \    var factorizationSumMinCount = 0\n    var factorizationSumMaxSum = 0\n  \
    \  var factorizationSumMinSum = 0\n    var factorizationSumSum = 0\n    var factorizationSumSumCount\
    \ = 0\n    var factorizationSumSumIndex = 0\n    var factorizationSumSumMax =\
    \ 0\n    var factorizationSumSumMin = 0\n    var factorizationSumSumMaxIndex =\
    \ 0\n    var factorizationSumSumMinIndex = 0\n    var factorizationSumSumMaxCount\
    \ = 0\n    var factorizationSumSumMinCount = 0\n    var factorizationSumSumMaxSum\
    \ = 0\n    var factorizationSumSumMinSum = 0\n    var factorizationSumSumSum =\
    \ 0\n    var factorizationSumSumSumCount = 0\n    var factorizationSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumMax = 0\n    var factorizationSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumMaxIndex = 0\n    var factorizationSumSumSumMinIndex\
    \ = 0\n    var factorizationSumSumSumMaxCount = 0\n    var factorizationSumSumSumMinCount\
    \ = 0\n    var factorizationSumSumSumMaxSum = 0\n    var factorizationSumSumSumMinSum\
    \ = 0\n    var factorizationSumSumSumSum = 0\n    var factorizationSumSumSumSumCount\
    \ = 0\n    var factorizationSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMin = 0\n    var factorizationSumSumSumSumMaxIndex\
    \ = 0\n    var factorizationSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumSumMaxCount\
    \ = 0\n    var factorizationSumSumSumSumMinCount = 0\n    var factorizationSumSumSumSumMaxSum\
    \ = 0\n    var factorizationSumSumSumSumMinSum = 0\n    var factorizationSumSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumSumCount = 0\n    var factorizationSumSumSumSumSumIndex\
    \ = 0\n    var factorizationSumSum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5_79chbz.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp5_79chbz.swift:70:9: error: type annotation missing in pattern\n    var\
    \ factorizationSumSum\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var\
    \ k: Int = 0\n    var count: Int = 0\n    var isPrime: Bool = false\n    var isPrime2:\
    \ Bool = false\n    var isPrime3: Bool = false\n    var isPrime4: Bool = false\n\
    \    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n    var isPrime7:\
    \ Bool = false\n    var isPrime8: Bool = false\n    var isPrime9: Bool = false\n\
    \    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n    var isPrime12:\
    \ Bool = false\n    var isPrime13: Bool = false\n    var isPrime14: Bool = false\n\
    \    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n    var isPrime17:\
    \ Bool = false\n    var isPrime18: Bool = false\n    var isPrime19: Bool = false\n\
    \    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n    var isPrime22:\
    \ Bool = false\n    var isPrime23: Bool = false\n    var isPrime24: Bool = false\n\
    \    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n    var isPrime27:\
    \ Bool = false\n    var isPrime28: Bool = false\n    var isPrime29: Bool = false\n\
    \    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n    var isPrime32:\
    \ Bool = false\n    var isPrime33: Bool = false\n    var isPrime34: Bool = false\n\
    \    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n    var isPrime37:\
    \ Bool = false\n    var isPrime38: Bool = false\n    var isPrime39: Bool = false\n\
    \    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n    var isPrime42:\
    \ Bool = false\n    var isPrime43: Bool = false\n    var isPrime44: Bool = false\n\
    \    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n    var isPrime47:\
    \ Bool = false\n    var isPrime48: Bool = false\n    var isPrime49: Bool = false\n\
    \    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n    var isPrime52:\
    \ Bool = false\n    var isPrime53: Bool = false\n    var isPrime54: \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjjqicem5.swift:71:19: error: expected type\n    var isPrime54:\
    \ \n                  ^\n                   <#type#>\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprtvfun2c.swift:29:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:31:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmprtvfun2c.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmprtvfun2c.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmprtvfun2c.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrime"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n \
    \   var primeFactorizationIndex = 0\n    var primeFactorizationIndex2 = 0\n  \
    \  var primeFactorizationIndex3 = 0\n    var primeFactorizationIndex4 = 0\n  \
    \  var primeFactorizationIndex5 = 0\n    var primeFactorizationIndex6 = 0\n  \
    \  var primeFactorizationIndex7 = 0\n    var primeFactorizationIndex8 = 0\n  \
    \  var primeFactorizationIndex9 = 0\n    var primeFactorizationIndex10 = 0\n \
    \   var primeFactorizationIndex11 = 0\n    var primeFactorizationIndex12 = 0\n\
    \    var primeFactorizationIndex13 = 0\n    var primeFactorizationIndex14 = 0\n\
    \    var primeFactorizationIndex15 = 0\n    var primeFactorizationIndex16 = 0\n\
    \    var primeFactorizationIndex17 = 0\n    var primeFactorizationIndex18 = 0\n\
    \    var primeFactorizationIndex19 = 0\n    var primeFactorizationIndex20 = 0\n\
    \    var primeFactorizationIndex21 = 0\n    var primeFactorizationIndex22 = 0\n\
    \    var primeFactorizationIndex23 = 0\n    var primeFactorizationIndex24 = 0\n\
    \    var primeFactorizationIndex25 = 0\n    var primeFactorizationIndex26 = 0\n\
    \    var primeFactorizationIndex27 = 0\n    var primeFactorizationIndex28 = 0\n\
    \    var primeFactorizationIndex29 = 0\n    var primeFactorizationIndex30 = 0\n\
    \    var primeFactorizationIndex31 = 0\n    var primeFactorizationIndex32 = 0\n\
    \    var primeFactorizationIndex33 = 0\n    var primeFactorizationIndex34 = 0\n\
    \    var primeFactorizationIndex35 = 0\n    var primeFactorizationIndex36 = 0\n\
    \    var primeFactorizationIndex37 = 0\n    var primeFactorizationIndex38 = 0\n\
    \    var primeFactorizationIndex39 = 0\n    var primeFactorizationIndex40 = 0\n\
    \    var primeFactorizationIndex41 = 0\n    var primeFactorizationIndex42 = 0\n\
    \    var primeFactorizationIndex43 = 0\n    var primeFactorizationIndex44 = 0\n\
    \    var primeFactorizationIndex45 = 0\n    var primeFactorizationIndex46 = 0\n\
    \    var primeFactorizationIndex47 = 0\n    var primeFactorizationIndex48 = 0\n\
    \    var primeFactorizationIndex49 = 0\n    var primeFactorizationIndex50 = 0\n\
    \    var primeFactorizationIndex51 = 0\n    var primeFactorizationIndex52 = 0\n\
    \    var primeFactorizationIndex53 = 0\n    var primeFactorizationIndex54 = 0\n\
    \    var primeFactorizationIndex55 = 0\n    var primeFactorizationIndex56 = 0\n\
    \    var primeFactorizationIndex57 = 0\n    var primeFactorizationIndex58 = 0\n\
    \    var primeFactorizationIndex59 = 0\n    var primeFactorizationIndex60 = 0\n\
    \    var primeFactorizationIndex61 = 0\n    var primeFactorization\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkbt0wae5.swift:76:9: error: type annotation missing in pattern\n\
    \    var primeFactorization\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var i = 2\n    var j = 1\n    var k = 0\n\
    \    var factorizationIndex = 0\n    var factorizationIndexMax = 0\n    var factorizationIndexMaxIndex\
    \ = 0\n    var factorizationIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndex\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndex = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n    var factorizationIndexMaxIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationIndexMaxIndexMaxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprpj2u8qa.swift:23:9: error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:22:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMax' previously declared here\n   \
    \ var factorizationIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:25:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:25:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:28:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:25:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:29:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:25:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:30:9:\
    \ error: invalid redeclaration of 'factorizationIndexMaxIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationIndexMaxIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmprpj2u8qa.swift:25:9:\
    \ note: 'factorizationIndexMaxIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationIndexMaxI"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var primeFactorsCount\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var\
    \ isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCount2\
    \ = [Int]()\n    var isPrimeFactorsCount3 = [Int]()\n    var isPrimeFactorsCount4\
    \ = [Int]()\n    var isPrimeFactorsCount5 = [Int]()\n    var isPrimeFactorsCount6\
    \ = [Int]()\n    var isPrimeFactorsCount7 = [Int]()\n    var isPrimeFactorsCount8\
    \ = [Int]()\n    var isPrimeFactorsCount9 = [Int]()\n    var isPrimeFactorsCount10\
    \ = [Int]()\n    var isPrimeFactorsCount11 = [Int]()\n    var isPrimeFactorsCount12\
    \ = [Int]()\n    var isPrimeFactorsCount13 = [Int]()\n    var isPrimeFactorsCount14\
    \ = [Int]()\n    var isPrimeFactorsCount15 = [Int]()\n    var isPrimeFactorsCount16\
    \ = [Int]()\n    var isPrimeFactorsCount17 = [Int]()\n    var isPrimeFactorsCount18\
    \ = [Int]()\n    var isPrimeFactorsCount19 = [Int]()\n    var isPrimeFactorsCount20\
    \ = [Int]()\n    var isPrimeFactorsCount21 = [Int]()\n    var isPrimeFactorsCount22\
    \ = [Int]()\n    var isPrimeFactorsCount23 = [Int]()\n    var isPrimeFactorsCount24\
    \ = [Int]()\n    var isPrimeFactorsCount25 = [Int]()\n    var isPrimeFactorsCount26\
    \ = [Int]()\n    var isPrimeFactorsCount27 = [Int]()\n    var isPrimeFactorsCount28\
    \ = [Int]()\n    var isPrimeFactorsCount29 = [Int]()\n    var isPrimeFactorsCount30\
    \ = [Int]()\n    var isPrimeFactorsCount31 = [Int]()\n    var isPrimeFactorsCount32\
    \ = [Int]()\n    var isPrimeFactorsCount33 = [Int]()\n    var isPrimeFactorsCount34\
    \ = [Int]()\n    var isPrimeFactorsCount35 = [\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: '/tmp/tmp9fw4bkjb.swift:54:1: error: expected expression in container literal

    }

    ^

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationSum = 0\n    var\
    \ factorizationSum2 = 0\n    var factorizationSum3 = 0\n    var factorizationSum4\
    \ = 0\n    var factorizationSum5 = 0\n    var factorizationSum6 = 0\n    var factorizationSum7\
    \ = 0\n    var factorizationSum8 = 0\n    var factorizationSum9 = 0\n    var factorizationSum10\
    \ = 0\n    var factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var\
    \ factorizationSum13 = 0\n    var factorizationSum14 = 0\n    var factorizationSum15\
    \ = 0\n    var factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var\
    \ factorizationSum18 = 0\n    var factorizationSum19 = 0\n    var factorizationSum20\
    \ = 0\n    var factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var\
    \ factorizationSum23 = 0\n    var factorizationSum24 = 0\n    var factorizationSum25\
    \ = 0\n    var factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var\
    \ factorizationSum28 = 0\n    var factorizationSum29 = 0\n    var factorizationSum30\
    \ = 0\n    var factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var\
    \ factorizationSum33 = 0\n    var factorizationSum34 = 0\n    var factorizationSum35\
    \ = 0\n    var factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var\
    \ factorizationSum38 = 0\n    var factorizationSum39 = 0\n    var factorizationSum40\
    \ = 0\n    var factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var\
    \ factorizationSum43 = 0\n    var factorizationSum44 = 0\n    var factorizationSum45\
    \ = 0\n    var factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var\
    \ factorizationSum48 = 0\n    var factorizationSum49 = 0\n    var factorizationSum50\
    \ = 0\n    var factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var\
    \ factorizationSum53 = 0\n    var factorizationSum54 = 0\n    var factorizationSum55\
    \ = 0\n    var factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var\
    \ factorizationSum58 = 0\n    var factorizationSum59 = 0\n    var factorizationSum60\
    \ = 0\n    var factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var\
    \ factorizationSum63 = 0\n    var factorizationSum64 = 0\n    var factorizationSum65\
    \ = 0\n    var factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var\
    \ factorizationSum68 = 0\n    var factorizationSum69 = 0\n    var factorizationSum70\
    \ = 0\n    var factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3sydesh2.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7ll04xt1.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isP"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var primeFactors: [Int] = []\n    var isPrime: [Bool] = []\n    var isPrimeCount:\
    \ [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin: Int =\
    \ 1\n    var isPrimeCountSum: Int = 0\n    var isPrimeCountSumMax: Int = 0\n \
    \   var isPrimeCountSumMin: Int = 0\n    var isPrimeCountSumSum: Int = 0\n   \
    \ var isPrimeCountSumSumMax: Int = 0\n    var isPrimeCountSumSumMin: Int = 0\n\
    \    var isPrimeCountSumSumSum: Int = 0\n    var isPrimeCountSumSumSumMax: Int\
    \ = 0\n    var isPrimeCountSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6snzmnrj.swift:34:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumMax'\n\
    \    var isPrimeCountSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:31:9:\
    \ note: 'isPrimeCountSumSumSumSumSumMax' previously declared here\n    var isPrimeCountSumSumSumSumSumMax:\
    \ Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumSumMin'\n    var isPrimeCountSumSumSumSumSumMin:\
    \ Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:32:9: note: 'isPrimeCountSumSumSumSumSumMin'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSumMin: Int = 0\n\
    \        ^\n/tmp/tmp6snzmnrj.swift:36:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSum'\n\
    \    var isPrimeCountSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:33:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSum' previously declared here\n    var isPrimeCountSumSumSumSumSumSum:\
    \ Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumSumSumMax'\n    var isPrimeCountSumSumSumSumSumSumMax:\
    \ Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:37:9: note: 'isPrimeCountSumSumSumSumSumSumMax'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n\
    \        ^\n/tmp/tmp6snzmnrj.swift:41:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumMin'\n\
    \    var isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:38:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumMin' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:42:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSum'\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:39:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSum' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmp6snzmnrj.swift:49:9:\
    \ error: type annotation missing in pattern\n    var isPrimeCountSumSumSumSum\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeCountMin = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMaxInt = Int(isPrimeCountMax)\n    var isPrimeCountMinInt\
    \ = Int(isPrimeCountMin)\n    var isPrimeCountMaxIntInt = Int(isPrimeCountMaxInt)\n\
    \    var isPrimeCountMinIntInt = Int(isPrimeCountMinInt)\n    var isPrimeCountMaxIntIntInt\
    \ = Int(isPrimeCountMaxIntInt)\n    var isPrimeCountMinIntIntInt = Int(isPrimeCountMinIntInt)\n\
    \    var isPrimeCountMaxIntIntIntInt = Int(isPrimeCountMaxIntIntInt)\n    var\
    \ isPrimeCountMinIntIntIntInt = Int(isPrimeCountMinIntIntInt)\n    var isPrimeCountMaxIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntInt)\n    var isPrimeCountMinIntIntIntIntInt =\
    \ Int(isPrimeCountMinIntIntIntInt)\n    var isPrimeCountMaxIntIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntIntInt)\n    var isPrimeCountMinIntIntIntIntIntInt\
    \ = Int(isPrimeCountMinIntIntIntIntInt)\n    var isPrimeCountMaxIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntIntIntInt)\n    var isPrimeCountMinIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMinIntIntIntIntIntIntInt)\n    var isPrimeCountMaxIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntIntIntIntIntInt)\n    var isPrimeCountMinIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMinIntIntIntIntIntIntIntInt)\n    var isPrimeCountMaxIntIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntIntIntIntIntIntInt)\n    var isPrimeCountMinIntIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd32giu6.swift:37:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpdd32giu6.swift:36:57: note: to match this opening '('\n    var isPrimeCountMinIntIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMin\n                                                    \
    \    ^\n/tmp/tmpdd32giu6.swift:17:31: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmpdd32giu6.swift:18:31:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdd32giu6.swift:32:52: error: use of local variable 'isPrimeCountMinIntIntIntIntIntIntInt'\
    \ before its declaration\n    var isPrimeCountMinIntIntIntIntIntIntInt = Int(isPrimeCountMinIntIntIntIntIntIntInt)\n\
    \                                                   ^\n/tmp/tmpdd32giu6.swift:32:9:\
    \ note: 'isPrimeCountMinIntIntIntIntIntIntInt' declared here\n    var isPrimeCountMinIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMinIntIntIntIntIntIntInt)\n        ^\n/tmp/tmpdd32giu6.swift:33:55:\
    \ error: use of local variable 'isPrimeCountMaxIntIntIntIntIntIntIntInt' before\
    \ its declaration\n    var isPrimeCountMaxIntIntIntIntIntIntIntInt = Int(isPrimeCountMaxIntIntIntIntIntIntIntInt)\n\
    \                                                      ^\n/tmp/tmpdd32giu6.swift:33:9:\
    \ note: 'isPrimeCountMaxIntIntIntIntIntIntIntInt' declared here\n    var isPrimeCountMaxIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMaxIntIntIntIntIntIntIntInt)\n        ^\n/tmp/tmpdd32giu6.swift:34:55:\
    \ error: use of local variable 'isPrimeCountMinIntIntIntIntIntIntIntInt' before\
    \ its declaration\n    var isPrimeCountMinIntIntIntIntIntIntIntInt = Int(isPrimeCountMinIntIntIntIntIntIntIntInt)\n\
    \                                                      ^\n/tmp/tmpdd32giu6.swift:34:9:\
    \ note: 'isPrimeCountMinIntIntIntIntIntIntIntInt' declared here\n    var isPrimeCountMinIntIntIntIntIntIntIntInt\
    \ = Int(isPrimeCountMinIntIntIntIntIntIntIntInt)\n     "
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = [Int]()\n    var primeFactorsCount = 1\n    var isPrime\
    \ = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp53_awxl_.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptcld02nb.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var n = n\n    var i = 2\n    var j = 1\n    var k = 0\n    var factor =\
    \ 1\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorization = false\n    var isPrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorization = false\n    var isPrimePrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorization =\
    \ false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvx75a7zp.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primeFactors = primeFactors(n)\n    var factorization = factorizationOf(n:\
    \ n)\n    var factorizationCount = 1\n    for prime in primeFactors {\n      \
    \  if factorization[factorizationCount] == prime {\n            factors.append(prime)\n\
    \            factorizationCount += 1\n        }\n    }\n    return factors\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjltw3ymu.swift:13:24: error: use of local variable 'primeFactors'\
    \ before its declaration\n    var primeFactors = primeFactors(n)\n           \
    \            ^\n/tmp/tmpjltw3ymu.swift:13:9: note: 'primeFactors' declared here\n\
    \    var primeFactors = primeFactors(n)\n        ^\n/tmp/tmpjltw3ymu.swift:14:25:\
    \ error: cannot find 'factorizationOf' in scope\n    var factorization = factorizationOf(n:\
    \ n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n  \
    \  var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7ll04xt1.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmp7ll04xt1.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = [Int]()\n        ^\n/tmp/tmp7ll04xt1.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isP"
  stdout: ''
  timestamp: 1660009224
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0p7ssml7.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:17:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:18:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:19:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:20:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:21:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:22:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:23:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp0p7ssml7.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp0p7ssml7.swift:2"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationSum = [Int]()\n  \
    \  var factorizationSumCount = [Int]()\n    var factorizationSumCountMax = Int()\n\
    \    var factorizationSumCountMaxIndex = Int()\n    var factorizationSumCountMin\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMinIndex = Int()\n    var factorizationSumCountMaxValue\
    \ = Int()\n    var factorizationSumCountMinValue = Int()\n    var factorizationSumCountMaxIndex\
    \ = Int()\n    var factorizationSumCountMin\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt6eytkme.swift:22:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmpt6eytkme.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpt6eytkme.swift:23:9: error: invalid redeclaration\
    \ of 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex =\
    \ Int()\n        ^\n/tmp/tmpt6eytkme.swift:19:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = Int()\n  \
    \      ^\n/tmp/tmpt6eytkme.swift:24:9: error: invalid redeclaration of 'factorizationSumCountMaxValue'\n\
    \    var factorizationSumCountMaxValue = Int()\n        ^\n/tmp/tmpt6eytkme.swift:20:9:\
    \ note: 'factorizationSumCountMaxValue' previously declared here\n    var factorizationSumCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmpt6eytkme.swift:25:9: error: invalid redeclaration\
    \ of 'factorizationSumCountMinValue'\n    var factorizationSumCountMinValue =\
    \ Int()\n        ^\n/tmp/tmpt6eytkme.swift:21:9: note: 'factorizationSumCountMinValue'\
    \ previously declared here\n    var factorizationSumCountMinValue = Int()\n  \
    \      ^\n/tmp/tmpt6eytkme.swift:26:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = Int()\n        ^\n/tmp/tmpt6eytkme.swift:17:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpt6eytkme.swift:27:9: error: invalid redeclaration\
    \ of 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex =\
    \ Int()\n        ^\n/tmp/tmpt6eytkme.swift:19:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = Int()\n  \
    \      ^\n/tmp/tmpt6eytkme.swift:28:9: error: invalid redeclaration of 'factorizationSumCountMaxValue'\n\
    \    var factorizationSumCountMaxValue = Int()\n        ^\n/tmp/tmpt6eytkme.swift:20:9:\
    \ note: 'factorizationSumCountMaxValue' previously declared here\n    var factorizationSumC"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeIndex\
    \ = 0\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax11 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax14 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax15 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax16 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax17 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax18 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax19 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax20 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax21 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax22 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax23 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax24 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax25 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax26 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax27 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax28 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax29 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax30 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax31 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeIndexMax32 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeIndexMax33 = Int(sqrt(Double(n)))\n    var isPrimeIndexMax34 = Int(sqrt(Double(n)))\n\
    \    var isPrimeIndexMax35 = Int(sqrt(Double(n)))\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd36odiq1.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpd36odiq1.swift:16:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeIndexMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmpd36odiq1.swift:17:32: error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmpd36odiq1.swift:18:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmpd36odiq1.swift:19:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:20:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:21:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:22:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:23:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:24:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmpd36odiq1.swift:25:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpd36odiq1.swift:26:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpd36odiq1.swift:27:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpd36odiq1.swift:28:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmpd36odiq1.swift:29:33: erro"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var primeFactorization\
    \ = factorizationOfPrimes(n)\n    var primeFactors = primeFactorization\n    var\
    \ primeFactorsCount = primeFactors.count\n    var factorizationCount = factorization.count\n\
    \    var factorizationIndex = factorizationCount - 1\n    var primeFactorsIndex\
    \ = primeFactorsCount - 1\n    var primeFactorsIndex2 = primeFactorsIndex - 1\n\
    \    var factorizationIndex2 = factorizationIndex - 1\n    var factorizationIndex3\
    \ = factorizationIndex - 1\n    var factorizationIndex4 = factorizationIndex -\
    \ 1\n    var factorizationIndex5 = factorizationIndex - 1\n    var factorizationIndex6\
    \ = factorizationIndex - 1\n    var factorizationIndex7 = factorizationIndex -\
    \ 1\n    var factorizationIndex8 = factorizationIndex - 1\n    var factorizationIndex9\
    \ = factorizationIndex - 1\n    var factorizationIndex10 = factorizationIndex\
    \ - 1\n    var factorizationIndex11 = factorizationIndex - 1\n    var factorizationIndex12\
    \ = factorizationIndex - 1\n    var factorizationIndex13 = factorizationIndex\
    \ - 1\n    var factorizationIndex14 = factorizationIndex - 1\n    var factorizationIndex15\
    \ = factorizationIndex - 1\n    var factorizationIndex16 = factorizationIndex\
    \ - 1\n    var factorizationIndex17 = factorizationIndex - 1\n    var factorizationIndex18\
    \ = factorizationIndex - 1\n    var factorizationIndex19 = factorizationIndex\
    \ - 1\n    var factorizationIndex20 = factorizationIndex - 1\n    var factorizationIndex21\
    \ = factorizationIndex - 1\n    var factorizationIndex22 = factorizationIndex\
    \ - 1\n    var factorizationIndex23 = factorizationIndex - 1\n    var factorizationIndex24\
    \ = factorizationIndex - 1\n    var factorizationIndex25 = factorizationIndex\
    \ - 1\n    var factorizationIndex26 = factorizationIndex - 1\n    var factorizationIndex27\
    \ = factorizationIndex - 1\n    var factorizationIndex28 = factorizationIndex\
    \ - 1\n    var factorizationIndex29 = factorizationIndex - 1\n    var factorizationIndex30\
    \ = factorizationIndex - 1\n    var factorizationIndex31 = factorizationIndex\
    \ - 1\n    var factorizationIndex32 = factorizationIndex - 1\n    var factorizationIndex33\
    \ = factorizationIndex - 1\n    var factorizationIndex34 = factorizationIndex\
    \ - 1\n    var factorizationIndex35 = factorizationIndex - 1\n    var factorizationIndex36\
    \ = factorizationIndex - 1\n    var factorizationIndex37 = factorizationIndex\
    \ - 1\n    var factorizationIndex38 = factorizationIndex - 1\n    var factorizationIndex39\
    \ = factorizationIndex - 1\n    var factorizationIndex40 = factorizationIndex\
    \ - 1\n    var factorizationIndex41 = \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaehs3bg4.swift:60:31: error: expected initial value after '='\n\
    \    var factorizationIndex41 = \n                              ^\n/tmp/tmpaehs3bg4.swift:13:25:\
    \ error: cannot find 'factorizationOfNumber' in scope\n    var factorization =\
    \ factorizationOfNumber(n)\n                        ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaehs3bg4.swift:14:30:\
    \ error: cannot find 'factorizationOfPrimes' in scope\n    var primeFactorization\
    \ = factorizationOfPrimes(n)\n                             ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var primes: [Int] = []\n    var max: Int = 1\n    for _ in 0..<n {\n    \
    \    max = max * 2\n    }\n    for _ in 0..<n {\n        if max % 2 == 0 {\n \
    \           factors.append(2)\n        }\n        for _ in 0..<n {\n         \
    \   if max % max == 0 {\n                factors.append(max)\n               \
    \ max /= max\n            }\n        }\n    }\n    for _ in 0..<n {\n        if\
    \ max % 2 == 0 {\n            primes.append(2)\n        }\n        for _ in 0..<n\
    \ {\n            if max % max == 0 {\n                primes.append(max)\n   \
    \             max /= max\n            }\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpx1ikp2x6/tmpx1ikp2x6.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b472ac45c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b472a93cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b472a93c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b472a93b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx1ikp2x6                        0x000056300a339552 <unavailable> + 5458

    5    libc.so.6                          0x00002b472ae31460 __libc_start_main +
    245

    6    tmpx1ikp2x6                        0x000056300a3391a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n \
    \   var currentFactorizationIndex = 0\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrimeFactorization = [1]\n    var currentPrimeFactorizationIndex\
    \ = 0\n    var currentPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5zluwnt_.swift:18:9: error: invalid redeclaration of 'currentPrimeFactorizationIndex'\n\
    \    var currentPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp5zluwnt_.swift:16:9:\
    \ note: 'currentPrimeFactorizationIndex' previously declared here\n    var currentPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp5zluwnt_.swift:19:9: error: invalid redeclaration of\
    \ 'currentPrimeFactorization'\n    var currentPrimeFactorization = [1]\n     \
    \   ^\n/tmp/tmp5zluwnt_.swift:17:9: note: 'currentPrimeFactorization' previously\
    \ declared here\n    var currentPrimeFactorization = [1]\n        ^\n/tmp/tmp5zluwnt_.swift:20:9:\
    \ error: invalid redeclaration of 'currentPrimeFactorizationIndex'\n    var currentPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp5zluwnt_.swift:16:9: note: 'currentPrimeFactorizationIndex'\
    \ previously declared here\n    var currentPrimeFactorizationIndex = 0\n     \
    \   ^\n/tmp/tmp5zluwnt_.swift:21:9: error: invalid redeclaration of 'currentPrimeFactorization'\n\
    \    var currentPrimeFactorization = [1]\n        ^\n/tmp/tmp5zluwnt_.swift:17:9:\
    \ note: 'currentPrimeFactorization' previously declared here\n    var currentPrimeFactorization\
    \ = [1]\n        ^\n/tmp/tmp5zluwnt_.swift:22:9: error: invalid redeclaration\
    \ of 'currentPrimeFactorizationIndex'\n    var currentPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp5zluwnt_.swift:16:9: note: 'currentPrimeFactorizationIndex'\
    \ previously declared here\n    var currentPrimeFactorizationIndex = 0\n     \
    \   ^\n/tmp/tmp5zluwnt_.swift:23:9: error: invalid redeclaration of 'currentPrimeFactorization'\n\
    \    var currentPrimeFactorization = [1]\n        ^\n/tmp/tmp5zluwnt_.swift:17:9:\
    \ note: 'currentPrimeFactorization' previously declared here\n    var currentPrimeFactorization\
    \ = [1]\n        ^\n/tmp/tmp5zluwnt_.swift:24:9: error: invalid redeclaration\
    \ of 'currentPrimeFactorizationIndex'\n    var currentPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp5zluwnt_.swift:16:9: note: 'currentPrimeFactorizationIndex'\
    \ previously declared here\n    var currentPrimeFactorizationIndex = 0\n     \
    \   ^\n/tmp/tmp5zluwnt_.swift:25:9: error: invalid r"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var i = 2\n    var j = 0\n    var k = n - 1\n \
    \   var m = 1\n    var n = 2\n    var p = 1\n    var q = 1\n    var r = 1\n  \
    \  var s = 2\n    var t = 0\n    var u = 1\n    var v = 1\n    var w = 1\n   \
    \ var x = 1\n    var y = 1\n    var z = 1\n    var a = 2\n    var b = 1\n    var\
    \ c = 1\n    var d = 1\n    var e = 1\n    var f = 1\n    var g = 1\n    var h\
    \ = 1\n    var i = 1\n    var j = 1\n    var k = 1\n    var l = 1\n    var m =\
    \ 1\n    var n = 2\n    var p = 1\n    var q = 1\n    var r = 1\n    var s = 2\n\
    \    var t = 0\n    var u = 1\n    var v = 1\n    var w = 1\n    var x = 1\n \
    \   var y = 1\n    var z = 1\n    var a = 2\n    var b = 1\n    var c = 1\n  \
    \  var d = 1\n    var e = 1\n    var f = 1\n    var g = 1\n    var h = 1\n   \
    \ var i = 1\n    var j = 1\n    var k = 1\n    var l = 1\n    var m = 1\n    var\
    \ n = 2\n    var p = 1\n    var q = 1\n    var r = 1\n    var s = 2\n    var t\
    \ = 0\n    var u = 1\n    var v = 1\n    var w = 1\n    var x = 1\n    var y =\
    \ 1\n    var z = 1\n    var a = 2\n    var b = 1\n    var c = 1\n    var d = 1\n\
    \    var e = 1\n    var f = 1\n    var g = 1\n    var h = 1\n    var i = 1\n \
    \   var j = 1\n    var k = 1\n    var l = 1\n    var m = 1\n    var n = 2\n  \
    \  var p = 1\n    var q = 1\n    var r = 1\n    var s = 2\n    var t = 0\n   \
    \ var u = 1\n    var v = 1\n    var w = 1\n    var x = 1\n    var y = 1\n    var\
    \ z = 1\n    var a = 2\n    var b = 1\n    var c = 1\n    var d = 1\n    var e\
    \ = 1\n    var f = 1\n    var g = 1\n    var h = 1\n    var i = 1\n    var j =\
    \ 1\n    var k = 1\n    var l = 1\n    var m = 1\n    var n = 2\n    var p = 1\n\
    \    var q = 1\n    var r = 1\n    var s = 2\n    var t = 0\n    var u = 1\n \
    \   var v = 1\n    var w = 1\n    var x = 1\n    var y = 1\n    var z = 1\n  \
    \  var a = 2\n    var b = 1\n    var c = 1\n    var d = 1\n    var e = 1\n   \
    \ var f = 1\n    var g = 1\n    var h = 1\n    var \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsob66zf0.swift:138:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpsob66zf0.swift:38:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 1\n        ^\n/tmp/tmpsob66zf0.swift:14:9: note: 'i' previously declared\
    \ here\n    var i = 2\n        ^\n/tmp/tmpsob66zf0.swift:39:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 1\n        ^\n/tmp/tmpsob66zf0.swift:15:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpsob66zf0.swift:40:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 1\n        ^\n/tmp/tmpsob66zf0.swift:16:9:\
    \ note: 'k' previously declared here\n    var k = n - 1\n        ^\n/tmp/tmpsob66zf0.swift:42:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 1\n        ^\n/tmp/tmpsob66zf0.swift:17:9:\
    \ note: 'm' previously declared here\n    var m = 1\n        ^\n/tmp/tmpsob66zf0.swift:43:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 2\n        ^\n/tmp/tmpsob66zf0.swift:18:9:\
    \ note: 'n' previously declared here\n    var n = 2\n        ^\n/tmp/tmpsob66zf0.swift:44:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 1\n        ^\n/tmp/tmpsob66zf0.swift:19:9:\
    \ note: 'p' previously declared here\n    var p = 1\n        ^\n/tmp/tmpsob66zf0.swift:45:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 1\n        ^\n/tmp/tmpsob66zf0.swift:20:9:\
    \ note: 'q' previously declared here\n    var q = 1\n        ^\n/tmp/tmpsob66zf0.swift:46:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 1\n        ^\n/tmp/tmpsob66zf0.swift:21:9:\
    \ note: 'r' previously declared here\n    var r = 1\n        ^\n/tmp/tmpsob66zf0.swift:47:9:\
    \ error: invalid redeclaration of 's'\n    var s = 2\n        ^\n/tmp/tmpsob66zf0.swift:22:9:\
    \ note: 's' previously declared here\n    var s = 2\n        ^\n/tmp/tmpsob66zf0.swift:48:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpsob66zf0.swift:23:9:\
    \ note: 't' previously declared here\n    var t = 0\n        ^\n/tmp/tmpsob66zf0.swift:49:9:\
    \ error: invalid redeclaration of 'u'\n    var u = 1\n        ^\n/tmp/tmpsob66zf0.swift:24:9:\
    \ note: 'u' previously declared here\n    var u = 1\n        ^\n/tmp/tmpsob66zf0.swift:50"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberSum = 0\n    var factorizationNumberSumIndex\
    \ = 0\n    var factorizationNumberSumCount = 0\n    var factorizationNumberSumSum\
    \ = 0\n    var factorizationNumberSumSumIndex = 0\n    var factorizationNumberSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSum = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumSumSum = 0\n    var factorizationNumberSumSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSumCount = 0\n    var factorizationNumberSumSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSum = 0\n    var factorizationNumberSumSumSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSumSumCount = 0\n    var factorizationNumberSumSumSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumSum = 0\n    var factorizationNumberSumSumSumSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumCount = 0\n    var factorizationNumberSumSumSumSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumSum = 0\n    var factorizationNumberSumSumSumSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSumSumCount = 0\n    var factorizationNumberSumSumSumSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumSum = 0\n    var factorizationNumberSumSumSumSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSumSumCount = 0\n    var factorizationNumberSumSumSumSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumSumSumSumIndex = 0\n    var factorizationNumberSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4k6pk8s7.swift:31:9: error: invalid redeclaration of 'factorizationNumberSumSumSumSumIndex'\n\
    \    var factorizationNumberSumSumSumSumIndex = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:28:9:\
    \ note: 'factorizationNumberSumSumSumSumIndex' previously declared here\n    var\
    \ factorizationNumberSumSumSumSumIndex = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:32:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumCount'\n   \
    \ var factorizationNumberSumSumSumSumCount = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:29:9:\
    \ note: 'factorizationNumberSumSumSumSumCount' previously declared here\n    var\
    \ factorizationNumberSumSumSumSumCount = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:33:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumSum'\n    var\
    \ factorizationNumberSumSumSumSumSum = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:30:9:\
    \ note: 'factorizationNumberSumSumSumSumSum' previously declared here\n    var\
    \ factorizationNumberSumSumSumSumSum = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:37:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumSumIndex'\n\
    \    var factorizationNumberSumSumSumSumSumIndex = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:34:9:\
    \ note: 'factorizationNumberSumSumSumSumSumIndex' previously declared here\n \
    \   var factorizationNumberSumSumSumSumSumIndex = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:38:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumSumSumCount = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:35:9:\
    \ note: 'factorizationNumberSumSumSumSumSumCount' previously declared here\n \
    \   var factorizationNumberSumSumSumSumSumCount = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:39:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumSumSum'\n  \
    \  var factorizationNumberSumSumSumSumSumSum = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:36:9:\
    \ note: 'factorizationNumberSumSumSumSumSumSum' previously declared here\n   \
    \ var factorizationNumberSumSumSumSumSumSum = 0\n        ^\n/tmp/tmp4k6pk8s7.swift:40:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSumSumIndex'\n\
    \    var factorizationNu"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var factor = 1\n    var factorization = factorizationOfNumber(n)\n\
    \    while i < factorization.count {\n        if factorization[i] == 1 {\n   \
    \         factors.append(factor)\n            factor = 1\n        } else {\n \
    \           factor *= factorization[i]\n        }\n        i += 1\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprxr4ep0n.swift:15:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd8pb8zxf.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var factorizationCount = 0\n\
    \    var primeFactorizationCount = 0\n    var factorizationPrimeCount = 0\n  \
    \  var primeFactorizationPrimeCount = 0\n    var factorizationPrimeCountMax =\
    \ 0\n    var primeFactorizationPrimeCountMax = 0\n    var factorizationPrimeCountMax2\
    \ = 0\n    var primeFactorizationPrimeCountMax2 = 0\n    var factorizationPrimeCountMax3\
    \ = 0\n    var primeFactorizationPrimeCountMax3 = 0\n    var factorizationPrimeCountMax4\
    \ = 0\n    var primeFactorizationPrimeCountMax4 = 0\n    var factorizationPrimeCountMax5\
    \ = 0\n    var primeFactorizationPrimeCountMax5 = 0\n    var factorizationPrimeCountMax6\
    \ = 0\n    var primeFactorizationPrimeCountMax6 = 0\n    var factorizationPrimeCountMax7\
    \ = 0\n    var primeFactorizationPrimeCountMax7 = 0\n    var factorizationPrimeCountMax8\
    \ = 0\n    var primeFactorizationPrimeCountMax8 = 0\n    var factorizationPrimeCountMax9\
    \ = 0\n    var primeFactorizationPrimeCountMax9 = 0\n    var factorizationPrimeCountMax10\
    \ = 0\n    var primeFactorizationPrimeCountMax10 = 0\n    var factorizationPrimeCountMax11\
    \ = 0\n    var primeFactorizationPrimeCountMax11 = 0\n    var factorizationPrimeCountMax12\
    \ = 0\n    var primeFactorizationPrimeCountMax12 = 0\n    var factorizationPrimeCountMax13\
    \ = 0\n    var primeFactorizationPrimeCountMax13 = 0\n    var factorizationPrimeCountMax14\
    \ = 0\n    var primeFactorizationPrimeCountMax14 = 0\n    var factorizationPrimeCountMax15\
    \ = 0\n    var primeFactorizationPrimeCountMax15 = 0\n    var factorizationPrimeCountMax16\
    \ = 0\n    var primeFactorizationPrimeCountMax16 = 0\n    var factorizationPrimeCountMax17\
    \ = 0\n    var primeFactorizationPrimeCountMax17 = 0\n    var factorizationPrimeCountMax18\
    \ = 0\n    var primeFactorizationPrimeCountMax18 = 0\n    var factorizationPrimeCountMax19\
    \ = 0\n    var primeFactorizationPrimeCountMax19 = 0\n    var factorizationPrimeCountMax20\
    \ = 0\n    var primeFactorizationPrimeCountMax20 = 0\n    var factorizationPrimeCountMax21\
    \ = 0\n    var primeFactorizationPrimeCountMax21 = 0\n    var factorizationPrimeCountMax22\
    \ = 0\n    var primeFactorizationPrimeCountMax22 = 0\n    var factorizationPrimeCountMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpomfjqi_n.swift:62:9: error: type annotation missing in pattern\n\
    \    var factorizationPrimeCountMax\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationIndex\
    \ = 0\n    var factorizationIndex = 0\n    var primeFactorizationIndex2 = 0\n\
    \    var factorizationIndex2 = 0\n    var primeFactorizationIndex3 = 0\n    var\
    \ factorizationIndex3 = 0\n    var primeFactorizationIndex4 = 0\n    var factorizationIndex4\
    \ = 0\n    var primeFactorizationIndex5 = 0\n    var factorizationIndex5 = 0\n\
    \    var primeFactorizationIndex6 = 0\n    var factorizationIndex6 = 0\n    var\
    \ primeFactorizationIndex7 = 0\n    var factorizationIndex7 = 0\n    var primeFactorizationIndex8\
    \ = 0\n    var factorizationIndex8 = 0\n    var primeFactorizationIndex9 = 0\n\
    \    var factorizationIndex9 = 0\n    var primeFactorizationIndex10 = 0\n    var\
    \ factorizationIndex10 = 0\n    var primeFactorizationIndex11 = 0\n    var factorizationIndex11\
    \ = 0\n    var primeFactorizationIndex12 = 0\n    var factorizationIndex12 = 0\n\
    \    var primeFactorizationIndex13 = 0\n    var factorizationIndex13 = 0\n   \
    \ var primeFactorizationIndex14 = 0\n    var factorizationIndex14 = 0\n    var\
    \ primeFactorizationIndex15 = 0\n    var factorizationIndex15 = 0\n    var primeFactorizationIndex16\
    \ = 0\n    var factorizationIndex16 = 0\n    var primeFactorizationIndex17 = 0\n\
    \    var factorizationIndex17 = 0\n    var primeFactorizationIndex18 = 0\n   \
    \ var factorizationIndex18 = 0\n    var primeFactorizationIndex19 = 0\n    var\
    \ factorizationIndex19 = 0\n    var primeFactorizationIndex20 = 0\n    var factorizationIndex20\
    \ = 0\n    var primeFactorizationIndex21 = 0\n    var factorizationIndex21 = 0\n\
    \    var primeFactorizationIndex22 = 0\n    var factorizationIndex22 = 0\n   \
    \ var primeFactorizationIndex23 = 0\n    var factorizationIndex23 = 0\n    var\
    \ primeFactorizationIndex24 = 0\n    var factorizationIndex24 = 0\n    var primeFactorizationIndex25\
    \ = 0\n    var factorizationIndex25 = 0\n    var primeFactorizationIndex26 = 0\n\
    \    var factorizationIndex26 = 0\n    var primeFactorizationIndex27 = 0\n   \
    \ var factorizationIndex27 = 0\n    var primeFactorizationIndex28 = 0\n    var\
    \ factorizationIndex28 = 0\n    var primeFactorizationIndex29 = 0\n    var factorizationIndex29\
    \ = 0\n    var primeFactorizationIndex30 = 0\n    var factorizationIndex30 = 0\n\
    \    var primeFactorizationIndex31 = 0\n    var factorizationIndex31 = 0\n   \
    \ var primeFactorizationIndex32 = 0\n    var factorizationIndex32 = 0\n    var\
    \ primeFactorizationIndex33 = 0\n    var factorizationIndex33 = 0\n    var primeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8q0bx47g.swift:80:9: error: type annotation missing in pattern\n\
    \    var primeFactorization\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountIndex = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9m3hsbeg.swift:20:9: error: invalid redeclaration of 'primeFactorizationIndex'\n\
    \    var primeFactorizationIndex = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:15:9:\
    \ note: 'primeFactorizationIndex' previously declared here\n    var primeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:21:9: error: invalid redeclaration of\
    \ 'primeFactorizationCountIndex'\n    var primeFactorizationCountIndex = 0\n \
    \       ^\n/tmp/tmp9m3hsbeg.swift:16:9: note: 'primeFactorizationCountIndex' previously\
    \ declared here\n    var primeFactorizationCountIndex = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationIndex'\n    var primeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:15:9: note: 'primeFactorizationIndex'\
    \ previously declared here\n    var primeFactorizationIndex = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountIndex'\n    var primeFactorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:16:9: note: 'primeFactorizationCountIndex'\
    \ previously declared here\n    var primeFactorizationCountIndex = 0\n       \
    \ ^\n/tmp/tmp9m3hsbeg.swift:24:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:17:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmp9m3hsbeg.swift:25:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:18:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmp9m3hsbeg.swift:26:9: error: invalid redeclaration of 'factorizationCountIndex'\n\
    \    var factorizationCountIndex = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:19:9:\
    \ note: 'factorizationCountIndex' previously declared here\n    var factorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp9m3hsbeg.swift:27:9: error: invalid redeclaration of\
    \ 'primeFactorizationIndex'\n    var primeFactorizationIndex = 0\n        ^\n\
    /tmp/tmp9m3hsbeg.swift:15:9: note: 'primeFactorizationIndex'"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n  \
    \  var isPrimeFactorsCountMax = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc1_cgov0.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpc1_cgov0.swift:26:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorsCount = 0\n\
    \    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzaarln9s.swift:37:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n  \
    \      ^\n/tmp/tmpzaarln9s.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpzaarln9s.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n       \
    \ ^\n/tmp/tmpzaarln9s.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpzaarln9s.swift:41:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumCountMax = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCountMaxIndexIndex = 0\n    var factorizationSumCountMaxIndexIndex\
    \ = 0\n    var factorizationSumCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm7zb1r3j.swift:19:9: error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n\
    \    var factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'factorizationSumCountMaxIndexIndex' previously declared here\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxIndexIndex'\n    var\
    \ factorizationSumCountMaxIndexIndex = 0\n        ^\n/tmp/tmpm7zb1r3j.swift:18:9:\
    \ note: 'fac"
  stdout: ''
  timestamp: 1660009225
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
