language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69\
    \ = 0\n    var factorizationIndex70 = 0\n    var factorizationIndex71 = 0\n  \
    \  var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjzaoiszy.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var isPrime: Bool = false\n  \
    \  var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeIndex2 = 0\n\
    \    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n    var isPrimeCount3 =\
    \ 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 = 0\n    var isPrimeCount6\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9 = 0\n    var isPrimeCount9\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10 = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12 = 0\n    var isPrimeCount12\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13 = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15 = 0\n    var isPrimeCount15\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16 = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18 = 0\n    var isPrimeCount18\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19 = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21 = 0\n    var isPrimeCount21\
    \ = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24 = 0\n    var isPrimeCount24\
    \ = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25 = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27 = 0\n    var isPrimeCount27\
    \ = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28 = 0\n    var isPrimeIndex29\
    \ = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30 = 0\n    var isPrimeCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp94d7b712.swift:76:9: error: type annotation missing in pattern\n\
    \    var isPrimeCount\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = [Int]()\n    var primeFactorization = [Int]()\n    var\
    \ primeFactors = [Int]()\n    var primeFactorsCount = 0\n    var primeFactorsSum\
    \ = 0\n    var primeFactorsSum2 = 0\n    var primeFactorsSum3 = 0\n    var primeFactorsSum4\
    \ = 0\n    var primeFactorsSum5 = 0\n    var primeFactorsSum6 = 0\n    var primeFactorsSum7\
    \ = 0\n    var primeFactorsSum8 = 0\n    var primeFactorsSum9 = 0\n    var primeFactorsSum10\
    \ = 0\n    var primeFactorsSum11 = 0\n    var primeFactorsSum12 = 0\n    var primeFactorsSum13\
    \ = 0\n    var primeFactorsSum14 = 0\n    var primeFactorsSum15 = 0\n    var primeFactorsSum16\
    \ = 0\n    var primeFactorsSum17 = 0\n    var primeFactorsSum18 = 0\n    var primeFactorsSum19\
    \ = 0\n    var primeFactorsSum20 = 0\n    var primeFactorsSum21 = 0\n    var primeFactorsSum22\
    \ = 0\n    var primeFactorsSum23 = 0\n    var primeFactorsSum24 = 0\n    var primeFactorsSum25\
    \ = 0\n    var primeFactorsSum26 = 0\n    var primeFactorsSum27 = 0\n    var primeFactorsSum28\
    \ = 0\n    var primeFactorsSum29 = 0\n    var primeFactorsSum30 = 0\n    var primeFactorsSum31\
    \ = 0\n    var primeFactorsSum32 = 0\n    var primeFactorsSum33 = 0\n    var primeFactorsSum34\
    \ = 0\n    var primeFactorsSum35 = 0\n    var primeFactorsSum36 = 0\n    var primeFactorsSum37\
    \ = 0\n    var primeFactorsSum38 = 0\n    var primeFactorsSum39 = 0\n    var primeFactorsSum40\
    \ = 0\n    var primeFactorsSum41 = 0\n    var primeFactorsSum42 = 0\n    var primeFactorsSum43\
    \ = 0\n    var primeFactorsSum44 = 0\n    var primeFactorsSum45 = 0\n    var primeFactorsSum46\
    \ = 0\n    var primeFactorsSum47 = 0\n    var primeFactorsSum48 = 0\n    var primeFactorsSum49\
    \ = 0\n    var primeFactorsSum50 = 0\n    var primeFactorsSum51 = 0\n    var primeFactorsSum52\
    \ = 0\n    var primeFactorsSum53 = 0\n    var primeFactorsSum54 = 0\n    var primeFactorsSum55\
    \ = 0\n    var primeFactorsSum56 = 0\n    var primeFactorsSum57 = 0\n    var primeFactorsSum58\
    \ = 0\n    var primeFactorsSum59 = 0\n    var prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt8yh72e3.swift:76:9: error: type annotation missing in pattern\n\
    \    var prime\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factor != 1 {\n         \
    \   factors.append(factor)\n            factorizationCount *= factor\n       \
    \ }\n    }\n    if factorizationCount == 1 {\n        return factors\n    }\n\
    \    var primeFactors = [Int]()\n    var primeFactorization = factorizationOfNumber(n)\n\
    \    var primeFactorizationCount = 1\n    for primeFactor in primeFactorization\
    \ {\n        if primeFactor != 1 {\n            primeFactors.append(primeFactor)\n\
    \            primeFactorizationCount *= primeFactor\n        }\n    }\n    var\
    \ primeFactorizationCount = 1\n    for primeFactorIndex in 0..<primeFactors.count\
    \ {\n        let primeFactor = primeFactors[primeFactorIndex]\n        if primeFactorizationCount\
    \ != 1 {\n            factors.append(primeFactor)\n            factorizationCount\
    \ *= primeFactor\n        }\n        if factorizationCount != 1 {\n          \
    \  factors.append(factorizationCount)\n            factorizationCount = 1\n  \
    \      }\n        primeFactorizationCount *= primeFactor\n    }\n    if factorizationCount\
    \ != 1 {\n        factors.append(factorizationCount)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpko9ff6zh.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpko9ff6zh.swift:25:30: error: cannot find\
    \ 'factorizationOfNumber' in scope\n    var primeFactorization = factorizationOfNumber(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpko9ff6zh.swift:33:9:\
    \ error: invalid redeclaration of 'primeFactorizationCount'\n    var primeFactorizationCount\
    \ = 1\n        ^\n/tmp/tmpko9ff6zh.swift:26:9: note: 'primeFactorizationCount'\
    \ previously declared here\n    var primeFactorizationCount = 1\n        ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ojb6t8.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationNumber = 0\n    var factorizationNumberCount = 0\n    var factorizationNumberIndex\
    \ = 0\n    var factorizationNumberRemainder = 0\n    var factorizationNumberRemainderCount\
    \ = 0\n    var factorizationNumberRemainderIndex = 0\n    var factorizationNumberRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainder = 0\n    var factorizationNumberRemainderRemainderRemainderCount\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainder = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \  var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \  var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n    var factorizationNumberRemainderRemainderRemainderRemainderCount =\
    \ 0\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex = 0\n\
    \    var factorizationNumberRemainderRemainderRemainderRemain\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7rbf5hnj.swift:31:9: error: invalid redeclaration of 'factorizationNumberRemainderRemainderRemainderRemainderCount'\n\
    \    var factorizationNumberRemainderRemainderRemainderRemainderCount = 0\n  \
    \      ^\n/tmp/tmp7rbf5hnj.swift:28:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderCount'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:32:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:29:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:33:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderRemainder'\n    var\
    \ factorizationNumberRemainderRemainderRemainderRemainderRemainder = 0\n     \
    \   ^\n/tmp/tmp7rbf5hnj.swift:30:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderRemainder'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderRemainder\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:34:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderCount'\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:28:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderCount'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemainderRemainderCount\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:35:9: error: invalid redeclaration of\
    \ 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\n    var factorizationNumberRemainderRemainderRemainderRemainderIndex\
    \ = 0\n        ^\n/tmp/tmp7rbf5hnj.swift:29:9: note: 'factorizationNumberRemainderRemainderRemainderRemainderIndex'\
    \ previously declared here\n    var factorizationNumberRemainderRemainderRemai"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    var j = 1\n    var k = n\n    while i * j <= k {\n       \
    \ if n % i == 0 {\n            factors.append(i)\n            n /= i\n       \
    \ }\n        if n % j == 0 {\n            factors.append(j)\n            n /=\
    \ j\n        }\n        i += 1\n        j += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsoveb22z.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpsoveb22z.swift:23:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndexCount = 0\n    var factorizationIndexCountMax = Int(IntMax)\n\
    \    var factorizationIndexCountMin = Int(IntMin)\n    var factorizationIndexCountMaxInt\
    \ = Int(IntMax)\n    var factorizationIndexCountMinInt = Int(IntMin)\n    var\
    \ factorizationIndexCountMaxFloat = Float(FloatMax)\n    var factorizationIndexCountMinFloat\
    \ = Float(FloatMin)\n    var factorizationIndexCountMaxDouble = Double(DoubleMax)\n\
    \    var factorizationIndexCountMinDouble = Double(DoubleMin)\n    var factorizationIndexCountMaxBool\
    \ = Bool(BoolMax)\n    var factorizationIndexCountMinBool = Bool(BoolMin)\n  \
    \  var factorizationIndexCountMaxString = String(StringMax)\n    var factorizationIndexCountMinString\
    \ = String(StringMin)\n    var factorizationIndexCountMaxArray = Array<Int>(ArrayMax)\n\
    \    var factorizationIndexCountMinArray = Array<Int>(ArrayMin)\n    var factorizationIndexCountMaxDictionary\
    \ = Dictionary<Int, Int>(DictionaryMax)\n    var factorizationIndexCountMinDictionary\
    \ = Dictionary<Int, Int>(DictionaryMin)\n    var factorizationIndexCountMaxSet\
    \ = Set<Int>(SetMax)\n    var factorizationIndexCountMinSet = Set<Int>(SetMin)\n\
    \    var factorizationIndexCountMaxArraySlice = ArraySlice<Int>(ArraySliceMax)\n\
    \    var factorizationIndexCountMinArraySlice = ArraySlice<Int>(ArraySliceMin)\n\
    \    var factorizationIndexCountMaxDictionarySlice = DictionarySlice<Int, Int>(DictionarySliceMax)\n\
    \    var factorizationIndexCountMinDictionarySlice = DictionarySlice<Int, Int>(DictionarySliceMin)\n\
    \    var factorizationIndexCountMaxSetSlice = SetSlice<Int>(SetSliceMax)\n   \
    \ var factorizationIndexCountMinSetSlice = SetSlice<Int>(SetSliceMin)\n    var\
    \ factorizationIndexCountMaxArraySliceFromIndex = ArraySliceFromIndex<Int>(ArraySliceFromIndexMax)\n\
    \    var factorizationIndexCountMinArraySliceFromIndex = ArraySliceFromIndex<Int>(ArraySliceFromIndexMin)\n\
    \    var factorizationIndexCountMaxDictionarySliceFromIndex = DictionarySliceFromIndex<Int,\
    \ Int>(DictionarySliceFromIndexMax)\n    var factorizationIndexCountMinDictionarySliceFromIndex\
    \ = DictionarySliceFromIndex<Int, Int>(DictionarySliceFromIndexMin)\n    var factorizationIndexCountMaxSetSliceFromIndex\
    \ = SetSlice\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe7t5rvvx.swift:16:42: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationIndexCountMax = Int(IntMax)\n                            \
    \             ^~~~~~\n/tmp/tmpe7t5rvvx.swift:17:42: error: cannot find 'IntMin'\
    \ in scope\n    var factorizationIndexCountMin = Int(IntMin)\n               \
    \                          ^~~~~~\n/tmp/tmpe7t5rvvx.swift:18:45: error: cannot\
    \ find 'IntMax' in scope\n    var factorizationIndexCountMaxInt = Int(IntMax)\n\
    \                                            ^~~~~~\n/tmp/tmpe7t5rvvx.swift:19:45:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationIndexCountMinInt\
    \ = Int(IntMin)\n                                            ^~~~~~\n/tmp/tmpe7t5rvvx.swift:20:49:\
    \ error: cannot find 'FloatMax' in scope\n    var factorizationIndexCountMaxFloat\
    \ = Float(FloatMax)\n                                                ^~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:21:49: error: cannot find 'FloatMin' in scope\n    var\
    \ factorizationIndexCountMinFloat = Float(FloatMin)\n                        \
    \                        ^~~~~~~~\n/tmp/tmpe7t5rvvx.swift:22:51: error: cannot\
    \ find 'DoubleMax' in scope\n    var factorizationIndexCountMaxDouble = Double(DoubleMax)\n\
    \                                                  ^~~~~~~~~\n/tmp/tmpe7t5rvvx.swift:23:51:\
    \ error: cannot find 'DoubleMin' in scope\n    var factorizationIndexCountMinDouble\
    \ = Double(DoubleMin)\n                                                  ^~~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:24:47: error: cannot find 'BoolMax' in scope\n    var factorizationIndexCountMaxBool\
    \ = Bool(BoolMax)\n                                              ^~~~~~~\n/tmp/tmpe7t5rvvx.swift:25:47:\
    \ error: cannot find 'BoolMin' in scope\n    var factorizationIndexCountMinBool\
    \ = Bool(BoolMin)\n                                              ^~~~~~~\n/tmp/tmpe7t5rvvx.swift:26:51:\
    \ error: cannot find 'StringMax' in scope\n    var factorizationIndexCountMaxString\
    \ = String(StringMax)\n                                                  ^~~~~~~~~\n\
    /tmp/tmpe7t5rvvx.swift:27:51: error: cannot find 'StringMin' in scope\n    var\
    \ factori"
  stdout: ''
  timestamp: 1659825016
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factor = 2\n    var factorCount = 0\n    var isPrime = true\n\
    \    var isDivisible = false\n    while factor <= n {\n        if n % factor ==\
    \ 0 {\n            factorCount += 1\n            if factor > 2 {\n           \
    \     factorization[factorCount] = factor\n            }\n            if isPrime\
    \ {\n                isPrime = false\n            }\n            if isDivisible\
    \ {\n                factorization[factorCount] = factor\n            }\n    \
    \        isDivisible = true\n        } else {\n            isPrime = true\n  \
    \          if factor > 2 {\n                factorization[factorCount] = factor\n\
    \            }\n            if isDivisible {\n                factorization[factorCount]\
    \ = factor\n            }\n            isDivisible = false\n        }\n      \
    \  factor += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpwvdtg7rn/tmpwvdtg7rn.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a31f4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a31c41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a31c41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a31c407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwvdtg7rn                        0x0000558039bc6462 <unavailable> + 5218

    5    libc.so.6                          0x00002b1a32136460 __libc_start_main +
    245

    6    tmpwvdtg7rn                        0x0000558039bc60b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var primeFactors = [Int]()\n    var factorization\
    \ = [Int]()\n    var factorizationCount = [Int]()\n    var factorizationIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = 0\n    var isPrimeFactorizationIndex = false\n    var isPrimeFactorizationCountIndex\
    \ = false\n    var isPrimeFactorizationCountIndex = 0\n    var isPrimeFactorizationIndex\
    \ = false\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6kxu6sdb.swift:24:9: error: invalid redeclaration of 'isPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationIndex = false\n        ^\n/tmp/tmp6kxu6sdb.swift:21:9:\
    \ note: 'isPrimeFactorizationIndex' previously declared here\n    var isPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:25:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationCountIndex'\n    var isPrimeFactorizationCountIndex = false\n\
    \        ^\n/tmp/tmp6kxu6sdb.swift:23:9: note: 'isPrimeFactorizationCountIndex'\
    \ previously declared here\n    var isPrimeFactorizationCountIndex = 0\n     \
    \   ^\n/tmp/tmp6kxu6sdb.swift:26:9: error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n\
    \    var isPrimeFactorizationCountIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9:\
    \ note: 'isPrimeFactorizationCountIndex' previously declared here\n    var isPrimeFactorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:27:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = false\n   \
    \     ^\n/tmp/tmp6kxu6sdb.swift:21:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n    var isPrimeFactorizationCountIndex\
    \ = false\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9: note: 'isPrimeFactorizationCountIndex'\
    \ previously declared here\n    var isPrimeFactorizationCountIndex = 0\n     \
    \   ^\n/tmp/tmp6kxu6sdb.swift:29:9: error: invalid redeclaration of 'isPrimeFactorizationCountIndex'\n\
    \    var isPrimeFactorizationCountIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:23:9:\
    \ note: 'isPrimeFactorizationCountIndex' previously declared here\n    var isPrimeFactorizationCountIndex\
    \ = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:30:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = false\n   \
    \     ^\n/tmp/tmp6kxu6sdb.swift:21:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp6kxu6sdb.swift:31:9:\
    \ error: i"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            i\
    \ += 1\n            factors.append(i)\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpxhufa8s3/tmpxhufa8s3.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcf88fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcf85f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcf85f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcf85f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxhufa8s3                        0x0000557f5d76a4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002adcf8ae6460 __libc_start_main +
    245

    6    tmpxhufa8s3                        0x0000557f5d76a119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    for factor in factorization\
    \ {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz86wtodw.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorizationOfNumber(n)\n    var factorizationCount\
    \ = 1\n    for factor in factorization {\n        if factorizationCount > factors.count\
    \ {\n            factors.append(factor)\n        } else {\n            factors[factors.count-1]\
    \ *= factor\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1rnbkk01.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var\
    \ factorizationCountIndex = 0\n    var isPrime = true\n    var isPrimeIndex =\
    \ 0\n    var isPrimeCount = 0\n    var isPrimeCountIndex = 0\n    var isPrimeCountMax\
    \ = 0\n    var isPrimeCountMaxIndex = 0\n    var isPrimeCountMin = 0\n    var\
    \ isPrimeCountMinIndex = 0\n    var isPrimeCountMaxMin = 0\n    var isPrimeCountMaxMinIndex\
    \ = 0\n    var isPrimeCountMinMax = 0\n    var isPrimeCountMinMaxIndex = 0\n \
    \   var isPrimeCountMaxMinMax = 0\n    var isPrimeCountMaxMinMaxIndex = 0\n  \
    \  var isPrimeCountMinMaxMinMax = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var isPrimeCountMinMaxMinMaxIndex = 0\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4mnksiyj.swift:60:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp4mnksiyj.swift:32:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:34:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:36:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n    var isPrimeCountMinMaxMinMaxIndex\
    \ = 0\n        ^\n/tmp/tmp4mnksiyj.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimeCountMinMaxMinMaxIndex'\n    var isPrimeCountMinMaxMinMaxIndex = 0\n\
    \        ^\n/tmp/tmp4mnksiyj.swift:31:9: note: 'isPrimeCountMinMaxMinMaxIndex'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxIndex = 0\n      \
    \  ^\n/tmp/tmp4mnksiyj.swift:38:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxIndex'\n\
    \    var isPrimeCountMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmp4mnksiyj.swift:31:9:\
    \ note: 'isPrimeCountMinMaxMinMaxIndex' previously declared here\n   "
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorizationCount = 0\n    var currentFactorizationCount = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n\
    \    var currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdd6lyt4x.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmpdd6lyt4x.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmpdd6lyt4x.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = factorization(n)\n    for prime in primes {\n        factors.append(prime)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkemebmpx.swift:13:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n\
    \    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n    var isPrime4:\
    \ Bool = false\n    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n\
    \    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n    var isPrime9:\
    \ Bool = false\n    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n\
    \    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n    var isPrime14:\
    \ Bool = false\n    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n\
    \    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n    var isPrime19:\
    \ Bool = false\n    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n\
    \    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n    var isPrime24:\
    \ Bool = false\n    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n\
    \    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n    var isPrime29:\
    \ Bool = false\n    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n\
    \    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n    var isPrime34:\
    \ Bool = false\n    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n\
    \    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n    var isPrime39:\
    \ Bool = false\n    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n\
    \    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n    var isPrime44:\
    \ Bool = false\n    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n\
    \    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n    var isPrime49:\
    \ Bool = false\n    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n\
    \    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n    var isPrime54:\
    \ Bool = false\n    var isPrime55: Bool = false\n    var isPrime56: Bool\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp14cigtuu.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:13:9: warning:\
    \ variable 'primeFactorization' was never used; consider replacing with '_' or\
    \ removing it\n    var primeFactorization: [Int] = []\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp14cigtuu.swift:14:9: warning: variable 'isPrime' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime: Bool = false\n\
    \        ^~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:15:9: warning: variable 'isPrime2'\
    \ was never used; consider replacing with '_' or removing it\n    var isPrime2:\
    \ Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:16:9: warning:\
    \ variable 'isPrime3' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:17:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:18:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:19:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:20:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:21:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:22:9:\
    \ warning: variable 'isPrime9' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime9: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmp14cigtuu.swift:23:9:\
    \ warning: variable 'isPrime10' was never used; consider r"
  stdout: ''
  timestamp: 1659825016
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n    var isPrimeCountMaxInt\
    \ = Int(ceil(sqrt(Double(isPrimeCountMax))))\n    var isPrimeCountMaxDouble =\
    \ Double(isPrimeCountMaxInt)\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6901wv48.swift:38:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp6901wv48.swift:16:31: error: cannot find 'ceil' in scope\n    var\
    \ isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                             \
    \ ^~~~\n/tmp/tmp6901wv48.swift:16:36: error: cannot find 'sqrt' in scope\n   \
    \ var isPrimeCountMax = Int(ceil(sqrt(Double(n))))\n                         \
    \          ^~~~\n/tmp/tmp6901wv48.swift:17:34: error: cannot find 'ceil' in scope\n\
    \    var isPrimeCountMaxInt = Int(ceil(sqrt(Double(isPrimeCountMax))))\n     \
    \                            ^~~~\n/tmp/tmp6901wv48.swift:17:39: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMaxInt = Int(ceil(sqrt(Double(isPrimeCountMax))))\n\
    \                                      ^~~~\n/tmp/tmp6901wv48.swift:19:40: error:\
    \ cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:19:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDouble))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:20:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:20:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:21:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                       ^~~~\n/tmp/tmp6901wv48.swift:21:45: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCountMaxDoubleInt))))\n\
    \                                            ^~~~\n/tmp/tmp6901wv48.swift:22:40:\
    \ error: cannot find 'ceil' in scope\n    var isPrimeCountMaxDoubleInt = Int(ceil(sqrt(Double(isPrimeCo"
  stdout: ''
  timestamp: 1659825017
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n\
    \    var isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n    var isPrimeCountMin: Int = 1\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex: Int\
    \ = 0\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMinIndex\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_3m9552n.swift:20:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:23:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:19:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:17:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:26:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:17:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp_3m9552n.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp_3m9552n.swift:19:9: note: 'isPrimeCountMinIndex' previously declar"
  stdout: ''
  timestamp: 1659825016
