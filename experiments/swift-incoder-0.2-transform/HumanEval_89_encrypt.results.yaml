language: swift
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.indexOf(c)\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[0]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1g9r1up9.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += alphabet[alphabet.index(c) + 2]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplslzdxth.swift:18:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c) + 2]\n                  ^~~~~~~~\n\
    /tmp/tmplslzdxth.swift:18:28: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.index(c) + 2]\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.index(c)\n        let newIndex = index + 2\n        if newIndex <\
    \ alphabet.count {\n            result += alphabet[newIndex]\n        } else {\n\
    \            result += alphabet[alphabet.count - 1]\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ufzf96d.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(c)\n                    ^~~~~~~~\n/tmp/tmp4ufzf96d.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp4ufzf96d.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp4ufzf96d.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmp4ufzf96d.swift:23:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.indexOf(c)\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[alphabet.count - 1]\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7llh57ce.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp7llh57ce.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp7llh57ce.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.indexOf(c)\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[0]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1g9r1up9.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp1g9r1up9.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = [Character]()\n    for c in s.characters\
    \ {\n        alphabet.append(c)\n    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyehfn4cn.swift:17:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyehfn4cn.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:24:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:25:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:26:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:27:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:28:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824934
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for letter in s {\n        result\
    \ += alphabet.index(letter) + 2\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqgqrp13b.swift:18:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.index(letter) + 2\n                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824934
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.index(of: c)!\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[0]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpnnhp0wji.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: c)!\n                    ^~~~~~~~\n/tmp/tmpnnhp0wji.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpnnhp0wji.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpnnhp0wji.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659825071
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = [Character]()\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"a\".unicodeScalars.first!))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"b\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"c\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"d\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"e\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"f\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"g\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"h\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"i\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"j\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"k\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"l\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"m\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"n\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"o\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"p\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"q\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"r\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"s\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"t\".unicodeScalars.first!))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"u\".unicodeScalars.first!))\n\
    \    }\n    for \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6vezvwfi.swift:80:8: error: expected pattern\n    for \n      \
    \ ^\n/tmp/tmp6vezvwfi.swift:80:8: error: expected Sequence expression for for-each\
    \ loop\n    for \n       ^\n/tmp/tmp6vezvwfi.swift:80:8: error: expected '{' to\
    \ start the body of for-each loop\n    for \n       ^\n"
  stdout: ''
  timestamp: 1659825071
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ = result + alphabet[alphabet.index(c) + 2]\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3a4kieaw.swift:18:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(c) + 2]\n                 \
    \         ^~~~~~~~\n/tmp/tmp3a4kieaw.swift:18:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.index(c) + 2]\n      \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.indexOf(c)\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[alphabet.count - 1]\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7llh57ce.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp7llh57ce.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp7llh57ce.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += alphabet[alphabet.index(alphabet.indexOf(c) + 2)]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmph3dlgoam.swift:18:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(alphabet.indexOf(c) + 2)]\n       \
    \           ^~~~~~~~\n/tmp/tmph3dlgoam.swift:18:28: error: cannot find 'alphabet'\
    \ in scope\n        result += alphabet[alphabet.index(alphabet.indexOf(c) + 2)]\n\
    \                           ^~~~~~~~\n/tmp/tmph3dlgoam.swift:18:43: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[alphabet.index(alphabet.indexOf(c)\
    \ + 2)]\n                                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659825071
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return s.rotate().rotate().rotate()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt0b2o30_.swift:16:14: error: value of type 'String' has no member\
    \ 'rotate'\n    return s.rotate().rotate().rotate()\n           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = make([]rune, 26)\n    for i := 0; i\
    \ < len(alphabet); i++ {\n        alphabet[i] = 'a'\n    }\n    alphabet[0] =\
    \ 'z'\n    alphabet[26] = 'a'\n    alphabet[27] = 'z'\n    alphabet[28] = 'a'\n\
    \    alphabet[29] = 'z'\n    alphabet[30] = 'a'\n    alphabet[31] = 'z'\n    alphabet[32]\
    \ = 'a'\n    alphabet[33] = 'z'\n    alphabet[34] = 'a'\n    alphabet[35] = 'z'\n\
    \    alphabet[36] = 'a'\n    alphabet[37] = 'z'\n    alphabet[38] = 'a'\n    alphabet[39]\
    \ = 'z'\n    alphabet[40] = 'a'\n    alphabet[41] = 'z'\n    alphabet[42] = 'a'\n\
    \    alphabet[43] = 'z'\n    alphabet[44] = 'a'\n    alphabet[45] = 'z'\n    alphabet[46]\
    \ = 'a'\n    alphabet[47] = 'z'\n    alphabet[48] = 'a'\n    alphabet[49] = 'z'\n\
    \    alphabet[50] = 'a'\n    alphabet[51] = 'z'\n    alphabet[52] = 'a'\n    alphabet[53]\
    \ = 'z'\n    alphabet[54] = 'a'\n    alphabet[55] = 'z'\n    alphabet[56] = 'a'\n\
    \    alphabet[57] = 'z'\n    alphabet[58] = 'a'\n    alphabet[59] = 'z'\n    alphabet[60]\
    \ = 'a'\n    alphabet[61] = 'z'\n    alphabet[62] = 'a'\n    alphabet[63] = 'z'\n\
    \    alphabet[64] = 'a'\n    alphabet[65] = 'z'\n    alphabet[66] = 'a'\n    alphabet[67]\
    \ = 'z'\n    alphabet[68] = 'a'\n    alphabet[69] = 'z'\n    alphabet[70] = 'a'\n\
    \    alphabet[71] = 'z'\n    alphabet[72] = 'a'\n    alphabet[73] = 'z'\n    alphabet[74]\
    \ = 'a'\n    alphabet[75] = 'z'\n    alphabet[76] = 'a'\n    alphabet[77] = 'z'\n\
    \    alphabet[78] = 'a'\n    alphabet[79] = 'z'\n    alphabet[80] = 'a'\n    alphabet[81]\
    \ = 'z'\n    alphabet[82] = 'a'\n    alphabet[83] = 'z'\n    alphabet[84] = 'a'\n\
    \    alphabet[85] = 'z'\n    alphabet[86] = 'a'\n    alphabet[87] = 'z'\n    alphabet[88]\
    \ = 'a'\n    alphabet[\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8k7jq7q8.swift:16:27: error: expected ',' separator\n    var alphabet\
    \ = make([]rune, 26)\n                          ^\n                          ,\n\
    /tmp/tmp8k7jq7q8.swift:17:12: error: expected type\n    for i := 0; i < len(alphabet);\
    \ i++ {\n           ^\n            <#type#>\n/tmp/tmp8k7jq7q8.swift:17:12: error:\
    \ expected 'in' after for-each pattern\n    for i := 0; i < len(alphabet); i++\
    \ {\n           ^\n/tmp/tmp8k7jq7q8.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(alphabet); i++ {\n           ^\n\
    /tmp/tmp8k7jq7q8.swift:18:23: error: single-quoted string literal found, use '\"\
    '\n        alphabet[i] = 'a'\n                      ^~~\n                    \
    \  \"a\"\n/tmp/tmp8k7jq7q8.swift:20:19: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[0] = 'z'\n                  ^~~\n                  \"\
    z\"\n/tmp/tmp8k7jq7q8.swift:21:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[26] = 'a'\n                   ^~~\n                 \
    \  \"a\"\n/tmp/tmp8k7jq7q8.swift:22:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[27] = 'z'\n                   ^~~\n                 \
    \  \"z\"\n/tmp/tmp8k7jq7q8.swift:23:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[28] = 'a'\n                   ^~~\n                 \
    \  \"a\"\n/tmp/tmp8k7jq7q8.swift:24:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[29] = 'z'\n                   ^~~\n                 \
    \  \"z\"\n/tmp/tmp8k7jq7q8.swift:25:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[30] = 'a'\n                   ^~~\n                 \
    \  \"a\"\n/tmp/tmp8k7jq7q8.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[31] = 'z'\n                   ^~~\n                 \
    \  \"z\"\n/tmp/tmp8k7jq7q8.swift:27:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[32] = 'a'\n                   ^~~\n                 \
    \  \"a\"\n/tmp/tmp8k7jq7q8.swift:28:20: error: single-quoted string literal found,\
    \ use '\"'\n    alphabet[33] = 'z'\n                   ^~~\n                 \
    \  \"z"
  stdout: ''
  timestamp: 1659825071
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.index(of: c)!\n        let newIndex = index + 2\n        let newChar\
    \ = alphabet[newIndex]\n        result += newChar\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4v8fyogr.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: c)!\n                    ^~~~~~~~\n/tmp/tmp4v8fyogr.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n\
    \                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.index(c)\n        let newIndex = index + 2\n        if newIndex <\
    \ alphabet.count {\n            result += alphabet[newIndex]\n        } else {\n\
    \            result += alphabet[0]\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzcd3c_5g.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(c)\n                    ^~~~~~~~\n/tmp/tmpzcd3c_5g.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpzcd3c_5g.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpzcd3c_5g.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824934
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var alphabet2 = \"nopqrstuvwxyzabcdefghijklm\"\n    var alphabet3 = \"nopqrstuvwxyzabcdefghijklmnopq\"\
    \n    var alphabet4 = \"nopqrstuvwxyzabcdefghijklmnopqrst\"\n    var alphabet5\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuv\"\n    var alphabet6 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvw\"\
    \n    var alphabet7 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwx\"\n    var alphabet8\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxy\"\n    var alphabet9 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"\
    \n    var alphabet10 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyza\"\n    var alphabet11\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\"\n    var alphabet12 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabc\"\
    \n    var alphabet13 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd\"\n    var\
    \ alphabet14 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcde\"\n    var alphabet15\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdef\"\n    var alphabet16 = \"\
    nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefg\"\n    var alphabet17 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefgh\"\
    \n    var alphabet18 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\"\n\
    \    var alphabet19 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghij\"\n\
    \    var alphabet20 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk\"\n\
    \    var alphabet21 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijkl\"\n\
    \    var alphabet22 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm\"\
    \n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp43na8q0p.swift:38:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp43na8q0p.swift:16:9: warning: initialization of variable 'alphabet'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    ~~~~^~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:17:9:\
    \ warning: initialization of variable 'alphabet2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var alphabet2 = \"nopqrstuvwxyzabcdefghijklm\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:18:9: warning: initialization\
    \ of variable 'alphabet3' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet3 = \"nopqrstuvwxyzabcdefghijklmnopq\"\n\
    \    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:19:9: warning: initialization\
    \ of variable 'alphabet4' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet4 = \"nopqrstuvwxyzabcdefghijklmnopqrst\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:20:9: warning: initialization\
    \ of variable 'alphabet5' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet5 = \"nopqrstuvwxyzabcdefghijklmnopqrstuv\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:21:9: warning: initialization\
    \ of variable 'alphabet6' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet6 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvw\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:22:9: warning: initialization\
    \ of variable 'alphabet7' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet7 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwx\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:23:9: warning: initialization\
    \ of variable 'alphabet8' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabet8 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxy\"\
    \n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp43na8q0p.swift:24:9: warning: initialization\
    \ of variable 'alphabet9' was never used; consider replacing with assignment to\
    \ '_' or remov"
  stdout: ''
  timestamp: 1659825071
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return s.rotate().rotate()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkf315_mt.swift:16:14: error: value of type 'String' has no member\
    \ 'rotate'\n    return s.rotate().rotate()\n           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.indexOf(c)\n        let newIndex = index + 2\n        if newIndex\
    \ < alphabet.count {\n            result += alphabet[newIndex]\n        } else\
    \ {\n            result += alphabet[alphabet.count - 1]\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7llh57ce.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp7llh57ce.swift:20:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp7llh57ce.swift:21:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmp7llh57ce.swift:23:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824933
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = [Character]()\n    for c in s.characters\
    \ {\n        alphabet.append(c)\n    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyehfn4cn.swift:17:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyehfn4cn.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:24:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:25:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:26:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:27:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpyehfn4cn.swift:28:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824934
