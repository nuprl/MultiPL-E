language: swift
name: HumanEval_20_find_closest_elements
results:
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpput40doe.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp5t71f54y/tmp5t71f54y.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab32790fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab327606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab327606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3276057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5t71f54y                        0x0000561995b476be <unavailable> + 5822

    5    libc.so.6                          0x00002ab327afb460 __libc_start_main +
    245

    6    tmp5t71f54y                        0x0000561995b47279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1at8o5g5.swift:13:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmp1at8o5g5.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp1at8o5g5.swift:16:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmp1at8o5g5.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwo34xrdo/tmpwo34xrdo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e71d40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e71a37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e71a37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e71a367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwo34xrdo                        0x000055bca07616be <unavailable> + 5822

    5    libc.so.6                          0x00002b1e71f2c460 __libc_start_main +
    245

    6    tmpwo34xrdo                        0x000055bca0761279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq3hpf1vi.swift:10:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp6eqcz3c2/tmp6eqcz3c2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0ff2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0fefacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0fefac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0fefab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6eqcz3c2                        0x0000560ec277b69e <unavailable> + 5790

    5    libc.so.6                          0x00002ad0ff4a1460 __libc_start_main +
    245

    6    tmp6eqcz3c2                        0x0000560ec277b259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpps041u74.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpps041u74.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    guard numbers.count < 3 else {\n        return\
    \ (0.0,0.0)\n    }\n    guard numbers.count > 3 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 6 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 6 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 9 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 9 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 12 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 12 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 15 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 15 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 18 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 18 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 21 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 21 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 24 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 24 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 27 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 27 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 30 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 30 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 33 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 33 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 36 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 36 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 39 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 39 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 42 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count > 42 else {\n        return (numbers[0],numbers[0])\n\
    \    }\n    guard numbers.count < 45 else {\n        return (numbers[0],numbers[0])\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpz6g77c8o.swift:118:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpz6g77c8o.swift:8:67: note: to match this opening '{'\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n                                          \
    \                        ^\n/tmp/tmpz6g77c8o.swift:102:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min: Double = Double(numbers.min())\n\
    \    let max: Double = Double(numbers.max())\n    let minIndex: Int = Int(numbers.index(of:\
    \ min))!\n    let maxIndex: Int = Int(numbers.index(of: max))!\n    return (numbers[minIndex],\
    \ numbers[maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwbrrfohj.swift:9:38: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = Double(numbers.min())\n\
    \                                     ^\n/tmp/tmpwbrrfohj.swift:9:38: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = Double(numbers.min())\n                                  \
    \   ^\n                                           ?? <#default value#>\n/tmp/tmpwbrrfohj.swift:9:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = Double(numbers.min())\n                       \
    \              ^\n                                          !\n/tmp/tmpwbrrfohj.swift:10:38:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    let max: Double = Double(numbers.max())\n                    \
    \                 ^\n/tmp/tmpwbrrfohj.swift:10:38: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    let max: Double\
    \ = Double(numbers.max())\n                                     ^\n          \
    \                                 ?? <#default value#>\n/tmp/tmpwbrrfohj.swift:10:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = Double(numbers.max())\n                       \
    \              ^\n                                          !\n/tmp/tmpwbrrfohj.swift:11:37:\
    \ error: cannot convert value of type 'Array<Double>.Index?' (aka 'Optional<Int>')\
    \ to expected argument type 'String'\n    let minIndex: Int = Int(numbers.index(of:\
    \ min))!\n                                    ^\n/tmp/tmpwbrrfohj.swift:12:37:\
    \ error: cannot convert value of type 'Array<Double>.Index?' (aka 'Optional<Int>')\
    \ to expected argument type 'String'\n    let maxIndex: Int = Int(numbers.index(of:\
    \ max))!\n                                    ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    \n    for number in numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n    }\n    \n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpxmweze_t/tmpxmweze_t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b791b69cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b791b393b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b791b393988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b791b3927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxmweze_t                        0x0000555f9cf6169e <unavailable> + 5790

    5    libc.so.6                          0x00002b791b888460 __libc_start_main +
    245

    6    tmpxmweze_t                        0x0000555f9cf61259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallestDifference = Double.infinity\n\
    \    var smallestDifferenceIndex = -1\n    var largestDifference = Double.infinity\n\
    \    var largestDifferenceIndex = -1\n\n    for i in 0..<numbers.count {\n   \
    \     let difference = abs(numbers[i] - numbers[smallestDifferenceIndex])\n  \
    \      if difference < smallestDifference {\n            smallestDifference =\
    \ difference\n            smallestDifferenceIndex = i\n        }\n        if difference\
    \ > largestDifference {\n            largestDifference = difference\n        \
    \    largestDifferenceIndex = i\n        }\n    }\n\n    return (numbers[smallestDifferenceIndex],\
    \ numbers[largestDifferenceIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba35492dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba354624561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba354624286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba35462413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba354623bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba354423f44 <unavailable> + 188228

    6    tmpdkq0bcaa                        0x000056520b6bcfd6 <unavailable> + 8150

    7    tmpdkq0bcaa                        0x000056520b6bc70d <unavailable> + 5901

    8    libc.so.6                          0x00002ba354b19460 __libc_start_main +
    245

    9    tmpdkq0bcaa                        0x000056520b6bc3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        let current = numbers[i]\n\
    \        if current < smallest {\n            smallest = current\n        } else\
    \ if current > largest {\n            largest = current\n        }\n    }\n  \
    \  return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbq744_lc.swift:14:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = current\n            ^~~~~~~~\n\
    /tmp/tmpbq744_lc.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpbq744_lc.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = current\n            ^~~~~~~\n/tmp/tmpbq744_lc.swift:10:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq3hpf1vi.swift:10:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let min2 =\
    \ min(numbers)\n    let minDiff = abs(min1 - min2)\n    let minIndex = numbers.index(of:\
    \ min1)\n    let minIndex2 = numbers.index(of: min2)\n    if minDiff < abs(minIndex\
    \ - minIndex2) {\n        return (min1, min2)\n    } else {\n        return (min2,\
    \ min1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp52yhzfrw.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp52yhzfrw.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let min2 = min(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp52yhzfrw.swift:11:19: error: global function 'abs'\
    \ requires that 'Duration' conform to 'SignedNumeric'\n    let minDiff = abs(min1\
    \ - min2)\n                  ^\nSwift.abs:1:24: note: where 'T' = 'Duration'\n\
    @inlinable public func abs<T>(_ x: T) -> T where T : Comparable, T : SignedNumeric\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers)\n    let max2 = max(numbers)\n   \
    \ if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2 {\n\
    \        return (max1, max2)\n    }\n    return (min1, max2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprb7z9aox.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmprb7z9aox.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmprb7z9aox.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmprb7z9aox.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpsvsn7jaz/tmpsvsn7jaz.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95c8b0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95c8801b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95c8801988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95c88007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvsn7jaz                        0x00005597a1e8c69e <unavailable> + 5790

    5    libc.so.6                          0x00002b95c8cf6460 __libc_start_main +
    245

    6    tmpsvsn7jaz                        0x00005597a1e8c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzra13_kv.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpzra13_kv.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpzra13_kv.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpzra13_kv.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpzra13_kv.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkdq2c5nl.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpput40doe.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closest1 = sortedNumbers[0]\n    let closest2 = sortedNumbers[1]\n  \
    \  if closest1 < closest2 {\n        return (closest1, closest2)\n    } else {\n\
    \        return (closest2, closest1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp30c1xgjg/tmp30c1xgjg.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c1948fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c19186b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c19186988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c191857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30c1xgjg                        0x000055be65d3957e <unavailable> + 5502

    5    libc.so.6                          0x00002b0c1967b460 __libc_start_main +
    245

    6    tmp30c1xgjg                        0x000055be65d39139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n  \
    \          smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3dxdmxfj.swift:16:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp3dxdmxfj.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmp3dxdmxfj.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmp3dxdmxfj.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    if smallest == largest {\n        return (smallest, smallest)\n\
    \    }\n    if smallest < largest {\n        return (smallest, largest)\n    }\n\
    \    return (largest, smallest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3qt6xtxy.swift:12:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (smallest, smallest)\n               ^\n/tmp/tmp3qt6xtxy.swift:14:17: error:\
    \ binary operator '<' cannot be applied to two 'Double?' operands\n    if smallest\
    \ < largest {\n       ~~~~~~~~ ^ ~~~~~~~\n/tmp/tmp3qt6xtxy.swift:15:16: error:\
    \ cannot convert return expression of type '(Double?, Double?)' to return type\
    \ '(Double, Double)'\n        return (smallest, largest)\n               ^\n/tmp/tmp3qt6xtxy.swift:17:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (largest, smallest)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 1 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count >= 2 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 1 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 1 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count >= 2 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 1 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 1 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count >= 2 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 1 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 1 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count >= 2 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 1 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: '/tmp/tmp6wf_yv1c.swift:42:1: error: missing return in global function expected
    to return ''(Double, Double)''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    if max1 < min1 {\n        return (max1, min1)\n    }\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if max2 < min2\
    \ {\n        return (max2, min2)\n    }\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpgy4bfulq.swift:11:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if max1 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpgy4bfulq.swift:12:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (max1, min1)\n               ^\n/tmp/tmpgy4bfulq.swift:16:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if max2 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpgy4bfulq.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max2, min2)\n               ^\n/tmp/tmpgy4bfulq.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers, max: max1)\n    let max2 = max(numbers,\
    \ min: min1)\n    return (min1, min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnyqe6qsw.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpnyqe6qsw.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpnyqe6qsw.swift:11:19: error: extraneous argument\
    \ label 'max:' in call\n    let min2 = min(numbers, max: max1)\n             \
    \     ^         ~~~~~\n                            \n/tmp/tmpnyqe6qsw.swift:12:19:\
    \ error: extraneous argument label 'min:' in call\n    let max2 = max(numbers,\
    \ min: min1)\n                  ^         ~~~~~\n                            \n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        } else if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp593sqyq6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp593sqyq6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp593sqyq6.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp593sqyq6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkdq2c5nl.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        let currentNumber = numbers[i]\n        if currentNumber < smallest\
    \ {\n            smallest = currentNumber\n            smallestIndex = i\n   \
    \     }\n        if currentNumber > largest {\n            largest = currentNumber\n\
    \            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf1a0bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf19db5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaf19db5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaf19db513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaf19db4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aaf19bb4f44 <unavailable> + 188228

    6    tmp1yvguq5z                        0x0000559acf1fdf4c <unavailable> + 8012

    7    tmp1yvguq5z                        0x0000559acf1fd5cd <unavailable> + 5581

    8    libc.so.6                          0x00002aaf1a2aa460 __libc_start_main +
    245

    9    tmp1yvguq5z                        0x0000559acf1fd279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp6eqcz3c2/tmp6eqcz3c2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0ff2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0fefacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0fefac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0fefab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6eqcz3c2                        0x0000560ec277b69e <unavailable> + 5790

    5    libc.so.6                          0x00002ad0ff4a1460 __libc_start_main +
    245

    6    tmp6eqcz3c2                        0x0000560ec277b259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestIndex = sortedNumbers.firstIndex(of: sortedNumbers.last!)\n  \
    \  let closestValue = sortedNumbers[closestIndex]\n    return (closestValue, closestIndex)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7y4eev3v.swift:11:38: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n    let closestValue = sortedNumbers[closestIndex]\n          \
    \                           ^\n/tmp/tmp7y4eev3v.swift:11:38: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    let closestValue\
    \ = sortedNumbers[closestIndex]\n                                     ^\n    \
    \                                              ?? <#default value#>\n/tmp/tmp7y4eev3v.swift:11:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let closestValue = sortedNumbers[closestIndex]\n                \
    \                     ^\n                                                 !\n\
    /tmp/tmp7y4eev3v.swift:12:12: error: cannot convert return expression of type\
    \ '(Double, Array<Double>.Index?)' (aka '(Double, Optional<Int>)') to return type\
    \ '(Double, Double)'\n    return (closestValue, closestIndex)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpv9_50ca8.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpv9_50ca8.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpv9_50ca8.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpv9_50ca8.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpk25en2vc.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkdq2c5nl.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers.min()\n    let max =\
    \ numbers.max()\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplaefm51s.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (min,\
    \ max)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpmiy96_lx/tmpmiy96_lx.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b797d3e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b797d0deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b797d0de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b797d0dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmiy96_lx                        0x00005608cfe9f69e <unavailable> + 5790

    5    libc.so.6                          0x00002b797d5d3460 __libc_start_main +
    245

    6    tmpmiy96_lx                        0x00005608cfe9f259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.count < 2 {\n        return sortedNumbers[0], sortedNumbers[0]\n\
    \    }\n    let closest1 = sortedNumbers[0]\n    let closest2 = sortedNumbers[1]\n\
    \    if closest1 < closest2 {\n        return closest1, closest2\n    }\n    return\
    \ closest2, closest1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj1i1gppp.swift:11:32: error: consecutive statements on a line must\
    \ be separated by ';'\n        return sortedNumbers[0], sortedNumbers[0]\n   \
    \                            ^\n                               ;\n/tmp/tmpj1i1gppp.swift:11:32:\
    \ error: expected expression\n        return sortedNumbers[0], sortedNumbers[0]\n\
    \                               ^\n/tmp/tmpj1i1gppp.swift:16:24: error: consecutive\
    \ statements on a line must be separated by ';'\n        return closest1, closest2\n\
    \                       ^\n                       ;\n/tmp/tmpj1i1gppp.swift:16:24:\
    \ error: expected expression\n        return closest1, closest2\n            \
    \           ^\n/tmp/tmpj1i1gppp.swift:18:20: error: consecutive statements on\
    \ a line must be separated by ';'\n    return closest2, closest1\n           \
    \        ^\n                   ;\n/tmp/tmpj1i1gppp.swift:18:20: error: expected\
    \ expression\n    return closest2, closest1\n                   ^\n/tmp/tmpj1i1gppp.swift:11:29:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n        return sortedNumbers[0], sortedNumbers[0]\n              \
    \ ~~~~~~~~~~~~~^~~\n/tmp/tmpj1i1gppp.swift:16:16: error: cannot convert return\
    \ expression of type 'Double' to return type '(Double, Double)'\n        return\
    \ closest1, closest2\n               ^~~~~~~~\n/tmp/tmpj1i1gppp.swift:18:12: error:\
    \ cannot convert return expression of type 'Double' to return type '(Double, Double)'\n\
    \    return closest2, closest1\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestToFirst = sortedNumbers.first!\n    let closestToSecond = sortedNumbers.last!\n\
    \    return (closestToFirst, closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp96hitggo/tmp96hitggo.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac06b6aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac06b3a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac06b3a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac06b3a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp96hitggo                        0x000056207edde6fe <unavailable> + 5886

    5    libc.so.6                          0x00002ac06b896460 __libc_start_main +
    245

    6    tmp96hitggo                        0x000056207edde2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpv9_50ca8.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpv9_50ca8.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpv9_50ca8.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpv9_50ca8.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpou8vtcwl.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpou8vtcwl.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpou8vtcwl.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpou8vtcwl.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.infinity\n\
    \    var largest: Double = -Double.infinity\n    for number in numbers {\n   \
    \     if number < smallest {\n            smallest = number\n        }\n     \
    \   if number > largest {\n            largest = number\n        }\n    }\n  \
    \  return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpzm7acyk0/tmpzm7acyk0.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b693db2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b693d821b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b693d821988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b693d8207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzm7acyk0                        0x000056081385064e <unavailable> + 5710

    5    libc.so.6                          0x00002b693dd16460 __libc_start_main +
    245

    6    tmpzm7acyk0                        0x0000560813850209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    return (sortedNumbers[0], sortedNumbers[1])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpthwkd8nt/tmpthwkd8nt.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34b4d11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34b4a08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34b4a08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34b4a077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpthwkd8nt                        0x000055c49576457e <unavailable> + 5502

    5    libc.so.6                          0x00002b34b4efd460 __libc_start_main +
    245

    6    tmpthwkd8nt                        0x000055c495764139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] > largest {\n        \
    \    largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_noxbie_.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropLast())\n    let max2 = max(numbers.dropLast())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpx20kc46x.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmpx20kc46x.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmpx20kc46x.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx20kc46x.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpx20kc46x.swift:11:38: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropLast())\n             \
    \                        ^\n                                     , <#[Double]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpx20kc46x.swift:12:38:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropLast())\n\
    \                                     ^\n                                    \
    \ , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkdq2c5nl.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        } else if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp53ghtcl5.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for n in numbers {\n\
    \        if n < min1 {\n            min1 = n\n        } else if n > max1 {\n \
    \           max1 = n\n        }\n        if n < min2 {\n            min2 = n\n\
    \        } else if n > max2 {\n            max2 = n\n        }\n    }\n    return\
    \ (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp0qwz5mvs.swift:15:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmp0qwz5mvs.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp0qwz5mvs.swift:17:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmp0qwz5mvs.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp0qwz5mvs.swift:20:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = n\n            ^~~~\n/tmp/tmp0qwz5mvs.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp0qwz5mvs.swift:22:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = n\n            ^~~~\n/tmp/tmp0qwz5mvs.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    if min2 < min1 {\n        return (min2, max1)\n   \
    \ }\n    if max1 > max2 {\n        return (max1, max2)\n    }\n    return (max1,\
    \ min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpgq4tbip_.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpgq4tbip_.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpgq4tbip_.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpgq4tbip_.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpgq4tbip_.swift:22:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min2 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpgq4tbip_.swift:23:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max1)\n               ^\n/tmp/tmpgq4tbip_.swift:25:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpgq4tbip_.swift:26:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpgq4tbip_.swift:28:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (max1, min2)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestIndex = sortedNumbers.firstIndex({ $0 < sortedNumbers.last() })\n\
    \    return (sortedNumbers[closestIndex], sortedNumbers[closestIndex + 1])\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpp4g549ue.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 < sortedNumbers.last()\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmpp4g549ue.swift:10:70: error: cannot\
    \ call value of non-function type 'Double?'\n    let closestIndex = sortedNumbers.firstIndex({\
    \ $0 < sortedNumbers.last() })\n                                             \
    \                        ^   ~~\n                                            \
    \                             \n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    guard numbers.count <= Double.greatestFiniteMagnitude\
    \ else {\n        return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n   \
    \ let largest = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpuhaprkd6.swift:12:25: error: binary operator '<=' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    guard numbers.count <= Double.greatestFiniteMagnitude\
    \ else {\n          ~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuhaprkd6.swift:12:25:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard numbers.count <= Double.greatestFiniteMagnitude else {\n\
    \                        ^\n/tmp/tmpuhaprkd6.swift:19:13: error: cannot assign\
    \ to value: 'largest' is a 'let' constant\n            largest = numbers[i]\n\
    \            ^~~~~~~\n/tmp/tmpuhaprkd6.swift:16:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpuhaprkd6.swift:22:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpuhaprkd6.swift:15:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    let mid = (min + max) / 2\n    return (mid, max)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpti2gmfdh.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpti2gmfdh.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpti2gmfdh.swift:11:20: error: cannot convert value\
    \ of type 'String' to expected argument type 'Int'\n    let mid = (min + max)\
    \ / 2\n                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n  \
    \          smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppkl5exhk.swift:16:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmppkl5exhk.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmppkl5exhk.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmppkl5exhk.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpb71l0jzy.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpb71l0jzy.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpb71l0jzy.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpb71l0jzy.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[2]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[3]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[4]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[5]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[6]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[7]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[8]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[9])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[10]) }\n\
    \    guard numbers.count > 12 else { return (numbers[0], numbers[11]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[12]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[13]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[14]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[15]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[16]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[17]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[18])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[19]) }\n\
    \    guard numbers.count > 21 else { return (numbers[0], numbers[20]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[21]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[22]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[23]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[24]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[25]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[26]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[27])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], number\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjp40pn03.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpjp40pn03.swift:37:44: note: to match this opening '('\n    guard numbers.count\
    \ > 29 else { return (numbers[0], number\n                                   \
    \        ^\n/tmp/tmpjp40pn03.swift:57:80: error: expected '}' at end of brace\
    \ statement\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == (2.2, 3.1))\n                                                           \
    \                    ^\n/tmp/tmpjp40pn03.swift:8:67: note: to match this opening\
    \ '{'\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n \
    \                                                                 ^\n/tmp/tmpjp40pn03.swift:37:57:\
    \ error: cannot find 'number' in scope\n    guard numbers.count > 29 else { return\
    \ (numbers[0], number\n                                                      \
    \  ^~~~~~\n/tmp/tmpjp40pn03.swift:41:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.max\n   \
    \ var largest: Double = Double.min\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_7gen0ge.swift:9:35: error: type 'Double' has no member 'max'\n\
    \    var smallest: Double = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmp_7gen0ge.swift:10:34: error: type 'Double' has no member 'min'\n    var\
    \ largest: Double = Double.min\n                          ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var closest1 = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n  \
    \  for i in 1..<sortedNumbers.count {\n        let currentClosest1 = sortedNumbers[i]\n\
    \        let currentClosest2 = sortedNumbers[i - 1]\n        if currentClosest1\
    \ < closest1 {\n            closest1 = currentClosest1\n        }\n        if\
    \ currentClosest2 < closest2 {\n            closest2 = currentClosest2\n     \
    \   }\n    }\n    return (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpiblhopyi/tmpiblhopyi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98fe03dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98fdd34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b98fdd34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98fdd337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiblhopyi                        0x000055654447e75e <unavailable> + 5982

    5    libc.so.6                          0x00002b98fe229460 __libc_start_main +
    245

    6    tmpiblhopyi                        0x000055654447e319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min2, min1)\n    }\n    if max1 > max2\
    \ {\n        return (max2, max1)\n    }\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphowc84mg.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmphowc84mg.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min2, min1)\n               ^\n/tmp/tmphowc84mg.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmphowc84mg.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max2, max1)\n               ^\n/tmp/tmphowc84mg.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = numbers[0]\n   \
    \ var largest: Double = numbers[0]\n    for i in 1..<numbers.count {\n       \
    \ if numbers[i] < smallest {\n            smallest = numbers[i]\n        }\n \
    \       if numbers[i] > largest {\n            largest = numbers[i]\n        }\n\
    \    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmputln49in/tmputln49in.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74cd951c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74cd648b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74cd648988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74cd6477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmputln49in                        0x0000562adeaf26be <unavailable> + 5822

    5    libc.so.6                          0x00002b74cdb3d460 __libc_start_main +
    245

    6    tmputln49in                        0x0000562adeaf2279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        } else if number > largest {\n         \
    \   largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp37sid3k0/tmp37sid3k0.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af357120c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af356e17b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af356e17988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af356e167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp37sid3k0                        0x000055ed68bfe69e <unavailable> + 5790

    5    libc.so.6                          0x00002af35730c460 __libc_start_main +
    245

    6    tmp37sid3k0                        0x000055ed68bfe259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    guard numbers.count > 1 else {\n        return\
    \ (0.0,numbers[0])\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] > largest {\n        \
    \    largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfcvgu5cq.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] < min1 {\n            min1 = numbers[i]\n        }\n\
    \        if numbers[i] > max1 {\n            max1 = numbers[i]\n        }\n  \
    \      if numbers[i] < min2 {\n            min2 = numbers[i]\n        }\n    \
    \    if numbers[i] > max2 {\n            max2 = numbers[i]\n        }\n    }\n\
    \    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2j37rt4u.swift:15:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = numbers[i]\n            ^~~~\n/tmp/tmp2j37rt4u.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp2j37rt4u.swift:18:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = numbers[i]\n            ^~~~\n\
    /tmp/tmp2j37rt4u.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let max1 = numbers[0]\n    ^~~\n    var\n/tmp/tmp2j37rt4u.swift:21:13: error:\
    \ cannot assign to value: 'min2' is a 'let' constant\n            min2 = numbers[i]\n\
    \            ^~~~\n/tmp/tmp2j37rt4u.swift:11:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let min2 = numbers[0]\n    ^~~\n    var\n/tmp/tmp2j37rt4u.swift:24:13:\
    \ error: cannot assign to value: 'max2' is a 'let' constant\n            max2\
    \ = numbers[i]\n            ^~~~\n/tmp/tmp2j37rt4u.swift:12:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let max2 = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        } else if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7o5emmfn.swift:13:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp7o5emmfn.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmp7o5emmfn.swift:15:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmp7o5emmfn.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp81dgmbbu/tmp81dgmbbu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac75013cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac74fe33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac74fe33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac74fe327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp81dgmbbu                        0x0000556dd5d786be <unavailable> + 5822

    5    libc.so.6                          0x00002ac750328460 __libc_start_main +
    245

    6    tmp81dgmbbu                        0x0000556dd5d78279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        } else if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp593sqyq6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp593sqyq6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp593sqyq6.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp593sqyq6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpdtugyn5i/tmpdtugyn5i.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05dc8fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05dc5f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05dc5f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05dc5f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdtugyn5i                        0x000055fe0364764e <unavailable> + 5710

    5    libc.so.6                          0x00002b05dcae9460 __libc_start_main +
    245

    6    tmpdtugyn5i                        0x000055fe03647209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let current1 = numbers[i]\n        let current2 = numbers[i - 1]\n\
    \        let current3 = numbers[i - 1]\n        let current4 = numbers[i]\n  \
    \      let current5 = numbers[i]\n        let current6 = numbers[i - 1]\n    \
    \    let current7 = numbers[i - 1]\n        let current8 = numbers[i]\n      \
    \  let current9 = numbers[i]\n        let current10 = numbers[i]\n        let\
    \ current11 = numbers[i - 1]\n        let current12 = numbers[i - 1]\n       \
    \ let current13 = numbers[i - 1]\n        let current14 = numbers[i]\n       \
    \ let current15 = numbers[i]\n        let current16 = numbers[i - 1]\n       \
    \ let current17 = numbers[i - 1]\n        let current18 = numbers[i]\n       \
    \ let current19 = numbers[i]\n        let current20 = numbers[i - 1]\n       \
    \ let current21 = numbers[i - 1]\n        let current22 = numbers[i - 1]\n   \
    \     let current23 = numbers[i - 1]\n        let current24 = numbers[i]\n   \
    \     let current25 = numbers[i]\n        let current26 = numbers[i - 1]\n   \
    \     let current27 = numbers[i - 1]\n        let current28 = numbers[i]\n   \
    \     let current29 = numbers[i]\n        let current30 = numbers[i - 1]\n   \
    \     let current31 = numbers[i - 1]\n        let current32 = numbers[i - 1]\n\
    \        let current33 = numbers[i - 1]\n        let current34 = numbers[i]\n\
    \        let current35 = numbers[i]\n        let current36 = numbers[i - 1]\n\
    \        let current37 = numbers[i - 1]\n        let current38 = numbers[i]\n\
    \        let current39 = numbers[i]\n        let current40 = numbers[i - 1]\n\
    \        let current41 = numbers[i - 1]\n        let current42 = numbers[i - 1]\n\
    \        let current43 = numbers[i - 1]\n        let current44 = numbers[i]\n\
    \        let current45 = numbers[i]\n        let current46 = numbers[i - 1]\n\
    \        let current47 = numbers[i - 1]\n        let current48 = numbers[i]\n\
    \        let current49 = numbers[i]\n        let current50 = numbers[i - 1]\n\
    \        let current51 = numbers[i - 1]\n        let current52 = numbers[i - 1]\n\
    \        let current53 = numbers[i - 1]\n        let current54 = numbers[i]\n\
    \        let current55 = numbers[i]\n        let current56 = numbers[i - 1]\n\
    \        let current57 = numbers[i - 1]\n        let current58 = numbers[i]\n\
    \        let current59 = numbers[i]\n        let current60 = numbers[i - 1]\n\
    \        let current61 = numbers[i - 1]\n        let current62 = numbers[i - 1]\n\
    \        let current63 = numbers[\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7mvalti9.swift:80:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp7mvalti9.swift:99:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmp7mvalti9.swift:8:67: note: to match this opening '{'\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n                                          \
    \                        ^\n/tmp/tmp7mvalti9.swift:79:32: error: missing argument\
    \ for parameter #1 in call\n        let current63 = numbers[\n               \
    \                ^\n                               <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp7mvalti9.swift:83:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7of665kn.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp7of665kn.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp25ag_ifm.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp25ag_ifm.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp25ag_ifm.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp25ag_ifm.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        let current = numbers[i]\n        if\
    \ current < min {\n            min = current\n        } else if current > max\
    \ {\n            max = current\n        }\n    }\n    return (min, max)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyuz13cb8.swift:14:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = current\n            ^~~\n/tmp/tmpyuz13cb8.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpyuz13cb8.swift:16:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = current\n            ^~~\n/tmp/tmpyuz13cb8.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        } else if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp53ghtcl5.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1i9vifrw/tmp1i9vifrw.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add22881c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add22578b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add22578988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add225777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1i9vifrw                        0x0000562732d1069e <unavailable> + 5790

    5    libc.so.6                          0x00002add22a6d460 __libc_start_main +
    245

    6    tmp1i9vifrw                        0x0000562732d10259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpput40doe.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        let current = numbers[i]\n        if current < smallest {\n     \
    \       smallest = current\n            smallestIndex = i\n        }\n       \
    \ if current > largest {\n            largest = current\n            largestIndex\
    \ = i\n        }\n    }\n\n    return (numbers[smallestIndex], numbers[largestIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a366b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a363b0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a363b0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a363b013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a363afbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5a361aff44 <unavailable> + 188228

    6    tmp72i_u7yv                        0x0000558eb569df4c <unavailable> + 8012

    7    tmp72i_u7yv                        0x0000558eb569d5cd <unavailable> + 5581

    8    libc.so.6                          0x00002b5a368a5460 __libc_start_main +
    245

    9    tmp72i_u7yv                        0x0000558eb569d279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013778
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let smallest = sortedNumbers.first!\n    let largest = sortedNumbers.last!\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpi7_8kvdz/tmpi7_8kvdz.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c048dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c045d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c045d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c045d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi7_8kvdz                        0x000056282a13a6fe <unavailable> + 5886

    5    libc.so.6                          0x00002b7c04acb460 __libc_start_main +
    245

    6    tmpi7_8kvdz                        0x000056282a13a2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers[1] })\n\
    \    let closestValue = sortedNumbers[closestIndex]\n    return (closestValue,\
    \ sortedNumbers[closestIndex + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1hqjksc0.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers[1]\
    \ })\n                                                ^\n                    \
    \                            where: \n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \           smallestIndex = i\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i]\n            largestIndex = i\n        }\n \
    \   }\n\n    return (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d7fb47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d7f83e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d7f83e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d7f83e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d7f83dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8d7f63df44 <unavailable> + 188228

    6    tmpsschvcd6                        0x00005569a02fff7e <unavailable> + 8062

    7    tmpsschvcd6                        0x00005569a02ff5cd <unavailable> + 5581

    8    libc.so.6                          0x00002b8d7fd33460 __libc_start_main +
    245

    9    tmpsschvcd6                        0x00005569a02ff279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013778
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 || numbers.count >= 18 || numbers.count >= 19 || numbers.count >= 20 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 || numbers.count\
    \ >= 22 || numbers.count >= 23 || numbers.count >= 24 || numbers.count >= 25 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 26 || numbers.count\
    \ >= 27 || numbers.count >= 28 || numbers.count >= 29 || numbers.count >= 30 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 31 || numbers.count\
    \ >= 32 || numbers.count >= 33 || numbers.count >= 34 || numbers.count >= 35 ||\
    \ numbers.count >= 36 || numbers.count >= 37 || numbers.count >= 38 || numbers.count\
    \ >= 39 || numbers.count >= 40 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 41 || numbers.count >= 42 || numbers.count >= 43 || numbers.count\
    \ >= 44 || numbers.count >= 45 || numbers.count >= 46 || numbers.count >= 47 ||\
    \ numbers.count >= 48 || numbers.count >= 49 || numbers.count >= 50 || numbers.count\
    \ >= 51 || numbers.count >= 52 || numbers.count >= 53 || numbers.count >= 54 ||\
    \ numbers.count >= 55 || numbers.count >= 56 || numbers.count >= \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: '/tmp/tmpnm5siceu.swift:29:1: error: expected expression after operator

    }

    ^

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwo34xrdo/tmpwo34xrdo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e71d40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e71a37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e71a37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e71a367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwo34xrdo                        0x000055bca07616be <unavailable> + 5822

    5    libc.so.6                          0x00002b1e71f2c460 __libc_start_main +
    245

    6    tmpwo34xrdo                        0x000055bca0761279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpps041u74.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpps041u74.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else {\n      \
    \  return (0.0,0.0)\n    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for n in numbers {\n\
    \        if n < min1 {\n            min1 = n\n        } else if n > max1 {\n \
    \           max1 = n\n        }\n        if n < min2 {\n            min2 = n\n\
    \        } else if n > max2 {\n            max2 = n\n        }\n    }\n    return\
    \ (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp28lu7f7d.swift:18:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmp28lu7f7d.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp28lu7f7d.swift:20:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmp28lu7f7d.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp28lu7f7d.swift:23:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = n\n            ^~~~\n/tmp/tmp28lu7f7d.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp28lu7f7d.swift:25:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = n\n            ^~~~\n/tmp/tmp28lu7f7d.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkdq2c5nl.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    guard numbers.count > 1 else {\n        return\
    \ (0.0,0.0)\n    }\n    guard numbers.count <= numbers.max() else {\n        return\
    \ (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n  \
    \          smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5ykom9_5.swift:15:36: error: cannot convert value of type 'Double?'\
    \ to expected argument type 'Int'\n    guard numbers.count <= numbers.max() else\
    \ {\n                                   ^\n/tmp/tmp5ykom9_5.swift:22:13: error:\
    \ cannot assign to value: 'largest' is a 'let' constant\n            largest =\
    \ numbers[i]\n            ^~~~~~~\n/tmp/tmp5ykom9_5.swift:19:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n\
    /tmp/tmp5ykom9_5.swift:25:13: error: cannot assign to value: 'smallest' is a 'let'\
    \ constant\n            smallest = numbers[i]\n            ^~~~~~~~\n/tmp/tmp5ykom9_5.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzra13_kv.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpzra13_kv.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpzra13_kv.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpzra13_kv.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpzra13_kv.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpqx_vti9s.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpqx_vti9s.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpqx_vti9s.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpqx_vti9s.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    if max1 == min1 {\n        return (max1, max1)\n    }\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if max2 == min2\
    \ {\n        return (max2, max2)\n    }\n    var closest1 = min1\n    var closest2\
    \ = min2\n    if max1 < min2 {\n        closest1 = max1\n        closest2 = min2\n\
    \    } else {\n        closest1 = min1\n        closest2 = max2\n    }\n    var\
    \ closest3 = min1\n    var closest4 = min2\n    if max1 < min3 {\n        closest3\
    \ = max1\n        closest4 = min2\n    } else {\n        closest3 = min1\n   \
    \     closest4 = max2\n    }\n    var closest5 = min1\n    var closest6 = min2\n\
    \    if max1 < min4 {\n        closest5 = max1\n        closest6 = min2\n    }\
    \ else {\n        closest5 = min1\n        closest6 = max2\n    }\n    var closest7\
    \ = min1\n    var closest8 = min2\n    if max1 < min5 {\n        closest7 = max1\n\
    \        closest8 = min2\n    } else {\n        closest7 = min1\n        closest8\
    \ = max2\n    }\n    var closest9 = min1\n    var closest10 = min2\n    if max1\
    \ < min6 {\n        closest9 = max1\n        closest10 = min2\n    } else {\n\
    \        closest9 = min1\n        closest10 = max2\n    }\n    var closest11 =\
    \ min1\n    var closest12 = min2\n    if max1 < min7 {\n        closest11 = max1\n\
    \        closest12 = min2\n    } else {\n        closest11 = min1\n        closest12\
    \ = max2\n    }\n    var closest13 = min1\n    var closest14 = min2\n    if max1\
    \ < min8 {\n        closest13 = max1\n        closest14 = min2\n    } else {\n\
    \        closest13 = min1\n        closest14 = max2\n    }\n    var closest15\
    \ = min1\n    var closest16 = min2\n    if max1 < min9 {\n        closest15 =\
    \ max1\n        closest16 = min2\n    } else {\n        closest15 = min1\n   \
    \     closest16 = max2\n    }\n    var closest17 = min1\n    var closest18 = min2\n\
    \    if max1 < min10 {\n        closest17 = max1\n        closest18 = min2\n \
    \   } else {\n        closest17 = min1\n        closest18 = max2\n    }\n    var\
    \ closest19 = min1\n    var closest20 = min2\n    if max1 < min11 {\n        \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpuy0c4r5f.swift:123:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpuy0c4r5f.swift:8:67: note: to match this opening '{'\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n                                          \
    \                        ^\n/tmp/tmpuy0c4r5f.swift:12:16: error: cannot convert\
    \ return expression of type '(Double?, Double?)' to return type '(Double, Double)'\n\
    \        return (max1, max1)\n               ^\n/tmp/tmpuy0c4r5f.swift:17:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (max2, max2)\n               ^\n/tmp/tmpuy0c4r5f.swift:21:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if max1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpuy0c4r5f.swift:30:15: error: cannot\
    \ find 'min3' in scope\n    if max1 < min3 {\n              ^~~~\n/tmp/tmpuy0c4r5f.swift:30:8:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    if max1 < min3 {\n       ^\n/tmp/tmpuy0c4r5f.swift:30:8: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    if max1 < min3 {\n       ^\n            ?? <#default value#>\n/tmp/tmpuy0c4r5f.swift:30:8:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if max1 < min3 {\n       ^\n           !\n/tmp/tmpuy0c4r5f.swift:39:15:\
    \ error: cannot find 'min4' in scope\n    if max1 < min4 {\n              ^~~~\n\
    /tmp/tmpuy0c4r5f.swift:39:8: error: value of optional type 'Double?' must be unwrapped\
    \ to a value of type 'Double'\n    if max1 < min4 {\n       ^\n/tmp/tmpuy0c4r5f.swift:39:8:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if max1 < min4 {\n       ^\n            ?? <#default value#>\n/tmp/tmpuy0c4r5f.swift:39:8:\
    \ note: force-unwrap using '!' to abort execution if the optional value cont"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl3jvzyyp.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpl3jvzyyp.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp6eqcz3c2/tmp6eqcz3c2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0ff2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0fefacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0fefac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0fefab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6eqcz3c2                        0x0000560ec277b69e <unavailable> + 5790

    5    libc.so.6                          0x00002ad0ff4a1460 __libc_start_main +
    245

    6    tmp6eqcz3c2                        0x0000560ec277b259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpsvsn7jaz/tmpsvsn7jaz.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95c8b0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95c8801b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95c8801988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95c88007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvsn7jaz                        0x00005597a1e8c69e <unavailable> + 5790

    5    libc.so.6                          0x00002b95c8cf6460 __libc_start_main +
    245

    6    tmpsvsn7jaz                        0x00005597a1e8c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.count < 2 {\n        return (sortedNumbers[0], sortedNumbers[0])\n\
    \    }\n    if sortedNumbers.count == 2 {\n        return (sortedNumbers[0], sortedNumbers[1])\n\
    \    }\n    if sortedNumbers.count == 3 {\n        let closest1 = sortedNumbers[0]\n\
    \        let closest2 = sortedNumbers[1]\n        if closest1 < closest2 {\n \
    \           return (closest1, closest2)\n        } else {\n            return\
    \ (closest2, closest1)\n        }\n    }\n    if sortedNumbers.count == 4 {\n\
    \        let closest1 = sortedNumbers[0]\n        let closest2 = sortedNumbers[1]\n\
    \        let closest3 = sortedNumbers[2]\n        if closest1 < closest2 {\n \
    \           if closest1 < closest3 {\n                return (closest1, closest2)\n\
    \            } else {\n                return (closest1, closest3)\n         \
    \   }\n        } else {\n            if closest2 < closest3 {\n              \
    \  return (closest2, closest3)\n            } else {\n                return (closest2,\
    \ closest1)\n            }\n        }\n    }\n    if sortedNumbers.count == 5\
    \ {\n        let closest1 = sortedNumbers[0]\n        let closest2 = sortedNumbers[1]\n\
    \        let closest3 = sortedNumbers[2]\n        let closest4 = sortedNumbers[3]\n\
    \        if closest1 < closest2 {\n            if closest1 < closest3 {\n    \
    \            if closest1 < closest4 {\n                    return (closest1, closest2)\n\
    \                } else {\n                    return (closest1, closest4)\n \
    \               }\n            } else {\n                if closest2 < closest4\
    \ {\n                    return (closest2, closest4)\n                } else {\n\
    \                    return (closest2, closest3)\n                }\n        \
    \    }\n        } else {\n            if closest2 < closest3 {\n             \
    \   if closest2 < closest4 {\n                    return (closest2, closest3)\n\
    \                } else {\n                    return (closest2, closest4)\n \
    \               }\n            } else {\n                if closest3 < closest4\
    \ {\n                    return (closest3, closest4)\n                } else {\n\
    \                    return (closest3, closest2)\n                }\n        \
    \    }\n        }\n    }\n    if sortedNumbers.count == 6 {\n        let closest1\
    \ = sortedNumbers[0]\n        let closest2 = sortedNumbers[1]\n        let closest3\
    \ = sortedNumbers[2]\n        let closest4 = sortedNumbers[3]\n        let closest5\
    \ = sortedNumbers[4]\n        if closest1 < closest2 {\n            if closest1\
    \ < closest3 {\n                if closest1 < closest4 {\n                   \
    \ if closest1 < closest5 {\n                        return (closest1, closest2)\n\
    \                    } else {\n                        return (closest1, closest5)\n\
    \                    }\n                } else {\n                    if closest2\
    \ < closest5 {\n                        return (closest2, closest5)\n        \
    \            } else {\n                        return (closest2, closest3)\n \
    \                   }\n                }\n            } else {\n             \
    \   if closest2 < closest3 {\n                    if closest2 < closest4 {\n \
    \                       if closest2 < closest5 {\n                           \
    \ return (closest2, closest3)\n                        } else {\n            \
    \                return (closest2, closest5)\n                        }\n    \
    \                } else {\n                        if closest3 < closest5 {\n\
    \                            return (closest3, \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpypu15ysk.swift:110:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpypu15ysk.swift:129:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpypu15ysk.swift:107:28: note: to match this opening '{'\n      \
    \              } else {\n                           ^\n/tmp/tmpypu15ysk.swift:129:80:\
    \ error: expected '}' at end of brace statement\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n                                \
    \                                               ^\n/tmp/tmpypu15ysk.swift:100:40:\
    \ note: to match this opening '{'\n                if closest2 < closest3 {\n\
    \                                       ^\n/tmp/tmpypu15ysk.swift:129:80: error:\
    \ expected '}' at end of brace statement\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n                                \
    \                                               ^\n/tmp/tmpypu15ysk.swift:99:20:\
    \ note: to match this opening '{'\n            } else {\n                   ^\n\
    /tmp/tmpypu15ysk.swift:129:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpypu15ysk.swift:84:32: note: to match this opening '{'\n       \
    \ if closest1 < closest2 {\n                               ^\n/tmp/tmpypu15ysk.swift:129:80:\
    \ error: expected '}' at end of brace statement\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n                                \
    \                                               ^\n/tmp/tmpypu15ysk.swift:78:33:\
    \ note: to match this opening '{'\n    if sortedNumbers.count == 6 {\n       \
    \                         ^\n/tmp/tmpypu15ysk.swift:129:80: error: expected '}'\
    \ at end of brace statement\nassert(find_closest_elements(numbers: [1.1, 2.2,\
    \ 3.1, 4.1, 5.1]) == ("
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzra13_kv.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpzra13_kv.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpzra13_kv.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpzra13_kv.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpzra13_kv.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n  \
    \          smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppkl5exhk.swift:16:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmppkl5exhk.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmppkl5exhk.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmppkl5exhk.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp25ag_ifm.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp25ag_ifm.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp25ag_ifm.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp25ag_ifm.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfv92s890.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min: Double = numbers.min()\n    let\
    \ max: Double = numbers.max()\n    let mid: Double = (min + max) / 2\n    return\
    \ (mid, numbers.firstIndex(of: mid))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpave3q_h2.swift:9:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmpave3q_h2.swift:9:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmpave3q_h2.swift:9:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmpave3q_h2.swift:10:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmpave3q_h2.swift:10:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmpave3q_h2.swift:10:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n/tmp/tmpave3q_h2.swift:12:12: error: cannot\
    \ convert return expression of type '(Double, Array<Double>.Index?)' (aka '(Double,\
    \ Optional<Int>)') to return type '(Double, Double)'\n    return (mid, numbers.firstIndex(of:\
    \ mid))\n           ^\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwikt5es6.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpwikt5es6.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpwikt5es6.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpwikt5es6.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipo_e0hv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpipo_e0hv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph93coexm.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmph93coexm.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmph93coexm.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmph93coexm.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \n    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        } else if numbers[i] < smallest {\n     \
    \       smallest = numbers[i]\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj7i0cwjd.swift:17:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpj7i0cwjd.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpj7i0cwjd.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpj7i0cwjd.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        let current = numbers[i]\n\
    \        if current < smallest {\n            smallest = current\n        } else\
    \ if current > largest {\n            largest = current\n        }\n    }\n  \
    \  return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbq744_lc.swift:14:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = current\n            ^~~~~~~~\n\
    /tmp/tmpbq744_lc.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpbq744_lc.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = current\n            ^~~~~~~\n/tmp/tmpbq744_lc.swift:10:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpezw3wt23.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpezw3wt23.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpezw3wt23.swift:15:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpezw3wt23.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi_n16gu/tmphi_n16gu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73e3c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73e398db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73e398d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73e398c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi_n16gu                        0x000055a5133e864e <unavailable> + 5710

    5    libc.so.6                          0x00002b73e3e82460 __libc_start_main +
    245

    6    tmphi_n16gu                        0x000055a5133e8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9qm5h8ri.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013777
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp6eqcz3c2/tmp6eqcz3c2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0ff2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0fefacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0fefac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0fefab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6eqcz3c2                        0x0000560ec277b69e <unavailable> + 5790

    5    libc.so.6                          0x00002ad0ff4a1460 __libc_start_main +
    245

    6    tmp6eqcz3c2                        0x0000560ec277b259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013777
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpput40doe.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var smallestDifference = Double.greatestFiniteMagnitude\n    var smallestDifferenceIndex\
    \ = -1\n    var largestDifference = Double.greatestFiniteMagnitude\n    var largestDifferenceIndex\
    \ = -1\n    for i in 0..<numbers.count {\n        let difference = abs(numbers[i]\
    \ - sortedNumbers[i])\n        if difference < smallestDifference {\n        \
    \    smallestDifference = difference\n            smallestDifferenceIndex = i\n\
    \        }\n        if difference > largestDifference {\n            largestDifference\
    \ = difference\n            largestDifferenceIndex = i\n        }\n    }\n   \
    \ return (sortedNumbers[smallestDifferenceIndex], sortedNumbers[largestDifferenceIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b80ac890c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80ac587561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b80ac587286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b80ac58713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b80ac586bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b80ac388f44 <unavailable> + 188228

    6    tmph9wopuen                        0x000055d76380919c <unavailable> + 8604

    7    tmph9wopuen                        0x000055d76380878d <unavailable> + 6029

    8    libc.so.6                          0x00002b80aca7c460 __libc_start_main +
    245

    9    tmph9wopuen                        0x000055d763808439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013778
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        } else if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmc9h66tr.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013778
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxnbfunbr.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpxnbfunbr.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013776
