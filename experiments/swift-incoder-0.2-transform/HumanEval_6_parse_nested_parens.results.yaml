language: swift
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var paren_count = 0\n    for\
    \ char in paren_string {\n        if char == '(' {\n            paren_count +=\
    \ 1\n        } else if char == ')' {\n            paren_count -= 1\n         \
    \   if paren_count == 0 {\n                levels.append(paren_count)\n      \
    \      }\n        }\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp4tfzg0mz.swift:11:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmp4tfzg0mz.swift:13:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    for char in paren_string.characters {\n        if char == '(' {\n \
    \           levels[level] = parens\n            parens += 1\n        } else if\
    \ char == ')' {\n            levels[level] = parens\n            parens -= 1\n\
    \        } else if char == ' ' {\n            levels[level] = parens\n       \
    \ }\n        level += 1\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpaqya9yuk.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmpaqya9yuk.swift:15:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpaqya9yuk.swift:18:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ' ' {\n          \
    \                ^~~\n                          \" \"\n/tmp/tmpaqya9yuk.swift:11:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in paren_string.characters {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824947
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    var parens_count = 0\n    var parens_level = 0\n    for c in paren_string.characters\
    \ {\n        if c == '(' {\n            parens_count += 1\n            parens_level\
    \ += 1\n        } else if c == ')' {\n            parens_count -= 1\n        \
    \    parens_level -= 1\n            if parens_level == 0 {\n                levels.append(level)\n\
    \            }\n        } else if parens_count > 0 {\n            level = 0\n\
    \            parens = 0\n            parens_count = 0\n            parens_level\
    \ = 0\n        }\n        level += 1\n    }\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpf1a29zl3.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpf1a29zl3.swift:17:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpf1a29zl3.swift:13:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in paren_string.characters {\n       \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpf1a29zl3.swift:10:9: warning: variable 'parens' was written to, but\
    \ never read\n    var parens = 0\n        ^\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    var parens_count = 0\n    var parens_level = 0\n    for char in paren_string.characters\
    \ {\n        switch char {\n        case ')':\n            levels[level] = parens_level\n\
    \            parens_level = 0\n            parens_count += 1\n            parens\
    \ += parens_count\n            level++\n        case ')':\n            levels[level]\
    \ = parens_level\n            parens_level = 0\n            parens_count += 1\n\
    \            parens += parens_count\n            level++\n        default:\n \
    \           parens_level++\n        }\n    }\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgv3kewlu.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpgv3kewlu.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpgv3kewlu.swift:13:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgv3kewlu.swift:20:18: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpgv3kewlu.swift:26:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  level++\n                 ^~\n/tmp/tmpgv3kewlu.swift:28:25: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            parens_level++\n \
    \                       ^~\n/tmp/tmpgv3kewlu.swift:21:14: warning: literal value\
    \ is already handled by previous pattern; consider removing it\n        case ')':\n\
    \             ^~~\n/tmp/tmpgv3kewlu.swift:15:14: note: first occurrence of identical\
    \ literal pattern is here\n        case ')':\n             ^~~\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    var max_level_parens\
    \ = 0\n    var paren_count = 0\n    var paren_char_count = 0\n    var paren_char\
    \ = \"\"\n    var paren_chars = []\n    var paren_char_index = 0\n    var paren_char_indexes\
    \ = []\n    var paren_char_indexes_count = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n    var paren_char_indexes_index\
    \ = 0\n    var paren_char_indexes_index = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpufa7zco5.swift:14:23: error: empty collection literal requires\
    \ an explicit type\n    var paren_chars = []\n                      ^~\n/tmp/tmpufa7zco5.swift:16:30:\
    \ error: empty collection literal requires an explicit type\n    var paren_char_indexes\
    \ = []\n                             ^~\n/tmp/tmpufa7zco5.swift:19:9: error: invalid\
    \ redeclaration of 'paren_char_indexes_index'\n    var paren_char_indexes_index\
    \ = 0\n        ^\n/tmp/tmpufa7zco5.swift:18:9: note: 'paren_char_indexes_index'\
    \ previously declared here\n    var paren_char_indexes_index = 0\n        ^\n\
    /tmp/tmpufa7zco5.swift:20:9: error: invalid redeclaration of 'paren_char_indexes_index'\n\
    \    var paren_char_indexes_index = 0\n        ^\n/tmp/tmpufa7zco5.swift:18:9:\
    \ note: 'paren_char_indexes_index' previously declared here\n    var paren_char_indexes_index\
    \ = 0\n        ^\n/tmp/tmpufa7zco5.swift:21:9: error: invalid redeclaration of\
    \ 'paren_char_indexes_index'\n    var paren_char_indexes_index = 0\n        ^\n\
    /tmp/tmpufa7zco5.swift:18:9: note: 'paren_char_indexes_index' previously declared\
    \ here\n    var paren_char_indexes_index = 0\n        ^\n/tmp/tmpufa7zco5.swift:22:9:\
    \ error: invalid redeclaration of 'paren_char_indexes_index'\n    var paren_char_indexes_index\
    \ = 0\n        ^\n/tmp/tmpufa7zco5.swift:18:9: note: 'paren_char_indexes_index'\
    \ previously declared here\n    var paren_char_indexes_index = 0\n        ^\n\
    /tmp/tmpufa7zco5.swift:23:9: error: invalid redeclaration of 'paren_char_indexes_index'\n\
    \    var paren_char_indexes_index = 0\n        ^\n/tmp/tmpufa7zco5.swift:18:9:\
    \ note: 'paren_char_indexes_index' previously declared here\n    var paren_char_indexes_index\
    \ = 0\n        ^\n/tmp/tmpufa7zco5.swift:24:9: error: invalid redeclaration of\
    \ 'paren_char_indexes_index'\n    var paren_char_indexes_index = 0\n        ^\n\
    /tmp/tmpufa7zco5.swift:18:9: note: 'paren_char_indexes_index' previously declared\
    \ here\n    var paren_char_indexes_index = 0\n        ^\n/tmp/tmpufa7zco5.swift:25:9:\
    \ error: invalid redeclaration of 'paren_char_indexes_index'\n    var paren_char_indexes_index\
    \ = 0\n        ^\n/tmp/tmpu"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var level = 0\n    var levels\
    \ = [Int]()\n    var levels_stack = [Int]()\n    var levels_stack_index = 0\n\
    \    var paren_level = 0\n    var paren_level_stack = [Int]()\n    var paren_level_stack_index\
    \ = 0\n    var paren_level_stack_index2 = 0\n    var paren_level_stack_index3\
    \ = 0\n    var paren_level_stack_index4 = 0\n    var paren_level_stack_index5\
    \ = 0\n    var paren_level_stack_index6 = 0\n    var paren_level_stack_index7\
    \ = 0\n    var paren_level_stack_index8 = 0\n    var paren_level_stack_index9\
    \ = 0\n    var paren_level_stack_index10 = 0\n    var paren_level_stack_index11\
    \ = 0\n    var paren_level_stack_index12 = 0\n    var paren_level_stack_index13\
    \ = 0\n    var paren_level_stack_index14 = 0\n    var paren_level_stack_index15\
    \ = 0\n    var paren_level_stack_index16 = 0\n    var paren_level_stack_index17\
    \ = 0\n    var paren_level_stack_index18 = 0\n    var paren_level_stack_index19\
    \ = 0\n    var paren_level_stack_index20 = 0\n    var paren_level_stack_index21\
    \ = 0\n    var paren_level_stack_index22 = 0\n    var paren_level_stack_index23\
    \ = 0\n    var paren_level_stack_index24 = 0\n    var paren_level_stack_index25\
    \ = 0\n    var paren_level_stack_index26 = 0\n    var paren_level_stack_index27\
    \ = 0\n    var paren_level_stack_index28 = 0\n    var paren_level_stack_index29\
    \ = 0\n    var paren_level_stack_index30 = 0\n    var paren_level_stack_index31\
    \ = 0\n    var paren_level_stack_index32 = 0\n    var paren_level_stack_index33\
    \ = 0\n    var paren_level_stack_index34 = 0\n    var paren_level_stack_index35\
    \ = 0\n    var paren_level_stack_index36 = 0\n    var paren_level_stack_index37\
    \ = 0\n    var paren_level_stack_index38 = 0\n    var paren_level_stack_index39\
    \ = 0\n    var paren_level_stack_index40 = 0\n    var paren_level_stack_index41\
    \ = 0\n    var paren_level_stack_index42 = 0\n    var paren_level_stack_index43\
    \ = 0\n    var paren_level_stack_index44 = 0\n    var paren_level_stack_index45\
    \ = 0\n    var paren_level_stack_index46 = 0\n    var paren_level_stack_index47\
    \ = 0\n    var paren_level_stack_index48 = 0\n    var paren_level_stack_index49\
    \ = 0\n    var paren_level_stack_index50 = 0\n    var paren_level_stack_index51\
    \ = 0\n    var paren_level_stack_index\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnv5nqkyx.swift:66:9: error: type annotation missing in pattern\n\
    \    var paren_level_stack_index\n        ^\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var paren_count\
    \ = 0\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end = 0\n\
    \    var paren_char = 0\n    var paren_char_count = 0\n    var paren_char_level\
    \ = 0\n    var paren_char_start = 0\n    var paren_char_end = 0\n    var paren_char_char\
    \ = 0\n    var paren_char_char_count = 0\n    var paren_char_char_level = 0\n\
    \    var paren_char_char_start = 0\n    var paren_char_char_end = 0\n    var paren_char_char_char\
    \ = 0\n    var paren_char_char_char_count = 0\n    var paren_char_char_char_level\
    \ = 0\n    var paren_char_char_char_start = 0\n    var paren_char_char_char_end\
    \ = 0\n    var paren_char_char_char_char = 0\n    var paren_char_char_char_char_count\
    \ = 0\n    var paren_char_char_char_char_level = 0\n    var paren_char_char_char_char_start\
    \ = 0\n    var paren_char_char_char_char_end = 0\n    var paren_char_char_char_char_char\
    \ = 0\n    var paren_char_char_char_char_char_count = 0\n    var paren_char_char_char_char_char_level\
    \ = 0\n    var paren_char_char_char_char_char_start = 0\n    var paren_char_char_char_char_char_end\
    \ = 0\n    var paren_char_char_char_char_char_char = 0\n    var paren_char_char_char_char_char_char_count\
    \ = 0\n    var paren_char_char_char_char_char_char_level = 0\n    var paren_char_char_char_char_char_char_start\
    \ = 0\n    var paren_char_char_char_char_char_char_end = 0\n    var paren_char_char_char_char_char_char_char\
    \ = 0\n    var paren_char_char_char_char_char_char_char_count = 0\n    var paren_char_char_char_char_char_char_char_level\
    \ = 0\n    var paren_char_char_char_char_char_char_char_start = 0\n    var paren_char_char_char_char_char_char_char_end\
    \ = 0\n    var paren_char_char_char_char_char_char_char_char = 0\n    var paren_char_char_char_char_char_char_char_char_count\
    \ = 0\n    var paren_char_char_char_char_char_char_char_char_level = 0\n    var\
    \ paren_char_char_char_char_char_char_char_char_start = 0\n    var paren_char_char_char_char_char_char_char_char_char_end\
    \ = 0\n    var paren_char_char_char_char_char_char_char_char_char = 0\n    var\
    \ paren_char_char_char_char_char_char_char_char_char_count = 0\n    var paren_char_char_char_char_char_char_char_char_char_level\
    \ = 0\n    var paren_char_char_char_char_char_char_char_char_char_start = 0\n\
    \    var paren_char_char_char_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpep18sx0r.swift:58:9: error: type annotation missing in pattern\n\
    \    var paren_char_char_char_\n        ^\n"
  stdout: ''
  timestamp: 1659824947
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_char = 0\n\
    \    var paren_char_count = 0\n    var paren_char_count_prev = 0\n    var paren_char_count_next\
    \ = 0\n    var paren_char_count_prev_next = 0\n    var paren_char_count_prev_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next = 0\n    var paren_char_count_prev_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next = 0\n    var paren_char_count_prev_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next = 0\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next = 0\n \
    \   var paren_char_count_prev_next_next_next_next_next_next_next_next_next = 0\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next_next =\
    \ 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptla0fc9z.swift:42:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmptla0fc9z.swift:26:9: error: invalid redeclaration of 'paren_char_count_prev_next_next_next_next_next_next_next_next_next'\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next_next =\
    \ 0\n        ^\n/tmp/tmptla0fc9z.swift:25:9: note: 'paren_char_count_prev_next_next_next_next_next_next_next_next_next'\
    \ previously declared here\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:28:9: error: invalid redeclaration of\
    \ 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next'\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:27:9: note: 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next'\
    \ previously declared here\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:31:9: error: invalid redeclaration of\
    \ 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next'\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:30:9: note: 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next'\
    \ previously declared here\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:32:9: error: invalid redeclaration of\
    \ 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next'\n\
    \    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:30:9: note: 'paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next'\
    \ previously declared here\n    var paren_char_count_prev_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0\n        ^\n/tmp/tmptla0fc9z.swift:33:9: error: invalid redeclaration of\
    \ 'paren_char_count_prev_next_"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    for char in paren_string.characters {\n        if char == '(' {\n \
    \           parens += 1\n            levels.append(level)\n            level =\
    \ 0\n        } else if char == ')' {\n            level -= 1\n            levels.append(level)\n\
    \            level = 0\n        } else {\n            level += 1\n        }\n\
    \    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpbh8v4jk7.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmpbh8v4jk7.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpbh8v4jk7.swift:11:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    var max_level_parens\
    \ = 0\n    var parens = 0\n    var parens_count = 0\n    var parens_string = \"\
    \"\n    for char in paren_string.characters {\n        if char == \"(\" {\n  \
    \          parens += 1\n            parens_count += 1\n            parens_string\
    \ += String(char)\n        } else if char == \")\" {\n            parens -= 1\n\
    \            parens_count -= 1\n            if parens_count == 0 {\n         \
    \       parens_string = parens_string[..<parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, start\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpe84uro0h.swift:24:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpe84uro0h.swift:23:2007: note: to match this opening '('\n         \
    \       parens_string = parens_string[..<parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ parens_string.index(char, startIndex: parens_string.index(char, startIndex:\
    \ p"
  stdout: ''
  timestamp: 1659825124
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    var max_level_parens\
    \ = 0\n    var paren_level = 0\n    var paren_level_parens = 0\n    var paren_level_parens_count\
    \ = 0\n    var paren_level_parens_count_max = 0\n    var paren_level_parens_count_max_max\
    \ = 0\n    var paren_level_parens_count_max_min = 0\n    var paren_level_parens_count_max_min_index\
    \ = 0\n    var paren_level_parens_count_max_min_index_index = 0\n    var paren_level_parens_count_max_min_index2\
    \ = 0\n    var paren_level_parens_count_max_min_index2_index = 0\n    var paren_level_parens_count_max_min_index3\
    \ = 0\n    var paren_level_parens_count_max_min_index3_index = 0\n    var paren_level_parens_count_max_min_index4\
    \ = 0\n    var paren_level_parens_count_max_min_index4_index = 0\n    var paren_level_parens_count_max_min_index5\
    \ = 0\n    var paren_level_parens_count_max_min_index5_index = 0\n    var paren_level_parens_count_max_min_index6\
    \ = 0\n    var paren_level_parens_count_max_min_index6_index = 0\n    var paren_level_parens_count_max_min_index7\
    \ = 0\n    var paren_level_parens_count_max_min_index7_index = 0\n    var paren_level_parens_count_max_min_index8\
    \ = 0\n    var paren_level_parens_count_max_min_index8_index = 0\n    var paren_level_parens_count_max_min_index9\
    \ = 0\n    var paren_level_parens_count_max_min_index9_index = 0\n    var paren_level_parens_count_max_min_index10\
    \ = 0\n    var paren_level_parens_count_max_min_index10_index = 0\n    var paren_level_parens_count_max_min_index11\
    \ = 0\n    var paren_level_parens_count_max_min_index11_index = 0\n    var paren_level_parens_count_max_min_index12\
    \ = 0\n    var paren_level_parens_count_max_min_index12_index = 0\n    var paren_level_parens_count_max_min_index13\
    \ = 0\n    var paren_level_parens_count_max_min_index13_index = 0\n    var paren_level_parens_count_max_min_index14\
    \ = 0\n    var paren_level_parens_count_max_min_index14_index = 0\n    var paren_level_parens_count_max_min_index15\
    \ = 0\n    var paren_level_parens_count_max_min_index15_index = 0\n    var paren_level_parens_count_max_min_index16\
    \ = 0\n    var paren_level_parens_count_max_min_index16_index = 0\n    var paren_level_parens_count_max_min_index17\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_zn3gaj2.swift:50:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp_zn3gaj2.swift:8:9: warning: initialization of variable 'level' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ level = 0\n    ~~~~^~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:9:9: warning: initialization\
    \ of variable 'max_level' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var max_level = 0\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:10:9:\
    \ warning: initialization of variable 'max_level_parens' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var max_level_parens =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:11:9: warning: initialization\
    \ of variable 'paren_level' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var paren_level = 0\n    ~~~~^~~~~~~~~~~\n    _\n\
    /tmp/tmp_zn3gaj2.swift:12:9: warning: initialization of variable 'paren_level_parens'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var paren_level_parens = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:13:9:\
    \ warning: initialization of variable 'paren_level_parens_count' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var paren_level_parens_count\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:14:9: warning:\
    \ initialization of variable 'paren_level_parens_count_max' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var paren_level_parens_count_max\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:15:9:\
    \ warning: initialization of variable 'paren_level_parens_count_max_max' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var paren_level_parens_count_max_max\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_zn3gaj2.swift:16:9:\
    \ warning: initialization of variable 'paren_level_parens_count_max_min' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var paren_level_paren"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var paren_count\
    \ = 0\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end = 0\n\
    \    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_start\
    \ = 0\n    var paren_end = 0\n    var paren_levels = [Int]()\n    var paren_level\
    \ = 0\n    var paren_start = 0\n    var paren_end = 0\n    var paren_levels =\
    \ [Int]()\n    var paren_level = 0\n    var paren_start\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl_txb0jt.swift:15:9: error: invalid redeclaration of 'paren_level'\n\
    \    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:11:9: note: 'paren_level'\
    \ previously declared here\n    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:16:9:\
    \ error: invalid redeclaration of 'paren_start'\n    var paren_start = 0\n   \
    \     ^\n/tmp/tmpl_txb0jt.swift:12:9: note: 'paren_start' previously declared\
    \ here\n    var paren_start = 0\n        ^\n/tmp/tmpl_txb0jt.swift:17:9: error:\
    \ invalid redeclaration of 'paren_end'\n    var paren_end = 0\n        ^\n/tmp/tmpl_txb0jt.swift:13:9:\
    \ note: 'paren_end' previously declared here\n    var paren_end = 0\n        ^\n\
    /tmp/tmpl_txb0jt.swift:18:9: error: invalid redeclaration of 'paren_levels'\n\
    \    var paren_levels = [Int]()\n        ^\n/tmp/tmpl_txb0jt.swift:14:9: note:\
    \ 'paren_levels' previously declared here\n    var paren_levels = [Int]()\n  \
    \      ^\n/tmp/tmpl_txb0jt.swift:19:9: error: invalid redeclaration of 'paren_level'\n\
    \    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:11:9: note: 'paren_level'\
    \ previously declared here\n    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:20:9:\
    \ error: invalid redeclaration of 'paren_start'\n    var paren_start = 0\n   \
    \     ^\n/tmp/tmpl_txb0jt.swift:12:9: note: 'paren_start' previously declared\
    \ here\n    var paren_start = 0\n        ^\n/tmp/tmpl_txb0jt.swift:21:9: error:\
    \ invalid redeclaration of 'paren_end'\n    var paren_end = 0\n        ^\n/tmp/tmpl_txb0jt.swift:13:9:\
    \ note: 'paren_end' previously declared here\n    var paren_end = 0\n        ^\n\
    /tmp/tmpl_txb0jt.swift:22:9: error: invalid redeclaration of 'paren_levels'\n\
    \    var paren_levels = [Int]()\n        ^\n/tmp/tmpl_txb0jt.swift:14:9: note:\
    \ 'paren_levels' previously declared here\n    var paren_levels = [Int]()\n  \
    \      ^\n/tmp/tmpl_txb0jt.swift:23:9: error: invalid redeclaration of 'paren_level'\n\
    \    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:11:9: note: 'paren_level'\
    \ previously declared here\n    var paren_level = 0\n        ^\n/tmp/tmpl_txb0jt.swift:24:9:\
    \ error: invalid redeclaration of 'paren_start'\n    "
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    var max_level_parens\
    \ = 0\n    var paren_count = 0\n    var paren_level = 0\n    var paren_level_parens\
    \ = 0\n    var paren_level_parens_count = 0\n    var paren_level_parens_count_max\
    \ = 0\n    var paren_level_parens_count_min = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n    var paren_level_parens_count_max_index = 0\n    var paren_level_parens_count_min_index\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjxjcd7td.swift:19:9: error: invalid redeclaration of 'paren_level_parens_count_min_index'\n\
    \    var paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:17:9:\
    \ note: 'paren_level_parens_count_min_index' previously declared here\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:20:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_max_index'\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:18:9:\
    \ note: 'paren_level_parens_count_max_index' previously declared here\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:21:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_min_index'\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:17:9:\
    \ note: 'paren_level_parens_count_min_index' previously declared here\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:22:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_max_index'\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:18:9:\
    \ note: 'paren_level_parens_count_max_index' previously declared here\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:23:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_min_index'\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:17:9:\
    \ note: 'paren_level_parens_count_min_index' previously declared here\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:24:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_max_index'\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:18:9:\
    \ note: 'paren_level_parens_count_max_index' previously declared here\n    var\
    \ paren_level_parens_count_max_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:25:9:\
    \ error: invalid redeclaration of 'paren_level_parens_count_min_index'\n    var\
    \ paren_level_parens_count_min_index = 0\n        ^\n/tmp/tmpjxjcd7td.swift:17:9:\
    \ note: 'par"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    var parens_level = 0\n    for c in paren_string.unicodeScalars {\n\
    \        if c == '(' {\n            parens += 1\n            parens_level += 1\n\
    \        } else if c == ')' {\n            parens -= 1\n            if parens\
    \ == 0 {\n                levels.append(parens_level)\n            }\n       \
    \ }\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqzcaijzb.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpqzcaijzb.swift:16:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpqzcaijzb.swift:9:9: warning: initialization of variable\
    \ 'level' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var level = 0\n    ~~~~^~~~~\n    _\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    var parens_level = 0\n    var parens_count = 0\n    var parens_count_max\
    \ = 0\n    var parens_count_max_index = 0\n    var parens_count_max_index2 = 0\n\
    \    var parens_count_max_index3 = 0\n    var parens_count_max_index4 = 0\n  \
    \  var parens_count_max_index5 = 0\n    var parens_count_max_index6 = 0\n    var\
    \ parens_count_max_index7 = 0\n    var parens_count_max_index8 = 0\n    var parens_count_max_index9\
    \ = 0\n    var parens_count_max_index10 = 0\n    var parens_count_max_index11\
    \ = 0\n    var parens_count_max_index12 = 0\n    var parens_count_max_index13\
    \ = 0\n    var parens_count_max_index14 = 0\n    var parens_count_max_index15\
    \ = 0\n    var parens_count_max_index16 = 0\n    var parens_count_max_index17\
    \ = 0\n    var parens_count_max_index18 = 0\n    var parens_count_max_index19\
    \ = 0\n    var parens_count_max_index20 = 0\n    var parens_count_max_index21\
    \ = 0\n    var parens_count_max_index22 = 0\n    var parens_count_max_index23\
    \ = 0\n    var parens_count_max_index24 = 0\n    var parens_count_max_index25\
    \ = 0\n    var parens_count_max_index26 = 0\n    var parens_count_max_index27\
    \ = 0\n    var parens_count_max_index28 = 0\n    var parens_count_max_index29\
    \ = 0\n    var parens_count_max_index30 = 0\n    var parens_count_max_index31\
    \ = 0\n    var parens_count_max_index32 = 0\n    var parens_count_max_index33\
    \ = 0\n    var parens_count_max_index34 = 0\n    var parens_count_max_index35\
    \ = 0\n    var parens_count_max_index36 = 0\n    var parens_count_max_index37\
    \ = 0\n    var parens_count_max_index38 = 0\n    var parens_count_max_index39\
    \ = 0\n    var parens_count_max_index40 = 0\n    var parens_count_max_index41\
    \ = 0\n    var parens_count_max_index42 = 0\n    var parens_count_max_index43\
    \ = 0\n    var parens_count_max_index44 = 0\n    var parens_count_max_index45\
    \ = 0\n    var parens_count_max_index46 = 0\n    var parens_count_max_index47\
    \ = 0\n    var parens_count_max_index48 = 0\n    var parens_count_max_index49\
    \ = 0\n    var parens_count_max_index50 = 0\n    var parens_count_max_index51\
    \ = 0\n    var parens_count_max_index52 = 0\n    var parens_count_max_index53\
    \ = 0\n    var parens_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl9yn4iev.swift:67:9: error: type annotation missing in pattern\n\
    \    var parens_\n        ^\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    var parens_count = 0\n    for c in paren_string.unicodeScalars {\n\
    \        if parens_count == 0 {\n            levels.append(level)\n        }\n\
    \        if parens_count == 1 {\n            levels[level] = levels[level] + 1\n\
    \        }\n        if parens_count == 2 {\n            levels[level] = levels[level]\
    \ + 1\n        }\n        if parens_count == 3 {\n            levels[level] =\
    \ levels[level] + 1\n        }\n        if parens_count == 4 {\n            levels[level]\
    \ = levels[level] + 1\n        }\n        if parens_count == 5 {\n           \
    \ levels[level] = levels[level] + 1\n        }\n        if parens_count == 6 {\n\
    \            levels[level] = levels[level] + 1\n        }\n        if parens_count\
    \ == 7 {\n            levels[level] = levels[level] + 1\n        }\n        if\
    \ parens_count == 8 {\n            levels[level] = levels[level] + 1\n       \
    \ }\n        if parens_count == 9 {\n            levels[level] = levels[level]\
    \ + 1\n        }\n        if parens_count == 10 {\n            levels[level] =\
    \ levels[level] + 1\n        }\n        if parens_count == 11 {\n            levels[level]\
    \ = levels[level] + 1\n        }\n        if parens_count == 12 {\n          \
    \  levels[level] = levels[level] + 1\n        }\n        if parens_count == 13\
    \ {\n            levels[level] = levels[level] + 1\n        }\n        if parens_count\
    \ == 14 {\n            levels[level] = levels[level] + 1\n        }\n        if\
    \ parens_count == 15 {\n            levels[level] = levels[level] + 1\n      \
    \  }\n        if parens_count == 16 {\n            levels[level] = levels[level]\
    \ + 1\n        }\n        if parens_count == 17 {\n            levels[level] =\
    \ levels[level] + 1\n        }\n        if parens_count == 18 {\n            levels[level]\
    \ = levels[level] + 1\n        }\n        if parens_count == 19 {\n          \
    \  levels[level] = levels[level] + 1\n        }\n        if parens_count == 20\
    \ {\n            levels[level] = levels[level] + 1\n        }\n        if parens_count\
    \ == 21 {\n            levels[level] = levels[level] + 1\n        }\n        if\
    \ parens_count == 22 {\n            levels[level] = levels[level] + 1\n      \
    \  }\n        if parens_count == 23 {\n            levels[level] = levels[level]\
    \ + 1\n        }\n        if parens_count == 24 {\n            levels[level] =\
    \ levels[\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpu2x1slfs.swift:87:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpu2x1slfs.swift:104:67: error: expected '}' at end of brace statement\n\
    assert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])\n       \
    \                                                           ^\n/tmp/tmpu2x1slfs.swift:12:42:\
    \ note: to match this opening '{'\n    for c in paren_string.unicodeScalars {\n\
    \                                         ^\n/tmp/tmpu2x1slfs.swift:104:67: error:\
    \ expected '}' at end of brace statement\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])\n                                              \
    \                    ^\n/tmp/tmpu2x1slfs.swift:7:57: note: to match this opening\
    \ '{'\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n           \
    \                                             ^\n/tmp/tmpu2x1slfs.swift:86:35:\
    \ error: missing argument for parameter #1 in call\n            levels[level]\
    \ = levels[\n                                  ^\n                           \
    \       <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable\
    \ public subscript(index: Int) -> Element { get set }\n                      ^\n\
    /tmp/tmpu2x1slfs.swift:90:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var paren_level = 0\n    var\
    \ paren_levels = [Int]()\n    var paren_levels_count = 0\n    var paren_levels_count_max\
    \ = paren_levels_count + 1\n    var paren_levels_count_min = paren_levels_count\
    \ - 1\n    var paren_levels_count_max_index = paren_levels_count - 1\n    var\
    \ paren_levels_count_min_index = paren_levels_count - 1\n    var paren_levels_count_max_value\
    \ = paren_levels_count - 1\n    var paren_levels_count_min_value = paren_levels_count\
    \ - 1\n    var paren_levels_count_max_value_minus_1 = paren_levels_count - 1\n\
    \    var paren_levels_count_min_value_minus_1 = paren_levels_count - 1\n    var\
    \ paren_levels_count_max_value_minus_2 = paren_levels_count - 1\n    var paren_levels_count_min_value_minus_2\
    \ = paren_levels_count - 1\n    var paren_levels_count_max_value_minus_3 = paren_levels_count\
    \ - 1\n    var paren_levels_count_min_value_minus_3 = paren_levels_count - 1\n\
    \    var paren_levels_count_max_value_minus_4 = paren_levels_count - 1\n    var\
    \ paren_levels_count_min_value_minus_4 = paren_levels_count - 1\n    var paren_levels_count_max_value_minus_5\
    \ = paren_levels_count - 1\n    var paren_levels_count_min_value_minus_5 = paren_levels_count\
    \ - 1\n    var paren_levels_count_max_value_minus_6 = paren_levels_count - 1\n\
    \    var paren_levels_count_min_value_minus_6 = paren_levels_count - 1\n    var\
    \ paren_levels_count_max_value_minus_7 = paren_levels_count - 1\n    var paren_levels_count_min_value_minus_7\
    \ = paren_levels_count - 1\n    var paren_levels_count_max_value_minus_8 = paren_levels_count\
    \ - 1\n    var paren_levels_count_min_value_minus_8 = paren_levels_count - 1\n\
    \    var paren_levels_count_max_value_minus_9 = paren_levels_count - 1\n    var\
    \ paren_levels_count_min_value_minus_9 = paren_levels_count - 1\n    var paren_levels_count_max_value_minus_10\
    \ = paren_levels_count - 1\n    var paren_levels_count_min_value_minus_10 = paren_levels_count\
    \ - 1\n    var paren_levels_count_max_value_minus_11 = paren_levels_count - 1\n\
    \    var paren_levels_count_min_value_minus_11 = paren_levels_count - 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphnfplk2l.swift:8:9: warning: initialization of variable 'levels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var levels = [Int]()\n    ~~~~^~~~~~\n    _\n/tmp/tmphnfplk2l.swift:9:9: warning:\
    \ initialization of variable 'paren_level' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var paren_level = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmphnfplk2l.swift:10:9: warning: initialization of variable 'paren_levels'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var paren_levels = [Int]()\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmphnfplk2l.swift:11:9:\
    \ warning: variable 'paren_levels_count' was never mutated; consider changing\
    \ to 'let' constant\n    var paren_levels_count = 0\n    ~~~ ^\n    let\n/tmp/tmphnfplk2l.swift:12:9:\
    \ warning: initialization of variable 'paren_levels_count_max' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var paren_levels_count_max\
    \ = paren_levels_count + 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphnfplk2l.swift:13:9:\
    \ warning: initialization of variable 'paren_levels_count_min' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var paren_levels_count_min\
    \ = paren_levels_count - 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphnfplk2l.swift:14:9:\
    \ warning: initialization of variable 'paren_levels_count_max_index' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var paren_levels_count_max_index\
    \ = paren_levels_count - 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphnfplk2l.swift:15:9:\
    \ warning: initialization of variable 'paren_levels_count_min_index' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var paren_levels_count_min_index\
    \ = paren_levels_count - 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmphnfplk2l.swift:16:9:\
    \ warning: initialization of variable 'paren_levels_count_max_value' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var paren_levels_count_max_value\
    \ = pare"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var paren_count\
    \ = 0\n    var paren_level = 0\n    var paren_start = 0\n    var paren_end = 0\n\
    \    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren_start_idx\
    \ = 0\n    var paren_end_idx = 0\n    var paren_start_idx = 0\n    var paren_end_idx\
    \ = 0\n    var paren_start_idx = 0\n    var paren_end_idx = 0\n    var paren\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpfzqp3plm.swift:16:9: error: invalid redeclaration of 'paren_start_idx'\n\
    \    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:14:9: note: 'paren_start_idx'\
    \ previously declared here\n    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:17:9:\
    \ error: invalid redeclaration of 'paren_end_idx'\n    var paren_end_idx = 0\n\
    \        ^\n/tmp/tmpfzqp3plm.swift:15:9: note: 'paren_end_idx' previously declared\
    \ here\n    var paren_end_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:18:9: error:\
    \ invalid redeclaration of 'paren_start_idx'\n    var paren_start_idx = 0\n  \
    \      ^\n/tmp/tmpfzqp3plm.swift:14:9: note: 'paren_start_idx' previously declared\
    \ here\n    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:19:9: error:\
    \ invalid redeclaration of 'paren_end_idx'\n    var paren_end_idx = 0\n      \
    \  ^\n/tmp/tmpfzqp3plm.swift:15:9: note: 'paren_end_idx' previously declared here\n\
    \    var paren_end_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:20:9: error: invalid\
    \ redeclaration of 'paren_start_idx'\n    var paren_start_idx = 0\n        ^\n\
    /tmp/tmpfzqp3plm.swift:14:9: note: 'paren_start_idx' previously declared here\n\
    \    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:21:9: error: invalid\
    \ redeclaration of 'paren_end_idx'\n    var paren_end_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:15:9:\
    \ note: 'paren_end_idx' previously declared here\n    var paren_end_idx = 0\n\
    \        ^\n/tmp/tmpfzqp3plm.swift:22:9: error: invalid redeclaration of 'paren_start_idx'\n\
    \    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:14:9: note: 'paren_start_idx'\
    \ previously declared here\n    var paren_start_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:23:9:\
    \ error: invalid redeclaration of 'paren_end_idx'\n    var paren_end_idx = 0\n\
    \        ^\n/tmp/tmpfzqp3plm.swift:15:9: note: 'paren_end_idx' previously declared\
    \ here\n    var paren_end_idx = 0\n        ^\n/tmp/tmpfzqp3plm.swift:24:9: error:\
    \ invalid redeclaration of 'paren_start_idx'\n    var paren_start_idx = 0\n  \
    \      ^\n/tmp/tmpfzqp3plm.swift:14:9: note: 'paren_start_idx' previously declared\
    \ here\n    var paren_start_i"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var paren_count = 0\n    var\
    \ paren_level = 0\n    for c in paren_string {\n        if c == '(' {\n      \
    \      paren_count += 1\n        } else if c == ')' {\n            paren_count\
    \ -= 1\n            if paren_count == 0 {\n                levels.append(paren_level)\n\
    \            }\n        }\n        paren_level += (c == '(' ? 1 : -1)\n    }\n\
    \    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpcr0hnd_6.swift:12:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpcr0hnd_6.swift:14:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpcr0hnd_6.swift:20:30: error: single-quoted string literal\
    \ found, use '\"'\n        paren_level += (c == '(' ? 1 : -1)\n              \
    \               ^~~\n                             \"(\"\n"
  stdout: ''
  timestamp: 1659825102
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parens\
    \ = 0\n    for char in paren_string.characters {\n        switch char {\n    \
    \    case ')':\n            levels[level] = parens\n            parens = 0\n \
    \           level += 1\n        case ')':\n            parens += 1\n        default:\n\
    \            parens = 0\n        }\n    }\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvk5rr2u4.swift:13:14: error: single-quoted string literal found,\
    \ use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpvk5rr2u4.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpvk5rr2u4.swift:11:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvk5rr2u4.swift:17:14: warning: literal value is already\
    \ handled by previous pattern; consider removing it\n        case ')':\n     \
    \        ^~~\n/tmp/tmpvk5rr2u4.swift:13:14: note: first occurrence of identical\
    \ literal pattern is here\n        case ')':\n             ^~~\n"
  stdout: ''
  timestamp: 1659825102
