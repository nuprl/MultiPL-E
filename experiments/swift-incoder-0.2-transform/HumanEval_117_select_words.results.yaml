language: swift
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n   \
    \         i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \"a\" {\n            i += 1\n            if j == s.count {\n               \
    \ i += 1\n                j = 0\n                continue\n            }\n   \
    \         \n            if s[k] == \" \" {\n                j += 1\n         \
    \       continue\n            }\n            \n            if s[k] == \"a\" {\n\
    \                j += 1\n                k += 1\n                continue\n  \
    \          }\n            \n            if s[k] == \"e\" {\n                j\
    \ += 1\n                k += 1\n                continue\n            }\n    \
    \        \n            if s[k] == \"i\" {\n                j += 1\n          \
    \      k += 1\n                continue\n            }\n            \n       \
    \     if s[k] == \"o\" {\n                j += 1\n                k += 1\n   \
    \             continue\n            }\n            \n            if s[k] == \"\
    u\" {\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if s[k] == \"y\" {\n               \
    \ j += 1\n                k += 1\n                continue\n            }\n  \
    \          \n            if s[k] == \"s\" {\n                j += 1\n        \
    \        k += 1\n                continue\n            }\n            \n     \
    \       if s[k] == \"d\" {\n                j += 1\n                k += 1\n \
    \               continue\n            }\n            \n            if s[k] ==\
    \ \"h\" {\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if s[k] == \"l\" {\n               \
    \ j += 1\n                k += 1\n                continue\n            }\n  \
    \          \n            if s[k] == \"m\" {\n                j += 1\n        \
    \        k += 1\n                continue\n            }\n            \n     \
    \       if s[k] == \"n\" {\n                j += 1\n                k += 1\n \
    \               continue\n            }\n            \n            if s[k] ==\
    \ \"t\" {\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if s[k] == \"f\" {\n               \
    \ j += 1\n                k += 1\n                continue\n            }\n  \
    \          \n            if s[k] == \"l\" {\n                j += 1\n        \
    \        k += 1\n                continue\n            }\n            \n     \
    \       if s[k] == \"b\" {\n                j += 1\n                k += 1\n \
    \               continue\n            }\n            \n            if s[k] ==\
    \ \"p\" {\n                j += 1\n                k += 1\n                continue\n\
    \            }\n            \n            if s[k] == \"v\" {\n               \
    \ j += 1\n                k += 1\n                continue\n            }\n  \
    \          \n            if s[k] == \"r\" {\n                j += 1\n        \
    \        k += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpioohmmmt.swift:180:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpioohmmmt.swift:35:24:\
    \ note: to match this opening '{'\n        if s[i] == \"a\" {\n              \
    \         ^\n/tmp/tmpioohmmmt.swift:180:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpioohmmmt.swift:29:23: note: to match this opening '{'\n    while\
    \ i < s.count {\n                      ^\n/tmp/tmpioohmmmt.swift:180:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpioohmmmt.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpioohmmmt.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpioohmmmt.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpioohmmmt.swift:43:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[k] == \" \" {\n              \
    \ ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpioohmmmt.swift:48:16:\
    \ error: "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words = s.split(separator: \" \"\
    )\n    \n    var result = [String]()\n    \n    for word in words {\n        if\
    \ word.hasPrefix(\"consonant\") {\n            if word.hasSuffix(\"consonant\"\
    ) {\n                if word.hasPrefix(\"consonant\") {\n                    if\
    \ word.hasSuffix(\"consonant\") {\n                        if word.hasPrefix(\"\
    consonant\") {\n                            if word.hasSuffix(\"consonant\") {\n\
    \                                if word.hasPrefix(\"consonant\") {\n        \
    \                            if word.hasSuffix(\"consonant\") {\n            \
    \                            if word.hasPrefix(\"consonant\") {\n            \
    \                                if word.hasSuffix(\"consonant\") {\n        \
    \                                        if word.hasPrefix(\"consonant\") {\n\
    \                                                    if word.hasSuffix(\"consonant\"\
    ) {\n                                                        if word.hasPrefix(\"\
    consonant\") {\n                                                            if\
    \ word.hasSuffix(\"consonant\") {\n                                          \
    \                      if word.hasPrefix(\"consonant\") {\n                  \
    \                                                  if word.hasSuffix(\"consonant\"\
    ) {\n                                                                        if\
    \ word.hasPrefix(\"consonant\") {\n                                          \
    \                                  if word.hasSuffix(\"consonant\") {\n      \
    \                                                                          if\
    \ word.hasPrefix(\"consonant\") {\n                                          \
    \                                          if word.hasSuffix(\"consonant\") {\n\
    \                                                                            \
    \            if word.hasPrefix(\"consonant\") {\n                            \
    \                                                                if word.hasSuffix(\"\
    consonant\") {\n                                                             \
    \                                   if word.hasPrefix(\"consonant\") {\n     \
    \                                                                            \
    \                   if word.hasSuffix(\"consonant\") {\n                     \
    \                                                                            \
    \       if word.hasPrefix(\"consonant\") {\n                                 \
    \                                                                           if\
    \ word.hasSuffix(\"consonant\") {\n                                          \
    \                                                                      if word.hasPrefix(\"\
    consonant\") {\n                                                             \
    \                                                       if word.hasSuffix(\"consonant\"\
    ) {\n                                                                        \
    \                                                if word.hasPrefix(\"consonant\"\
    ) {\n                                                                        \
    \                                                    if word.hasSuffix(\"consonant\"\
    ) {\n                                                                        \
    \                                                        if word.hasPrefix(\"\
    consonant\") {\n                                                             \
    \                                                                       if word.hasSuffix(\"\
    consonant\") {\n                                                             \
    \                                                                           if\
    \ word.hasPrefix(\"consonant\") {\n                                          \
    \                                                                            \
    \                      if word.hasSuffix(\"consonant\") {\n                  \
    \                                                                            \
    \                                                  if word.hasPrefix(\"consonant\"\
    ) {\n                                                                        \
    \                                                                            if\
    \ word.hasSuffix(\"consonant\") {\n                                          \
    \                                                                            \
    \                                  if word.hasPrefix(\"consonant\") {\n      \
    \                                                                            \
    \                                                                          if\
    \ word.hasSuffix(\"consonant\") {\n                                          \
    \                                                                            \
    \                                          if word.hasPrefix(\"consonant\") {\n\
    \                                                                            \
    \                                                                            \
    \            if word.hasSuffix(\"consonant\") {\n                            \
    \                                                                            \
    \                                                                if word.hasPrefix(\"\
    consonant\") {\n                                                             \
    \                                                                            \
    \                                   if word.hasSuffix(\"consonant\") {\n     \
    \                                                                            \
    \                                                                            \
    \                   if word.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpna8q63g7.swift:67:184: error: expected member name following '.'\n\
    \                                                                            \
    \                                                                            \
    \                        if word.\n                                          \
    \                                                                            \
    \                                                                 ^\n/tmp/tmpna8q63g7.swift:67:185:\
    \ error: expected '{' after 'if' condition\n                                 \
    \                                                                            \
    \                                                                   if word.\n\
    \                                                                            \
    \                                                                            \
    \                                ^\n/tmp/tmpna8q63g7.swift:89:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmpna8q63g7.swift:65:200: note: to match this\
    \ opening '{'\n                                                              \
    \                                                                            \
    \                              if word.hasPrefix(\"consonant\") {\n          \
    \                                                                            \
    \                                                                            \
    \                                     ^\n/tmp/tmpna8q63g7.swift:89:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpna8q63g7.swift:64:196: note: to match\
    \ this opening '{'\n                                                         \
    \                                                                            \
    \                               if word.hasSuffix(\"consonant\") {\n       "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    \n    var count = 0\n    var last = 0\n\
    \    var lastCount = 0\n    var lastLast = 0\n    \n    for c in s {\n       \
    \ if c == \" \" {\n            if count > n {\n                break\n       \
    \     }\n            count = 0\n        } else {\n            count += 1\n   \
    \     }\n        last = lastCount\n        lastCount = count\n        lastLast\
    \ = last\n    }\n    \n    if count > n {\n        return result\n    }\n    \n\
    \    for c in s {\n        if c == \" \" {\n            if count > n {\n     \
    \           break\n            }\n            count = 0\n        } else {\n  \
    \          count += 1\n        }\n        last = lastCount\n        lastCount\
    \ = count\n        lastLast = last\n    }\n    \n    if count > n {\n        return\
    \ result\n    }\n    \n    for c in s {\n        if c == \" \" {\n           \
    \ if count > n {\n                break\n            }\n            count = 0\n\
    \        } else {\n            count += 1\n        }\n        last = lastCount\n\
    \        lastCount = count\n        lastLast = last\n    }\n    \n    if count\
    \ > n {\n        return result\n    }\n    \n    for c in s {\n        if c ==\
    \ \" \" {\n            if count > n {\n                break\n            }\n\
    \            count = 0\n        } else {\n            count += 1\n        }\n\
    \        last = lastCount\n        lastCount = count\n        lastLast = last\n\
    \    }\n    \n    if count > n {\n        return result\n    }\n    \n    for\
    \ c in s {\n        if c == \" \" {\n            if count > n {\n            \
    \    break\n            }\n            count = 0\n        } else {\n         \
    \   count += 1\n        }\n        last = lastCount\n        lastCount = count\n\
    \        lastLast = last\n    }\n    \n    if count > n {\n        return result\n\
    \    }\n    \n    for c in s {\n        if c == \" \" {\n            if count\
    \ > n {\n                break\n            }\n            count = 0\n       \
    \ } else {\n            count += 1\n        }\n        last = lastCount\n    \
    \    lastCount = count\n        lastLast = last\n    }\n    \n    if count > n\
    \ {\n        return result\n    }\n    \n    for c in s {\n        if c == \"\
    \ \" {\n            if count > n {\n                break\n            }\n   \
    \         count = 0\n        } else {\n            count += 1\n        }\n   \
    \     last = lastCount\n        lastCount = count\n        lastLast = last\n \
    \   }\n    \n    if count > n {\n        return result\n    }\n    \n    for c\
    \ in s {\n        if c == \" \" {\n            if count > n {\n              \
    \  break\n            }\n            count = 0\n        } else {\n           \
    \ count += 1\n        }\n        last = lastCount\n        lastCount = count\n\
    \        lastLast = last\n    }\n    \n    if count > n {\n        return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph52pqufd.swift:192:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmph52pqufd.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmph52pqufd.swift:174:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmph52pqufd.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n/tmp/tmph52pqufd.swift:27:9:\
    \ warning: variable 'lastLast' was written to, but never read\n    var lastLast\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s.characters {\n        if char == \" \" {\n           \
    \ i += 1\n        }\n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n       \
    \ if j == n {\n            result.append(String(s[i:j]))\n            j = i\n\
    \            j = 0\n            i = 0\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsyhc_lyw.swift:28:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsyhc_lyw.swift:36:35:\
    \ error: extraneous argument label 'i:' in subscript\n            result.append(String(s[i:j]))\n\
    \                                  ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words: [String] = []\n    if s == \"\"\
    \ {\n        return words\n    }\n    var index = 0\n    var count = 0\n    for\
    \ c in s {\n        if c == \" \" {\n            words.append(s[index:s.startIndex])\n\
    \            index = s.startIndex\n            count = 0\n        } else {\n \
    \           count += 1\n            if count == n {\n                words.append(s[index:s.startIndex])\n\
    \                index = s.startIndex\n                count = 0\n           \
    \ }\n        }\n    }\n    words.append(s[index:s.startIndex])\n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_0zw38rm.swift:27:27: error: extraneous argument label 'index:'\
    \ in subscript\n            words.append(s[index:s.startIndex])\n            \
    \              ^~~~~~~\n                           \n/tmp/tmp_0zw38rm.swift:28:23:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  index = s.startIndex\n                    ~~^~~~~~~~~~\n/tmp/tmp_0zw38rm.swift:33:31:\
    \ error: extraneous argument label 'index:' in subscript\n                words.append(s[index:s.startIndex])\n\
    \                              ^~~~~~~\n                               \n/tmp/tmp_0zw38rm.swift:34:27:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \      index = s.startIndex\n                        ~~^~~~~~~~~~\n/tmp/tmp_0zw38rm.swift:39:19:\
    \ error: extraneous argument label 'index:' in subscript\n    words.append(s[index:s.startIndex])\n\
    \                  ^~~~~~~\n                   \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return s.split(\" \").filter{ $0.characters.count\
    \ >= n }.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm635hyjc.swift:19:20: error: missing argument label 'separator:'\
    \ in call\n    return s.split(\" \").filter{ $0.characters.count >= n }.sorted()\n\
    \                   ^\n                   separator: \n/tmp/tmpm635hyjc.swift:19:60:\
    \ error: cannot convert return expression of type '[String.SubSequence]' (aka\
    \ 'Array<Substring>') to return type '[String]'\n    return s.split(\" \").filter{\
    \ $0.characters.count >= n }.sorted()\n                                      \
    \                     ^\n/tmp/tmpm635hyjc.swift:19:60: note: arguments to generic\
    \ parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are\
    \ expected to be equal\n    return s.split(\" \").filter{ $0.characters.count\
    \ >= n }.sorted()\n                                                          \
    \ ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: Write your code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp0pzjovvn/tmp0pzjovvn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad949a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad94975ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad94975a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9497597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0pzjovvn                        0x0000556130d4f4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ad949c4f460 __libc_start_main +
    245

    6    tmp0pzjovvn                        0x0000556130d4f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    \n    var result = [String]()\n    \n    for word in words {\n    \
    \    let letters = word.componentsSeparatedByString(\"\")\n        \n        if\
    \ letters.count == n {\n            result.append(word)\n        }\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw76woy51.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw9yjym0b.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw9yjym0b.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n \
    \   var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n  \
    \  var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n   \
    \ var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var\
    \ f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k\
    \ = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p =\
    \ 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n\
    \    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n \
    \   var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n  \
    \  var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n   \
    \ var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\
    \ p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u\
    \ = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z =\
    \ 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n\
    \    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n  \
    \  var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n   \
    \ var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var\
    \ z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e\
    \ = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv2zc5qvx.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv2zc"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            continue\n        }\n        if char == \"y\" {\n     \
    \       if s.count > n {\n                continue\n            }\n        }\n\
    \        if char == \"n\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if char == \"h\" {\n            if s.count\
    \ > n {\n                continue\n            }\n        }\n        if char ==\
    \ \"r\" {\n            if s.count > n {\n                continue\n          \
    \  }\n        }\n        if char == \"d\" {\n            if s.count > n {\n  \
    \              continue\n            }\n        }\n        if char == \"s\" {\n\
    \            if s.count > n {\n                continue\n            }\n     \
    \   }\n        if char == \"t\" {\n            if s.count > n {\n            \
    \    continue\n            }\n        }\n        if char == \"c\" {\n        \
    \    if s.count > n {\n                continue\n            }\n        }\n  \
    \      if char == \"k\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if char == \"m\" {\n            if s.count\
    \ > n {\n                continue\n            }\n        }\n        if char ==\
    \ \"l\" {\n            if s.count > n {\n                continue\n          \
    \  }\n        }\n        if char == \"f\" {\n            if s.count > n {\n  \
    \              continue\n            }\n        }\n        if char == \"p\" {\n\
    \            if s.count > n {\n                continue\n            }\n     \
    \   }\n        if char == \"v\" {\n            if s.count > n {\n            \
    \    continue\n            }\n        }\n        if char == \"b\" {\n        \
    \    if s.count > n {\n                continue\n            }\n        }\n  \
    \      if char == \"j\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if char == \"m\" {\n            if s.count\
    \ > n {\n                continue\n            }\n        }\n        if char ==\
    \ \"o\" {\n            if s.count > n {\n                continue\n          \
    \  }\n        }\n        if char == \"n\" {\n            if s.count > n {\n  \
    \              continue\n            }\n        }\n        if char == \"i\" {\n\
    \            if s.count > n {\n                continue\n            }\n     \
    \   }\n        if char == \"e\" {\n            if s.count > n {\n            \
    \    continue\n            }\n        }\n        if char == \"l\" {\n        \
    \    if s.count > n {\n                continue\n            }\n        }\n  \
    \      if char == \"u\" {\n            if s.count > n {\n                continue\n\
    \            }\n        }\n        if char == \"a\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzf8jhciy.swift:142:20: error: unterminated string literal\n   \
    \     if char == \"a\n                   ^\n/tmp/tmpzf8jhciy.swift:164:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpzf8jhciy.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpzf8jhciy.swift:146:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for char in s {\n        if char == \" \" {\n       \
    \     j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            k = i\n     \
    \   }\n        \n        if char == \" \" {\n            i = k\n        }\n  \
    \      \n        if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n            i = k\n        }\n        \n        if\
    \ char == \" \" {\n            i = k\n        }\n        \n        if char ==\
    \ \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\
    \            i = k\n        }\n        \n        if char == \" \" {\n        \
    \    i = k\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = k\n     \
    \   }\n        \n        if char == \" \" {\n            i = k\n        }\n  \
    \      \n        if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n            i = k\n        }\n        \n        if\
    \ char == \" \" {\n            i = k\n        }\n        \n        if char ==\
    \ \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\
    \            i = k\n        }\n        \n        if char == \" \" {\n        \
    \    i = k\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = k\n     \
    \   }\n        \n        if char == \" \" {\n            i = k\n        }\n  \
    \      \n        if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n            i = k\n        }\n        \n        if\
    \ char == \" \" {\n            i = k\n        }\n        \n        if char ==\
    \ \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\
    \            i = k\n        }\n        \n        if char == \" \" {\n        \
    \    i = k\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = k\n     \
    \   }\n        \n        if char == \" \" {\n            i = k\n        }\n  \
    \      \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpha8rc9eo.swift:136:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpha8rc9eo.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpha8rc9eo.swift:118:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpha8rc9eo.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n/tmp/tmpha8rc9eo.swift:26:9:\
    \ warning: variable 'j' was written to, but never read\n    var j = 0\n      \
    \  ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let vowels = \"aeiouAEIOU\"\n\
    \    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2buoifxp.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    let chars = s.characters\n  \
    \  \n    for char in chars {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            words.append(String(char))\n        }\n    }\n\
    \    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcsc60_tv.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcsc60_tv.swift:28:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n     \
    \       j = i\n            \n            for k < s.count {\n                if\
    \ s[k] == \" \" {\n                    k = k + 1\n                } else {\n \
    \                   break\n                }\n            }\n            \n  \
    \          if k == s.count {\n                result.insert(i, s.substringWithRange(s.startIndex.advancedBy(i),\
    \ s.startIndex.advancedBy(j)))\n                i = j + 1\n            }\n   \
    \     } else {\n            i = i + 1\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv8vtvpgn.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpv8vtvpgn.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpv8vtvpgn.swift:33:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpv8vtvpgn.swift:33:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpv8vtvpgn.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpv8vtvpgn.swift:33:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    while i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if j == n {\n            result.append(String(s[i..<s.endIndex]))\n\
    \            i = s.endIndex\n            \n            if i == s.endIndex {\n\
    \                break\n            }\n            \n            j = 0\n     \
    \   }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n \
    \       \n        j += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7w1qv7w0.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp7w1qv7w0.swift:34:36: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.Index'\n            result.append(String(s[i..<s.endIndex]))\n\
    \                                   ^\n/tmp/tmp7w1qv7w0.swift:35:19: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            i = s.endIndex\n\
    \                ~~^~~~~~~~\n/tmp/tmp7w1qv7w0.swift:37:18: error: operator function\
    \ '==' requires that 'String.Index' conform to 'BinaryInteger'\n            if\
    \ i == s.endIndex {\n                 ^\nSwift.BinaryInteger:2:24: note: where\
    \ 'Other' = 'String.Index'\n    public static func == <Other>(lhs: Self, rhs:\
    \ Other) -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp7w1qv7w0.swift:44:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    for letter in s {\n    \
    \    if letter == \" \" {\n            if i == n {\n                break\n  \
    \          }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" ||\
    \ letter == \"u\" {\n            if i == n {\n                break\n        \
    \    }\n            i += 1\n            continue\n        }\n        if letter\
    \ == \"y\" || letter == \"s\" || letter == \"d\" || letter == \"r\" || letter\
    \ == \"t\" {\n            if i == n {\n                break\n            }\n\
    \            i += 1\n            continue\n        }\n        if letter == \"\
    n\" || letter == \"l\" || letter == \"m\" || letter == \"p\" {\n            if\
    \ i == n {\n                break\n            }\n            i += 1\n       \
    \     continue\n        }\n        if letter == \"c\" || letter == \"h\" || letter\
    \ == \"k\" || letter == \"v\" {\n            if i == n {\n                break\n\
    \            }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"b\" || letter == \"f\" || letter == \"j\" || letter == \"x\" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter == \"k\" || letter\
    \ == \"q\" || letter == \"p\" || letter == \"v\" {\n            if i == n {\n\
    \                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"m\" || letter == \"n\" || letter == \"r\" ||\
    \ letter == \"s\" {\n            if i == n {\n                break\n        \
    \    }\n            i += 1\n            continue\n        }\n        if letter\
    \ == \"w\" || letter == \"x\" || letter == \"z\" {\n            if i == n {\n\
    \                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"t\" || letter == \"v\" || letter == \"b\" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter == \"d\" || letter\
    \ == \"j\" || letter == \"s\" {\n            if i == n {\n                break\n\
    \            }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"f\" || letter == \"h\" || letter == \"x\" {\n            if i ==\
    \ n {\n                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"e\" || letter == \"g\" || letter == \"m\" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter == \"a\" || letter\
    \ == \"i\" || letter == \"o\" {\n            if i == n {\n                break\n\
    \            }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"u\" || letter == \"o\" || letter == \"n\" {\n            if i ==\
    \ n {\n                break\n            }\n            i += 1\n            continue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppw0retp2.swift:150:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmppw0retp2.swift:24:21:\
    \ note: to match this opening '{'\n    for letter in s {\n                   \
    \ ^\n/tmp/tmppw0retp2.swift:150:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmppw0retp2.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmppw0retp2.swift:132:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmppw0retp2.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    var i = 0\n \
    \   for c in s {\n        if c.isLetterOrDigit() {\n            if i == n {\n\
    \                words.append(String(s[i:]))\n                i = 0\n        \
    \    }\n            i += 1\n        }\n    }\n    if i != 0 {\n        words.append(String(s[i:]))\n\
    \    }\n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpox382n5h.swift:24:41: error: expected expression in list of expressions\n\
    \                words.append(String(s[i:]))\n                               \
    \         ^\n/tmp/tmpox382n5h.swift:31:33: error: expected expression in list\
    \ of expressions\n        words.append(String(s[i:]))\n                      \
    \          ^\n/tmp/tmpox382n5h.swift:22:14: error: value of type 'Character' has\
    \ no member 'isLetterOrDigit'\n        if c.isLetterOrDigit() {\n           ~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpox382n5h.swift:24:41: error: missing argument for parameter\
    \ #1 in call\n                words.append(String(s[i:]))\n                  \
    \                      ^\n                                        <#String.Index#>\n\
    Swift.String:12:12: note: 'subscript(_:)' declared here\n    public subscript(i:\
    \ String.Index) -> Character { get }\n           ^\n/tmp/tmpox382n5h.swift:31:33:\
    \ error: missing argument for parameter #1 in call\n        words.append(String(s[i:]))\n\
    \                                ^\n                                <#String.Index#>\n\
    Swift.String:12:12: note: 'subscript(_:)' declared here\n    public subscript(i:\
    \ String.Index) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char.unicodeScalars.count >= n {\n            result.append(String(char))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcv9g6szr.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.hasConsonant() {\n            if result.count < n {\n       \
    \         result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdos79155.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdos79155.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i += 1\n  \
    \      }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n       \
    \ \n        if j == n {\n            result.append(String(s[i:j]))\n         \
    \   i = j\n            j = 0\n        }\n    }\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7n58rr9s.swift:38:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014487
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for letter in s.characters {\n\
    \        if letter.isConsonant() {\n            if result.count < n {\n      \
    \          result.append(String(letter))\n            }\n        }\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq1qjxbu4.swift:25:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpq1qjxbu4.swift:26:19:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if letter.isConsonant()\
    \ {\n           ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for letter in\
    \ s {\n        if letter == \" \" {\n            continue\n        }\n       \
    \ if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\" {\n            continue\n        }\n        if letter ==\
    \ \"y\" {\n            if s.count > 1 {\n                let start = s.startIndex\n\
    \                let end = s.endIndex\n                let sub = s[start..<end]\n\
    \                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"n\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"h\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"r\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"d\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"s\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"c\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n        if\
    \ letter == \"t\" {\n            if s.count > 1 {\n                let start =\
    \ s.startIndex\n                let end = s.endIndex\n                let sub\
    \ = s[start..<end]\n                if sub.count > n {\n                    result.append(sub)\n\
    \                }\n            }\n            continue\n        }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph8fmy1fc.swift:136:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmph8fmy1fc.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmph8fmy1fc.swift:33:28:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \      result.append(sub)\n                           ^\nSwift.Array:6:37: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'Substring')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Substring')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmph8fmy1fc.swift:33:28: note: found\
    \ candidate with type '(__owned Substring) -> ()'\n                    result.append(sub)\n\
    \                           ^\n/tmp/tmph8fmy1fc.swift:44:28: error: no exact matches\
    \ in call to instance method 'append'\n                    result.append(sub)\n\
    \                           ^\nSwift.Array:6:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'Substring')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'Substring')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Self.Element)\n                          \
    \          ^\n/tmp/tmph8fmy1fc.swift:44:28: note: found candidate with type '(__owned\
    \ Substring) -> ()'\n                    result.append(sub)\n                \
    \           ^\n/tmp/tmph8fmy1fc.swift:55:28: error: no exact matches in call to\
    \ instance method 'append'\n                    result.append(sub)\n       "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i += 1\n  \
    \      }\n        if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n            j += 1\n        }\n        if j == n {\n\
    \            result.append(String(s[i:j]))\n            i = j\n            j =\
    \ 0\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_388jqye.swift:36:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            continue\n        }\n        \n        if char == \"n\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if char == \"c\" || char == \"h\" || char\
    \ == \"l\" || char == \"o\" || char == \"r\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"d\" || char == \"s\" || char == \"t\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"f\" || char == \"v\" || char == \"y\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"g\" || char == \"b\" {\n            if s.characters.count > n\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ char == \"m\" || char == \"p\" {\n            if s.characters.count > n {\n\
    \                continue\n            }\n        }\n        \n        if char\
    \ == \"t\" || char == \"k\" {\n            if s.characters.count > n {\n     \
    \           continue\n            }\n        }\n        \n        if char == \"\
    j\" {\n            if s.characters.count > n {\n                continue\n   \
    \         }\n        }\n        \n        if char == \"q\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"z\" {\n            if s.characters.count > n {\n             \
    \   continue\n            }\n        }\n        \n        if char == \"x\" {\n\
    \            if s.characters.count > n {\n                continue\n         \
    \   }\n        }\n        \n        if char == \"z\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"y\" {\n            if s.characters.count > n {\n             \
    \   continue\n            }\n        }\n        \n        if char == \"k\" {\n\
    \            if s.characters.count > n {\n                continue\n         \
    \   }\n        }\n        \n        if char == \"p\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"m\" {\n            if s.characters.count > n {\n             \
    \   continue\n            }\n        }\n        \n        if char == \"b\" {\n\
    \            if s.characters.count > n {\n                continue\n         \
    \   }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo1bplt51.swift:160:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpo1bplt51.swift:25:30:\
    \ note: to match this opening '{'\n    for char in s.characters {\n          \
    \                   ^\n/tmp/tmpo1bplt51.swift:160:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpo1bplt51.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpo1bplt51.swift:25:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpo1bplt51.swift:39:18: error: 'characters' is unavailable: Please\
    \ use String directly\n            if s.characters.count > n {\n             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpo1bplt51.swift:45:18:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if s.characters.count > n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpo1bplt51.swift:51:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ > n {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpo1bplt51.swift:57:18: error: 'characters' is unavailable:\
    \ Please use String directly\n            if s.characters.count > n {\n      \
    \           ^~~~~~~~~~\nSwift.String:5:16: "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var count =\
    \ 0\n    for letter in s.characters {\n        if letter == \" \" {\n        \
    \    count += 1\n            if count == n {\n                result.append(String(letter))\n\
    \                count = 0\n            }\n        } else {\n            count\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9l3wcwve.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    var result = [String]()\n    \n    for word in words {\n        let\
    \ letters = word.componentsSeparatedByString(\"\")\n        \n        if letters.count\
    \ == n {\n            result.append(word)\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiprr6rve.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // Your code here\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            result.append(String(char))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxvakagmp.swift:21:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxvakagmp.swift:22:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.isConsonant() {\n            if result.count < n {\n        \
    \        result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk1gprkbs.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk1gprkbs.swift:26:17:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if char.isConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // Your code here\n    \n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpbme81adc/tmpbme81adc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4df948c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4df63fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4df63f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4df63e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbme81adc                        0x00005560d105b4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab4dfb34460 __libc_start_main +
    245

    6    tmpbme81adc                        0x00005560d105b0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    while i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"n\" {\n \
    \           i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"t\" || s[i] == \"s\" || s[i] == \"h\" || s[i] == \"r\" || s[i] == \"d\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"l\" || s[i] == \"b\" || s[i] == \"m\" || s[i] == \"p\" || s[i] ==\
    \ \"f\" || s[i] == \"v\" || s[i] == \"y\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"c\" || s[i] == \"k\" || s[i] == \"\
    q\" || s[i] == \"x\" || s[i] == \"z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"A\" || s[i] == \"E\" || s[i] == \"\
    I\" || s[i] == \"O\" || s[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"N\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"T\" || s[i] == \"S\"\
    \ || s[i] == \"H\" || s[i] == \"R\" || s[i] == \"D\" {\n            i += 1\n \
    \           continue\n        }\n        \n        if s[i] == \"L\" || s[i] ==\
    \ \"B\" || s[i] == \"M\" || s[i] == \"P\" || s[i] == \"F\" || s[i] == \"V\" ||\
    \ s[i] == \"Y\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"C\" || s[i] == \"K\" || s[i] == \"Q\" || s[i] == \"\
    X\" || s[i] == \"Z\" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \"0\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"1\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"2\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"3\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"4\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"5\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"6\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"7\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"8\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"9\" {\n\
    \            i += 1\n            continue\n        }\n        \n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7qoxemq0.swift:156:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp7qoxemq0.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp7qoxemq0.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7qoxemq0.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7qoxemq0.swift:34:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7qoxemq0.swift:34:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp7qoxemq0.swift:34:57: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] ="
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n\
    \ {\n            result.append(String(char))\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplmrsf9z4.swift:21:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isConsonant'\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n                                        ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    var i = 0\n    var j = 0\n  \
    \  \n    while i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \            continue\n        }\n        \n        if j == n {\n            words.append(String(s[i..<s.endIndex]))\n\
    \            i = s.endIndex\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<s.endIndex]))\n            }\n    \
    \        \n            i += 1\n            \n            if i == s.endIndex {\n\
    \                words.append(String(s[i..<\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp51fngyqf.swift:130:1: error: expected ']' in expression list\n\
    }\n^\n/tmp/tmp51fngyqf.swift:129:38: note: to match this opening '['\n       \
    \         words.append(String(s[i..<\n                                     ^\n\
    /tmp/tmp51fngyqf.swift:151:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp51fngyqf.swift:34:19:\
    \ note: to match this opening '{'\n        if j == n {\n                  ^\n\
    /tmp/tmp51fngyqf.swift:151:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp51fngyqf.swift:28:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmp51fngyqf.swift:151:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp51fngyqf.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp51fngyqf.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp51fngyqf.swift:35:35:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            words.append(String(s[i..<s.endIndex]))\n                       \
    \           ^\n/tmp/tmp51fngyqf.swift:36:19: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n            i = s.endIndex\n                ~~^~~~~~~~\n\
    /tmp/tmp51fngyqf.swift:38:18: error: operator function '==' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n            if i ="
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.hasConsonant() {\n            if result.count < n {\n       \
    \         result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdos79155.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdos79155.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.characters.count {\n        if s.characters[i]\
    \ == 'a' || s.characters[i] == 'e' || s.characters[i] == 'i' || s.characters[i]\
    \ == 'o' || s.characters[i] == 'u' {\n            i = i + 1\n        } else if\
    \ s.characters[i] == 'b' || s.characters[i] == 'c' || s.characters[i] == 'd' ||\
    \ s.characters[i] == 'f' || s.characters[i] == 'g' || s.characters[i] == 'h' ||\
    \ s.characters[i] == 'j' || s.characters[i] == 'k' || s.characters[i] == 'l' ||\
    \ s.characters[i] == 'm' || s.characters[i] == 'n' || s.characters[i] == 'p' ||\
    \ s.characters[i] == 'q' || s.characters[i] == 'r' || s.characters[i] == 's' ||\
    \ s.characters[i] == 't' || s.characters[i] == 'v' || s.characters[i] == 'w' ||\
    \ s.characters[i] == 'x' || s.characters[i] == 'y' || s.characters[i] == 'z' {\n\
    \            i = i + 1\n        } else if s.characters[i] == 'A' || s.characters[i]\
    \ == 'E' || s.characters[i] == 'I' || s.characters[i] == 'O' || s.characters[i]\
    \ == 'U' {\n            i = i + 1\n        } else if s.characters[i] == 'B' ||\
    \ s.characters[i] == 'C' || s.characters[i] == 'D' || s.characters[i] == 'F' ||\
    \ s.characters[i] == 'G' || s.characters[i] == 'H' || s.characters[i] == 'J' ||\
    \ s.characters[i] == 'K' || s.characters[i] == 'L' || s.characters[i] == 'M' ||\
    \ s.characters[i] == 'N' || s.characters[i] == 'P' || s.characters[i] == 'Q' ||\
    \ s.characters[i] == 'R' || s.characters[i] == 'S' || s.characters[i] == 'T' ||\
    \ s.characters[i] == 'V' || s.characters[i] == 'W' || s.characters[i] == 'X' ||\
    \ s.characters[i] == 'Y' || s.characters[i] == 'Z' {\n            i = i + 1\n\
    \        } else {\n            if s.characters[j] == s.characters[i] {\n     \
    \           j = j + 1\n            } else {\n                if s.characters[k]\
    \ == s.characters[i] {\n                    k = k + 1\n                } else\
    \ {\n                    if s.characters[k] == s.characters[j] {\n           \
    \             k = k + 1\n                    } else {\n                      \
    \  if s.characters[k] == s.characters[j] && s.characters[k] == s.characters[i]\
    \ {\n                            k = k + 1\n                        } else {\n\
    \                            if s.characters[k] == s.characters[j] && s.characters[k]\
    \ == s.characters[i] && s.characters[k] == s.characters[k] {\n               \
    \                 k = k + 1\n                            } else {\n          \
    \                      if s.characters[k] == s.characters[j] && s.characters[k\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpynxr1ze0.swift:30:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] == 'a' || s.characters[i] == 'e' || s.characters[i]\
    \ == 'i' || s.characters[i] == 'o' || s.characters[i] == 'u' {\n             \
    \                 ^~~\n                              \"a\"\n/tmp/tmpynxr1ze0.swift:30:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[i]\
    \ == 'a' || s.characters[i] == 'e' || s.characters[i] == 'i' || s.characters[i]\
    \ == 'o' || s.characters[i] == 'u' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"e\"\n/tmp/tmpynxr1ze0.swift:30:83: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] == 'a' || s.characters[i] == 'e' || s.characters[i]\
    \ == 'i' || s.characters[i] == 'o' || s.characters[i] == 'u' {\n             \
    \                                                                     ^~~\n  \
    \                                                                            \
    \    \"i\"\n/tmp/tmpynxr1ze0.swift:30:109: error: single-quoted string literal\
    \ found, use '\"'\n        if s.characters[i] == 'a' || s.characters[i] == 'e'\
    \ || s.characters[i] == 'i' || s.characters[i] == 'o' || s.characters[i] == 'u'\
    \ {\n                                                                        \
    \                                    ^~~\n                                   \
    \                                                                         \"o\"\
    \n/tmp/tmpynxr1ze0.swift:30:135: error: single-quoted string literal found, use\
    \ '\"'\n        if s.characters[i] == 'a' || s.characters[i] == 'e' || s.characters[i]\
    \ == 'i' || s.characters[i] == 'o' || s.characters[i] == 'u' {\n             \
    \                                                                            \
    \                                             ^~~\n                          \
    \                                                                            \
    \                                \"u\"\n/tmp/tmpynxr1ze0.swift:32:38: error: single-quoted\
    \ string literal found, use '\"'\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char.hasConsonants {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpls_oh7s_.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpls_oh7s_.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.unicodeScalars.count >= n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumpkutg1.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n       \
    \     result.append(String(char))\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgbhtejkf.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgbhtejkf.swift:30:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n            continue\n        }\n        \n        if char == \"\
    n\" {\n            if n == 1 {\n                result.append(s)\n           \
    \ } else {\n                result.append(s.substringToIndex(s.startIndex.advancedBy(n)))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt78eo9is.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt78eo9is.swift:38:33:\
    \ error: value of type 'String' has no member 'substringToIndex'\n           \
    \     result.append(s.substringToIndex(s.startIndex.advancedBy(n)))\n        \
    \                      ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpt78eo9is.swift:38:63: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n                result.append(s.substringToIndex(s.startIndex.advancedBy(n)))\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let vowels = \"aeiouAEIOU\"\n\
    \    \n    for letter in s.characters {\n        if vowels.contains(String(letter))\
    \ {\n            if result.count < n {\n                result.append(String(letter))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6im8cxoj.swift:27:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n     \
    \       j = i\n            \n            while j < s.count && s[j] != \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         k = j\n            \n            while k < s.count && s[k] != \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            i = k\n        }\n        \n        if s[i] == \"a\" || s[i]\
    \ == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j\
    \ = i\n            \n            while j < s.count && s[j] != \" \" {\n      \
    \          j += 1\n            }\n            \n            if j == s.count {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     k = j\n            \n            while k < s.count && s[k] != \" \" {\n\
    \                k += 1\n            }\n            \n            if k == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i = k\n        }\n        \n        if s[i] == \"n\" {\n           \
    \ j = i\n            \n            while j < s.count && s[j] != \" \" {\n    \
    \            j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         k = j\n            \n            while k < s.count && s[k] != \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            i = k\n        }\n        \n        if s[i] == \"t\" || s[i]\
    \ == \"s\" || s[i] == \"h\" || s[i] == \"r\" || s[i] == \"d\" {\n            j\
    \ = i\n            \n            while j < s.count && s[j] != \" \" {\n      \
    \          j += 1\n            }\n            \n            if j == s.count {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     k = j\n            \n            while k < s.count && s[k] != \" \" {\n\
    \                k += 1\n            }\n            \n            if k == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i = k\n        }\n        \n        if s[i] == \"b\" || s[i] == \"c\"\
    \ || s[i] == \"d\" || s[i] == \"f\" || s[i] == \"g\" || s[i] == \"h\" || s[i]\
    \ == \"j\" || s[i] == \"k\" || s[i] == \"l\" || s[i] == \"m\" || s[i] == \"n\"\
    \ || s[i] == \"p\" || s[i] == \"q\" || \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbs5h5kkn.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpbs5h5kkn.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpbs5h5kkn.swift:127:1: error: expected expression\
    \ after operator\n}\n^\n/tmp/tmpbs5h5kkn.swift:148:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpbs5h5kkn.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpbs5h5kkn.swift:29:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpbs5h5kkn.swift:130:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for word in\
    \ s.split(\" \") {\n        if word.hasPrefix(\"a\") || word.hasPrefix(\"e\")\
    \ || word.hasPrefix(\"i\") || word.hasPrefix(\"o\") || word.hasPrefix(\"u\") {\n\
    \            result.append(word)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpedi1b10o.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let chars = s.characters\n \
    \   \n    for char in chars {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ == true }).count == n {\n            result.append(String(char))\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjzetnl7f.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjzetnl7f.swift:28:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() == true }).count == n {\n    \
    \                                    ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // TODO: Write your code here\n   \
    \ \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpwuxvsb3d/tmpwuxvsb3d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1b39cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1b36c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1b36c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1b36c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwuxvsb3d                        0x0000560347b5f4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ac1b3bb6460 __libc_start_main +
    245

    6    tmpwuxvsb3d                        0x0000560347b5f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    for letter in s {\n        if\
    \ letter == \" \" {\n            words.append(\"\")\n        } else {\n      \
    \      if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"\
    o\" || letter == \"u\" {\n                words.append(letter)\n            }\
    \ else {\n                for _ in 0..<n {\n                    words.append(letter)\n\
    \                }\n            }\n        }\n    }\n    \n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp12jx5_50.swift:30:30: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                words.append(letter)\n \
    \                            ^\n/tmp/tmp12jx5_50.swift:33:34: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \       words.append(letter)\n                                 ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n   \
    \         i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \"a\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"e\" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \"i\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"o\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"u\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"y\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"A\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"E\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"I\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"O\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"U\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"Y\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"n\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"d\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"h\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"l\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"l\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"l\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"o\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"s\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"t\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"w\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"w\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"w\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"w\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"y\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"a\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"e\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"i\" {\n            i\
    \ += 1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplg0a6kao.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmplg0a6kao.swift:29:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmplg0a6kao.swift:199:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmplg0a6kao.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmplg0a6kao.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplg0a6kao.swift:35:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplg0a6kao.swift:40:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplg0a6kao.swift:45:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplg0a6kao.swift:50:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for c in s {\n\
    \        if c.isConsonant() {\n            if result.count < n {\n           \
    \     result.append(c)\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvsffiwou.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpvsffiwou.swift:23:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(c)\n                              ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"\
    d\" || s[i] == \"f\" || s[i] == \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i]\
    \ == \"k\" || s[i] == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\"\
    \ || s[i] == \"q\" || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i]\
    \ == \"v\" || s[i] == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"A\" || s[i]\
    \ == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n            i\
    \ += 1\n        }\n        \n        if s[i] == \"B\" || s[i] == \"C\" || s[i]\
    \ == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i] == \"H\" || s[i] == \"J\"\
    \ || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\" || s[i] == \"N\" || s[i]\
    \ == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i] == \"S\" || s[i] == \"T\"\
    \ || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\" || s[i] == \"Y\" || s[i]\
    \ == \"Z\" {\n            i += 1\n        }\n        \n        if s[i] == \"0\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"1\" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"2\" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \"3\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \"4\" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \"5\" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \"6\" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \"7\" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \"8\" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \"9\" {\n            i += 1\n        }\n        \n        if s[i] == \"!\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"?\" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"-\" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \"_\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \".\" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \"/\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj3jjalq5.swift:110:20: error: unterminated string literal\n   \
    \     if s[i] == \"/\n                   ^\n/tmp/tmpj3jjalq5.swift:132:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpj3jjalq5.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpj3jjalq5.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpj3jjalq5.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpj3jjalq5.swift:34:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpj3jjalq5.swift:34:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpj3jjalq5.swift:34:57: error: 'subs"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: Write your code in Swift 4.2 or\
    \ later\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpg6sm01xm/tmpg6sm01xm.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06ce97dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06ce674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06ce674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06ce6737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6sm01xm                        0x000055b4efc994c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b06ceb69460 __libc_start_main +
    245

    6    tmpg6sm01xm                        0x000055b4efc990c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"a\" {\n            i += 1\n            if j == 0 {\n             \
    \   j = 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 1 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 2 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 3 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 4 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 5 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 6 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 7 {\n\
    \                result.append(\"a\")\n                i += 1\n              \
    \  j += 1\n                k += 1\n                continue\n            }\n \
    \           \n            if k == n {\n                result.append(\"a\")\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            \n            if j == 8 {\n\
    \                result.append(\"a\")\n                i += 1\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1ja_b0kj.swift:189:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp1ja_b0kj.swift:36:24:\
    \ note: to match this opening '{'\n        if s[i] == \"a\" {\n              \
    \         ^\n/tmp/tmp1ja_b0kj.swift:189:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmp1ja_b0kj.swift:30:23: note: to match this opening '{'\n    while\
    \ i < s.count {\n                      ^\n/tmp/tmp1ja_b0kj.swift:189:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp1ja_b0kj.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp1ja_b0kj.swift:31:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1ja_b0kj.swift:36:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1ja_b0kj.swift:171:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            j = i\n   \
    \     }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \" \" {\n            j = i\n        }\n        \n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            i = j\n        }\n        \n        if char == \" \" {\n\
    \            j = i\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n      \
    \  if char == \" \" {\n            j = i\n        }\n        \n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            i = j\n        }\n        \n        if char == \" \" {\n    \
    \        j = i\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n  \
    \      }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n      \
    \  if char == \" \" {\n            j = i\n        }\n        \n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            i = j\n        }\n        \n        if char == \" \" {\n    \
    \        j = i\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n  \
    \      }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n      \
    \  if char == \" \" {\n            j = i\n        }\n        \n        if char\
    \ == \"a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvr_c4_by.swift:113:20: error: unterminated string literal\n   \
    \     if char == \"a\n                   ^\n/tmp/tmpvr_c4_by.swift:135:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpvr_c4_by.swift:18:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpvr_c4_by.swift:117:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for word in\
    \ s.split(\" \") {\n        if word.hasPrefix(\"a\") {\n            if word.hasPrefix(\"\
    b\") {\n                if word.hasPrefix(\"c\") {\n                    if word.hasPrefix(\"\
    d\") {\n                        if word.hasPrefix(\"e\") {\n                 \
    \           if word.hasPrefix(\"f\") {\n                                if word.hasPrefix(\"\
    g\") {\n                                    if word.hasPrefix(\"h\") {\n     \
    \                                   if word.hasPrefix(\"i\") {\n             \
    \                               if word.hasPrefix(\"j\") {\n                 \
    \                               if word.hasPrefix(\"k\") {\n                 \
    \                                   if word.hasPrefix(\"l\") {\n             \
    \                                           if word.hasPrefix(\"m\") {\n     \
    \                                                       if word.hasPrefix(\"n\"\
    ) {\n                                                                if word.hasPrefix(\"\
    o\") {\n                                                                    if\
    \ word.hasPrefix(\"p\") {\n                                                  \
    \                                      if word.hasPrefix(\"q\") {\n          \
    \                                                                  if word.hasPrefix(\"\
    r\") {\n                                                                     \
    \           if word.hasPrefix(\"s\") {\n                                     \
    \                                               if word.hasPrefix(\"t\") {\n \
    \                                                                            \
    \           if word.hasPrefix(\"u\") {\n                                     \
    \                                                       if word.hasPrefix(\"v\"\
    ) {\n                                                                        \
    \                        if word.hasPrefix(\"w\") {\n                        \
    \                                                                            if\
    \ word.hasPrefix(\"x\") {\n                                                  \
    \                                                      if word.hasPrefix(\"y\"\
    ) {\n                                                                        \
    \                                    if word.hasPrefix(\"z\") {\n            \
    \                                                                            \
    \                        if word.hasPrefix(\"A\") {\n                        \
    \                                                                            \
    \                if word.hasPrefix(\"B\") {\n                                \
    \                                                                            \
    \            if word.hasPrefix(\"C\") {\n                                    \
    \                                                                            \
    \            if word.hasPrefix(\"D\") {\n                                    \
    \                                                                            \
    \                                if word.hasPrefix(\"E\") {\n                \
    \                                                                            \
    \                                        if word.hasPrefix(\"F\") {\n        \
    \                                                                            \
    \                                                    if word.hasPrefix(\"G\")\
    \ {\n                                                                        \
    \                                                                            \
    \                        if word.hasPrefix(\"H\") {\n                        \
    \                                                                            \
    \                                                                            if\
    \ word.hasPrefix(\"I\") {\n                                                  \
    \                                                                            \
    \                                                      if word.hasPrefix(\"J\"\
    ) {\n                                                                        \
    \                                                                            \
    \                                    if word.hasPrefix(\"K\") {\n            \
    \                                                                            \
    \                                                                            \
    \                        if word.hasPrefix(\"L\") {\n                        \
    \                                                                            \
    \                                                                            \
    \                                if word.hasPrefix(\"M\") {\n                \
    \                                                                            \
    \                                                                            \
    \                            if word.hasPrefix(\"N\") {\n                    \
    \                                                                            \
    \                                                                            \
    \                            if word.hasPrefix(\"O\") {\n                    \
    \                                                                            \
    \                                                                            \
    \                                                                if word.hasPrefix(\"\
    P\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                   if word.hasPrefix(\"Q\") {\n                             \
    \                                                                            \
    \                                                                            \
    \                                                               if word.hasPrefix(\"\
    R\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                           if word.hasPrefix(\"S\") {\n                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \    if word.hasPrefix(\"T\") {\n                                            \
    \                                                                            \
    \                                                                            \
    \                                                                if word.hasPrefix(\"\
    U\") {\n                                                                     \
    \                                                                            \
    \                                                                            \
    \                                           if word.hasPrefix(\"V\") {\n     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                   if word.hasPrefix(\"W\") {\n             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                               if word.\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu9n8ezbx.swift:70:280: error: expected member name following '.'\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                            if word.\n                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                             ^\n/tmp/tmpu9n8ezbx.swift:70:281: error: expected\
    \ '{' after 'if' condition\n                                                 \
    \                                                                            \
    \                                                                            \
    \                                                                       if word.\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                    ^\n/tmp/tmpu9n8ezbx.swift:92:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpu9n8ezbx.swift:68:288:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                                                            \
    \                                                                      if word.hasPrefix(\"\
    V\") {\n                                                                     \
    \                                                                            \
    \                                                                  "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var count =\
    \ 0\n    for letter in s.characters {\n        if letter == \" \" {\n        \
    \    count += 1\n            if count == n {\n                result.append(String(letter))\n\
    \                count = 0\n            }\n        } else {\n            count\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9l3wcwve.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmps2wgjfbz.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for char in s {\n        if char == \" \" {\n       \
    \     j = i\n            \n            if j == i {\n                result.append(\"\
    \\n\")\n            }\n            \n            i = j\n            \n       \
    \     continue\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j = i\n  \
    \          \n            if j == i {\n                result.append(\"\\n\")\n\
    \            }\n            \n            i = j\n            \n            continue\n\
    \        }\n        \n        if char == \"n\" {\n            k = i\n        \
    \    \n            if k == i {\n                result.append(\"\\n\")\n     \
    \       }\n            \n            i = k\n            \n            continue\n\
    \        }\n        \n        if char == \"t\" || char == \"s\" || char == \"\
    h\" || char == \"r\" || char == \"d\" {\n            k = i\n            \n   \
    \         if k == i {\n                result.append(\"\\n\")\n            }\n\
    \            \n            i = k\n            \n            continue\n       \
    \ }\n        \n        if char == \"b\" || char == \"c\" || char == \"m\" || char\
    \ == \"p\" || char == \"f\" || char == \"v\" || char == \"x\" {\n            k\
    \ = i\n            \n            if k == i {\n                result.append(\"\
    \\n\")\n            }\n            \n            i = k\n            \n       \
    \     continue\n        }\n        \n        if char == \"k\" || char == \"l\"\
    \ || char == \"m\" || char == \"p\" || char == \"s\" || char == \"v\" || char\
    \ == \"x\" {\n            k = i\n            \n            if k == i {\n     \
    \           result.append(\"\\n\")\n            }\n            \n            i\
    \ = k\n            \n            continue\n        }\n        \n        if char\
    \ == \"j\" || char == \"h\" || char == \"r\" || char == \"d\" || char == \"v\"\
    \ || char == \"x\" {\n            k = i\n            \n            if k == i {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     i = k\n            \n            continue\n        }\n        \n       \
    \ if char == \"p\" || char == \"f\" || char == \"v\" || char == \"x\" {\n    \
    \        k = i\n            \n            if k == i {\n                result.append(\"\
    \\n\")\n            }\n            \n            i = k\n            \n       \
    \     continue\n        }\n        \n        if char == \"b\" || char == \"c\"\
    \ || char == \"m\" || char == \"p\" || char == \"f\" || char == \"v\" || char\
    \ == \"x\" {\n            k = i\n            \n            if k == i {\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzaq_l756.swift:152:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpzaq_l756.swift:126:114:\
    \ note: to match this opening '{'\n        if char == \"b\" || char == \"c\" ||\
    \ char == \"m\" || char == \"p\" || char == \"f\" || char == \"v\" || char ==\
    \ \"x\" {\n                                                                  \
    \                                               ^\n/tmp/tmpzaq_l756.swift:152:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpzaq_l756.swift:29:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpzaq_l756.swift:152:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpzaq_l756.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpzaq_l756.swift:134:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // Your code here\n    \n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpbme81adc/tmpbme81adc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4df948c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4df63fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4df63f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4df63e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbme81adc                        0x00005560d105b4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab4dfb34460 __libc_start_main +
    245

    6    tmpbme81adc                        0x00005560d105b0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    var i = 0\n    var j = 0\n  \
    \  \n    for char in s {\n        if char == \" \" {\n            words.append(s[i\
    \ ..< j])\n            i = j\n            j = 0\n        } else {\n          \
    \  j += 1\n        }\n    }\n    \n    words.append(s[i ..< j])\n    \n    return\
    \ words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcnsyzf8a.swift:30:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \            words.append(s[i ..< j])\n                         ^~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpcnsyzf8a.swift:38:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    words.append(s[i ..< j])\n                 ^~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let letters = Array(s.characters)\n\
    \    \n    for letter in letters {\n        if letter == \" \" {\n           \
    \ continue\n        }\n        \n        let count = count_consonants(letter)\n\
    \        \n        if count == n {\n            result.append(String(letter))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn415son7.swift:25:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = Array(s.characters)\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpn415son7.swift:32:21: error: cannot find 'count_consonants' in scope\n\
    \        let count = count_consonants(letter)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    var index = 0\n\
    \    while index < s.count {\n        if s.substring(index, index+n).characters.count\
    \ == n {\n            words.append(s.substring(index, index+n))\n            index\
    \ += n\n        }\n        else {\n            index += 1\n        }\n    }\n\
    \    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpidbb74lq.swift:22:14: error: value of type 'String' has no member\
    \ 'substring'\n        if s.substring(index, index+n).characters.count == n {\n\
    \           ~ ^~~~~~~~~\n/tmp/tmpidbb74lq.swift:23:28: error: value of type 'String'\
    \ has no member 'substring'\n            words.append(s.substring(index, index+n))\n\
    \                         ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    var i = 0\n \
    \   for c in s {\n        if isConsonant(c) {\n            if i == n {\n     \
    \           words.append(s[i : s.startIndex])\n                i = 0\n       \
    \     } else {\n                i += 1\n            }\n        }\n    }\n    if\
    \ i != 0 {\n        words.append(s[i : s.startIndex])\n    }\n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxsvc8p4z.swift:22:12: error: cannot find 'isConsonant' in scope\n\
    \        if isConsonant(c) {\n           ^~~~~~~~~~~\n/tmp/tmpxsvc8p4z.swift:24:31:\
    \ error: extraneous argument label 'i:' in subscript\n                words.append(s[i\
    \ : s.startIndex])\n                              ^~~~~\n                    \
    \           \n/tmp/tmpxsvc8p4z.swift:32:23: error: extraneous argument label 'i:'\
    \ in subscript\n        words.append(s[i : s.startIndex])\n                  \
    \    ^~~~~\n                       \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.hasConsonants {\n            if result.count < n {\n        \
    \        result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzmcmbyh7.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzmcmbyh7.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let vowels = \"aeiou\"\n   \
    \ \n    for char in s.characters {\n        if vowels.contains(String(char)) {\n\
    \            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4gbz8qr.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var count = 0\n    var last\
    \ = 0\n    var lastChar = s[0]\n    \n    for char in s.characters {\n       \
    \ if char == lastChar {\n            count += 1\n        } else {\n          \
    \  if count == n {\n                result.insert(last + 1, String(s[last:char]))\n\
    \                last = char\n                count = 0\n            } else {\n\
    \                count = 0\n            }\n        }\n        lastChar = char\n\
    \    }\n    \n    if count > n {\n        result.insert(last + 1, String(s[last:]))\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprxt93l73.swift:45:47: error: expected expression in list of expressions\n\
    \        result.insert(last + 1, String(s[last:]))\n                         \
    \                     ^\n/tmp/tmprxt93l73.swift:27:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    var lastChar = s[0]\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmprxt93l73.swift:29:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmprxt93l73.swift:34:49: error: no exact matches in call to subscript\
    \ \n                result.insert(last + 1, String(s[last:char]))\n          \
    \                                      ^\n/tmp/tmprxt93l73.swift:34:49: note:\
    \ candidate has partially matching parameter list (String.Index)\n           \
    \     result.insert(last + 1, String(s[last:char]))\n                        \
    \                        ^\n/tmp/tmprxt93l73.swift:34:49: note: candidate has\
    \ partially matching parameter list (Range<String.Index>)\n                result.insert(last\
    \ + 1, String(s[last:char]))\n                                               \
    \ ^\n/tmp/tmprxt93l73.swift:34:49: note: candidate has partially matching parameter\
    \ list ((UnboundedRange_) -> ())\n                result.insert(last + 1, String(s[last:char]))\n\
    \                                                ^\n/tmp/tmprxt93l73.swift:34:24:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  result.insert(last + 1, String(s[last:char]))\n                       ^\n/tmp/tmprxt93l73.swift:34:24:\
    \ note: candidate has partially matching parameter list (__owned String, at: Int)\n\
    \                result.insert(last + 1, String(s[last:char]))\n             \
    \          ^\n/tmp/tmprxt93l73.swift:34:24: note: candidate "
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i += 1\n  \
    \      }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n       \
    \ \n        if j == n {\n            result.append(String(s[i:j]))\n         \
    \   i = j + 1\n            j = 0\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp52zmiz0y.swift:38:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        if char == \"n\" {\n\
    \            if n == 1 {\n                result.append(\"\")\n            } else\
    \ {\n                result.append(\" \")\n            }\n            continue\n\
    \        }\n        if char == \"c\" || char == \"d\" || char == \"h\" || char\
    \ == \"l\" || char == \"r\" || char == \"v\" {\n            continue\n       \
    \ }\n        if char == \"b\" {\n            if n == 1 {\n                result.append(\"\
    \")\n            } else {\n                result.append(\" \")\n            }\n\
    \            continue\n        }\n        if char == \"m\" {\n            if n\
    \ == 1 {\n                result.append(\"\")\n            } else {\n        \
    \        result.append(\" \")\n            }\n            continue\n        }\n\
    \        if char == \"g\" || char == \"s\" {\n            if n == 1 {\n      \
    \          result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"t\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"k\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"p\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"f\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"v\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"y\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"z\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"x\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"q\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"z\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n            continue\n        }\n        if char == \"w\"\
    \ {\n            if n == 1 {\n                result.append(\"\")\n          \
    \  } else {\n                result.append(\" \")\n            }\n           \
    \ continue\n        }\n        if char == \"l\" {\n            if n == 1 {\n \
    \               result.append(\"\")\n            } else {\n                result.append(\"\
    \ \")\n            }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6s3oirmq.swift:177:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp6s3oirmq.swift:20:30:\
    \ note: to match this opening '{'\n    for char in s.characters {\n          \
    \                   ^\n/tmp/tmp6s3oirmq.swift:177:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp6s3oirmq.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmp6s3oirmq.swift:20:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp6s3oirmq.swift:159:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.characters.count {\n        if s[i] == \" \"\
    \ {\n            j = i\n            \n            for k < s.characters.count {\n\
    \                if s[k] == \" \" {\n                    k = k + 1\n         \
    \       } else {\n                    break\n                }\n            }\n\
    \            \n            if j - i > n {\n                result.appendContentsOf(s.substringWithRange(i...j))\n\
    \            }\n            i = j\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4qh2w2b3.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.characters.count {\n          ^\n/tmp/tmp4qh2w2b3.swift:29:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.characters.count\
    \ {\n          ^~\n           \n/tmp/tmp4qh2w2b3.swift:33:19: error: expected\
    \ 'in' after for-each pattern\n            for k < s.characters.count {\n    \
    \              ^\n/tmp/tmp4qh2w2b3.swift:33:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < s.characters.count {\n     \
    \             ^~\n                   \n/tmp/tmp4qh2w2b3.swift:29:11: error: '<'\
    \ is not a prefix unary operator\n    for i < s.characters.count {\n         \
    \ ^\n/tmp/tmp4qh2w2b3.swift:33:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.characters.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for word in\
    \ s.split(\" \") {\n        if word.characters.count >= n {\n            result.append(word)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprtejrjvw.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for word in\
    \ s.split(\" \") {\n        if word.characters.count >= n {\n            result.append(word)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprtejrjvw.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j\
    \ = 0\n    \n    for char in s {\n        if char == \" \" {\n            j =\
    \ i\n        }\n        \n        if char == \"a\" || char == \"e\" || char ==\
    \ \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n        }\n  \
    \      \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"n\" {\n            i = j\n        }\n        \n        if\
    \ char == \"c\" || char == \"d\" || char == \"h\" || char == \"l\" || char ==\
    \ \"m\" || char == \"p\" || char == \"t\" || char == \"v\" || char == \"w\" ||\
    \ char == \"y\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n       \
    \     i = j\n        }\n        \n        if char == \" \" {\n            j =\
    \ i\n        }\n        \n        if char == \"n\" {\n            i = j\n    \
    \    }\n        \n        if char == \"c\" || char == \"d\" || char == \"h\" ||\
    \ char == \"l\" || char == \"m\" || char == \"p\" || char == \"t\" || char ==\
    \ \"v\" || char == \"w\" || char == \"y\" {\n            i = j\n        }\n  \
    \      \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \"n\" {\n\
    \            i = j\n        }\n        \n        if char == \"c\" || char == \"\
    d\" || char == \"h\" || char == \"l\" || char == \"m\" || char == \"p\" || char\
    \ == \"t\" || char == \"v\" || char == \"w\" || char == \"y\" {\n            i\
    \ = j\n        }\n        \n        if char == \" \" {\n            j = i\n  \
    \      }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \" \" {\n            j = i\n        }\n        \n        if\
    \ char == \"n\" {\n            i = j\n        }\n        \n        if char ==\
    \ \"c\" || char == \"d\" || char == \"h\" || char == \"l\" || char == \"m\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb3p_7ces.swift:106:80: error: unterminated string literal\n   \
    \     if char == \"c\" || char == \"d\" || char == \"h\" || char == \"l\" || char\
    \ == \"m\n                                                                   \
    \            ^\n/tmp/tmpb3p_7ces.swift:128:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpb3p_7ces.swift:18:50: note: to match this opening '{'\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n                                            \
    \     ^\n/tmp/tmpb3p_7ces.swift:110:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var count = 0\n    \n    for\
    \ letter in s {\n        if letter == \" \" {\n            count += 1\n      \
    \      if count == n {\n                result.append(\"\\n\")\n             \
    \   count = 0\n            }\n        } else {\n            count = 0\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpu381y_uf/tmpu381y_uf.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dc15e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dc12d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dc12d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dc12d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu381y_uf                        0x000055dd647ac774 <unavailable> + 6004

    5    libc.so.6                          0x00002b3dc17ce460 __libc_start_main +
    245

    6    tmpu381y_uf                        0x000055dd647ac379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw9yjym0b.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw9yjym0b.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = s.characters.count\n    var m = n\n\
    \    var n = s.characters.count\n    var o = n\n    var p = n\n    var q = n\n\
    \    var r = n\n    var s = n\n    var t = n\n    var u = n\n    var v = n\n \
    \   var w = n\n    var x = n\n    var y = n\n    var z = n\n    var a = n\n  \
    \  var b = n\n    var c = n\n    var d = n\n    var e = n\n    var f = n\n   \
    \ var g = n\n    var h = n\n    var i = n\n    var j = n\n    var k = n\n    var\
    \ l = n\n    var m = n\n    var n = n\n    var o = n\n    var p = n\n    var q\
    \ = n\n    var r = n\n    var s = n\n    var t = n\n    var u = n\n    var v =\
    \ n\n    var w = n\n    var x = n\n    var y = n\n    var z = n\n    var a = n\n\
    \    var b = n\n    var c = n\n    var d = n\n    var e = n\n    var f = n\n \
    \   var g = n\n    var h = n\n    var i = n\n    var j = n\n    var k = n\n  \
    \  var l = n\n    var m = n\n    var n = n\n    var o = n\n    var p = n\n   \
    \ var q = n\n    var r = n\n    var s = n\n    var t = n\n    var u = n\n    var\
    \ v = n\n    var w = n\n    var x = n\n    var y = n\n    var z = n\n    var a\
    \ = n\n    var b = n\n    var c = n\n    var d = n\n    var e = n\n    var f =\
    \ n\n    var g = n\n    var h = n\n    var i = n\n    var j = n\n    var k = n\n\
    \    var l = n\n    var m = n\n    var n = n\n    var o = n\n    var p = n\n \
    \   var q = n\n    var r = n\n    var s = n\n    var t = n\n    var u = n\n  \
    \  var v = n\n    var w = n\n    var x = n\n    var y = n\n    var z = n\n   \
    \ var a = n\n    var b = n\n    var c = n\n    var d = n\n    var e = n\n    var\
    \ f = n\n    var g = n\n    var h = n\n    var i = n\n    var j = n\n    var k\
    \ = n\n    var l = n\n    var m = n\n    var n = n\n    var o = n\n    var p =\
    \ n\n    var q = n\n    var r = n\n    var s = n\n    var t = n\n    var u = n\n\
    \    var v = n\n    var w = n\n    var x = n\n    var y = n\n    var z = n\n \
    \   var a = n\n    var b = n\n    var c = n\n    var d = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi2ugw22f.swift:145:12: error: expected initial value after '='\n\
    \    var d = \n           ^\n/tmp/tmpi2ugw22f.swift:23:15: error: 'characters'\
    \ is unavailable: Please use String directly\n    var l = s.characters.count\n\
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpi2ugw22f.swift:25:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var n = s.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpi2ugw22f.swift:46:9:\
    \ error: invalid redeclaration of 'i'\n    var i = n\n        ^\n/tmp/tmpi2ugw22f.swift:20:9:\
    \ note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi2ugw22f.swift:47:9:\
    \ error: invalid redeclaration of 'j'\n    var j = n\n        ^\n/tmp/tmpi2ugw22f.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi2ugw22f.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = n\n        ^\n/tmp/tmpi2ugw22f.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi2ugw22f.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = n\n        ^\n/tmp/tmpi2ugw22f.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = s.characters.count\n       \
    \ ^\n/tmp/tmpi2ugw22f.swift:50:9: error: invalid redeclaration of 'm'\n    var\
    \ m = n\n        ^\n/tmp/tmpi2ugw22f.swift:24:9: note: 'm' previously declared\
    \ here\n    var m = n\n        ^\n/tmp/tmpi2ugw22f.swift:51:9: error: invalid\
    \ redeclaration of 'n'\n    var n = n\n        ^\n/tmp/tmpi2ugw22f.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = s.characters.count\n       \
    \ ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    for c in s.characters {\n        if c == \" \" {\n            if i == n {\n\
    \                break\n            }\n        } else {\n            if i == n\
    \ {\n                result.append(String(s.characters.dropLast()))\n        \
    \        break\n            }\n        }\n        i += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2ixsh261.swift:21:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2ixsh261.swift:28:40:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     result.append(String(s.characters.dropLast()))\n                       \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var count = 0\n    var last = 0\n    var lastCount = 0\n    for i < s.characters.count\
    \ {\n        if s[i] == \" \" {\n            count += 1\n            if count\
    \ == n {\n                result.insert(last, String(s.substringWithRange(s.startIndex.advancedBy(i),\
    \ s.endIndex.advancedBy(i))))\n                lastCount += 1\n              \
    \  last = i\n                count = 0\n            }\n        } else {\n    \
    \        count += 1\n            if count == n {\n                result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                lastCount += 1\n                last = i\n                count\
    \ = 0\n            }\n        }\n        i += 1\n    }\n    if count != 0 {\n\
    \        result.insert(last, String(s.substringWithRange(s.startIndex.advancedBy(i),\
    \ s.endIndex.advancedBy(i))))\n        lastCount += 1\n    }\n    if lastCount\
    \ != n {\n        result.insert(last, String(s.substringWithRange(s.startIndex.advancedBy(i),\
    \ s.endIndex.advancedBy(i))))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6ba3knl9.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.characters.count {\n          ^\n/tmp/tmp6ba3knl9.swift:29:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < s.characters.count\
    \ {\n          ^~\n           \n/tmp/tmp6ba3knl9.swift:29:11: error: '<' is not\
    \ a prefix unary operator\n    for i < s.characters.count {\n          ^\n/tmp/tmp6ba3knl9.swift:50:22:\
    \ error: missing argument labels 'contentsOf:at:' in call\n        result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                     ^\n                      contentsOf:  at: \n/tmp/tmp6ba3knl9.swift:50:38:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                                   ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp6ba3knl9.swift:50:70:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                                                        ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp6ba3knl9.swift:50:96: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        result.insert(last, String(s.substringWithRange(s.startIndex.advancedBy(i),\
    \ s.endIndex.advancedBy(i))))\n                                              \
    \                                      ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp6ba3knl9.swift:54:22:\
    \ error: missing argument labels 'contentsOf:at:' in call\n        result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                     ^\n                      contentsOf:  at: \n/tmp/tmp6ba3knl9.swift:54:38:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        result.insert(last,\
    \ String(s.substringWithRange(s.startIndex.advancedBy(i), s.endIndex.advancedBy(i))))\n\
    \                                   ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp6ba3knl9.swif"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    while i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \            \n            if j == n {\n                j += 1\n             \
    \   \n                if j == n {\n                    result.append(String(s[i..<s.endIndex]))\n\
    \                }\n            }\n        } else {\n            i += 1\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoqoc5s5a.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpoqoc5s5a.swift:36:44: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.Index'\n                   \
    \ result.append(String(s[i..<s.endIndex]))\n                                 \
    \          ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            if i == 0 {\n\
    \                j++\n            }\n            \n            if j == n {\n \
    \               result.append(\"\\(stringToString(s[i:]))\")\n               \
    \ i = i + 1\n                j = 0\n            }\n        }\n        \n     \
    \   if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n            if i == 0 {\n                j++\n            }\n  \
    \          \n            if j == n {\n                result.append(\"\\(stringToString(s[i:]))\"\
    )\n                i = i + 1\n                j = 0\n            }\n        }\n\
    \        \n        if char == \"b\" || char == \"c\" || char == \"d\" || char\
    \ == \"f\" || char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\"\
    \ || char == \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char\
    \ == \"q\" || char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\"\
    \ || char == \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n    \
    \        if i == 0 {\n                j++\n            }\n            \n     \
    \       if j == n {\n                result.append(\"\\(stringToString(s[i:]))\"\
    )\n                i = i + 1\n                j = 0\n            }\n        }\n\
    \        \n        if char == \"A\" || char == \"E\" || char == \"I\" || char\
    \ == \"O\" || char == \"U\" {\n            if i == 0 {\n                j++\n\
    \            }\n            \n            if j == n {\n                result.append(\"\
    \\(stringToString(s[i:]))\")\n                i = i + 1\n                j = 0\n\
    \            }\n        }\n        \n        if char == \"B\" || char == \"C\"\
    \ || char == \"D\" || char == \"F\" || char == \"G\" || char == \"H\" || char\
    \ == \"J\" || char == \"K\" || char == \"L\" || char == \"M\" || char == \"N\"\
    \ || char == \"P\" || char == \"Q\" || char == \"R\" || char == \"S\" || char\
    \ == \"T\" || char == \"V\" || char == \"W\" || char == \"X\" || char == \"Y\"\
    \ || char == \"Z\" {\n            if i == 0 {\n                j++\n         \
    \   }\n            \n            if j == n {\n                result.append(\"\
    \\(stringToString(s[i:]))\")\n                i = i + 1\n                j = 0\n\
    \            }\n        }\n        \n        if char == \"0\" {\n            if\
    \ i == 0 {\n                j++\n            }\n            \n            if j\
    \ == n {\n                result.append(\"\\(stringToString(s[i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpstihejg7.swift:35:53: error: expected expression in list of expressions\n\
    \                result.append(\"\\(stringToString(s[i:]))\")\n              \
    \                                      ^\n/tmp/tmpstihejg7.swift:47:53: error:\
    \ expected expression in list of expressions\n                result.append(\"\
    \\(stringToString(s[i:]))\")\n                                               \
    \     ^\n/tmp/tmpstihejg7.swift:59:53: error: expected expression in list of expressions\n\
    \                result.append(\"\\(stringToString(s[i:]))\")\n              \
    \                                      ^\n/tmp/tmpstihejg7.swift:71:53: error:\
    \ expected expression in list of expressions\n                result.append(\"\
    \\(stringToString(s[i:]))\")\n                                               \
    \     ^\n/tmp/tmpstihejg7.swift:83:53: error: expected expression in list of expressions\n\
    \                result.append(\"\\(stringToString(s[i:]))\")\n              \
    \                                      ^\n/tmp/tmpstihejg7.swift:95:33: error:\
    \ cannot find ')' to match opening '(' in string interpolation\n             \
    \   result.append(\"\\(stringToString(s[i\n                                ^\n\
    /tmp/tmpstihejg7.swift:95:31: error: unterminated string literal\n           \
    \     result.append(\"\\(stringToString(s[i\n                              ^\n\
    /tmp/tmpstihejg7.swift:117:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpstihejg7.swift:89:24:\
    \ note: to match this opening '{'\n        if char == \"0\" {\n              \
    \         ^\n/tmp/tmpstihejg7.swift:117:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpstihejg7.swift:28:19: note: to match this opening '{'\n    for\
    \ char in s {\n                  ^\n/tmp/tmpstihejg7.swift:117:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d "
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            if i == n {\n\
    \                j++\n            }\n            \n            if j == n {\n \
    \               result.append(s[i : s.startIndex])\n                i = s.startIndex\n\
    \                j = 0\n            }\n        } else {\n            if i == n\
    \ {\n                j++\n            }\n            \n            if j == n {\n\
    \                result.append(s[i : s.startIndex])\n                i = s.startIndex\n\
    \                j = 0\n            }\n        }\n    }\n    \n    if j == n {\n\
    \        result.append(s[i : s.startIndex])\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5ttbobmc.swift:31:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmp5ttbobmc.swift:35:32:\
    \ error: extraneous argument label 'i:' in subscript\n                result.append(s[i\
    \ : s.startIndex])\n                               ^~~~~\n                   \
    \             \n/tmp/tmp5ttbobmc.swift:36:23: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n                i = s.startIndex\n           \
    \         ~~^~~~~~~~~~\n/tmp/tmp5ttbobmc.swift:41:18: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                j++\n                 ^~\n\
    /tmp/tmp5ttbobmc.swift:45:32: error: extraneous argument label 'i:' in subscript\n\
    \                result.append(s[i : s.startIndex])\n                        \
    \       ^~~~~\n                                \n/tmp/tmp5ttbobmc.swift:46:23:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \      i = s.startIndex\n                    ~~^~~~~~~~~~\n/tmp/tmp5ttbobmc.swift:53:24:\
    \ error: extraneous argument label 'i:' in subscript\n        result.append(s[i\
    \ : s.startIndex])\n                       ^~~~~\n                        \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i += 1\n  \
    \      }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n       \
    \ \n        if j == n {\n            result.append(String(s[i:j]))\n         \
    \   j = i\n            i = 0\n        }\n    }\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl9ry59us.swift:38:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.hasConsonants {\n            if result.count < n {\n        \
    \        result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzmcmbyh7.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzmcmbyh7.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonants'\n        if char.hasConsonants\
    \ {\n           ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s {\n        if char.unicodeScalars.count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpkvtynplx/tmpkvtynplx.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b792a5c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b792a2b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b792a2b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b792a2b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvtynplx                        0x000055901e89a7d4 <unavailable> + 6100

    5    libc.so.6                          0x00002b792a7ac460 __libc_start_main +
    245

    6    tmpkvtynplx                        0x000055901e89a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // Your code here\n    \n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpbme81adc/tmpbme81adc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4df948c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4df63fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4df63f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4df63e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbme81adc                        0x00005560d105b4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab4dfb34460 __libc_start_main +
    245

    6    tmpbme81adc                        0x00005560d105b0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for letter in\
    \ s.characters {\n        if let index = s.firstIndex(of: letter) {\n        \
    \    if index == s.startIndex {\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \            } else {\n                result.append(s[s.startIndex..<index])\n\
    \            }\n            if index == s.endIndex {\n                result.append(s[s.endIndex..<s.endIndex])\n\
    \            }\n            if index == s.endIndex - n {\n                result.append(s[s.endIndex..<s.endIndex])\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9kfxrws4.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9kfxrws4.swift:23:32:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n                result.append(s[s.startIndex..<s.endIndex])\n\
    \                               ^\nSwift.String:5:12: note: where 'R.Bound' =\
    \ 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp9kfxrws4.swift:25:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.startIndex..<index])\n                    \
    \           ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n   \
    \ public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp9kfxrws4.swift:28:32: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                result.append(s[s.endIndex..<s.endIndex])\n                 \
    \              ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmp9kfxrws4.swift:30:22: error: referencing\
    \ operator function '==' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n            if index == s.endIndex - n {\n             \
    \        ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension\
    \ BinaryInteger {\n          ^\n/tmp/tmp9kfxrws4.swift:30:36: error: binary operator\
    \ '-' cannot be applied to operands of type 'String.Index' and 'Int'\n       \
    \     if index == s.endIndex - n {\n                        ~~~~~~~~~~ ^ ~\n/tmp/tmp9kfxrws4.swift:30:36:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Int, Int)\n "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let vowels = \"aeiouAEIOU\"\n\
    \    \n    for letter in s.characters {\n        if vowels.contains(String(letter))\
    \ {\n            if result.count < n {\n                result.append(String(letter))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6im8cxoj.swift:27:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    while i < s.count {\n        if s[i] == \" \" {\n            j = i\n\
    \            while j < s.count && s[j] != \" \" {\n                j += 1\n  \
    \          }\n            \n            if j == s.count {\n                result.append(s.substring(i\
    \ + 1, s.count))\n                i = s.count\n            } else {\n        \
    \        result.append(s.substring(i + 1, j))\n                i = j\n       \
    \     }\n        } else {\n            i += 1\n        }\n    }\n    \n    if\
    \ n == 1 {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n\
    \    \n    while i < s.count {\n        if s[i] == \" \" {\n            j = i\n\
    \            while j < s.count && s[j] != \" \" {\n                j += 1\n  \
    \          }\n            \n            if j == s.count {\n                result.append(s.substring(i\
    \ + 1, s.count))\n                i = s.count\n            } else {\n        \
    \        result.append(s.substring(i + 1, j))\n                i = j\n       \
    \     }\n        } else {\n            i += 1\n        }\n    }\n    \n    if\
    \ n >= 2 {\n        var i = 0\n        var j = 0\n        \n        while i <\
    \ s.count {\n            if s[i] == \" \" {\n                j = i\n         \
    \       while j < s.count && s[j] != \" \" {\n                    j += 1\n   \
    \             }\n                \n                if j == s.count {\n       \
    \             result.append(s.substring(i + 1, s.count))\n                   \
    \ i = s.count\n                } else {\n                    result.append(s.substring(i\
    \ + 1, j))\n                    i = j\n                }\n            } else {\n\
    \                i += 1\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqlbthl46.swift:29:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqlbthl46.swift:31:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpqlbthl46.swift:36:33: error: value of type 'String' has no member\
    \ 'substring'\n                result.append(s.substring(i + 1, s.count))\n  \
    \                            ~ ^~~~~~~~~\n/tmp/tmpqlbthl46.swift:39:33: error:\
    \ value of type 'String' has no member 'substring'\n                result.append(s.substring(i\
    \ + 1, j))\n                              ~ ^~~~~~~~~\n/tmp/tmpqlbthl46.swift:51:9:\
    \ error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpqlbthl46.swift:25:9:\
    \ note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpqlbthl46.swift:52:9:\
    \ error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpqlbthl46.swift:26:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpqlbthl46.swift:62:33:\
    \ error: value of type 'String' has no member 'substring'\n                result.append(s.substring(i\
    \ + 1, s.count))\n                              ~ ^~~~~~~~~\n/tmp/tmpqlbthl46.swift:65:33:\
    \ error: value of type 'String' has no member 'substring'\n                result.append(s.substring(i\
    \ + 1, j))\n                              ~ ^~~~~~~~~\n/tmp/tmpqlbthl46.swift:78:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[i] == \" \" {\n              \
    \ ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char.consonants.count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5qxlioj6.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5qxlioj6.swift:21:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants.count\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n            continue\n        }\n        \n        if char == \"\
    n\" {\n            if s.characters.count - s.characters.filter({ $0 == \"n\" }).count\
    \ >= n {\n                result.append(String(char))\n            }\n       \
    \     continue\n        }\n        \n        if char == \"c\" || char == \"h\"\
    \ || char == \"l\" || char == \"o\" || char == \"r\" || char == \"s\" {\n    \
    \        if s.characters.count - s.characters.filter({ $0 == \"c\" }).count >=\
    \ n {\n                result.append(String(char))\n            }\n          \
    \  continue\n        }\n        \n        if char == \"d\" || char == \"e\" ||\
    \ char == \"l\" || char == \"m\" || char == \"p\" || char == \"t\" || char ==\
    \ \"w\" {\n            if s.characters.count - s.characters.filter({ $0 == \"\
    d\" }).count >= n {\n                result.append(String(char))\n           \
    \ }\n            continue\n        }\n        \n        if char == \"b\" || char\
    \ == \"d\" || char == \"f\" || char == \"h\" || char == \"k\" || char == \"l\"\
    \ || char == \"m\" || char == \"p\" || char == \"r\" || char == \"s\" || char\
    \ == \"t\" || char == \"v\" || char == \"w\" {\n            if s.characters.count\
    \ - s.characters.filter({ $0 == \"b\" }).count >= n {\n                result.append(String(char))\n\
    \            }\n            continue\n        }\n        \n        if char ==\
    \ \"f\" || char == \"g\" || char == \"h\" || char == \"k\" || char == \"l\" ||\
    \ char == \"o\" || char == \"r\" || char == \"s\" || char == \"t\" || char ==\
    \ \"v\" || char == \"w\" {\n            if s.characters.count - s.characters.filter({\
    \ $0 == \"f\" }).count >= n {\n                result.append(String(char))\n \
    \           }\n            continue\n        }\n        \n        if char == \"\
    g\" || char == \"h\" || char == \"k\" || char == \"l\" || char == \"o\" || char\
    \ == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char == \"w\"\
    \ {\n            if s.characters.count - s.characters.filter({ $0 == \"g\" }).count\
    \ >= n {\n                result.append(String(char))\n            }\n       \
    \     continue\n        }\n        \n        if char == \"h\" || char == \"k\"\
    \ || char == \"l\" || char == \"o\" || char == \"r\" || char == \"s\" || char\
    \ == \"t\" || char == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8ljheexr.swift:76:125: error: unterminated string literal\n   \
    \     if char == \"h\" || char == \"k\" || char == \"l\" || char == \"o\" || char\
    \ == \"r\" || char == \"s\" || char == \"t\" || char == \"\n                 \
    \                                                                            \
    \                               ^\n/tmp/tmp8ljheexr.swift:98:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp8ljheexr.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp8ljheexr.swift:25:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8ljheexr.swift:35:18: error: 'characters' is unavailable: Please\
    \ use String directly\n            if s.characters.count - s.characters.filter({\
    \ $0 == \"n\" }).count >= n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8ljheexr.swift:35:39: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ - s.characters.filter({ $0 == \"n\" }).count >= n {\n                      \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8ljheexr.swift:42:18: error: 'characters' is unavailable: Please\
    \ use String directly\n            if s.characters.count - s.characters.filter({\
    \ $0 == \"c\" }).count >= n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8ljheexr.swift:42:39: error: 'characters' "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    for c in s {\n        if i == n {\n            break\n        }\n       \
    \ if c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c !=\
    \ \"y\" {\n            result.append(String(s[i:c]))\n            i = c\n    \
    \    }\n    }\n    if i != 0 {\n        result.append(String(s[i:]))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcdr89e1f.swift:31:34: error: expected expression in list of expressions\n\
    \        result.append(String(s[i:]))\n                                 ^\n/tmp/tmpcdr89e1f.swift:26:35:\
    \ error: no exact matches in call to subscript \n            result.append(String(s[i:c]))\n\
    \                                  ^\n/tmp/tmpcdr89e1f.swift:26:35: note: candidate\
    \ expects value of type 'String.Index' for parameter #1 (got 'Character')\n  \
    \          result.append(String(s[i:c]))\n                                  ^\n\
    /tmp/tmpcdr89e1f.swift:26:35: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Character')\n            result.append(String(s[i:c]))\n\
    \                                  ^\n/tmp/tmpcdr89e1f.swift:26:35: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \            result.append(String(s[i:c]))\n                                 \
    \ ^\n/tmp/tmpcdr89e1f.swift:27:17: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n            i = c\n                ^\n/tmp/tmpcdr89e1f.swift:31:34:\
    \ error: missing argument for parameter #1 in call\n        result.append(String(s[i:]))\n\
    \                                 ^\n                                 <#String.Index#>\n\
    Swift.String:12:12: note: 'subscript(_:)' declared here\n    public subscript(i:\
    \ String.Index) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n     \
    \       j = i\n            \n            for k < s.count {\n                if\
    \ s[k] == \" \" {\n                    k = k + 1\n                } else {\n \
    \                   break\n                }\n            }\n            \n  \
    \          if j - i > n {\n                result.appendContentsOf(s[i ..< j])\n\
    \            }\n            i = j\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphd5cr837.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmphd5cr837.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmphd5cr837.swift:33:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmphd5cr837.swift:33:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmphd5cr837.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmphd5cr837.swift:33:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    var index = 0\n\
    \    var count = 0\n    for letter in s {\n        if letter == \" \" {\n    \
    \        words.append(String(s[index:]))\n            index = index + 1\n    \
    \        count = 0\n        } else {\n            count = count + 1\n        \
    \    if count == n {\n                words.append(String(s[index:]))\n      \
    \          index = index + 1\n                count = 0\n            }\n     \
    \   }\n    }\n    if count > 0 {\n        words.append(String(s[index:]))\n  \
    \  }\n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc1zzod0n.swift:24:41: error: expected expression in list of expressions\n\
    \            words.append(String(s[index:]))\n                               \
    \         ^\n/tmp/tmpc1zzod0n.swift:30:45: error: expected expression in list\
    \ of expressions\n                words.append(String(s[index:]))\n          \
    \                                  ^\n/tmp/tmpc1zzod0n.swift:37:37: error: expected\
    \ expression in list of expressions\n        words.append(String(s[index:]))\n\
    \                                    ^\n/tmp/tmpc1zzod0n.swift:24:41: error: missing\
    \ argument for parameter #1 in call\n            words.append(String(s[index:]))\n\
    \                                        ^\n                                 \
    \       <#String.Index#>\nSwift.String:12:12: note: 'subscript(_:)' declared here\n\
    \    public subscript(i: String.Index) -> Character { get }\n           ^\n/tmp/tmpc1zzod0n.swift:30:45:\
    \ error: missing argument for parameter #1 in call\n                words.append(String(s[index:]))\n\
    \                                            ^\n                             \
    \               <#String.Index#>\nSwift.String:12:12: note: 'subscript(_:)' declared\
    \ here\n    public subscript(i: String.Index) -> Character { get }\n         \
    \  ^\n/tmp/tmpc1zzod0n.swift:37:37: error: missing argument for parameter #1 in\
    \ call\n        words.append(String(s[index:]))\n                            \
    \        ^\n                                    <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    let letters = Array(s.characters)\n\
    \    \n    for letter in letters {\n        if letter == \" \" {\n           \
    \ continue\n        }\n        \n        let count = count_consonants(letter)\n\
    \        \n        if count == n {\n            result.append(letter)\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn8kuwm5v.swift:25:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = Array(s.characters)\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpn8kuwm5v.swift:32:21: error: cannot find 'count_consonants' in scope\n\
    \        let count = count_consonants(letter)\n                    ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpn8kuwm5v.swift:35:27: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            result.append(letter)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: Write your code in Swift 4.2 or\
    \ later\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpg6sm01xm/tmpg6sm01xm.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06ce97dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06ce674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06ce674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06ce6737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6sm01xm                        0x000055b4efc994c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b06ceb69460 __libc_start_main +
    245

    6    tmpg6sm01xm                        0x000055b4efc990c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for k in s.characters {\n        if k == \" \" {\n  \
    \          continue\n        }\n        \n        if i == n {\n            result.append(String(s.characters[i:j]))\n\
    \            i = j + 1\n        }\n        \n        if j == n {\n           \
    \ result.append(String(s.characters[i:k]))\n            i = k + 1\n        }\n\
    \        \n        if k == n {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if j == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if k == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if j == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if k == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n        \n        if i == k {\n           \
    \ result.append(String(s.characters[i:j]))\n            i = j + 1\n        }\n\
    \        \n        if i == j {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpixi4awkq.swift:150:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpixi4awkq.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpixi4awkq.swift:29:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpixi4awkq.swift:35:46: error: extraneous argument label\
    \ 'i:' in subscript\n            result.append(String(s.characters[i:j]))\n  \
    \                                           ^~~\n                            \
    \                  \n/tmp/tmpixi4awkq.swift:40:46: error: no exact matches in\
    \ call to subscript \n            result.append(String(s.characters[i:k]))\n \
    \                                            ^\n/tmp/tmpixi4awkq.swift:40:46:\
    \ note: candidate expects value of type 'String.Index' for parameter #1 (got 'Character')\n\
    \            result.append(String(s.characters[i:k]))\n                      \
    \                       ^\n/tmp/tmpixi4awkq.swift:40:46: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Character')\n   \
    \         result.append(String(s.characters[i:k]))\n                         \
    \                    ^\n/tmp/tmpixi4awkq.swift:40:46: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \            result.append(String(s.characters[i:k]))\n                      \
    \                       ^\n/tmp/tmpixi4awkq.swift:41:17: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            i = k\
    \ + 1\n                ^\n/tmp/tmpixi4awkq.swift:44:14: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'Int'\n        if\
    \ k == n {\n           ~ ^  ~\n/tmp/tmpi"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for letter in s {\n        if\
    \ letter == \" \" {\n            continue\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n            continue\n        }\n        \n        if letter ==\
    \ \"n\" {\n            if n == 1 {\n                continue\n            }\n\
    \            \n            if n == 2 {\n                result.append(\"little\"\
    )\n                continue\n            }\n            \n            if n ==\
    \ 3 {\n                result.append(\"lamb\")\n                continue\n   \
    \         }\n            \n            if n == 4 {\n                result.append(\"\
    Mary\")\n                continue\n            }\n            \n            if\
    \ n == 5 {\n                result.append(\"Sam\")\n                continue\n\
    \            }\n            \n            if n == 6 {\n                result.append(\"\
    Uncle\")\n                continue\n            }\n            \n            if\
    \ n == 7 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 8 {\n                result.append(\"\
    Uncle\")\n                continue\n            }\n            \n            if\
    \ n == 9 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 10 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 11 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 12 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 13 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 14 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 15 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 16 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 17 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 18 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 19 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 20 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 21 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 22 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 23 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 24 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 25 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 26 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 27\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf88q81qh.swift:164:23: error: expected '{' after 'if' condition\n\
    \            if n == 27\n                      ^\n/tmp/tmpf88q81qh.swift:186:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpf88q81qh.swift:25:21:\
    \ note: to match this opening '{'\n    for letter in s {\n                   \
    \ ^\n/tmp/tmpf88q81qh.swift:186:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpf88q81qh.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpf88q81qh.swift:168:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            if i == 0 {\n\
    \                i = j\n            }\n            \n            if j == n {\n\
    \                result.append(\"\\(strings[i - 1])\")\n                \n   \
    \             i = j\n                j = 0\n            }\n        } else {\n\
    \            j += 1\n        }\n    }\n    \n    if j != n {\n        result.append(\"\
    \\(strings[i - 1])\")\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw2rs5ewk.swift:35:34: error: cannot find 'strings' in scope\n \
    \               result.append(\"\\(strings[i - 1])\")\n                      \
    \           ^~~~~~~\n/tmp/tmpw2rs5ewk.swift:46:26: error: cannot find 'strings'\
    \ in scope\n        result.append(\"\\(strings[i - 1])\")\n                  \
    \       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n  \
    \          result.append(String(char))\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsx89fpo_.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsx89fpo_.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n     \
    \       j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j - i > n\
    \ {\n                for k = i; k < j; k++ {\n                    result.append(String(s[k]))\n\
    \                }\n            }\n            \n            i = j\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuvsfogwy.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpuvsfogwy.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpuvsfogwy.swift:38:17: error: C-style for statement\
    \ has been removed in Swift 3\n                for k = i; k < j; k++ {\n     \
    \           ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmpuvsfogwy.swift:29:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            if i == n {\n\
    \                result.appendContentsOf(select_words(s[i : j], n))\n        \
    \        i = j\n            }\n        }\n        \n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n       \
    \     if i == n {\n                result.appendContentsOf(select_words(s[i :\
    \ j], n))\n                i = j\n            }\n        }\n        \n       \
    \ if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" || char\
    \ == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char == \"l\"\
    \ || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" || char\
    \ == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char == \"w\"\
    \ || char == \"x\" || char == \"y\" || char == \"z\" {\n            if i == n\
    \ {\n                result.appendContentsOf(select_words(s[i : j], n))\n    \
    \            i = j\n            }\n        }\n        \n        if char == \"\
    A\" || char == \"E\" || char == \"I\" || char == \"O\" || char == \"U\" {\n  \
    \          if i == n {\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                i = j\n            }\n        }\n        \n     \
    \   if char == \"B\" || char == \"C\" || char == \"D\" || char == \"F\" || char\
    \ == \"G\" || char == \"H\" || char == \"J\" || char == \"K\" || char == \"L\"\
    \ || char == \"M\" || char == \"N\" || char == \"P\" || char == \"Q\" || char\
    \ == \"R\" || char == \"S\" || char == \"T\" || char == \"V\" || char == \"W\"\
    \ || char == \"X\" || char == \"Y\" || char == \"Z\" {\n            if i == n\
    \ {\n                result.appendContentsOf(select_words(s[i : j], n))\n    \
    \            i = j\n            }\n        }\n        \n        if char == \"\
    0\" {\n            if i == n {\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                i = j\n            }\n        }\n        \n     \
    \   if char == \"1\" {\n            if i == n {\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                i = j\n            }\n        }\n        \n     \
    \   if char == \"2\" {\n            if i == n {\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                i = j\n            }\n        }\n        \n     \
    \   if char\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnuzt7px7.swift:85:16: error: expected '{' after 'if' condition\n\
    \        if char\n               ^\n/tmp/tmpnuzt7px7.swift:107:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmpnuzt7px7.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmpnuzt7px7.swift:31:24: error:\
    \ value of type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpnuzt7px7.swift:31:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                                                    ^\n         \
    \                                            s:        n: \n/tmp/tmpnuzt7px7.swift:31:55:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.appendContentsOf(select_words(s[i : j], n))\n        \
    \                                              ^\n/tmp/tmpnuzt7px7.swift:31:55:\
    \ error: extraneous argument label 'i:' in subscript\n                result.appendContentsOf(select_words(s[i\
    \ : j], n))\n                                                      ^~~~~\n   \
    \                                                    \n/tmp/tmpnuzt7px7.swift:38:24:\
    \ error: value of type '[String]' has no member 'appendContentsOf'\n         \
    \       result.appendContentsOf(select_words(s[i : j], n))\n                ~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpnuzt7px7.swift:38:53: error: missing argument labels\
    \ 's:n:' in call\n                result.appendContentsOf(select_words(s[i : j],\
    \ n))\n                                                    ^\n               \
    \                                      s:        n: \n/tmp/tmpnuzt7px7.swift:38:55:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                res"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for k in s.characters {\n        if k == \" \" {\n  \
    \          continue\n        }\n        \n        if i == n {\n            result.append(s.substring(j,\
    \ k))\n            j = k + 1\n        }\n        \n        if k == s.characters.count\
    \ - 1 {\n            result.append(s.substring(j, k))\n            j = k + 1\n\
    \        }\n        \n        if s.characters[k] == \" \" {\n            j = k\
    \ + 1\n        }\n        \n        if s.characters[k] == \" \" {\n          \
    \  j = k + 1\n        }\n        \n        if s.characters[k] == \" \" {\n   \
    \         j = k + 1\n        }\n        \n        if s.characters[k] == \" \"\
    \ {\n            j = k + 1\n        }\n        \n        if s.characters[k] ==\
    \ \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n        if s.characters[k]\
    \ == \" \" {\n            j = k + 1\n        }\n        \n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmrgqrhdh.swift:158:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpmrgqrhdh.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpmrgqrhdh.swift:29:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmrgqrhdh.swift:35:29: error: value of type 'String'\
    \ has no member 'substring'\n            result.append(s.substring(j, k))\n  \
    \                        ~ ^~~~~~~~~\n/tmp/tmpmrgqrhdh.swift:36:17: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        \
    \    j = k + 1\n                ^\n/tmp/tmpmrgqrhdh.swift:39:14: error: binary\
    \ operator '==' cannot be applied to operands of type 'Character' and 'Int'\n\
    \        if k == s.characters.count - 1 {\n           ~ ^  ~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmrgqrhdh.swift:39:14: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (Int, Int)\n        if k ==\
    \ s.characters.count - 1 {\n             ^\n/tmp/tmpmrgqrhdh.swift:40:29: error:\
    \ value of type 'String' has no member 'substring'\n            result.append(s.substring(j,\
    \ k))\n                          ~ ^~~~~~~~~\n/tmp/tmpmrgqrhdh.swift:41:17: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Int'\n \
    \           j = k + 1\n                ^\n/tmp/tmpmrgqrhdh.swift:44:24: error:\
    \ no exact matches in call to subscript \n        if s.characters[k] == \" \"\
    \ {\n                       ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Character')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note:"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n \
    \   var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n  \
    \  var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n   \
    \ var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var\
    \ f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k\
    \ = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p =\
    \ 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n\
    \    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n \
    \   var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n  \
    \  var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n   \
    \ var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\
    \ p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u\
    \ = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z =\
    \ 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n\
    \    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n  \
    \  var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n   \
    \ var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var\
    \ z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e\
    \ = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv2zc5qvx.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv2zc"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            j = i\n   \
    \     }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \"n\" {\n            if i == j {\n                result.append(\"\
    n\")\n            }\n        }\n        \n        if char == \"c\" || char ==\
    \ \"d\" || char == \"h\" || char == \"l\" || char == \"r\" {\n            if i\
    \ == j {\n                result.append(\"c\")\n            }\n        }\n   \
    \     \n        if char == \"t\" || char == \"s\" || char == \"v\" || char ==\
    \ \"z\" {\n            if i == j {\n                result.append(\"t\")\n   \
    \         }\n        }\n        \n        if char == \"p\" || char == \"f\" ||\
    \ char == \"m\" || char == \"a\" || char == \"r\" {\n            if i == j {\n\
    \                result.append(\"p\")\n            }\n        }\n        \n  \
    \      if char == \"b\" || char == \"g\" || char == \"j\" || char == \"k\" ||\
    \ char == \"m\" {\n            if i == j {\n                result.append(\"b\"\
    )\n            }\n        }\n        \n        if char == \"k\" || char == \"\
    j\" || char == \"m\" || char == \"b\" || char == \"g\" {\n            if i ==\
    \ j {\n                result.append(\"k\")\n            }\n        }\n      \
    \  \n        if char == \"n\" || char == \"m\" || char == \"k\" || char == \"\
    j\" || char == \"b\" {\n            if i == j {\n                result.append(\"\
    n\")\n            }\n        }\n        \n        if char == \"p\" || char ==\
    \ \"f\" || char == \"m\" || char == \"a\" || char == \"r\" || char == \"s\" {\n\
    \            if i == j {\n                result.append(\"p\")\n            }\n\
    \        }\n        \n        if char == \"f\" || char == \"m\" || char == \"\
    a\" || char == \"r\" || char == \"s\" || char == \"p\" {\n            if i ==\
    \ j {\n                result.append(\"f\")\n            }\n        }\n      \
    \  \n        if char == \"m\" || char == \"a\" || char == \"r\" || char == \"\
    s\" || char == \"p\" || char == \"f\" {\n            if i == j {\n           \
    \     result.append(\"m\")\n            }\n        }\n        \n        if char\
    \ == \"a\" || char == \"r\" || char == \"s\" || char == \"p\" || char == \"f\"\
    \ || char == \"m\" {\n            if i == j {\n                result.append(\"\
    a\")\n            }\n        }\n        \n        if \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv68tsnti.swift:103:11: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmpv68tsnti.swift:125:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpv68tsnti.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpv68tsnti.swift:107:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words: [String] = s.components(separatedBy:\
    \ \" \")\n    \n    var result: [String] = []\n    \n    for word in words {\n\
    \        \n        let letters: [String] = word.components(separatedBy: \" \"\
    )\n        \n        var found: Bool = false\n        \n        for letter in\
    \ letters {\n            \n            let letters: [String] = letter.components(separatedBy:\
    \ \" \")\n            \n            for letter in letters {\n                \n\
    \                if letter.characters.count >= n {\n                    \n   \
    \                 found = true\n                    break\n                }\n\
    \            }\n            \n            if found {\n                break\n\
    \            }\n        }\n        \n        if found {\n            \n      \
    \      result.append(word)\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgxmggvs1.swift:20:29: error: value of type 'String' has no member\
    \ 'components'\n    let words: [String] = s.components(separatedBy: \" \")\n \
    \                         ~ ^~~~~~~~~~\n/tmp/tmpgxmggvs1.swift:26:38: error: value\
    \ of type 'String' has no member 'components'\n        let letters: [String] =\
    \ word.components(separatedBy: \" \")\n                                ~~~~ ^~~~~~~~~~\n\
    /tmp/tmpgxmggvs1.swift:32:44: error: value of type 'String' has no member 'components'\n\
    \            let letters: [String] = letter.components(separatedBy: \" \")\n \
    \                                   ~~~~~~ ^~~~~~~~~~\n/tmp/tmpgxmggvs1.swift:36:27:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     if letter.characters.count >= n {\n                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n   \
    \         i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \"a\" {\n            if j < n {\n                j += 1\n            }\n   \
    \     } else {\n            if k < n {\n                k += 1\n            }\n\
    \        }\n        \n        i += 1\n    }\n    \n    if j < n {\n        for\
    \ _ in 0..<j {\n            result.append(String(s[i]))\n        }\n    }\n  \
    \  \n    if k < n {\n        for _ in 0..<k {\n            result.append(String(s[i]))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp21lms_cn.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp21lms_cn.swift:35:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp21lms_cn.swift:50:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(String(s[i]))\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp21lms_cn.swift:56:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(String(s[i]))\n     \
    \                            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.consonants == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw9yjym0b.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw9yjym0b.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants\
    \ == n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // Your code here\n    \n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpbme81adc/tmpbme81adc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4df948c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4df63fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4df63f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4df63e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbme81adc                        0x00005560d105b4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab4dfb34460 __libc_start_main +
    245

    6    tmpbme81adc                        0x00005560d105b0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for k in s.characters {\n        if s.characters[k] ==\
    \ \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyt7gsnrc.swift:142:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpyt7gsnrc.swift:119:51:\
    \ note: to match this opening '{'\n    for j in s.characters[i..<s.characters.count]\
    \ {\n                                                  ^\n/tmp/tmpyt7gsnrc.swift:142:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpyt7gsnrc.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpyt7gsnrc.swift:29:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyt7gsnrc.swift:30:24: error: no exact matches in call\
    \ to subscript \n        if s.characters[k] == \" \" {\n                     \
    \  ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Character')\n    public subscript(r: Range<String.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n/tmp/tmpyt7gsnrc.swift:31:17: error: cannot\
    \ assign value of type 'Character' to type 'Int'\n            i = k\n        \
    \        ^\n/tmp/tmpyt7gsnrc.swift:35:14: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    for j in s.characters[i..<s.characters.count] {\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n     \
    \       j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.appendContentsOf(s[i : j])\n                i = j\n\
    \            }\n        }\n        \n        if s[i] == \"a\" && s[i+1] == \"\
    p\" && s[i+2] == \"p\" && s[i+3] == \"p\" {\n            k = i\n            \n\
    \            while k < s.count && s[k] == \" \" {\n                k += 1\n  \
    \          }\n            \n            if k == s.count {\n                result.appendContentsOf(s[i\
    \ : k])\n                i = k\n            }\n        }\n        \n        if\
    \ s[i] == \"a\" && s[i+1] == \"p\" && s[i+2] == \"p\" && s[i+3] == \"p\" {\n \
    \           k = i\n            \n            while k < s.count && s[k] == \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.appendContentsOf(s[i : k])\n             \
    \   i = k\n            }\n        }\n        \n        if s[i] == \"a\" && s[i+1]\
    \ == \"p\" && s[i+2] == \"p\" && s[i+3] == \"p\" {\n            k = i\n      \
    \      \n            while k < s.count && s[k] == \" \" {\n                k +=\
    \ 1\n            }\n            \n            if k == s.count {\n            \
    \    result.appendContentsOf(s[i : k])\n                i = k\n            }\n\
    \        }\n        \n        if s[i] == \"a\" && s[i+1] == \"p\" && s[i+2] ==\
    \ \"p\" && s[i+3] == \"p\" {\n            k = i\n            \n            while\
    \ k < s.count && s[k] == \" \" {\n                k += 1\n            }\n    \
    \        \n            if k == s.count {\n                result.appendContentsOf(s[i\
    \ : k])\n                i = k\n            }\n        }\n        \n        if\
    \ s[i] == \"a\" && s[i+1] == \"p\" && s[i+2] == \"p\" && s[i+3] == \"p\" {\n \
    \           k = i\n            \n            while k < s.count && s[k] == \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.appendContentsOf(s[i : k])\n             \
    \   i = k\n            }\n        }\n        \n        if s[i] == \"a\" && s[i+1]\
    \ == \"p\" && s[i+2] == \"p\" && s[i+3] == \"p\" {\n            k = i\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb3d1xupb.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpb3d1xupb.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpb3d1xupb.swift:132:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpb3d1xupb.swift:29:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpb3d1xupb.swift:132:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpb3d1xupb.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpb3d1xupb.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i += 1\n  \
    \          continue\n        }\n        \n        if char == \"a\" || char ==\
    \ \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if char == \"b\" || char\
    \ == \"c\" || char == \"d\" || char == \"f\" || char == \"g\" || char == \"h\"\
    \ || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char\
    \ == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char == \"s\"\
    \ || char == \"t\" || char == \"v\" || char == \"w\" || char == \"x\" || char\
    \ == \"y\" || char == \"z\" {\n            j += 1\n            continue\n    \
    \    }\n        \n        if char == \" \" {\n            i += 1\n           \
    \ j += 1\n            continue\n        }\n        \n        if char == \"a\"\
    \ || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n    \
    \        i += 1\n            j += 1\n            continue\n        }\n       \
    \ \n        if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\"\
    \ || char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char\
    \ == \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\"\
    \ || char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char\
    \ == \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j\
    \ += 1\n            i += 1\n            continue\n        }\n        \n      \
    \  if char == \" \" {\n            i += 1\n            j += 1\n            continue\n\
    \        }\n        \n        if char == \"a\" || char == \"e\" || char == \"\
    i\" || char == \"o\" || char == \"u\" {\n            i += 1\n            j +=\
    \ 1\n            continue\n        }\n        \n        if char == \"b\" || char\
    \ == \"c\" || char == \"d\" || char == \"f\" || char == \"g\" || char == \"h\"\
    \ || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char\
    \ == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char == \"s\"\
    \ || char == \"t\" || char == \"v\" || char == \"w\" || char == \"x\" || char\
    \ == \"y\" || char == \"z\" {\n            j += 1\n            i += 1\n      \
    \      continue\n        }\n        \n        if char == \" \" {\n           \
    \ i += 1\n            j += 1\n            continue\n        }\n        \n    \
    \    if char\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_xp0bg9s.swift:86:16: error: expected '{' after 'if' condition\n\
    \        if char\n               ^\n/tmp/tmp_xp0bg9s.swift:108:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp_xp0bg9s.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmp_xp0bg9s.swift:86:12: error:\
    \ cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \        if char\n           ^~~~\n/tmp/tmp_xp0bg9s.swift:90:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    var i = 0\n    var j = 0\n  \
    \  var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n      \
    \      j = i\n            \n            while j < s.count && s[j] != \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                words.append(String(s[i:j]))\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \"a\" || s[i]\
    \ == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            k\
    \ = i\n            \n            while k < s.count && s[k] != \" \" {\n      \
    \          k += 1\n            }\n            \n            if k == s.count {\n\
    \                words.append(String(s[i:k]))\n            }\n            \n \
    \           i = k + 1\n        }\n        \n        if s[i] == \"n\" {\n     \
    \       k = i\n            \n            while k < s.count && s[k] != \" \" {\n\
    \                k += 1\n            }\n            \n            if k == s.count\
    \ {\n                words.append(String(s[i:k]))\n            }\n           \
    \ \n            i = k + 1\n        }\n        \n        if s[i] == \"t\" || s[i]\
    \ == \"s\" || s[i] == \"h\" || s[i] == \"r\" || s[i] == \"d\" {\n            k\
    \ = i\n            \n            while k < s.count && s[k] != \" \" {\n      \
    \          k += 1\n            }\n            \n            if k == s.count {\n\
    \                words.append(String(s[i:k]))\n            }\n            \n \
    \           i = k + 1\n        }\n        \n        if s[i] == \"b\" || s[i] ==\
    \ \"c\" || s[i] == \"m\" || s[i] == \"p\" || s[i] == \"f\" || s[i] == \"v\" ||\
    \ s[i] == \"x\" {\n            k = i\n            \n            while k < s.count\
    \ && s[k] != \" \" {\n                k += 1\n            }\n            \n  \
    \          if k == s.count {\n                words.append(String(s[i:k]))\n \
    \           }\n            \n            i = k + 1\n        }\n        \n    \
    \    if s[i] == \"k\" || s[i] == \"l\" || s[i] == \"m\" || s[i] == \"p\" || s[i]\
    \ == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"x\" {\n            k\
    \ = i\n            \n            while k < s.count && s[k] != \" \" {\n      \
    \          k += 1\n            }\n            \n            if k == s.count {\n\
    \                words.append(String(s[i:k]))\n            }\n            \n \
    \           i = k + 1\n        }\n        \n        if s[i] == \"j\" || s[i] ==\
    \ \"q\" || s[i] == \"x\" || s[i] == \"z\" {\n            k = i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcyxxzu41.swift:29:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpcyxxzu41.swift:29:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpcyxxzu41.swift:137:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpcyxxzu41.swift:29:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpcyxxzu41.swift:137:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpcyxxzu41.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpcyxxzu41.swift:29:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var l = 0\n    var m = s.characters.count\n    var n = n\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = s.characters.count\n    var s = \"\"\
    \n    var t = \"\"\n    var u = \"\"\n    var v = \"\"\n    var w = \"\"\n   \
    \ var x = \"\"\n    var y = \"\"\n    var z = \"\"\n    var a = \"\"\n    var\
    \ b = \"\"\n    var c = \"\"\n    var d = \"\"\n    var e = \"\"\n    var f =\
    \ \"\"\n    var g = \"\"\n    var h = \"\"\n    var i = \"\"\n    var j = \"\"\
    \n    var k = \"\"\n    var l = \"\"\n    var m = \"\"\n    var n = \"\"\n   \
    \ var o = \"\"\n    var p = \"\"\n    var q = \"\"\n    var r = \"\"\n    var\
    \ s = \"\"\n    var t = \"\"\n    var u = \"\"\n    var v = \"\"\n    var w =\
    \ \"\"\n    var x = \"\"\n    var y = \"\"\n    var z = \"\"\n    var a = \"\"\
    \n    var b = \"\"\n    var c = \"\"\n    var d = \"\"\n    var e = \"\"\n   \
    \ var f = \"\"\n    var g = \"\"\n    var h = \"\"\n    var i = \"\"\n    var\
    \ j = \"\"\n    var k = \"\"\n    var l = \"\"\n    var m = \"\"\n    var n =\
    \ \"\"\n    var o = \"\"\n    var p = \"\"\n    var q = \"\"\n    var r = \"\"\
    \n    var s = \"\"\n    var t = \"\"\n    var u = \"\"\n    var v = \"\"\n   \
    \ var w = \"\"\n    var x = \"\"\n    var y = \"\"\n    var z = \"\"\n    var\
    \ a = \"\"\n    var b = \"\"\n    var c = \"\"\n    var d = \"\"\n    var e =\
    \ \"\"\n    var f = \"\"\n    var g = \"\"\n    var h = \"\"\n    var i = \"\"\
    \n    var j = \"\"\n    var k = \"\"\n    var l = \"\"\n    var m = \"\"\n   \
    \ var n = \"\"\n    var o = \"\"\n    var p = \"\"\n    var q = \"\"\n    var\
    \ r = \"\"\n    var s = \"\"\n    var t = \"\"\n    var u = \"\"\n    var v =\
    \ \"\"\n    var w = \"\"\n    var x = \"\"\n    var y = \"\"\n    var z = \"\"\
    \n    var a = \"\"\n    var b = \"\"\n    var c = \"\"\n    var d = \"\"\n   \
    \ var e = \"\"\n    var f = \"\"\n    var g = \"\"\n    var h = \"\"\n    var\
    \ i = \"\"\n    var j = \"\"\n    var k = \"\"\n    var l = \"\"\n    var m =\
    \ \"\"\n    var n = \"\"\n    var o = \"\"\n    var p = \"\"\n    var q = \"\"\
    \n    var r = \"\"\n    var s = \"\"\n    var t = \"\"\n    var u = \"\"\n   \
    \ var v = \"\"\n    var w = \"\"\n    var x = \"\"\n    var y = \"\"\n    var\
    \ z = \"\"\n    var a = \"\"\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsyt4_v8h.swift:146:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpsyt4_v8h.swift:27:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var m = s.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsyt4_v8h.swift:32:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    var r =\
    \ s.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsyt4_v8h.swift:49:9: error: invalid redeclaration of\
    \ 'i'\n    var i = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:23:9: note: 'i' previously\
    \ declared here\n    var i = 0\n        ^\n/tmp/tmpsyt4_v8h.swift:50:9: error:\
    \ invalid redeclaration of 'j'\n    var j = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpsyt4_v8h.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpsyt4_v8h.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpsyt4_v8h.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = s.characters.count\n       \
    \ ^\n/tmp/tmpsyt4_v8h.swift:54:9: error: invalid redeclaration of 'n'\n    var\
    \ n = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:28:9: note: 'n' previously declared\
    \ here\n    var n = n\n        ^\n/tmp/tmpsyt4_v8h.swift:55:9: error: invalid\
    \ redeclaration of 'o'\n    var o = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpsyt4_v8h.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = \"\"\n        ^\n/tmp/tmpsyt4_v8h.swift:30:9:\
    \ note: 'p' previously declared here\n    v"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        if char == \"y\" {\n\
    \            continue\n        }\n        if char == \"n\" {\n            continue\n\
    \        }\n        if char == \"t\" {\n            continue\n        }\n    \
    \    if char == \"s\" {\n            continue\n        }\n        if char == \"\
    h\" {\n            continue\n        }\n        if char == \"r\" {\n         \
    \   continue\n        }\n        if char == \"d\" {\n            continue\n  \
    \      }\n        if char == \"l\" {\n            continue\n        }\n      \
    \  if char == \"m\" {\n            continue\n        }\n        if char == \"\
    a\" {\n            continue\n        }\n        if char == \"p\" {\n         \
    \   continue\n        }\n        if char == \"e\" {\n            continue\n  \
    \      }\n        if char == \"f\" {\n            continue\n        }\n      \
    \  if char == \"v\" {\n            continue\n        }\n        if char == \"\
    g\" {\n            continue\n        }\n        if char == \"b\" {\n         \
    \   continue\n        }\n        if char == \"k\" {\n            continue\n  \
    \      }\n        if char == \"j\" {\n            continue\n        }\n      \
    \  if char == \"q\" {\n            continue\n        }\n        if char == \"\
    z\" {\n            continue\n        }\n        if char == \"x\" {\n         \
    \   continue\n        }\n        if char == \"z\" {\n            continue\n  \
    \      }\n        if char == \"m\" {\n            continue\n        }\n      \
    \  if char == \"n\" {\n            continue\n        }\n        if char == \"\
    k\" {\n            continue\n        }\n        if char == \"p\" {\n         \
    \   continue\n        }\n        if char == \"l\" {\n            continue\n  \
    \      }\n        if char == \"q\" {\n            continue\n        }\n      \
    \  if char == \"j\" {\n            continue\n        }\n        if char == \"\
    z\" {\n            continue\n        }\n        if char == \"a\" {\n         \
    \   continue\n        }\n        if char == \"e\" {\n            continue\n  \
    \      }\n        if char == \"i\" {\n            continue\n        }\n      \
    \  if char == \"o\" {\n            continue\n        }\n        if char == \"\
    u\" {\n            continue\n        }\n        if char == \"y\" {\n         \
    \   continue\n        }\n        if char == \"n\" {\n            continue\n  \
    \      }\n        if char == \"t\" {\n            continue\n        }\n      \
    \  if char == \"s\" {\n            continue\n        }\n        if char == \"\
    h\" {\n            continue\n        }\n        if char == \"r\" {\n         \
    \   continue\n        }\n        if char == \"d\" {\n            continue\n  \
    \      }\n        if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1ezbbdls.swift:153:11: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmp1ezbbdls.swift:175:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp1ezbbdls.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp1ezbbdls.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1ezbbdls.swift:157:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var count = 0\n    var lastChar\
    \ = \"\"\n    \n    for char in s {\n        if char == lastChar {\n         \
    \   count += 1\n        } else {\n            if count == n {\n              \
    \  result.append(String(lastChar))\n                count = 0\n            }\n\
    \            lastChar = char\n            count = 1\n        }\n    }\n    \n\
    \    if count > 0 {\n        result.append(String(lastChar))\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmy3_j_5h.swift:29:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == lastChar {\n\
    \           ~~~~ ^  ~~~~~~~~\n/tmp/tmpmy3_j_5h.swift:29:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == lastChar {\n                ^\n/tmp/tmpmy3_j_5h.swift:36:24:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  lastChar = char\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var count = 0\n    var lastChar = \"\"\n    for char in s {\n        if char\
    \ == \" \" {\n            if count == n {\n                result.append(String(lastChar))\n\
    \                count = 0\n            }\n        } else {\n            if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n                lastChar = char\n                count++\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37odypob.swift:36:28: error: cannot assign value of type 'Character'\
    \ to type 'String'\n                lastChar = char\n                        \
    \   ^~~~\n/tmp/tmp37odypob.swift:37:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                count++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n \
    \   var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n  \
    \  var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n   \
    \ var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var\
    \ f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k\
    \ = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p =\
    \ 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n\
    \    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n \
    \   var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n  \
    \  var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n   \
    \ var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\
    \ p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u\
    \ = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z =\
    \ 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n\
    \    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n  \
    \  var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n   \
    \ var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var\
    \ z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e\
    \ = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv2zc5qvx.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv2zc"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \" \" {\n     \
    \       i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0_m2zj72.swift:28:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp0_m2zj72.swift:28:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp0_m2zj72.swift:199:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp0_m2zj72.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmp0_m2zj72.swift:28:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmp0_m2zj72.swift:181:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    var i = 0\n    var j = 0\n  \
    \  var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            k = j\n    \
    \        \n            while k < s.count && s[k] != \" \" {\n                k\
    \ += 1\n            }\n            \n            if k == j {\n               \
    \ words.append(String(s[i:j]))\n                i = j + 1\n            } else\
    \ {\n                words.append(String(s[i:k]))\n                i = k + 1\n\
    \            }\n        } else {\n            i += 1\n        }\n    }\n    \n\
    \    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwyqll601.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpwyqll601.swift:33:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] == \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpwyqll601.swift:39:34: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   while k < s.count && s[k] != \" \" {\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwyqll601.swift:44:38:\
    \ error: extraneous argument label 'i:' in subscript\n                words.append(String(s[i:j]))\n\
    \                                     ^~~\n                                  \
    \    \n/tmp/tmpwyqll601.swift:47:38: error: extraneous argument label 'i:' in\
    \ subscript\n                words.append(String(s[i:k]))\n                  \
    \                   ^~~\n                                      \n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s {\n        if char.unicodeScalars.count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpkvtynplx/tmpkvtynplx.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b792a5c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b792a2b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b792a2b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b792a2b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvtynplx                        0x000055901e89a7d4 <unavailable> + 6100

    5    libc.so.6                          0x00002b792a7ac460 __libc_start_main +
    245

    6    tmpkvtynplx                        0x000055901e89a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let vowels = \"aeiouAEIOU\"\n    \n\
    \    var words = [String]()\n    \n    if s.isEmpty {\n        return words\n\
    \    }\n    \n    for letter in s.characters {\n        if vowels.contains(String(letter))\
    \ {\n            \n            let vowelIndex = vowels.firstIndex(of: String(letter))\n\
    \            \n            if vowelIndex == 0 {\n                words.append(String(letter))\n\
    \            } else if vowelIndex == vowels.count - 1 {\n                words.append(String(letter))\n\
    \            } else {\n                words.append(String(letter))\n        \
    \        words.append(String(s[vowelIndex]))\n            }\n        }\n    }\n\
    \    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp94al2hlw.swift:28:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp94al2hlw.swift:31:52:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            let vowelIndex = vowels.firstIndex(of: String(letter))\n\
    \                                                   ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    var count = 0\n    \n\
    \    for letter in s {\n        if letter == \" \" {\n            count += 1\n\
    \            if count == n {\n                result.append(\"\\n\")\n       \
    \         count = 0\n            }\n        } else {\n            count = 0\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmphwoko5pw/tmphwoko5pw.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002addd2b53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002addd284ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002addd284a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002addd28497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphwoko5pw                        0x000055d131aa0774 <unavailable> + 6004

    5    libc.so.6                          0x00002addd2d3f460 __libc_start_main +
    245

    6    tmphwoko5pw                        0x000055d131aa0379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n \
    \   var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n  \
    \  var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n   \
    \ var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var\
    \ f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k\
    \ = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p =\
    \ 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n\
    \    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n \
    \   var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n  \
    \  var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n   \
    \ var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\
    \ p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u\
    \ = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z =\
    \ 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n\
    \    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n  \
    \  var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n   \
    \ var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var\
    \ z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e\
    \ = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv2zc5qvx.swift:49:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:23:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:50:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:24:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:51:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:25:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:52:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:26:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:53:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:27:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:54:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:28:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:55:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:29:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:56:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:30:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:57:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:31:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:58:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:32:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:59:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:33:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv2zc5qvx.swift:60:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv2zc"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: Write your code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp0pzjovvn/tmp0pzjovvn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad949a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad94975ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad94975a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9497597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0pzjovvn                        0x0000556130d4f4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ad949c4f460 __libc_start_main +
    245

    6    tmp0pzjovvn                        0x0000556130d4f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    for char in s {\n  \
    \      if char == \" \" {\n            continue\n        }\n        \n       \
    \ if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n            continue\n        }\n        \n        if char == \"\
    n\" {\n            if n == 1 {\n                continue\n            }\n    \
    \        \n            if n == 2 {\n                result.append(\"little\")\n\
    \                continue\n            }\n            \n            if n == 3\
    \ {\n                result.append(\"Mary\")\n                continue\n     \
    \       }\n            \n            if n == 4 {\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 5 {\n                result.append(\"Sam\")\n                continue\n\
    \            }\n            \n            if n == 6 {\n                result.append(\"\
    Uncle\")\n                continue\n            }\n            \n            if\
    \ n == 7 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 8 {\n                result.append(\"\
    Uncle\")\n                continue\n            }\n            \n            if\
    \ n == 9 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 10 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 11 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 12 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 13 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 14 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 15 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 16 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 17 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 18 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 19 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 20 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 21 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 22 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 23 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 24 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == 25 {\n                result.append(\"sam\")\n                continue\n\
    \            }\n            \n            if n == 26 {\n                result.append(\"\
    sam\")\n                continue\n            }\n            \n            if\
    \ n == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx303cr2l.swift:166:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpx303cr2l.swift:187:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpx303cr2l.swift:26:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpx303cr2l.swift:187:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpx303cr2l.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpx303cr2l.swift:169:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words = s.components(separatedBy:\
    \ \" \")\n    \n    var result = [String]()\n    \n    for word in words {\n \
    \       if word.hasPrefix(\"con\") {\n            if word.hasSuffix(\"e\") {\n\
    \                if word.hasPrefix(\"n\") {\n                    if word.hasSuffix(\"\
    s\") {\n                        if word.hasPrefix(\"t\") {\n                 \
    \           if word.hasSuffix(\"e\") {\n                                if word.hasPrefix(\"\
    l\") {\n                                    if word.hasSuffix(\"l\") {\n     \
    \                                   if word.hasPrefix(\"h\") {\n             \
    \                               if word.hasSuffix(\"e\") {\n                 \
    \                               if word.hasPrefix(\"d\") {\n                 \
    \                                   if word.hasSuffix(\"a\") {\n             \
    \                                           if word.hasPrefix(\"t\") {\n     \
    \                                                       if word.hasSuffix(\"e\"\
    ) {\n                                                                if word.hasPrefix(\"\
    s\") {\n                                                    if word.hasSuffix(\"\
    s\") {\n                                                        if word.hasPrefix(\"\
    a\") {\n                                                            if word.hasSuffix(\"\
    m\") {\n                                                                if word.hasSuffix(\"\
    a\") {\n                                                                    if\
    \ word.hasPrefix(\"n\") {\n                                                  \
    \                      if word.hasSuffix(\"g\") {\n                          \
    \                                                  if word.hasPrefix(\"l\") {\n\
    \                                                                            \
    \    if word.hasSuffix(\"l\") {\n                                            \
    \                                        if word.hasPrefix(\"h\") {\n        \
    \                                                                            \
    \    if word.hasSuffix(\"e\") {\n                                            \
    \                                                if word.hasPrefix(\"d\") {\n\
    \                                                                            \
    \                    if word.hasSuffix(\"a\") {\n                            \
    \                                                                        if word.hasPrefix(\"\
    t\") {\n                                                                     \
    \                                   if word.hasSuffix(\"e\") {\n             \
    \                                                                            \
    \                   if word.hasPrefix(\"s\") {\n                             \
    \                                                                            \
    \       if word.hasSuffix(\"s\") {\n                                         \
    \                                                                           if\
    \ word.hasPrefix(\"a\") {\n                                                  \
    \                                                                      if word.hasSuffix(\"\
    m\") {\n                                                                     \
    \                                                       if word.hasSuffix(\"a\"\
    ) {\n                                                                        \
    \                                                                        if word.hasPrefix(\"\
    n\") {\n                                                                     \
    \                                                               if word.hasSuffix(\"\
    g\") {\n                                                                     \
    \                                                                   if word.hasPrefix(\"\
    l\") {\n                                                                     \
    \                                                                       if word.hasSuffix(\"\
    l\") {\n                                                                     \
    \                                                                           if\
    \ word.hasPrefix(\"h\") {\n                                                  \
    \                                                                            \
    \      if word.hasSuffix(\"e\") {\n                                          \
    \                                                                            \
    \                  if word.hasPrefix(\"d\") {\n                              \
    \                                                                            \
    \                                                                  if word.hasSuffix(\"\
    a\") {\n                                                                     \
    \                                                                            \
    \                               if word.hasPrefix(\"t\") {\n                 \
    \                                                                            \
    \                                                                            \
    \           if word.hasSuffix(\"e\") {\n                                     \
    \                                                                            \
    \                                                                       if word.hasPrefix(\"\
    s\") {\n                                                                     \
    \                                                                            \
    \                                           if word.hasSuffix(\"s\") {\n     \
    \                                                                            \
    \                                                                            \
    \                                                                   if word.hasPrefix(\"\
    a\") {\n                                                                     \
    \                                                                            \
    \                                                   if word.hasSuffix(\"m\") {\n\
    \                                                                            \
    \                                                                            \
    \                                                if word.hasSuffix(\"a\") {\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \        if word.hasPrefix(\"n\") {\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj2pbp1tx.swift:96:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpj2pbp1tx.swift:73:224:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                                                            \
    \      if word.hasSuffix(\"a\") {\n                                          \
    \                                                                            \
    \                                                                            \
    \                             ^\n/tmp/tmpj2pbp1tx.swift:96:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmpj2pbp1tx.swift:72:220: note: to match this\
    \ opening '{'\n                                                              \
    \                                                                            \
    \                                                          if word.hasSuffix(\"\
    m\") {\n                                                                     \
    \                                                                            \
    \                                                                          ^\n\
    /tmp/tmpj2pbp1tx.swift:96:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpj2pbp1tx.swift:71:248:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                                                            \
    \                              if word.hasPrefix(\"a\") {\n                  \
    \                                                       "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n  \
    \          result.append(String(char))\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsx89fpo_.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsx89fpo_.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: Write your code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp0pzjovvn/tmp0pzjovvn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad949a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad94975ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad94975a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9497597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0pzjovvn                        0x0000556130d4f4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ad949c4f460 __libc_start_main +
    245

    6    tmp0pzjovvn                        0x0000556130d4f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s {\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5e49v2_0.swift:26:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isConsonant'\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n                                        ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptm0dxd9p.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptm0dxd9p.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var count = 0\n    \n    for\
    \ letter in s {\n        if letter == \" \" {\n            count += 1\n      \
    \  }\n        if count == n {\n            result.append(letter)\n           \
    \ count = 0\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxdbtm_ux.swift:32:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    for char in s {\n        if vowels.contains(char) {\n            if\
    \ result.count < n {\n                result.append(char)\n            }\n   \
    \     }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv7bnygdo.swift:31:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(char)\n  \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.hasConsonant() {\n            if result.count < n {\n       \
    \         result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdos79155.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdos79155.swift:26:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] ==\
    \ \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" ||\
    \ s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s[i] == \"\
    y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" ||\
    \ s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"y\" || s[i] ==\
    \ \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\"\
    \ || s[i] == \"u\" {\n            i += 1\n            continue\n        }\n  \
    \      \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] ==\
    \ \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"y\" || s[i] ==\
    \ \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\"\
    \ || s[i] == \"u\" {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsd7lgh1f.swift:30:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpsd7lgh1f.swift:30:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpsd7lgh1f.swift:119:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpsd7lgh1f.swift:30:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpsd7lgh1f.swift:119:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpsd7lgh1f.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpsd7lgh1f.swift:30:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    var result = [String]()\n    \n   \
    \ if s == \"\" {\n        return result\n    }\n    \n    for letter in s {\n\
    \        if letter == \" \" {\n            continue\n        }\n        \n   \
    \     if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"\
    o\" || letter == \"u\" {\n            continue\n        }\n        \n        if\
    \ letter == \"y\" {\n            if s.hasPrefix(\"y\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"o\" {\n          \
    \  if s.hasPrefix(\"o\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"u\" {\n            if s.hasPrefix(\"u\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"i\" {\n            if s.hasPrefix(\"i\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"e\" {\n          \
    \  if s.hasPrefix(\"e\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"a\" {\n            if s.hasPrefix(\"a\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"n\" {\n            if s.hasPrefix(\"n\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"d\" {\n          \
    \  if s.hasPrefix(\"d\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"s\" {\n            if s.hasPrefix(\"s\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"h\" {\n            if s.hasPrefix(\"h\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"r\" {\n          \
    \  if s.hasPrefix(\"r\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"l\" {\n            if s.hasPrefix(\"l\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"m\" {\n            if s.hasPrefix(\"m\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"t\" {\n          \
    \  if s.hasPrefix(\"t\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"p\" {\n            if s.hasPrefix(\"p\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"f\" {\n            if s.hasPrefix(\"f\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"v\" {\n          \
    \  if s.hasPrefix(\"v\") {\n                continue\n            }\n        }\n\
    \        \n        if letter == \"c\" {\n            if s.hasPrefix(\"c\") {\n\
    \                continue\n            }\n        }\n        \n        if letter\
    \ == \"g\" {\n            if s.hasPrefix(\"g\") {\n                continue\n\
    \            }\n        }\n        \n        if letter == \"b\" {\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj9u9r9on.swift:172:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpj9u9r9on.swift:26:21:\
    \ note: to match this opening '{'\n    for letter in s {\n                   \
    \ ^\n/tmp/tmpj9u9r9on.swift:172:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpj9u9r9on.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpj9u9r9on.swift:154:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpj9u9r9on.swift:20:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            j = i\n   \
    \     }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \" \" {\n            j = i\n        }\n        \n        if\
    \ char == \" \" {\n            j = i\n        }\n        \n        if char ==\
    \ \"n\" {\n            i = j\n        }\n        \n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n       \
    \     i = j\n        }\n        \n        if char == \" \" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            j = i\n    \
    \    }\n        \n        if char == \"n\" {\n            i = j\n        }\n \
    \       \n        if char == \"a\" || char == \"e\" || char == \"i\" || char ==\
    \ \"o\" || char == \"u\" {\n            i = j\n        }\n        \n        if\
    \ char == \" \" {\n            j = i\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \"n\" {\n\
    \            i = j\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"n\" {\n            i = j\n        }\n        \n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            i = j\n        }\n        \n        if char == \" \" {\n\
    \            j = i\n        }\n        \n        if char == \" \" {\n        \
    \    j = i\n        }\n        \n        if char == \"n\" {\n            i = j\n\
    \        }\n        \n        if char == \"a\" || char == \"e\" || char == \"\
    i\" || char == \"o\" || char == \"u\" {\n            i = j\n        }\n      \
    \  \n        if char == \" \" {\n            j = i\n        }\n        \n    \
    \    if char == \" \" {\n            j = i\n        }\n        \n        if char\
    \ == \"n\" {\n            i = j\n        }\n        \n        if char == \"a\"\
    \ || char == \"e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7x1m9wqj.swift:129:35: error: unterminated string literal\n   \
    \     if char == \"a\" || char == \"e\n                                  ^\n/tmp/tmp7x1m9wqj.swift:151:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp7x1m9wqj.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp7x1m9wqj.swift:133:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // Your code here\n    var result = [String]()\n\
    \    var i = 0\n    while i < s.characters.count {\n        if s.characters[i]\
    \ != \" \" {\n            if s.characters[i] == \"a\" || s.characters[i] == \"\
    e\" || s.characters[i] == \"i\" || s.characters[i] == \"o\" || s.characters[i]\
    \ == \"u\" {\n                i += 1\n            } else {\n                result.appendContentsOf(select_words(s.substringFromIndex(i),\
    \ n))\n                i = s.characters.count\n            }\n        } else {\n\
    \            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwvq5_qbj.swift:22:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    while i < s.characters.count {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpwvq5_qbj.swift:23:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s.characters[i] != \" \" {\n       \
    \    ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwvq5_qbj.swift:23:14: error: 'characters' is unavailable:\
    \ Please use String directly\n        if s.characters[i] != \" \" {\n        \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwvq5_qbj.swift:24:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s.characters[i] == \"a\" || s.characters[i]\
    \ == \"e\" || s.characters[i] == \"i\" || s.characters[i] == \"o\" || s.characters[i]\
    \ == \"u\" {\n               ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwvq5_qbj.swift:24:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters[i] ==\
    \ \"a\" || s.characters[i] == \"e\" || s.characters[i] == \"i\" || s.characters[i]\
    \ == \"o\" || s.characters[i] == \"u\" {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpwvq5_qbj.swift:24:42: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s.characters[i] == \"a\" || s.characters[i] == \"e\" || s.characters[i]\
    \ == \"i\" || s.characters[i] == \"o\" || s.characters[i] == \"u\" {\n       \
    \    "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for c in s.characters {\n  \
    \      if c == \" \" {\n            continue\n        }\n        \n        if\
    \ c.isConsonant() {\n            if result.count < n {\n                result.append(String(c.unicodeScalars))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzfej86rz.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzfej86rz.swift:30:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var count =\
    \ 0\n    for letter in s.characters {\n        if letter == \" \" {\n        \
    \    count += 1\n            if count == n {\n                result.append(String(letter))\n\
    \            }\n        } else {\n            count = 0\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp32w39f1x.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return s.split(\" \").filter{ $0.contains(String(repeating:\
    \ \"a\", count: n)) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5ol742c3.swift:19:14: error: no exact matches in call to instance\
    \ method 'split'\n    return s.split(\" \").filter{ $0.contains(String(repeating:\
    \ \"a\", count: n)) }\n             ^\n/tmp/tmp5ol742c3.swift:19:14: note: found\
    \ candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    return s.split(\"\
    \ \").filter{ $0.contains(String(repeating: \"a\", count: n)) }\n            \
    \ ^\n/tmp/tmp5ol742c3.swift:19:14: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [String.SubSequence]' (aka '(Character, Int, Bool) -> Array<Substring>')\n\
    \    return s.split(\" \").filter{ $0.contains(String(repeating: \"a\", count:\
    \ n)) }\n             ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var index =\
    \ 0\n    var count = 0\n    for letter in s {\n        if letter == \" \" {\n\
    \            count += 1\n            if count == n {\n                result.insert(index,\
    \ letter)\n                index += 1\n                count = 0\n           \
    \ }\n        } else {\n            count = 0\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppz5skmis.swift:26:30: error: missing argument labels 'contentsOf:at:'\
    \ in call\n                result.insert(index, letter)\n                    \
    \         ^\n                              contentsOf:  at: \n/tmp/tmppz5skmis.swift:26:38:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Array<String>.Index'\
    \ (aka 'Int')\n                result.insert(index, letter)\n                \
    \                     ^\n/tmp/tmppz5skmis.swift:26:17: error: instance method\
    \ 'insert(contentsOf:at:)' requires that 'Int' conform to 'Collection'\n     \
    \           result.insert(index, letter)\n                ^\nSwift.RangeReplaceableCollection:7:37:\
    \ note: where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    for i < s.count {\n        if s[i] == \" \" {\n            j = i\n      \
    \      i = s.count\n        }\n        if j == i {\n            if k == n {\n\
    \                result.append(String(s[i:j]))\n                i = j\n      \
    \          j = 0\n                k = 0\n            } else {\n              \
    \  k += 1\n            }\n        } else {\n            j += 1\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3mz_4th1.swift:26:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp3mz_4th1.swift:26:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp3mz_4th1.swift:26:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for k in s.characters {\n        if k == ' ' {\n    \
    \        continue\n        }\n        \n        if j == n {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n            j = 0\n        }\n        \n        if k ==\
    \ s.characters.count - 1 {\n            result.append(String(s.characters[i:k]))\n\
    \            i = k + 1\n            j = 0\n        }\n        \n        if s.characters[k]\
    \ == 'a' || s.characters[k] == 'e' || s.characters[k] == 'i' || s.characters[k]\
    \ == 'o' || s.characters[k] == 'u' {\n            j++\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzcgkpvkr.swift:30:17: error: single-quoted string literal found,\
    \ use '\"'\n        if k == ' ' {\n                ^~~\n                \" \"\n\
    /tmp/tmpzcgkpvkr.swift:46:31: error: single-quoted string literal found, use '\"\
    '\n        if s.characters[k] == 'a' || s.characters[k] == 'e' || s.characters[k]\
    \ == 'i' || s.characters[k] == 'o' || s.characters[k] == 'u' {\n             \
    \                 ^~~\n                              \"a\"\n/tmp/tmpzcgkpvkr.swift:46:57:\
    \ error: single-quoted string literal found, use '\"'\n        if s.characters[k]\
    \ == 'a' || s.characters[k] == 'e' || s.characters[k] == 'i' || s.characters[k]\
    \ == 'o' || s.characters[k] == 'u' {\n                                       \
    \                 ^~~\n                                                      \
    \  \"e\"\n/tmp/tmpzcgkpvkr.swift:46:83: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[k] == 'a' || s.characters[k] == 'e' || s.characters[k]\
    \ == 'i' || s.characters[k] == 'o' || s.characters[k] == 'u' {\n             \
    \                                                                     ^~~\n  \
    \                                                                            \
    \    \"i\"\n/tmp/tmpzcgkpvkr.swift:46:109: error: single-quoted string literal\
    \ found, use '\"'\n        if s.characters[k] == 'a' || s.characters[k] == 'e'\
    \ || s.characters[k] == 'i' || s.characters[k] == 'o' || s.characters[k] == 'u'\
    \ {\n                                                                        \
    \                                    ^~~\n                                   \
    \                                                                         \"o\"\
    \n/tmp/tmpzcgkpvkr.swift:46:135: error: single-quoted string literal found, use\
    \ '\"'\n        if s.characters[k] == 'a' || s.characters[k] == 'e' || s.characters[k]\
    \ == 'i' || s.characters[k] == 'o' || s.characters[k] == 'u' {\n             \
    \                                                                            \
    \                                             ^~~\n                          \
    \                                                  "
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i = j\n   \
    \     }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3__py8kr.swift:73:46: error: expected '{' after 'if' condition\n\
    \        if char == \"b\" || char == \"c\" || char\n                         \
    \                    ^\n/tmp/tmp3__py8kr.swift:95:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp3__py8kr.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmp3__py8kr.swift:73:42: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Bool'\n       \
    \ if char == \"b\" || char == \"c\" || char\n                                \
    \         ^\n/tmp/tmp3__py8kr.swift:77:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    \n    var result = [String]()\n    \n    for word in words {\n    \
    \    if word.characters.count >= n {\n            result.append(word)\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpog6kxd5h.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s {\n        if char.unicodeScalars.count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpkvtynplx/tmpkvtynplx.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b792a5c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b792a2b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b792a2b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b792a2b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvtynplx                        0x000055901e89a7d4 <unavailable> + 6100

    5    libc.so.6                          0x00002b792a7ac460 __libc_start_main +
    245

    6    tmpkvtynplx                        0x000055901e89a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        if char == \" \" {\n            continue\n        }\n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            continue\n        }\n        if char == \"y\" {\n           \
    \ continue\n        }\n        if char == \"s\" {\n            continue\n    \
    \    }\n        if char == \"h\" {\n            continue\n        }\n        if\
    \ char == \"l\" {\n            continue\n        }\n        if char == \"d\" {\n\
    \            continue\n        }\n        if char == \"m\" {\n            continue\n\
    \        }\n        if char == \"n\" {\n            continue\n        }\n    \
    \    if char == \"t\" {\n            continue\n        }\n        if char == \"\
    k\" {\n            continue\n        }\n        if char == \"b\" {\n         \
    \   continue\n        }\n        if char == \"p\" {\n            continue\n  \
    \      }\n        if char == \"v\" {\n            continue\n        }\n      \
    \  if char == \"f\" {\n            continue\n        }\n        if char == \"\
    r\" {\n            continue\n        }\n        if char == \"q\" {\n         \
    \   continue\n        }\n        if char == \"z\" {\n            continue\n  \
    \      }\n        if char == \"c\" {\n            continue\n        }\n      \
    \  if char == \"g\" {\n            continue\n        }\n        if char == \"\
    j\" {\n            continue\n        }\n        if char == \"q\" {\n         \
    \   continue\n        }\n        if char == \"z\" {\n            continue\n  \
    \      }\n        if char == \"k\" {\n            continue\n        }\n      \
    \  if char == \"p\" {\n            continue\n        }\n        if char == \"\
    v\" {\n            continue\n        }\n        if char == \"f\" {\n         \
    \   continue\n        }\n        if char == \"r\" {\n            continue\n  \
    \      }\n        if char == \"q\" {\n            continue\n        }\n      \
    \  if char == \"z\" {\n            continue\n        }\n        if char == \"\
    c\" {\n            continue\n        }\n        if char == \"g\" {\n         \
    \   continue\n        }\n        if char == \"j\" {\n            continue\n  \
    \      }\n        if char == \"q\" {\n            continue\n        }\n      \
    \  if char == \"z\" {\n            continue\n        }\n        if char == \"\
    k\" {\n            continue\n        }\n        if char == \"p\" {\n         \
    \   continue\n        }\n        if char == \"v\" {\n            continue\n  \
    \      }\n        if char == \"f\" {\n            continue\n        }\n      \
    \  if char == \"r\" {\n            continue\n        }\n        if char == \"\
    q\" {\n            continue\n        }\n        if char == \"z\" {\n         \
    \   continue\n        }\n        if char == \"c\" {\n            continue\n  \
    \      }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwvl09yqx.swift:175:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpwvl09yqx.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpwvl09yqx.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpwvl09yqx.swift:157:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpwvl09yqx.swift:19:9: warning: initialization\
    \ of variable 'result' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var result = [String]()\n    ~~~~^~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s.characters {\n        if char == \" \" {\n           \
    \ i += 1\n        }\n        \n        if char == \"a\" || char == \"e\" || char\
    \ == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n        }\n\
    \        \n        if j == n {\n            result.append(String(s[i:j]))\n  \
    \          i = j + 1\n            j = 0\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgkestk4h.swift:28:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgkestk4h.swift:38:35:\
    \ error: extraneous argument label 'i:' in subscript\n            result.append(String(s[i:j]))\n\
    \                                  ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    while i < s.count {\n        if s[i] == \" \" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"y\" {\n \
    \           i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"s\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"h\" || s[i] == \"d\" || s[i] == \"l\" || s[i] == \"m\" ||\
    \ s[i] == \"n\" || s[i] == \"r\" || s[i] == \"t\" || s[i] == \"w\" || s[i] ==\
    \ \"v\" || s[i] == \"z\" {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"f\" || s[i]\
    \ == \"p\" || s[i] == \"v\" || s[i] == \"x\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"k\" || s[i] == \"j\" ||\
    \ s[i] == \"q\" || s[i] == \"x\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"m\" || s[i] == \"n\" || s[i] == \"\
    p\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"z\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"e\" || s[i] ==\
    \ \"g\" || s[i] == \"p\" || s[i] == \"t\" || s[i] == \"z\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"a\" || s[i]\
    \ == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"y\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"s\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"h\" || s[i] == \"d\" || s[i] == \"l\" || s[i] == \"m\" ||\
    \ s[i] == \"n\" || s[i] == \"r\" || s[i] == \"t\" || s[i] == \"w\" || s[i] ==\
    \ \"v\" || s[i] == \"z\" {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"f\" || s[i]\
    \ == \"p\" || s[i] == \"v\" || s[i] == \"x\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"k\" || s[i] == \"j\" ||\
    \ s[i] == \"q\" || s[i] == \"x\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"m\" || s[i] == \"n\" || s[i] == \"\
    p\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"z\" {\n            i += 1\n\
    \            continue\n        }\n        \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpufflrtzh.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpufflrtzh.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpufflrtzh.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpufflrtzh.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpufflrtzh.swift:34:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpufflrtzh.swift:34:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpufflrtzh.swift:34:57: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] ="
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    for char in s {\n        if char == \" \" {\n       \
    \     if j == n {\n                result.appendContentsOf(select_words(s[i ..<\
    \ s.endIndex], n))\n                i = s.startIndex\n                j = 0\n\
    \                k = 0\n            } else {\n                j += 1\n       \
    \     }\n        } else {\n            if char == \"a\" || char == \"e\" || char\
    \ == \"i\" || char == \"o\" || char == \"u\" {\n                k += 1\n     \
    \       }\n        }\n    }\n    \n    if j == n {\n        result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpni26rm83.swift:32:24: error: value of type '[String]' has no member\
    \ 'appendContentsOf'\n                result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpni26rm83.swift:32:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n                                                    ^\n\
    \                                                     s:                   n:\
    \ \n/tmp/tmpni26rm83.swift:32:64: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n                result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n                                                     \
    \          ^\n/tmp/tmpni26rm83.swift:33:23: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n                i = s.startIndex\n           \
    \         ~~^~~~~~~~~~\n/tmp/tmpni26rm83.swift:47:16: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n        result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n        ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpni26rm83.swift:47:45:\
    \ error: missing argument labels 's:n:' in call\n        result.appendContentsOf(select_words(s[i\
    \ ..< s.endIndex], n))\n                                            ^\n      \
    \                                       s:                   n: \n/tmp/tmpni26rm83.swift:47:56:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        result.appendContentsOf(select_words(s[i ..< s.endIndex], n))\n\
    \                                                       ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s {\n        if\
    \ char.unicodeScalars.count >= n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpfqxpctsw/tmpfqxpctsw.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74c0e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab74bddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab74bdda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab74bdd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfqxpctsw                        0x00005574014be834 <unavailable> + 6196

    5    libc.so.6                          0x00002ab74c2cf460 __libc_start_main +
    245

    6    tmpfqxpctsw                        0x00005574014be439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    for k in 0..<s.characters.count {\n        if s.characters[k] == \" \" {\n\
    \            if j == n {\n                result.append(\"\\(strings[k])\")\n\
    \                j = 0\n            } else {\n                j += 1\n       \
    \     }\n        } else {\n            if j == n {\n                result.append(\"\
    \\(strings[k])\")\n                j = 0\n            } else {\n             \
    \   j += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpocjlpx34.swift:26:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for k in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpocjlpx34.swift:27:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s.characters[k] == \" \" {\n       \
    \    ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpocjlpx34.swift:27:14: error: 'characters' is unavailable:\
    \ Please use String directly\n        if s.characters[k] == \" \" {\n        \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpocjlpx34.swift:29:34:\
    \ error: cannot find 'strings' in scope\n                result.append(\"\\(strings[k])\"\
    )\n                                 ^~~~~~~\n/tmp/tmpocjlpx34.swift:36:34: error:\
    \ cannot find 'strings' in scope\n                result.append(\"\\(strings[k])\"\
    )\n                                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for letter in\
    \ s.characters {\n        if letter == \" \" {\n            continue\n       \
    \ }\n        if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter\
    \ == \"o\" || letter == \"u\" {\n            continue\n        }\n        if letter\
    \ == \"y\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"n\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"t\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"s\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"h\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"r\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"d\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"l\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"m\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"a\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"p\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"e\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"u\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"c\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"b\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"f\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"v\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"m\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"p\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"l\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        if letter\
    \ == \"s\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        if letter == \"t\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd157km_f.swift:159:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpd157km_f.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpd157km_f.swift:20:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in s.characters {\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpd157km_f.swift:28:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ > n {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpd157km_f.swift:33:18: error: 'characters' is unavailable:\
    \ Please use String directly\n            if s.characters.count > n {\n      \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpd157km_f.swift:38:18: error: 'characters' is unavailable: Please use String\
    \ directly\n            if s.characters.count > n {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd157km_f.swift:43:18:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if s.characters.count > n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpd157km_f.swift:48:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ > n {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            i = j\n   \
    \     }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n\
    \        if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char == \"d\" || char == \"f\" ||\
    \ char == \"g\" || char == \"h\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"n\" || char == \"p\" || char == \"q\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            j =\
    \ i\n        }\n        \n        if char == \" \" {\n            i = j\n    \
    \    }\n        \n        if char == \"a\" || char == \"e\" || char == \"i\" ||\
    \ char == \"o\" || char == \"u\" {\n            i = j\n        }\n        \n \
    \       if char == \"b\" || char == \"c\" || char\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3__py8kr.swift:73:46: error: expected '{' after 'if' condition\n\
    \        if char == \"b\" || char == \"c\" || char\n                         \
    \                    ^\n/tmp/tmp3__py8kr.swift:95:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp3__py8kr.swift:18:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmp3__py8kr.swift:73:42: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Bool'\n       \
    \ if char == \"b\" || char == \"c\" || char\n                                \
    \         ^\n/tmp/tmp3__py8kr.swift:77:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var count = 0\n    var last = 0\n    var lastCount\
    \ = 0\n    var lastLast = 0\n    var lastLastCount = 0\n    var lastLastLast =\
    \ 0\n    var lastLastLastCount = 0\n    var lastLastLastLast = 0\n    var lastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLast = 0\n    var lastLastLastLastLastCount = 0\n\
    \    var lastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastCount =\
    \ 0\n    var lastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLast\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ym60vol.swift:38:9: error: invalid redeclaration of 'lastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmp9ym60vol.swift:36:9:\
    \ note: 'lastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmp9ym60vol.swift:39:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmp9ym60vol.swift:37:9: note: 'lastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastCount = 0\n  \
    \      ^\n/tmp/tmp9ym60vol.swift:42:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmp9ym60vol.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmp9ym60vol.swift:43:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmp9ym60vol.swift:41:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmp9ym60vol.swift:46:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmp9ym60vol.swift:44:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmp9ym60vol.swift:47:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmp9ym60vol.swift:45:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmp9ym60vol.swift:49:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmp9ym60"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    var l = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n        \
    \    j = i\n            \n            for k < s.count {\n                if s[k]\
    \ == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] == 'o' || s[k] == 'u' {\n     \
    \               l = k\n                    break\n                }\n        \
    \        k += 1\n            }\n            \n            if l == j {\n      \
    \          result.append(\"a\")\n                result.append(\"e\")\n      \
    \          result.append(\"i\")\n                result.append(\"o\")\n      \
    \          result.append(\"u\")\n            }\n            \n            if l\
    \ > j {\n                result.append(\"a\")\n                result.append(\"\
    e\")\n                result.append(\"i\")\n                result.append(\"o\"\
    )\n                result.append(\"u\")\n                result.append(\"a\")\n\
    \                result.append(\"e\")\n                result.append(\"i\")\n\
    \                result.append(\"o\")\n                result.append(\"u\")\n\
    \                result.append(\"a\")\n                result.append(\"e\")\n\
    \                result.append(\"i\")\n                result.append(\"o\")\n\
    \                result.append(\"u\")\n            }\n            \n         \
    \   if l < j {\n                result.append(\"a\")\n                result.append(\"\
    e\")\n                result.append(\"i\")\n                result.append(\"o\"\
    )\n                result.append(\"u\")\n                result.append(\"a\")\n\
    \                result.append(\"e\")\n                result.append(\"i\")\n\
    \                result.append(\"o\")\n                result.append(\"u\")\n\
    \                result.append(\"a\")\n                result.append(\"e\")\n\
    \                result.append(\"i\")\n                result.append(\"o\")\n\
    \                result.append(\"u\")\n                result.append(\"a\")\n\
    \                result.append(\"e\")\n                result.append(\"i\")\n\
    \                result.append(\"o\")\n                result.append(\"u\")\n\
    \                result.append(\"a\")\n                result.append(\"e\")\n\
    \                result.append(\"i\")\n                result.append(\"o\")\n\
    \                result.append(\"u\")\n                result.append(\"a\")\n\
    \                result.append(\"e\")\n                result.append(\"i\")\n\
    \                result.append(\"o\")\n                result.append(\"u\")\n\
    \                result.append(\"a\")\n                result.append(\"e\")\n\
    \                result.append(\"i\")\n                result.append(\"o\")\n\
    \                result.append(\"u\")\n                result.append(\"a\")\n\
    \                result.append(\"e\")\n                result.append(\"i\")\n\
    \                result.append(\"o\")\n                result.append(\"u\")\n\
    \                result.append(\"a\")\n                result.append(\"e\")\n\
    \                result.append(\"i\")\n                result.append(\"o\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2lexqrdy.swift:30:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp2lexqrdy.swift:30:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp2lexqrdy.swift:31:20: error: single-quoted string\
    \ literal found, use '\"'\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u' {\n                   ^~~\n                  \
    \ \"a\"\n/tmp/tmp2lexqrdy.swift:31:35: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u' {\n                                  ^~~\n                  \
    \                \"e\"\n/tmp/tmp2lexqrdy.swift:31:50: error: single-quoted string\
    \ literal found, use '\"'\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u' {\n                                          \
    \       ^~~\n                                                 \"i\"\n/tmp/tmp2lexqrdy.swift:31:65:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            \
    \                                                    ^~~\n                   \
    \                                             \"o\"\n/tmp/tmp2lexqrdy.swift:31:80:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            \
    \                                                                   ^~~\n    \
    \                                                                           \"\
    u\"\n/tmp/tmp2lexqrdy.swift:34:19: error: expected 'in' after for-each pattern\n\
    \            for k < s.count {\n                  ^\n/tmp/tmp2lexqrdy.swift:34:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmp2lexqrdy.swift:35:28:\
    \ error: single-quoted string literal found, use '\"'\n                if s[k]\
    \ == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] == 'o' || "
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s {\n        if\
    \ char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char ==\
    \ \"u\" {\n            if result.count < n {\n                result.append(char)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmps9d_qs8d.swift:28:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(char)\n  \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.consonants.count >= n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd1hz9c76.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd1hz9c76.swift:26:17:\
    \ error: value of type 'Character' has no member 'consonants'\n        if char.consonants.count\
    \ >= n {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    var i = 0\n    var j = 0\n  \
    \  \n    for char in s {\n        if char == \" \" {\n            words.append(String(s[i:j]))\n\
    \            i = j\n            j = 0\n        }\n        \n        if char ==\
    \ \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n\
    \            j = j + 1\n        }\n        \n        if char == \"n\" {\n    \
    \        if j == n {\n                words.append(String(s[i:j]))\n         \
    \       i = j\n                j = 0\n            }\n        }\n    }\n    \n\
    \    if j != 0 {\n        words.append(String(s[i:j]))\n    }\n    \n    return\
    \ words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqlu2cfls.swift:30:34: error: extraneous argument label 'i:' in\
    \ subscript\n            words.append(String(s[i:j]))\n                      \
    \           ^~~\n                                  \n/tmp/tmpqlu2cfls.swift:41:38:\
    \ error: extraneous argument label 'i:' in subscript\n                words.append(String(s[i:j]))\n\
    \                                     ^~~\n                                  \
    \    \n/tmp/tmpqlu2cfls.swift:49:30: error: extraneous argument label 'i:' in\
    \ subscript\n        words.append(String(s[i:j]))\n                          \
    \   ^~~\n                              \n"
  stdout: ''
  timestamp: 1660014490
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return s.split(\" \").filter{ $0.characters.count\
    \ >= n }.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm635hyjc.swift:19:20: error: missing argument label 'separator:'\
    \ in call\n    return s.split(\" \").filter{ $0.characters.count >= n }.sorted()\n\
    \                   ^\n                   separator: \n/tmp/tmpm635hyjc.swift:19:60:\
    \ error: cannot convert return expression of type '[String.SubSequence]' (aka\
    \ 'Array<Substring>') to return type '[String]'\n    return s.split(\" \").filter{\
    \ $0.characters.count >= n }.sorted()\n                                      \
    \                     ^\n/tmp/tmpm635hyjc.swift:19:60: note: arguments to generic\
    \ parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are\
    \ expected to be equal\n    return s.split(\" \").filter{ $0.characters.count\
    \ >= n }.sorted()\n                                                          \
    \ ^\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   var k = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n   \
    \         j = i\n            while j < s.count && s[j] != \" \" {\n          \
    \      j += 1\n            }\n            \n            if j == s.count {\n  \
    \              result.append(\"\\n\")\n            }\n            \n         \
    \   i = j\n            \n        } else {\n            k += 1\n            \n\
    \            if k == n {\n                result.append(String(s[i:j]))\n    \
    \            i = j\n                k = 0\n            }\n        }\n    }\n \
    \   \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppry9843v.swift:30:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmppry9843v.swift:32:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmppry9843v.swift:46:39: error: extraneous argument label 'i:' in\
    \ subscript\n                result.append(String(s[i:j]))\n                 \
    \                     ^~~\n                                       \n"
  stdout: ''
  timestamp: 1660014490
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpusvpuwf3/tmpusvpuwf3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7276231c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7275f28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7275f28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7275f277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusvpuwf3                        0x000055b357f984c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b727641d460 __libc_start_main +
    245

    6    tmpusvpuwf3                        0x000055b357f980c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014193
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // BEGIN Question 3\n    \n    // END\
    \ Question 3\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpvua0wrs2/tmpvua0wrs2.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06bdc8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06bd982b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06bd982988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06bd9817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvua0wrs2                        0x00005646ea4674c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b06bde77460 __libc_start_main +
    245

    6    tmpvua0wrs2                        0x00005646ea4670c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for letter in\
    \ s {\n        if letter == \" \" {\n            continue\n        }\n       \
    \ if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\" {\n            continue\n        }\n        if letter ==\
    \ \"y\" {\n            if s.hasPrefix(\"y\") {\n                continue\n   \
    \         }\n        }\n        if letter == \"h\" || letter == \"o\" || letter\
    \ == \"w\" {\n            if s.hasPrefix(\"h\") {\n                continue\n\
    \            }\n        }\n        if letter == \"l\" || letter == \"l\" || letter\
    \ == \"u\" {\n            if s.hasPrefix(\"l\") {\n                continue\n\
    \            }\n        }\n        if letter == \"s\" {\n            if s.hasPrefix(\"\
    s\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"t\" || letter == \"t\" || letter == \"e\" {\n            if s.hasPrefix(\"\
    t\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"d\" || letter == \"d\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    d\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"m\" || letter == \"a\" || letter == \"r\" {\n            if s.hasPrefix(\"\
    m\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"p\" || letter == \"p\" || letter == \"e\" {\n            if s.hasPrefix(\"\
    p\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"f\" || letter == \"f\" || letter == \"i\" {\n            if s.hasPrefix(\"\
    f\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"v\" || letter == \"v\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    v\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"b\" || letter == \"b\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    b\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"k\" || letter == \"k\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    k\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"j\" || letter == \"j\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    j\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"q\" || letter == \"q\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    q\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"n\" || letter == \"n\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    n\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"m\" || letter == \"m\" || letter == \"a\" {\n            if s.hasPrefix(\"\
    m\") {\n                continue\n            }\n        }\n        if letter\
    \ == \"p\" || letter == \"p\" || letter == \"a\" {\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq9cn3lpa.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpq9cn3lpa.swift:20:21:\
    \ note: to match this opening '{'\n    for letter in s {\n                   \
    \ ^\n/tmp/tmpq9cn3lpa.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpq9cn3lpa.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpq9cn3lpa.swift:112:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpq9cn3lpa.swift:19:9:\
    \ warning: initialization of variable 'result' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var result = [String]()\n    ~~~~^~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var words = [String]()\n    \n    if s ==\
    \ \"\" {\n        return words\n    }\n    \n    for letter in s {\n        if\
    \ letter == \" \" {\n            words.append(\"\")\n        } else {\n      \
    \      if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"\
    o\" || letter == \"u\" {\n                words.append(letter)\n            }\n\
    \        }\n    }\n    \n    words.sortInPlace()\n    \n    if words.count < n\
    \ {\n        return words\n    }\n    \n    var result = [String]()\n    \n  \
    \  for word in words {\n        if words.count > n {\n            break\n    \
    \    }\n        \n        if words.count > n {\n            break\n        }\n\
    \        \n        if words.count > n {\n            break\n        }\n      \
    \  \n        if words.count > n {\n            break\n        }\n        \n  \
    \      if words.count > n {\n            break\n        }\n        \n        if\
    \ words.count > n {\n            break\n        }\n        \n        if words.count\
    \ > n {\n            break\n        }\n        \n        if words.count > n {\n\
    \            break\n        }\n        \n        if words.count > n {\n      \
    \      break\n        }\n        \n        if words.count > n {\n            break\n\
    \        }\n        \n        if words.count > n {\n            break\n      \
    \  }\n        \n        if words.count > n {\n            break\n        }\n \
    \       \n        if words.count > n {\n            break\n        }\n       \
    \ \n        if words.count > n {\n            break\n        }\n        \n   \
    \     if words.count > n {\n            break\n        }\n        \n        if\
    \ words.count > n {\n            break\n        }\n        \n        if words.count\
    \ > n {\n            break\n        }\n        \n        if words.count > n {\n\
    \            break\n        }\n        \n        if words.count > n {\n      \
    \      break\n        }\n        \n        if words.count > n {\n            break\n\
    \        }\n        \n        if words.count > n {\n            break\n      \
    \  }\n        \n        if words.count > n {\n            break\n        }\n \
    \       \n        if words.count > n {\n            break\n        }\n       \
    \ \n        if words.count > n {\n            break\n        }\n        \n   \
    \     if words.count > n {\n            break\n        }\n        \n        if\
    \ words.count > n {\n            break\n        }\n        \n        if words.count\
    \ > n {\n            break\n        }\n        \n        if words.count > n {\n\
    \            break\n        }\n        \n        if words.count > n {\n      \
    \      break\n        }\n        \n        if words.count > n {\n            break\n\
    \        }\n        \n        if words.count > n {\n            break\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6kum7cck.swift:187:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp6kum7cck.swift:43:23:\
    \ note: to match this opening '{'\n    for word in words {\n                 \
    \     ^\n/tmp/tmp6kum7cck.swift:187:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp6kum7cck.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp6kum7cck.swift:30:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(letter)\n                             ^\n/tmp/tmp6kum7cck.swift:35:11:\
    \ error: value of type '[String]' has no member 'sortInPlace'\n    words.sortInPlace()\n\
    \    ~~~~~ ^~~~~~~~~~~\n/tmp/tmp6kum7cck.swift:169:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    for i < s.count {\n        if s[i] == \" \" {\n            j = i\n      \
    \      k = i\n            for k < s.count {\n                if s[k] == \" \"\
    \ {\n                    k = k + 1\n                } else {\n               \
    \     break\n                }\n            }\n            if k == s.count {\n\
    \                result.append(String(s[i:j]))\n            }\n            i =\
    \ j + 1\n        } else {\n            i = i + 1\n        }\n    }\n    if n ==\
    \ 1 {\n        return result\n    }\n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            result.append(String(s[i:]))\n            i = i + 1\n \
    \       } else {\n            i = i + 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwmo0ljpg.swift:26:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpwmo0ljpg.swift:26:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpwmo0ljpg.swift:30:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpwmo0ljpg.swift:30:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpwmo0ljpg.swift:48:11:\
    \ error: expected 'in' after for-each pattern\n    for i < s.count {\n       \
    \   ^\n/tmp/tmpwmo0ljpg.swift:48:11: error: unary operator cannot be separated\
    \ from its operand\n    for i < s.count {\n          ^~\n           \n/tmp/tmpwmo0ljpg.swift:50:38:\
    \ error: expected expression in list of expressions\n            result.append(String(s[i:]))\n\
    \                                     ^\n/tmp/tmpwmo0ljpg.swift:26:11: error:\
    \ '<' is not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpwmo0ljpg.swift:48:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpwmo0ljpg.swift:30:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptm0dxd9p.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptm0dxd9p.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n \
    \   \n    for char in s {\n        if char == \" \" {\n            if i == 0 {\n\
    \                j++\n            }\n            \n            if j == n {\n \
    \               result.append(s[i : s.startIndex])\n                i = s.startIndex\n\
    \                j = 0\n            }\n        } else {\n            i++\n   \
    \         j = 0\n        }\n    }\n    \n    if j == n {\n        result.append(s[i\
    \ : s.startIndex])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxiuse26b.swift:31:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpxiuse26b.swift:35:32:\
    \ error: extraneous argument label 'i:' in subscript\n                result.append(s[i\
    \ : s.startIndex])\n                               ^~~~~\n                   \
    \             \n/tmp/tmpxiuse26b.swift:36:23: error: cannot assign value of type\
    \ 'String.Index' to type 'Int'\n                i = s.startIndex\n           \
    \         ~~^~~~~~~~~~\n/tmp/tmpxiuse26b.swift:40:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpxiuse26b.swift:46:24:\
    \ error: extraneous argument label 'i:' in subscript\n        result.append(s[i\
    \ : s.startIndex])\n                       ^~~~~\n                        \n"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = s.count\n    \n    while\
    \ i < m {\n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"a\" {\n            if j == n {\n            \
    \    i += 1\n                j += 1\n                continue\n            }\n\
    \            if s[k] == \" \" {\n                i += 1\n                k +=\
    \ 1\n                continue\n            }\n            if s[k] == \"a\" {\n\
    \                i += 1\n                j += 1\n                k += 1\n    \
    \            continue\n            }\n            if s[k] == \"e\" {\n       \
    \         i += 1\n                j += 1\n                k += 1\n           \
    \     l += 1\n                continue\n            }\n            if s[k] ==\
    \ \"i\" {\n                i += 1\n                j += 1\n                k +=\
    \ 1\n                l += 1\n                m -= 1\n                continue\n\
    \            }\n            if s[k] == \"o\" {\n                i += 1\n     \
    \           j += 1\n                k += 1\n                l += 1\n         \
    \       m -= 1\n                n -= 1\n                continue\n           \
    \ }\n            if s[k] == \"u\" {\n                i += 1\n                j\
    \ += 1\n                k += 1\n                l += 1\n                m -= 1\n\
    \                n -= 1\n                o -= 1\n                continue\n  \
    \          }\n            if s[k] == \"y\" {\n                i += 1\n       \
    \         j += 1\n                k += 1\n                l += 1\n           \
    \     m -= 1\n                n -= 1\n                o -= 1\n               \
    \ p -= 1\n                continue\n            }\n            if s[k] == \"y\"\
    \ {\n                i += 1\n                j += 1\n                k += 1\n\
    \                l += 1\n                m -= 1\n                n -= 1\n    \
    \            o -= 1\n                p -= 1\n                q += 1\n        \
    \        continue\n            }\n            if s[k] == \"s\" {\n           \
    \     i += 1\n                j += 1\n                k += 1\n               \
    \ l += 1\n                m -= 1\n                n -= 1\n                o -=\
    \ 1\n                p -= 1\n                q += 1\n                r += 1\n\
    \                continue\n            }\n            if s[k] == \"s\" {\n   \
    \             i += 1\n                j += 1\n                k += 1\n       \
    \         l += 1\n                m -= 1\n                n -= 1\n           \
    \     o -= 1\n                p -= 1\n                q += 1\n               \
    \ r += 1\n                s -= 1\n                continue\n            }\n  \
    \          if s[k] == \"t\" {\n                i += 1\n                j += 1\n\
    \                k += 1\n                l += 1\n                m -= 1\n    \
    \            n -= 1\n                o -= 1\n                p -= 1\n        \
    \        q += 1\n                r += 1\n                s -= 1\n            \
    \    t -= 1\n                continue\n            }\n            if s[k] == \"\
    t\" {\n                i += 1\n                j += 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpge2gqnht.swift:171:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpge2gqnht.swift:31:24:\
    \ note: to match this opening '{'\n        if s[i] == \"a\" {\n              \
    \         ^\n/tmp/tmpge2gqnht.swift:171:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpge2gqnht.swift:26:17: note: to match this opening '{'\n    while\
    \ i < m {\n                ^\n/tmp/tmpge2gqnht.swift:171:69: error: expected '}'\
    \ at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) ==\
    \ [\"b\", \"c\", \"d\", \"f\"])\n                                            \
    \                        ^\n/tmp/tmpge2gqnht.swift:18:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmpge2gqnht.swift:27:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpge2gqnht.swift:31:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpge2gqnht.swift:37:16: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if s[k] == \" \" {\n               ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpge2gqnht.swift:42:16:\
    \ error: 'subscript(_"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    if s == \"\"\
    \ {\n        return result\n    }\n    \n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n \
    \   var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n  \
    \  var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n   \
    \ var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\
    \ u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z\
    \ = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e =\
    \ 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var\
    \ e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o =\
    \ 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n\
    \    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n \
    \   var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y =\
    \ 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6effsg1v.swift:50:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmp6effsg1v.swift:24:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmp6effsg1v.swift:51:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmp6effsg1v.swift:25:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmp6effsg1v.swift:52:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp6effsg1v.swift:26:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp6effsg1v.swift:53:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp6effsg1v.swift:27:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp6effsg1v.swift:54:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp6effsg1v.swift:28:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp6effsg1v.swift:55:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp6effsg1v.swift:29:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp6effsg1v.swift:56:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp6effsg1v.swift:30:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp6effsg1v.swift:57:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp6effsg1v.swift:31:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp6effsg1v.swift:58:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp6effsg1v.swift:32:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp6effsg1v.swift:59:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp6effsg1v.swift:33:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp6effsg1v.swift:60:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp6effsg1v.swift:34:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmp6effsg1v.swift:61:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmp6eff"
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var\
    \ n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s\
    \ = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x =\
    \ 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n\
    \    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n \
    \   var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n  \
    \  var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n   \
    \ var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var\
    \ x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c\
    \ = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h =\
    \ 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n\
    \    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n   \
    \ var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmperw9pati.swift:46:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmperw9pati.swift:20:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmperw9pati.swift:47:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmperw9pati.swift:48:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:22:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmperw9pati.swift:49:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:23:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmperw9pati.swift:50:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:24:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmperw9pati.swift:51:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:25:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmperw9pati.swift:52:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:26:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmperw9pati.swift:53:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:27:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmperw9pati.swift:54:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:28:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmperw9pati.swift:55:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:29:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmperw9pati.swift:56:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:30:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmperw9pati.swift:57:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmperw9"
  stdout: ''
  timestamp: 1660014488
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n  \
    \          result.append(String(char))\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsx89fpo_.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsx89fpo_.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014489
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // Your code here\n    \n    return []\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp1e9zxg93/tmp1e9zxg93.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78da867c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78da55eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78da55e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78da55d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1e9zxg93                        0x0000557ccf73f4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b78daa53460 __libc_start_main +
    245

    6    tmp1e9zxg93                        0x0000557ccf73f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014490
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    \n    // BEGIN Question 4\n    \n    // END\
    \ Question 4\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpdk8hqyhi/tmpdk8hqyhi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00af09ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00aed95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00aed95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00aed947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdk8hqyhi                        0x0000563a72cea4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b00af28a460 __libc_start_main +
    245

    6    tmpdk8hqyhi                        0x0000563a72cea0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014490
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    var result = [String]()\n    \n    if s ==\
    \ \"\" {\n        return result\n    }\n    \n    for char in s.characters {\n\
    \        if char.isConsonant() {\n            if result.count < n {\n        \
    \        result.append(String(char))\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk1gprkbs.swift:25:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk1gprkbs.swift:26:17:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if char.isConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014488
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n///\
    \ [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n///\
    \ [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n\
    /// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"\
    ]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n    // TODO: replace with solution\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpviofe232/tmpviofe232.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43d67f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43d64e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43d64e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43d64e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpviofe232                        0x000055bf33d0d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b43d69de460 __libc_start_main +
    245

    6    tmpviofe232                        0x000055bf33d0d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014490
