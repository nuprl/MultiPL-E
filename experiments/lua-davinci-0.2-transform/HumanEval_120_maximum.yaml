name: HumanEval_120_maximum
language: lua
prompt: "-- Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>>\
  \ maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4,\
  \ 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n\
  -- {2}\n-- Note:\n-- 1. The length of the array will be in the range of [1, 1000].\n\
  -- 2. The elements in the array will be in the range of [-1000, 1000].\n-- 3. 0\
  \ <= k <= len(arr)\nlocal function maximum(arr, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local heap = {}\n    local heap_size = 0\n    local function heap_push(x)\n\
    \        heap_size = heap_size + 1\n        heap[heap_size] = x\n        local\
    \ i = heap_size\n        while i > 1 do\n            local j = math.floor(i /\
    \ 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j]\
    \ = heap[j], heap[i]\n                i = j\n            else\n              \
    \  break\n            end\n        end\n    end\n    local function heap_pop()\n\
    \        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size\
    \ = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n\
    \            local j = i * 2\n            if j + 1 <= heap_size and heap[j + 1]\
    \ > heap[j] then\n                j = j + 1\n            end\n            if heap[i]\
    \ < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n      \
    \          i = j\n            else\n                break\n            end\n \
    \       end\n        return ret\n    end\n    for i = 1, #arr do\n        if heap_size\
    \ < k then\n            heap_push(arr[i])\n        elseif arr[i] > heap[1] then\n\
    \            heap_pop()\n            heap_push(arr[i])\n        end\n    end\n\
    \    local ret = {}\n    for i = 1, k do\n        ret[i] = heap_pop()\n    end\n\
    \    return ret\nend", "    local n = #arr\n    local t = {}\n    for i = 1, n\
    \ do\n        local v = arr[i]\n        local j = #t\n        while j > 0 and\
    \ t[j] < v do\n            j = j - 1\n        end\n        if j < k then\n   \
    \         table.insert(t, j + 1, v)\n            if #t > k then\n            \
    \    table.remove(t)\n            end\n        end\n    end\n    return t\nend",
  "    local function partition(arr, l, r)\n        local pivot = arr[r]\n       \
    \ local i = l - 1\n        for j = l, r - 1 do\n            if arr[j] <= pivot\
    \ then\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \            end\n        end\n        arr[i + 1], arr[r] = arr[r], arr[i + 1]\n\
    \        return i + 1\n    end\n    local function quick_select(arr, l, r, k)\n\
    \        if l == r then\n            return arr[l]\n        end\n        local\
    \ pivot = partition(arr, l, r)\n        if pivot == k then\n            return\
    \ arr[pivot]\n        elseif pivot > k then\n            return quick_select(arr,\
    \ l, pivot - 1, k)\n        else\n            return quick_select(arr, pivot +\
    \ 1, r, k)\n        end\n    end\n    local function quick_sort(arr, l, r)\n \
    \       if l < r then\n            local pivot = partition(arr, l, r)\n      \
    \      quick_sort(arr, l, pivot - 1)\n            quick_sort(arr, pivot + 1, r)\n\
    \        end\n    end\n    local n = #arr\n    local k = math.min(k, n)\n    quick_select(arr,\
    \ 1, n, n - k + 1)\n    quick_sort(arr, n - k + 1, n)\n    return arr\nend", " \
    \   local len = #arr\n    if k > len then\n        k = len\n    end\n    local\
    \ max = {}\n    for i = 1, k do\n        max[i] = arr[i]\n    end\n    for i =\
    \ k + 1, len do\n        local j = 1\n        while j <= k and max[j] > arr[i]\
    \ do\n            j = j + 1\n        end\n        if j <= k then\n           \
    \ for l = k, j + 1, -1 do\n                max[l] = max[l - 1]\n            end\n\
    \            max[j] = arr[i]\n        end\n    end\n    return max\nend", "  \
    \  local function partition(arr, left, right)\n        local pivot = arr[left]\n\
    \        local i = left\n        local j = right\n        while i < j do\n   \
    \         while i < j and arr[j] <= pivot do\n                j = j - 1\n    \
    \        end\n            if i < j then\n                arr[i] = arr[j]\n   \
    \             i = i + 1\n            end\n            while i < j and arr[i] >=\
    \ pivot do\n                i = i + 1\n            end\n            if i < j then\n\
    \                arr[j] = arr[i]\n                j = j - 1\n            end\n\
    \        end\n        arr[i] = pivot\n        return i\n    end\n    local function\
    \ quick_sort(arr, left, right)\n        if left < right then\n            local\
    \ pivot = partition(arr, left, right)\n            quick_sort(arr, left, pivot\
    \ - 1)\n            quick_sort(arr, pivot + 1, right)\n        end\n    end\n\
    \    quick_sort(arr, 1, #arr)\n    local res = {}\n    for i = 1, k do\n     \
    \   res[i] = arr[i]\n    end\n    return res\nend", "    local function partition(arr,\
    \ lo, hi)\n        local pivot = arr[hi]\n        local i = lo\n        for j\
    \ = lo, hi - 1 do\n            if arr[j] > pivot then\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n                i = i + 1\n            end\n      \
    \  end\n        arr[i], arr[hi] = arr[hi], arr[i]\n        return i\n    end\n\
    \    local function quickselect(arr, lo, hi, k)\n        if lo == hi then\n  \
    \          return arr[lo]\n        end\n        local p = partition(arr, lo, hi)\n\
    \        if p == k then\n            return arr[p]\n        elseif p < k then\n\
    \            return quickselect(arr, p + 1, hi, k)\n        else\n           \
    \ return quickselect(arr, lo, p - 1, k)\n        end\n    end\n    local function\
    \ sort(arr, lo, hi)\n        if lo >= hi then\n            return\n        end\n\
    \        local p = partition(arr, lo, hi)\n        sort(arr, lo, p - 1)\n    \
    \    sort(arr, p + 1, hi)\n    end\n    local function find_kth_largest(arr, k)\n\
    \        local n = #arr\n        local lo, hi = 1, n\n        local kth = quickselect(arr,\
    \ lo, hi, k)\n        local res = {}\n        for i = 1, n do\n            if\
    \ arr[i] >= kth then\n                res[#res + 1] = arr[i]\n            end\n\
    \        end\n        sort(res, 1, #res)\n        return res\n    end\n    return\
    \ find_kth_largest(arr, k)\nend", "    local function partition(arr, l, r)\n \
    \       local pivot = arr[r]\n        local i = l - 1\n        for j = l, r -\
    \ 1 do\n            if arr[j] <= pivot then\n                i = i + 1\n     \
    \           arr[i], arr[j] = arr[j], arr[i]\n            end\n        end\n  \
    \      arr[i + 1], arr[r] = arr[r], arr[i + 1]\n        return i + 1\n    end\n\
    \    local function quickSelect(arr, l, r, k)\n        if l == r then\n      \
    \      return arr[l]\n        end\n        local p = partition(arr, l, r)\n  \
    \      if p == k then\n            return arr[p]\n        elseif p < k then\n\
    \            return quickSelect(arr, p + 1, r, k)\n        else\n            return\
    \ quickSelect(arr, l, p - 1, k)\n        end\n    end\n    local function quickSort(arr,\
    \ l, r)\n        if l < r then\n            local p = partition(arr, l, r)\n \
    \           quickSort(arr, l, p - 1)\n            quickSort(arr, p + 1, r)\n \
    \       end\n    end\n    local n = #arr\n    local tmp = {}\n    for i = 1, k\
    \ do\n        tmp[i] = arr[i]\n    end\n    quickSort(tmp, 1, k)\n    for i =\
    \ k + 1, n do\n        if arr[i] > tmp[1] then\n            tmp[1] = arr[i]\n\
    \            quickSort(tmp, 1, k)\n        end\n    end\n    return tmp\nend",
  "    local heap = {}\n    for i = 1, k do\n        heap[i] = arr[i]\n    end\n \
    \   for i = k, 2, -1 do\n        if heap[i] < heap[i // 2] then\n            heap[i],\
    \ heap[i // 2] = heap[i // 2], heap[i]\n        end\n    end\n    for i = k +\
    \ 1, #arr do\n        if arr[i] > heap[1] then\n            heap[1] = arr[i]\n\
    \            for j = 1, k // 2 do\n                if heap[j] > heap[j * 2] or\
    \ heap[j] > heap[j * 2 + 1] then\n                    if heap[j * 2] < heap[j\
    \ * 2 + 1] then\n                        heap[j], heap[j * 2] = heap[j * 2], heap[j]\n\
    \                    else\n                        heap[j], heap[j * 2 + 1] =\
    \ heap[j * 2 + 1], heap[j]\n                    end\n                end\n   \
    \         end\n        end\n    end\n    return heap\nend", "    local function\
    \ partition(arr, left, right)\n        local pivot = arr[left]\n        local\
    \ i = left\n        local j = right\n        while i < j do\n            while\
    \ i < j and arr[j] <= pivot do\n                j = j - 1\n            end\n \
    \           arr[i] = arr[j]\n            while i < j and arr[i] >= pivot do\n\
    \                i = i + 1\n            end\n            arr[j] = arr[i]\n   \
    \     end\n        arr[i] = pivot\n        return i\n    end\n    local function\
    \ quick_sort(arr, left, right)\n        if left < right then\n            local\
    \ pivot = partition(arr, left, right)\n            quick_sort(arr, left, pivot\
    \ - 1)\n            quick_sort(arr, pivot + 1, right)\n        end\n    end\n\
    \    quick_sort(arr, 1, #arr)\n    local res = {}\n    for i = 1, k do\n     \
    \   res[i] = arr[i]\n    end\n    return res\nend", "    local function partition(arr,\
    \ left, right)\n        local pivot = arr[left]\n        local i = left\n    \
    \    local j = right\n        while i < j do\n            while i < j and arr[j]\
    \ <= pivot do\n                j = j - 1\n            end\n            if i <\
    \ j then\n                arr[i] = arr[j]\n                i = i + 1\n       \
    \     end\n            while i < j and arr[i] >= pivot do\n                i =\
    \ i + 1\n            end\n            if i < j then\n                arr[j] =\
    \ arr[i]\n                j = j - 1\n            end\n        end\n        arr[i]\
    \ = pivot\n        return i\n    end\n    local function quick_sort(arr, left,\
    \ right)\n        if left < right then\n            local pivot = partition(arr,\
    \ left, right)\n            quick_sort(arr, left, pivot - 1)\n            quick_sort(arr,\
    \ pivot + 1, right)\n        end\n    end\n    quick_sort(arr, 1, #arr)\n    local\
    \ result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n    end\n    return\
    \ result\nend", "    local len = #arr\n    if len == 0 then\n        return {}\n\
    \    end\n    if k == 0 then\n        return {}\n    end\n    if k >= len then\n\
    \        return arr\n    end\n    local function partition(arr, left, right)\n\
    \        local pivot = arr[left]\n        local i = left\n        local j = right\n\
    \        while i < j do\n            while i < j and arr[j] <= pivot do\n    \
    \            j = j - 1\n            end\n            arr[i] = arr[j]\n       \
    \     while i < j and arr[i] >= pivot do\n                i = i + 1\n        \
    \    end\n            arr[j] = arr[i]\n        end\n        arr[i] = pivot\n \
    \       return i\n    end\n    local function quick_sort(arr, left, right)\n \
    \       if left < right then\n            local pivot = partition(arr, left, right)\n\
    \            quick_sort(arr, left, pivot - 1)\n            quick_sort(arr, pivot\
    \ + 1, right)\n        end\n    end\n    quick_sort(arr, 1, len)\n    local ret\
    \ = {}\n    for i = 1, k do\n        ret[i] = arr[i]\n    end\n    return ret\n\
    end", "    local heap = {}\n    local function heap_push(heap, val)\n        local\
    \ i = #heap + 1\n        heap[i] = val\n        while i > 1 do\n            local\
    \ parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n   \
    \             heap[parent], heap[i] = heap[i], heap[parent]\n                i\
    \ = parent\n            else\n                break\n            end\n       \
    \ end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n\
    \        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n\
    \        while i < #heap do\n            local left = i * 2\n            local\
    \ right = i * 2 + 1\n            if left > #heap then\n                break\n\
    \            elseif right > #heap then\n                if heap[i] < heap[left]\
    \ then\n                    heap[i], heap[left] = heap[left], heap[i]\n      \
    \          end\n                break\n            else\n                if heap[left]\
    \ > heap[right] then\n                    if heap[i] < heap[left] then\n     \
    \                   heap[i], heap[left] = heap[left], heap[i]\n              \
    \          i = left\n                    else\n                        break\n\
    \                    end\n                else\n                    if heap[i]\
    \ < heap[right] then\n                        heap[i], heap[right] = heap[right],\
    \ heap[i]\n                        i = right\n                    else\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        return ret\n    end\n    for i = 1, #arr do\n\
    \        if #heap < k then\n            heap_push(heap, arr[i])\n        else\n\
    \            if arr[i] > heap[1] then\n                heap_pop(heap)\n      \
    \          heap_push(heap, arr[i])\n            end\n        end\n    end\n  \
    \  local ret = {}\n    for i = 1, #heap do\n        ret[i] = heap_pop(heap)\n\
    \    end\n    return ret\nend", "    local heap = {}\n    for i = 1, k do\n  \
    \      heap[i] = arr[i]\n    end\n    heapify(heap, k)\n    for i = k + 1, #arr\
    \ do\n        if arr[i] > heap[1] then\n            heap[1] = arr[i]\n       \
    \     heapify(heap, k)\n        end\n    end\n    return heap\nend", "    local\
    \ function partition(arr, left, right)\n        local pivot = arr[left]\n    \
    \    local i = left\n        local j = right\n        while i < j do\n       \
    \     while i < j and arr[j] <= pivot do\n                j = j - 1\n        \
    \    end\n            arr[i] = arr[j]\n            while i < j and arr[i] >= pivot\
    \ do\n                i = i + 1\n            end\n            arr[j] = arr[i]\n\
    \        end\n        arr[i] = pivot\n        return i\n    end\n    local function\
    \ quick_sort(arr, left, right)\n        if left < right then\n            local\
    \ pivot = partition(arr, left, right)\n            quick_sort(arr, left, pivot\
    \ - 1)\n            quick_sort(arr, pivot + 1, right)\n        end\n    end\n\
    \    quick_sort(arr, 1, #arr)\n    local res = {}\n    for i = 1, k do\n     \
    \   res[i] = arr[i]\n    end\n    return res\nend", "    local function partition(arr,\
    \ left, right)\n        local pivot = arr[left]\n        local i = left\n    \
    \    local j = right\n        while i < j do\n            while i < j and arr[j]\
    \ <= pivot do\n                j = j - 1\n            end\n            arr[i]\
    \ = arr[j]\n            while i < j and arr[i] >= pivot do\n                i\
    \ = i + 1\n            end\n            arr[j] = arr[i]\n        end\n       \
    \ arr[i] = pivot\n        return i\n    end\n    local function quick_sort(arr,\
    \ left, right)\n        if left < right then\n            local pivot = partition(arr,\
    \ left, right)\n            quick_sort(arr, left, pivot - 1)\n            quick_sort(arr,\
    \ pivot + 1, right)\n        end\n    end\n    quick_sort(arr, 1, #arr)\n    local\
    \ result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n    end\n    return\
    \ result\nend", "    local function partition(arr, lo, hi)\n        local pivot\
    \ = arr[hi]\n        local i = lo - 1\n        for j = lo, hi - 1 do\n       \
    \     if arr[j] > pivot then\n                i = i + 1\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            end\n        end\n        arr[i + 1], arr[hi]\
    \ = arr[hi], arr[i + 1]\n        return i + 1\n    end\n    local function quick_select(arr,\
    \ lo, hi, k)\n        if lo >= hi then\n            return\n        end\n    \
    \    local pivot = partition(arr, lo, hi)\n        if pivot == k then\n      \
    \      return\n        elseif pivot > k then\n            quick_select(arr, lo,\
    \ pivot - 1, k)\n        else\n            quick_select(arr, pivot + 1, hi, k)\n\
    \        end\n    end\n    quick_select(arr, 1, #arr, k)\n    return arr\nend",
  "    local function partition(arr, lo, hi)\n        local pivot = arr[hi]\n    \
    \    local i = lo\n        for j = lo, hi - 1 do\n            if arr[j] > pivot\
    \ then\n                arr[i], arr[j] = arr[j], arr[i]\n                i = i\
    \ + 1\n            end\n        end\n        arr[i], arr[hi] = arr[hi], arr[i]\n\
    \        return i\n    end\n    local function quickselect(arr, lo, hi, k)\n \
    \       if lo >= hi then\n            return\n        end\n        local p = partition(arr,\
    \ lo, hi)\n        if p == k then\n            return\n        elseif p < k then\n\
    \            quickselect(arr, p + 1, hi, k)\n        else\n            quickselect(arr,\
    \ lo, p - 1, k)\n        end\n    end\n    quickselect(arr, 1, #arr, k)\n    return\
    \ arr\nend", "    local function partition(arr, left, right)\n        local pivot\
    \ = arr[left]\n        local i = left\n        local j = right\n        while\
    \ i < j do\n            while i < j and arr[j] < pivot do\n                j =\
    \ j - 1\n            end\n            if i < j then\n                arr[i] =\
    \ arr[j]\n                i = i + 1\n            end\n            while i < j\
    \ and arr[i] > pivot do\n                i = i + 1\n            end\n        \
    \    if i < j then\n                arr[j] = arr[i]\n                j = j - 1\n\
    \            end\n        end\n        arr[i] = pivot\n        return i\n    end\n\
    \    local function quick_sort(arr, left, right)\n        if left < right then\n\
    \            local pivot = partition(arr, left, right)\n            quick_sort(arr,\
    \ left, pivot - 1)\n            quick_sort(arr, pivot + 1, right)\n        end\n\
    \    end\n    quick_sort(arr, 1, #arr)\n    local res = {}\n    for i = 1, k do\n\
    \        res[i] = arr[i]\n    end\n    return res\nend", "    local heap = {}\n\
    \    local function push(x)\n        local i = #heap + 1\n        heap[i] = x\n\
    \        while i > 1 do\n            local p = math.floor(i / 2)\n           \
    \ if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n\
    \                i = p\n            else\n                break\n            end\n\
    \        end\n    end\n    local function pop()\n        local ret = heap[1]\n\
    \        local x = heap[#heap]\n        heap[1] = x\n        heap[#heap] = nil\n\
    \        local i = 1\n        while i * 2 <= #heap do\n            local a, b\
    \ = i * 2, i * 2 + 1\n            if b <= #heap and heap[b] > heap[a] then\n \
    \               a = b\n            end\n            if heap[i] < heap[a] then\n\
    \                heap[i], heap[a] = heap[a], heap[i]\n                i = a\n\
    \            else\n                break\n            end\n        end\n     \
    \   return ret\n    end\n    for i = 1, #arr do\n        if #heap < k then\n \
    \           push(arr[i])\n        elseif arr[i] > heap[1] then\n            pop()\n\
    \            push(arr[i])\n        end\n    end\n    local ret = {}\n    for i\
    \ = 1, k do\n        ret[i] = pop()\n    end\n    return ret\nend", "    local\
    \ len = #arr\n    if k == len then\n        table.sort(arr)\n        return arr\n\
    \    end\n    local res = {}\n    for i = 1, k do\n        local max = -math.huge\n\
    \        local max_idx = 0\n        for j = 1, len do\n            if arr[j] >\
    \ max then\n                max = arr[j]\n                max_idx = j\n      \
    \      end\n        end\n        res[i] = max\n        arr[max_idx] = -math.huge\n\
    \    end\n    return res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
