language: lua
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqaw0s8uy.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpqaw0s8uy.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int < 0.5 then\n    return int\n  else\n    return int + 1\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi0i5kqkc.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpi0i5kqkc.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  local frac = num - int\n  if frac < 0.5 then\n    return int\n  else\n    return\
    \ int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgbkcv59q.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgbkcv59q.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer < 0.5 then\n\
    \        return integer\n    else\n        return integer + 1\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpai15378_.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpai15378_.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  if n == nil then\n    return nil\n  end\n  local int, frac = math.modf(n)\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmc6d8_sn.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmc6d8_sn.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  local decimal = number - integer\n  if decimal >= 0.5\
    \ then\n    return integer + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmqbwj9ch.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmqbwj9ch.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
