language: lua
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqaw0s8uy.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpqaw0s8uy.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int < 0.5 then\n    return int\n  else\n    return int + 1\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi0i5kqkc.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpi0i5kqkc.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  local frac = num - int\n  if frac < 0.5 then\n    return int\n  else\n    return\
    \ int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgbkcv59q.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgbkcv59q.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer < 0.5 then\n\
    \        return integer\n    else\n        return integer + 1\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpai15378_.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpai15378_.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  if n == nil then\n    return nil\n  end\n  local int, frac = math.modf(n)\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmc6d8_sn.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmc6d8_sn.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  local decimal = number - integer\n  if decimal >= 0.5\
    \ then\n    return integer + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmqbwj9ch.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmqbwj9ch.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    return math.floor(num\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa2lp5qft.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpa2lp5qft.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    if number > 0 then\n        return math.floor(number + 0.5)\n    else\n \
    \       return math.ceil(number - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num < 0 then\n    return math.ceil(num)\n  else\n    return math.floor(num)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_twskhar.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp_twskhar.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    local frac = num - int\n    if frac >= 0.5 then\n        return int + 1\n\
    \    else\n        return int\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0nymc42_.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp0nymc42_.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n\
    \  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7t3fecm6.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7t3fecm6.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int, frac = math.modf(num)\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmu0h39if.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmu0h39if.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local fraction = number\
    \ - integer\n  if fraction >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdcde8c_i.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdcde8c_i.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  local frac = num - int\n  if frac >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzs1t0i2z.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpzs1t0i2z.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local decimal\
    \ = number - integer\n    if decimal >= 0.5 then\n        return integer + 1\n\
    \    else\n        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4qgl4yv7.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4qgl4yv7.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local decimal = number\
    \ - integer\n  if decimal < 0.5 then\n    return integer\n  else\n    return integer\
    \ + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprvip2yn1.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprvip2yn1.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpphyovrjy.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpphyovrjy.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8x49au9_.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp8x49au9_.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local n = tonumber(value)\n\
    \    if n == nil then\n        return nil\n    end\n    local int = math.floor(n)\n\
    \    if n - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo8i56jnn.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpo8i56jnn.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppqjkvs4l.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmppqjkvs4l.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local fraction = number - integer\n\
    \    if fraction >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprkj8gfir.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprkj8gfir.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  local frac = num - int\n  if frac >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzs1t0i2z.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpzs1t0i2z.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local fraction = number - integer\n\
    \    if fraction >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprkj8gfir.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprkj8gfir.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local n = tonumber(value)\n\
    \  local i = math.floor(n)\n  local f = n - i\n  if f >= 0.5 then\n    return\
    \ i + 1\n  else\n    return i\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph_qiptpy.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmph_qiptpy.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num % 1 >= 0.5 then\n        return math.ceil(num)\n    else\n       \
    \ return math.floor(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp03huge1u.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp03huge1u.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local value = tonumber(value)\n\
    \  if value % 1 >= 0.5 then\n    return math.ceil(value)\n  else\n    return math.floor(value)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1qznu0rj.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1qznu0rj.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local int,\
    \ frac = math.modf(number)\n  if frac >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphvquhrs9.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphvquhrs9.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num then\n        return math.floor(num + 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxwljo8il.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxwljo8il.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ the function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbsd_o3gv.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpbsd_o3gv.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal < 0.5 then\n        return integer\n    else\n        return integer\
    \ + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi6pty85w.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpi6pty85w.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer < 0.5 then\n\
    \        return integer\n    else\n        return integer + 1\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpai15378_.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpai15378_.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == math.floor(num) then\n        return num\n    else\n        local\
    \ floor = math.floor(num)\n        local ceil = math.ceil(num)\n        if num\
    \ - floor < ceil - num then\n            return floor\n        else\n        \
    \    return ceil\n        end\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg4m970r_.lua:34:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpg4m970r_.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9r5nrz7k.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9r5nrz7k.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n\
    \  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7t3fecm6.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7t3fecm6.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num < 0 then\n        return math.ceil(num)\n    else\n        return\
    \ math.floor(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptndew6kp.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmptndew6kp.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppqjkvs4l.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmppqjkvs4l.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpphyovrjy.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpphyovrjy.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == math.floor(num) then\n    return num\n  else\n    local int, frac\
    \ = math.modf(num)\n    if frac >= 0.5 then\n      return int + 1\n    else\n\
    \      return int\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj03ipz3z.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj03ipz3z.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  if number\
    \ >= 0 then\n    return math.floor(number + 0.5)\n  else\n    return math.ceil(number\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n\
    \  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7t3fecm6.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7t3fecm6.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jggf__l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_jggf__l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local decimal\
    \ = number - integer\n    if decimal >= 0.5 then\n        return integer + 1\n\
    \    else\n        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4qgl4yv7.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4qgl4yv7.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    if num >= 0 then\n \
    \       return math.floor(num + 0.5)\n    else\n        return math.ceil(num -\
    \ 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local int = math.floor(tonumber(value))\n\
    \    local frac = tonumber(value) - int\n    if frac > 0.5 then\n        return\
    \ int + 1\n    elseif frac < -0.5 then\n        return int - 1\n    else\n   \
    \     return int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoa9b4c49.lua:30:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpoa9b4c49.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    if num >= 0 then\n \
    \       return math.floor(num + 0.5)\n    else\n        return math.ceil(num -\
    \ 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local floor = math.floor(number)\n    local ceil = math.ceil(number)\n  \
    \  if number - floor == 0.5 then\n        if number > 0 then\n            return\
    \ ceil\n        else\n            return floor\n        end\n    else\n      \
    \  if number - floor < 0.5 then\n            return floor\n        else\n    \
    \        return ceil\n        end\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local fraction = number - integer\n\
    \    if fraction >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprkj8gfir.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprkj8gfir.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local floor\
    \ = math.floor(number)\n  local ceil = math.ceil(number)\n  if number - floor\
    \ < ceil - number then\n    return floor\n  else\n    return ceil\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmcw4tkm2.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmcw4tkm2.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    if num > 0 then\n  \
    \      return math.floor(num + 0.5)\n    else\n        return math.ceil(num -\
    \ 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc4ew3q5p.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc4ew3q5p.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local fraction = number - integer\n\
    \    if fraction >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprkj8gfir.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprkj8gfir.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehfg0qz4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehfg0qz4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyny9qdh0.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpyny9qdh0.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int < 0.5 then\n        return int\n    else\n        return int\
    \ + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0ms4f0mk.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp0ms4f0mk.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgm3r880z.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpgm3r880z.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    if num - int > 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1iswodrf.lua:28:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp1iswodrf.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local fraction = number\
    \ - integer\n  if fraction >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdcde8c_i.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdcde8c_i.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy_23v8p9.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpy_23v8p9.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpka9j0l2u.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpka9j0l2u.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc4ew3q5p.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc4ew3q5p.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num < 0 then\n    return math.ceil(num)\n  else\n    return math.floor(num)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_twskhar.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp_twskhar.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == math.floor(num) then\n    return num\n  else\n    local floor = math.floor(num)\n\
    \    local ceil = math.ceil(num)\n    if num - floor < ceil - num then\n     \
    \ return floor\n    else\n      return ceil\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp26pd6pxd.lua:34:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp26pd6pxd.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  if number\
    \ >= 0 then\n    return math.floor(number + 0.5)\n  else\n    return math.ceil(number\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbuht2u87.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbuht2u87.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3446s33t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3446s33t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgm3r880z.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpgm3r880z.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ >= 0.5 then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnxg0khr7.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnxg0khr7.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num then\n    return math.floor(num + 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnqh4_obs.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnqh4_obs.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  return math.floor(number\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmputfh68wo.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmputfh68wo.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7guv1l_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpf7guv1l_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == math.floor(num) then\n        return num\n    else\n        local\
    \ int = math.floor(num)\n        local dec = num - int\n        if dec < 0.5 then\n\
    \            return int\n        else\n            return int + 1\n        end\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1exjm985.lua:34:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1exjm985.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy_23v8p9.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpy_23v8p9.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp019k5lfe.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp019k5lfe.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnlikzq5v.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnlikzq5v.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9r5nrz7k.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9r5nrz7k.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659805223
- exit_code: 0
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659805223
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbw6hui5l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbw6hui5l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1659750527
