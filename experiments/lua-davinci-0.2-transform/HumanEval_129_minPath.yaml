name: HumanEval_129_minPath
language: lua
prompt: "-- Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n-- each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have\
  \ to find the minimum path of length k in the grid. You can start\n-- from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n-- in other words,\
  \ you can go to cells which share an edge with you current\n-- cell.\n-- Please\
  \ note that a path of length k means visiting exactly k cells (not\n-- necessarily\
  \ distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered\
  \ less than a path B (of length k) if\n-- after making the ordered lists of the\
  \ values on the cells that A and B go\n-- through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n-- than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer\
  \ is unique.\n-- Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n-- Examples:    \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7,\
  \ 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n\
  -- {1}\nlocal function minPath(grid, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n\
  \    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n\
  \    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n   \
  \ lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14,\
  \ 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5,\
  \ 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n  \
  \  lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3,\
  \ 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7,\
  \ 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1,\
  \ 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16,\
  \ 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2,\
  \ 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6,\
  \ 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1,\
  \ 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1,\
  \ 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local N = #grid\n    local function get_neighbors(i, j)\n     \
    \   local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local neighbors = get_neighbors(i,\
    \ j)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local ni, nj = neighbor[1], neighbor[2]\n            if not\
    \ visited[ni][nj] then\n                visited[ni][nj] = true\n             \
    \   local new_path = dfs(ni, nj, {unpack(path), grid[ni][nj]}, visited)\n    \
    \            if not min_path or compare(new_path, min_path) then\n           \
    \         min_path = new_path\n                end\n                visited[ni][nj]\
    \ = false\n            end\n        end\n        return min_path\n    end\n  \
    \  local min_path = nil\n    for i = 1, N do\n        for j = 1, N do\n      \
    \      local visited = {}\n            for i = 1, N do\n                visited[i]\
    \ = {}\n            end\n            visited[i][j] = true\n            local new_path\
    \ = dfs(i, j, {grid[i][j]}, visited)\n            if not min_path or compare(new_path,",
  "    local n = #grid\n    local function get_neighbors(i, j)\n        local ret\
    \ = {}\n        if i > 1 then\n            table.insert(ret, {i - 1, j})\n   \
    \     end\n        if i < n then\n            table.insert(ret, {i + 1, j})\n\
    \        end\n        if j > 1 then\n            table.insert(ret, {i, j - 1})\n\
    \        end\n        if j < n then\n            table.insert(ret, {i, j + 1})\n\
    \        end\n        return ret\n    end\n    local function get_value(i, j)\n\
    \        return grid[i][j]\n    end\n    local function get_path(i, j, k)\n  \
    \      local ret = {}\n        if k == 0 then\n            return ret\n      \
    \  end\n        local min_path = nil\n        for _, n in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_path(n[1], n[2], k - 1)\n            if\
    \ path then\n                table.insert(path, 1, get_value(i, j))\n        \
    \        if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function isValid(i, j)\n   \
    \     return i >= 1 and i <= n and j >= 1 and j <= n\n    end\n    local function\
    \ getValue(i, j)\n        return grid[i][j]\n    end\n    local function getNeighbors(i,\
    \ j)\n        local neighbors = {}\n        if isValid(i - 1, j) then\n      \
    \      neighbors[#neighbors + 1] = {i - 1, j}\n        end\n        if isValid(i\
    \ + 1, j) then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n\
    \        if isValid(i, j - 1) then\n            neighbors[#neighbors + 1] = {i,\
    \ j - 1}\n        end\n        if isValid(i, j + 1) then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function getPaths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {getValue(i, j)}\n        else\n            for\
    \ _, neighbor in ipairs(getNeighbors(i, j)) do\n                local ni, nj =\
    \ neighbor[1], neighbor[2]\n                for _, path in ipairs(getPaths(ni,\
    \ nj, k - 1)) do\n                    paths[#paths + 1] = {getValue(i, j)}\n \
    \                   for _, value in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = value\n                    end\n                end\n            end\n\
    \        end\n        return paths\n    end\n    local minPath = {}\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            local paths = getPaths(i, j,\
    \ k)\n            for _, path in ipairs(paths) do\n                if #minPath\
    \ == 0 or path < minPath then\n                    minPath = path\n          \
    \      end\n            end\n        end\n    end\n    return minPath\nend", " \
    \   local n = #grid\n    local function isValid(x, y)\n        return x >= 1 and\
    \ x <= n and y >= 1 and y <= n\n    end\n    local function getValue(x, y)\n \
    \       return grid[x][y]\n    end\n    local function getNeighbors(x, y)\n  \
    \      local neighbors = {}\n        if isValid(x - 1, y) then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if isValid(x + 1, y) then\n        \
    \    neighbors[#neighbors + 1] = {x + 1, y}\n        end\n        if isValid(x,\
    \ y - 1) then\n            neighbors[#neighbors + 1] = {x, y - 1}\n        end\n\
    \        if isValid(x, y + 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function compare(a,\
    \ b)\n        for i = 1, #a do\n            if a[i] < b[i] then\n            \
    \    return true\n            elseif a[i] > b[i] then\n                return\
    \ false\n            end\n        end\n        return false\n    end\n    local\
    \ function getPath(x, y, k)\n        if k == 0 then\n            return {}\n \
    \       end\n        local minPath = nil\n        for _, neighbor in ipairs(getNeighbors(x,\
    \ y)) do\n            local path = getPath(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = getValue(x, y)\n\
    \                if not minPath or compare(path, minPath) then\n             \
    \       minPath = path\n                end\n            end\n        end\n  \
    \      return minPath\n    end\n    local minPath = nil\n    for i = 1, n do\n\
    \        for j = 1, n do\n            local path = getPath(i, j, k)\n        \
    \    if path then\n                path[#path + 1] = getValue(i, j)\n        \
    \        if not minPath or compare(path, minPath) then\n                    minPath\
    \ = path", "    local n = #grid\n    local function get_min_path(i, j, k)\n  \
    \      if k == 0 then\n            return {}\n        end\n        local min_path\
    \ = nil\n        if i > 1 then\n            local path = get_min_path(i - 1, j,\
    \ k - 1)\n            path[#path + 1] = grid[i][j]\n            if min_path ==\
    \ nil or path < min_path then\n                min_path = path\n            end\n\
    \        end\n        if i < n then\n            local path = get_min_path(i +\
    \ 1, j, k - 1)\n            path[#path + 1] = grid[i][j]\n            if min_path\
    \ == nil or path < min_path then\n                min_path = path\n          \
    \  end\n        end\n        if j > 1 then\n            local path = get_min_path(i,\
    \ j - 1, k - 1)\n            path[#path + 1] = grid[i][j]\n            if min_path\
    \ == nil or path < min_path then\n                min_path = path\n          \
    \  end\n        end\n        if j < n then\n            local path = get_min_path(i,\
    \ j + 1, k - 1)\n            path[#path + 1] = grid[i][j]\n            if min_path\
    \ == nil or path < min_path then\n                min_path = path\n          \
    \  end\n        end\n        return min_path\n    end\n    local min_path = nil\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path = get_min_path(i,\
    \ j, k)\n            path[#path + 1] = grid[i][j]\n            if min_path ==\
    \ nil or path < min_path then\n                min_path = path\n            end\n\
    \        end\n    end\n    return min_path\nend", "    local N = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < N then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < N then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function get_min_path(x, y, k)\n        if k == 0 then\n \
    \           return {}\n        end\n        local min_path = {get(x, y)}\n   \
    \     for _, neighbor in ipairs(get_neighbors(x, y)) do\n            local path\
    \ = get_min_path(neighbor[1], neighbor[2], k - 1)\n            path[#path + 1]\
    \ = get(x, y)\n            if compare(path, min_path) then\n                min_path\
    \ = path\n            end\n        end\n        return min_path\n    end\n   \
    \ return get_min_path(1, 1, k)\nend", "    local n = #grid\n    local function\
    \ get(i, j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local res = {}\n        if i > 1 then\n            res[#res + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            res[#res + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            res[#res + 1]\
    \ = {i, j - 1}\n        end\n        if j < n then\n            res[#res + 1]\
    \ = {i, j + 1}\n        end\n        return res\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ res = {}\n        local neighbors = get_neighbors(i, j)\n        for _, neighbor\
    \ in ipairs(neighbors) do\n            local path = get_path(neighbor[1], neighbor[2],\
    \ k - 1)\n            if #path > 0 then\n                res[#res + 1] = {get(i,\
    \ j), path}\n            end\n        end\n        table.sort(res, function(a,\
    \ b)\n            local a_val = a[1]\n            local b_val = b[1]\n       \
    \     if a_val < b_val then\n                return true\n            elseif a_val\
    \ > b_val then\n                return false\n            else\n             \
    \   local a_path = a[2]\n                local b_path = b[2]\n               \
    \ for i = 1, #a_path do\n                    local a_path_val = a_path[i]\n  \
    \                  local b_path_val = b_path[i]\n                    if a_path_val\
    \ < b_path_val then\n                        return true\n                   \
    \ elseif a_path_val > b_path_val then\n                        return false\n\
    \                    end\n                end\n                return false\n\
    \            end\n        end)\n        if #res > 0 then\n            return {get(i,\
    \ j)} .. res[1][2]\n        else\n            return {}\n        end\n    end",
  "    local n = #grid\n    local m = {}\n    for i = 1, n do\n        m[i] = {}\n\
    \        for j = 1, n do\n            m[i][j] = {grid[i][j]}\n        end\n  \
    \  end\n    for i = 2, k do\n        for j = 1, n do\n            for l = 1, n\
    \ do\n                local t = {}\n                if j > 1 then\n          \
    \          for _, v in ipairs(m[j - 1][l]) do\n                        table.insert(t,\
    \ v)\n                    end\n                end\n                if j < n then\n\
    \                    for _, v in ipairs(m[j + 1][l]) do\n                    \
    \    table.insert(t, v)\n                    end\n                end\n      \
    \          if l > 1 then\n                    for _, v in ipairs(m[j][l - 1])\
    \ do\n                        table.insert(t, v)\n                    end\n  \
    \              end\n                if l < n then\n                    for _,\
    \ v in ipairs(m[j][l + 1]) do\n                        table.insert(t, v)\n  \
    \                  end\n                end\n                table.sort(t)\n \
    \               m[j][l] = t\n            end\n        end\n    end\n    local\
    \ min = {}\n    for i = 1, n do\n        for j = 1, n do\n            if #min\
    \ == 0 or m[i][j][1] < min[1] then\n                min = m[i][j]\n          \
    \  end\n        end\n    end\n    return min\nend", "    local n = #grid\n   \
    \ local function get(x, y)\n        if x < 1 or x > n or y < 1 or y > n then\n\
    \            return nil\n        end\n        return grid[x][y]\n    end\n   \
    \ local function get_neighbors(x, y)\n        local neighbors = {}\n        for\
    \ _, d in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local x1,\
    \ y1 = x + d[1], y + d[2]\n            local v = get(x1, y1)\n            if v\
    \ then\n                neighbors[v] = {x1, y1}\n            end\n        end\n\
    \        return neighbors\n    end\n    local function get_path(x, y, k)\n   \
    \     if k == 0 then\n            return {}\n        end\n        local neighbors\
    \ = get_neighbors(x, y)\n        local min_path, min_value = nil, nil\n      \
    \  for v, pos in pairs(neighbors) do\n            local path = get_path(pos[1],\
    \ pos[2], k - 1)\n            if path then\n                table.insert(path,\
    \ 1, v)\n                if not min_path or path < min_path then\n           \
    \         min_path, min_value = path, v\n                end\n            end\n\
    \        end\n        return min_path\n    end\n    local min_path, min_value\
    \ = nil, nil\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ v = grid[i][j]\n            local path = get_path(i, j, k - 1)\n           \
    \ if path then\n                table.insert(path, 1, v)\n                if not\
    \ min_path or path < min_path then\n                    min_path, min_value =\
    \ path, v\n                end\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function get(x, y)\n       \
    \ if x < 1 or x > n or y < 1 or y > n then\n            return math.huge\n   \
    \     end\n        return grid[x][y]\n    end\n    local function less(x, y)\n\
    \        if x == math.huge then\n            return false\n        end\n     \
    \   if y == math.huge then\n            return true\n        end\n        return\
    \ x < y\n    end\n    local function min(x, y)\n        if less(x, y) then\n \
    \           return x\n        end\n        return y\n    end\n    local function\
    \ min3(x, y, z)\n        return min(min(x, y), z)\n    end\n    local function\
    \ min4(x, y, z, w)\n        return min(min(x, y), min(z, w))\n    end\n    local\
    \ function min5(x, y, z, w, v)\n        return min(min(x, y), min(z, min(w, v)))\n\
    \    end\n    local function min6(x, y, z, w, v, u)\n        return min(min(x,\
    \ y), min(z, min(w, min(v, u))))\n    end\n    local function min7(x, y, z, w,\
    \ v, u, t)\n        return min(min(x, y), min(z, min(w, min(v, min(u, t)))))\n\
    \    end\n    local function min8(x, y, z, w, v, u, t, s)\n        return min(min(x,\
    \ y), min(z, min(w, min(v, min(u, min(t, s))))))\n    end\n    local function\
    \ min9(x, y, z, w, v, u, t, s, r)\n        return min(min(x, y), min(z, min(w,\
    \ min(v, min(u, min(t, min(s, r)))))))\n    end\n    local function min10(x, y,\
    \ z, w, v, u, t, s, r, q)\n        return min(min(x, y),", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local res = {}\n        if x > 1 then\n       \
    \     res[#res + 1] = {x - 1, y}\n        end\n        if x < n then\n       \
    \     res[#res + 1] = {x + 1, y}\n        end\n        if y > 1 then\n       \
    \     res[#res + 1] = {x, y - 1}\n        end\n        if y < n then\n       \
    \     res[#res + 1] = {x, y + 1}\n        end\n        return res\n    end\n \
    \   local function get_path(x, y, k)\n        local res = {}\n        for i =\
    \ 1, k do\n            res[i] = get(x, y)\n            local neighbors = get_neighbors(x,\
    \ y)\n            local min_v = math.huge\n            local min_x, min_y\n  \
    \          for _, p in ipairs(neighbors) do\n                local v = get(p[1],\
    \ p[2])\n                if v < min_v then\n                    min_v = v\n  \
    \                  min_x, min_y = p[1], p[2]\n                end\n          \
    \  end\n            x, y = min_x, min_y\n        end\n        return res\n   \
    \ end\n    local min_path = {}\n    for i = 1, n do\n        for j = 1, n do\n\
    \            local path = get_path(i, j, k)\n            if not min_path[1] or\
    \ path < min_path then\n                min_path = path\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n     \
    \       return nil\n        end\n        return grid[i][j]\n    end\n    local\
    \ function get_neighbors(i, j)\n        local neighbors = {}\n        for _, v\
    \ in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local x, y = i\
    \ + v[1], j + v[2]\n            local val = get(x, y)\n            if val then\n\
    \                neighbors[val] = {x, y}\n            end\n        end\n     \
    \   return neighbors\n    end\n    local function get_min_path(i, j, k)\n    \
    \    if k == 0 then\n            return {}\n        end\n        local neighbors\
    \ = get_neighbors(i, j)\n        local min_path = {get(i, j)}\n        for val,\
    \ pos in pairs(neighbors) do\n            local path = get_min_path(pos[1], pos[2],\
    \ k - 1)\n            if #path == k - 1 then\n                table.insert(path,\
    \ 1, val)\n                if #min_path == 0 or path < min_path then\n       \
    \             min_path = path\n                end\n            end\n        end\n\
    \        return min_path\n    end\n    local min_path\n    for i = 1, n do\n \
    \       for j = 1, n do\n            local path = get_min_path(i, j, k)\n    \
    \        if #path == k then\n                if not min_path or path < min_path\
    \ then\n                    min_path = path\n                end\n           \
    \ end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ isValid(x, y)\n        return x >= 1 and x <= n and y >= 1 and y <= n\n    end\n\
    \    local function getNeighbors(x, y)\n        local neighbors = {}\n       \
    \ for _, d in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local\
    \ x1, y1 = x + d[1], y + d[2]\n            if isValid(x1, y1) then\n         \
    \       table.insert(neighbors, {x1, y1})\n            end\n        end\n    \
    \    return neighbors\n    end\n    local function less(a, b)\n        for i =\
    \ 1, k do\n            if a[i] < b[i] then\n                return true\n    \
    \        elseif a[i] > b[i] then\n                return false\n            end\n\
    \        end\n        return false\n    end\n    local function getPath(x, y,\
    \ k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ minPath = nil\n        for _, n in ipairs(getNeighbors(x, y)) do\n         \
    \   local path = getPath(n[1], n[2], k - 1)\n            if path then\n      \
    \          table.insert(path, 1, get(x, y))\n                if not minPath or\
    \ less(path, minPath) then\n                    minPath = path\n             \
    \   end\n            end\n        end\n        return minPath\n    end\n    local\
    \ minPath = nil\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ path = getPath(i, j, k)\n            if path then\n                if not minPath\
    \ or less(path, minPath) then\n                    minPath = path\n          \
    \      end\n            end\n        end\n    end\n    return minPath\nend", " \
    \   local n = #grid\n    local function get_min_path(i, j, k)\n        if k ==\
    \ 0 then\n            return {}\n        end\n        local min_path = nil\n \
    \       local min_path_value = nil\n        if i > 1 then\n            local path\
    \ = get_min_path(i - 1, j, k - 1)\n            if not min_path_value or path[1]\
    \ < min_path_value then\n                min_path = {grid[i][j]}\n           \
    \     min_path_value = grid[i][j]\n                for _, v in ipairs(path) do\n\
    \                    min_path[#min_path + 1] = v\n                end\n      \
    \      end\n        end\n        if i < n then\n            local path = get_min_path(i\
    \ + 1, j, k - 1)\n            if not min_path_value or path[1] < min_path_value\
    \ then\n                min_path = {grid[i][j]}\n                min_path_value\
    \ = grid[i][j]\n                for _, v in ipairs(path) do\n                \
    \    min_path[#min_path + 1] = v\n                end\n            end\n     \
    \   end\n        if j > 1 then\n            local path = get_min_path(i, j - 1,\
    \ k - 1)\n            if not min_path_value or path[1] < min_path_value then\n\
    \                min_path = {grid[i][j]}\n                min_path_value = grid[i][j]\n\
    \                for _, v in ipairs(path) do\n                    min_path[#min_path\
    \ + 1] = v\n                end\n            end\n        end\n        if j <\
    \ n then\n            local path = get_min_path(i, j + 1, k - 1)\n           \
    \ if not min_path_value or path[1] < min_path_value then\n                min_path\
    \ = {grid[i][j]}\n                min_path_value = grid[i][j]\n              \
    \  for _, v in ipairs(path) do\n                    min_path[#min_path + 1] =\
    \ v\n                end\n            end\n        end\n        return min_",
  "    local n = #grid\n    local function get_neighbors(i, j)\n        local res\
    \ = {}\n        if i > 1 then\n            res[#res + 1] = {i - 1, j}\n      \
    \  end\n        if i < n then\n            res[#res + 1] = {i + 1, j}\n      \
    \  end\n        if j > 1 then\n            res[#res + 1] = {i, j - 1}\n      \
    \  end\n        if j < n then\n            res[#res + 1] = {i, j + 1}\n      \
    \  end\n        return res\n    end\n    local function get_path(i, j, k)\n  \
    \      local res = {}\n        res[#res + 1] = grid[i][j]\n        if k == 1 then\n\
    \            return res\n        end\n        local neighbors = get_neighbors(i,\
    \ j)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n   \
    \         if min_path == nil or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n        for _, v in ipairs(min_path) do\n\
    \            res[#res + 1] = v\n        end\n        return res\n    end\n   \
    \ local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n       \
    \     local path = get_path(i, j, k)\n            if min_path == nil or path <\
    \ min_path then\n                min_path = path\n            end\n        end\n\
    \    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get_neighbors(i, j)\n        local res = {}\n        if i > 1 then\n       \
    \     res[#res + 1] = {i - 1, j}\n        end\n        if i < n then\n       \
    \     res[#res + 1] = {i + 1, j}\n        end\n        if j > 1 then\n       \
    \     res[#res + 1] = {i, j - 1}\n        end\n        if j < n then\n       \
    \     res[#res + 1] = {i, j + 1}\n        end\n        return res\n    end\n \
    \   local function get_path(i, j, k)\n        local res = {}\n        if k ==\
    \ 0 then\n            return res\n        end\n        local neighbors = get_neighbors(i,\
    \ j)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n   \
    \         if path then\n                path[#path + 1] = grid[i][j]\n       \
    \         if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = grid[i][j]\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function set(x, y, v)\n        grid[x][y] = v\n    end\n \
    \   local function get_neighbors(x, y)\n        local neighbors = {}\n       \
    \ if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n        end\n\
    \        if x < n then\n            neighbors[#neighbors + 1] = {x + 1, y}\n \
    \       end\n        if y > 1 then\n            neighbors[#neighbors + 1] = {x,\
    \ y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        local x1, y1 = a[1], a[2]\n        local x2,\
    \ y2 = b[1], b[2]\n        return get(x1, y1) < get(x2, y2)\n    end\n    local\
    \ function sort_neighbors(neighbors)\n        table.sort(neighbors, compare)\n\
    \    end\n    local function get_min_path(x, y, k)\n        if k == 0 then\n \
    \           return {get(x, y)}\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        sort_neighbors(neighbors)\n        local min_path = nil\n      \
    \  for _, neighbor in ipairs(neighbors) do\n            local x1, y1 = neighbor[1],\
    \ neighbor[2]\n            local path = get_min_path(x1, y1, k - 1)\n        \
    \    if min_path == nil or path < min_path then\n                min_path = path\n\
    \            end\n        end\n        return {get(x, y)} .. min_path\n    end\n\
    \    local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n    \
    \        local path = get_min_path(i, j, k)\n            if min_path ==", "  \
    \  local N = #grid\n    local function isValid(x, y)\n        return x >= 1 and\
    \ x <= N and y >= 1 and y <= N\n    end\n    local function getValue(x, y)\n \
    \       return grid[x][y]\n    end\n    local function getNeighbors(x, y)\n  \
    \      local neighbors = {}\n        if isValid(x - 1, y) then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if isValid(x + 1, y) then\n        \
    \    neighbors[#neighbors + 1] = {x + 1, y}\n        end\n        if isValid(x,\
    \ y - 1) then\n            neighbors[#neighbors + 1] = {x, y - 1}\n        end\n\
    \        if isValid(x, y + 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function isLess(path1,\
    \ path2)\n        for i = 1, k do\n            if getValue(path1[i][1], path1[i][2])\
    \ < getValue(path2[i][1], path2[i][2]) then\n                return true\n   \
    \         end\n            if getValue(path1[i][1], path1[i][2]) > getValue(path2[i][1],\
    \ path2[i][2]) then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function getPath(x, y, k)\n        if\
    \ k == 0 then\n            return {}\n        end\n        local minPath = nil\n\
    \        for _, neighbor in ipairs(getNeighbors(x, y)) do\n            local path\
    \ = getPath(neighbor[1], neighbor[2], k - 1)\n            if path then\n     \
    \           path[#path + 1] = {x, y}\n                if not minPath or isLess(path,\
    \ minPath) then\n                    minPath = path\n                end\n   \
    \         end\n        end\n        return minPath\n    end\n    local minPath\
    \ = nil\n    for i = 1, N do\n        for j = 1, N do\n           ", "    local\
    \ n = #grid\n    local function get(x, y)\n        return grid[x][y]\n    end\n\
    \    local function get_neighbors(x, y)\n        local neighbors = {}\n      \
    \  if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n       \
    \ end\n        if x < n then\n            neighbors[#neighbors + 1] = {x + 1,\
    \ y}\n        end\n        if y > 1 then\n            neighbors[#neighbors + 1]\
    \ = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(x, y)) do\n            local nx, ny = neighbor[1],\
    \ neighbor[2]\n            if not visited[nx][ny] then\n                visited[nx][ny]\
    \ = true\n                local new_path = dfs(nx, ny, {table.unpack(path), get(nx,\
    \ ny)}, visited)\n                if not min_path or compare(new_path, min_path)\
    \ then\n                    min_path = new_path\n                end\n       \
    \         visited[nx][ny] = false\n            end\n        end\n        return\
    \ min_path\n    end\n    local visited = {}\n    for i = 1, n do\n        visited[i]\
    \ = {}\n        for j = 1, n do\n            visited[i][j] = false\n        end\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            visited[i][j]", "    local N = #grid\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        local min_val = math.huge\n        if i > 1 then\n \
    \           local path = get_path(i - 1, j, k - 1)\n            table.insert(path,\
    \ 1, grid[i][j])\n            local val = 0\n            for _, v in ipairs(path)\
    \ do\n                val = val * 10 + v\n            end\n            if val\
    \ < min_val then\n                min_val = val\n                min_path = path\n\
    \            end\n        end\n        if i < N then\n            local path =\
    \ get_path(i + 1, j, k - 1)\n            table.insert(path, 1, grid[i][j])\n \
    \           local val = 0\n            for _, v in ipairs(path) do\n         \
    \       val = val * 10 + v\n            end\n            if val < min_val then\n\
    \                min_val = val\n                min_path = path\n            end\n\
    \        end\n        if j > 1 then\n            local path = get_path(i, j -\
    \ 1, k - 1)\n            table.insert(path, 1, grid[i][j])\n            local\
    \ val = 0\n            for _, v in ipairs(path) do\n                val = val\
    \ * 10 + v\n            end\n            if val < min_val then\n             \
    \   min_val = val\n                min_path = path\n            end\n        end\n\
    \        if j < N then\n            local path = get_path(i, j + 1, k - 1)\n \
    \           table.insert(path, 1, grid[i][j])\n            local val = 0\n   \
    \         for _, v in ipairs(path) do\n                val = val * 10 + v\n  \
    \          end\n            if val < min_val then\n                min_val = val\n\
    \                min_path = path\n            end\n        end\n        return\
    \ min_path\n    end\n    local min_path = nil\n    local min_val = math.huge\n\
    \    for i = 1, N do\n        for j = 1, N do\n            local path = get",
  "    local n = #grid\n    local function get(i, j)\n        if i < 1 or i > n or\
    \ j < 1 or j > n then\n            return math.huge\n        end\n        return\
    \ grid[i][j]\n    end\n    local function get_min(i, j)\n        return math.min(get(i\
    \ - 1, j), get(i + 1, j), get(i, j - 1), get(i, j + 1))\n    end\n    local function\
    \ get_min_path(i, j, k)\n        if k == 0 then\n            return {}\n     \
    \   end\n        local min_val = get_min(i, j)\n        local min_path = nil\n\
    \        if min_val == get(i - 1, j) then\n            min_path = get_min_path(i\
    \ - 1, j, k - 1)\n        elseif min_val == get(i + 1, j) then\n            min_path\
    \ = get_min_path(i + 1, j, k - 1)\n        elseif min_val == get(i, j - 1) then\n\
    \            min_path = get_min_path(i, j - 1, k - 1)\n        else\n        \
    \    min_path = get_min_path(i, j + 1, k - 1)\n        end\n        table.insert(min_path,\
    \ 1, grid[i][j])\n        return min_path\n    end\n    local min_path = nil\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path = get_min_path(i,\
    \ j, k)\n            if not min_path or path < min_path then\n               \
    \ min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local path = {}\n    local function dfs(i, j,\
    \ k)\n        if k == 0 then\n            return true\n        end\n        local\
    \ v = grid[i][j]\n        if i > 1 and grid[i - 1][j] < v then\n            path[#path\
    \ + 1] = grid[i - 1][j]\n            if dfs(i - 1, j, k - 1) then\n          \
    \      return true\n            end\n            path[#path] = nil\n        end\n\
    \        if i < n and grid[i + 1][j] < v then\n            path[#path + 1] = grid[i\
    \ + 1][j]\n            if dfs(i + 1, j, k - 1) then\n                return true\n\
    \            end\n            path[#path] = nil\n        end\n        if j > 1\
    \ and grid[i][j - 1] < v then\n            path[#path + 1] = grid[i][j - 1]\n\
    \            if dfs(i, j - 1, k - 1) then\n                return true\n     \
    \       end\n            path[#path] = nil\n        end\n        if j < n and\
    \ grid[i][j + 1] < v then\n            path[#path + 1] = grid[i][j + 1]\n    \
    \        if dfs(i, j + 1, k - 1) then\n                return true\n         \
    \   end\n            path[#path] = nil\n        end\n        return false\n  \
    \  end\n    for i = 1, n do\n        for j = 1, n do\n            path[1] = grid[i][j]\n\
    \            if dfs(i, j, k - 1) then\n                return path\n         \
    \   end\n        end\n    end\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        local path = {}\n        local function\
    \ dfs(x, y, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, neighbor in ipairs(get_neighbors(x, y)) do\n\
    \                local nx, ny = neighbor[1], neighbor[2]\n                if not\
    \ path[nx] or not path[nx][ny] then\n                    path[nx] = path[nx] or\
    \ {}\n                    path[nx][ny] = true\n                    if dfs(nx,\
    \ ny, k - 1) then\n                        return true\n                    end\n\
    \                    path[nx][ny] = nil\n                end\n            end\n\
    \            return false\n        end\n        if dfs(x, y, k) then\n       \
    \     local result = {}\n            for x, row in pairs(path) do\n          \
    \      for y, _ in pairs(row) do\n                    result[#result + 1] = get(x,\
    \ y)\n                end\n            end\n            return result\n      \
    \  end\n    end\n    local min_path\n    for x = 1, n do\n        for y = 1, n\
    \ do\n            local path = get_path(x, y, k)\n            if path then\n \
    \               if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function dfs(i, j, k, path)\n\
    \        if k == 0 then\n            return path\n        end\n        local min_path\
    \ = nil\n        if i > 1 then\n            local path1 = dfs(i - 1, j, k - 1,\
    \ path .. grid[i - 1][j])\n            if min_path == nil or path1 < min_path\
    \ then\n                min_path = path1\n            end\n        end\n     \
    \   if i < n then\n            local path2 = dfs(i + 1, j, k - 1, path .. grid[i\
    \ + 1][j])\n            if min_path == nil or path2 < min_path then\n        \
    \        min_path = path2\n            end\n        end\n        if j > 1 then\n\
    \            local path3 = dfs(i, j - 1, k - 1, path .. grid[i][j - 1])\n    \
    \        if min_path == nil or path3 < min_path then\n                min_path\
    \ = path3\n            end\n        end\n        if j < n then\n            local\
    \ path4 = dfs(i, j + 1, k - 1, path .. grid[i][j + 1])\n            if min_path\
    \ == nil or path4 < min_path then\n                min_path = path4\n        \
    \    end\n        end\n        return min_path\n    end\n    local min_path =\
    \ nil\n    for i = 1, n do\n        for j = 1, n do\n            local path =\
    \ dfs(i, j, k, grid[i][j])\n            if min_path == nil or path < min_path\
    \ then\n                min_path = path\n            end\n        end\n    end\n\
    \    local result = {}\n    for i = 1, k do\n        result[i] = tonumber(min_path:sub(i,\
    \ i))\n    end\n    return result\nend", "    local n = #grid\n    local m = {}\n\
    \    for i = 1, n do\n        m[i] = {}\n        for j = 1, n do\n           \
    \ m[i][j] = {}\n        end\n    end\n    local function dfs(i, j, k)\n      \
    \  if k == 0 then\n            return {grid[i][j]}\n        end\n        if m[i][j][k]\
    \ then\n            return m[i][j][k]\n        end\n        local res = {}\n \
    \       if i > 1 then\n            local t = dfs(i - 1, j, k - 1)\n          \
    \  if #res == 0 or t[1] < res[1] then\n                res = t\n            end\n\
    \        end\n        if i < n then\n            local t = dfs(i + 1, j, k - 1)\n\
    \            if #res == 0 or t[1] < res[1] then\n                res = t\n   \
    \         end\n        end\n        if j > 1 then\n            local t = dfs(i,\
    \ j - 1, k - 1)\n            if #res == 0 or t[1] < res[1] then\n            \
    \    res = t\n            end\n        end\n        if j < n then\n          \
    \  local t = dfs(i, j + 1, k - 1)\n            if #res == 0 or t[1] < res[1] then\n\
    \                res = t\n            end\n        end\n        table.insert(res,\
    \ 1, grid[i][j])\n        m[i][j][k] = res\n        return res\n    end\n    return\
    \ dfs(1, 1, k)\nend", "    local n = #grid\n    local function get(i, j)\n   \
    \     return grid[i][j]\n    end\n    local function get_neighbors(i, j)\n   \
    \     local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(i, j)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            path[#path + 1] = get(i, j)\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = get(i, j)\n                if not min_path or path < min_path then\n  \
    \                  min_path = path\n                end\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get_neighbors(i, j)\n        local res = {}\n        if i > 1 then\n\
    \            res[#res + 1] = {i - 1, j}\n        end\n        if i < n then\n\
    \            res[#res + 1] = {i + 1, j}\n        end\n        if j > 1 then\n\
    \            res[#res + 1] = {i, j - 1}\n        end\n        if j < n then\n\
    \            res[#res + 1] = {i, j + 1}\n        end\n        return res\n   \
    \ end\n    local function get_path(i, j, k)\n        if k == 0 then\n        \
    \    return {grid[i][j]}\n        end\n        local neighbors = get_neighbors(i,\
    \ j)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n   \
    \         if not min_path or path < min_path then\n                min_path =\
    \ path\n            end\n        end\n        return {grid[i][j], unpack(min_path)}\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k - 1)\n            if not min_path\
    \ or path < min_path then\n                min_path = path\n            end\n\
    \        end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local res = {}\n        if x > 1 then\n            res[#res + 1]\
    \ = {x - 1, y}\n        end\n        if x < n then\n            res[#res + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            res[#res + 1]\
    \ = {x, y - 1}\n        end\n        if y < n then\n            res[#res + 1]\
    \ = {x, y + 1}\n        end\n        return res\n    end\n    local function less(a,\
    \ b)\n        for i = 1, k do\n            if a[i] < b[i] then\n             \
    \   return true\n            elseif a[i] > b[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end\n    local function\
    \ dfs(x, y, k, path)\n        if k == 0 then\n            return path\n      \
    \  end\n        local min_path = nil\n        for _, n in ipairs(get_neighbors(x,\
    \ y)) do\n            local p = dfs(n[1], n[2], k - 1, {get(n[1], n[2])})\n  \
    \          if not min_path or less(p, min_path) then\n                min_path\
    \ = p\n            end\n        end\n        return min_path\n    end\n    local\
    \ min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ p = dfs(i, j, k - 1, {get(i, j)})\n            if not min_path or less(p, min_path)\
    \ then\n                min_path = p\n            end\n        end\n    end\n\
    \    return min_path\nend", "    local n = #grid\n    local function get(x, y)\n\
    \        return grid[x][y]\n    end\n    local function set(x, y, v)\n       \
    \ grid[x][y] = v\n    end\n    local function get_neighbors(x, y)\n        local\
    \ neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors + 1]\
    \ = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        if a[1] < b[1] then\n            return true\n\
    \        elseif a[1] > b[1] then\n            return false\n        else\n   \
    \         return a[2] < b[2]\n        end\n    end\n    local function get_min_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        local neighbors = get_neighbors(x, y)\n        table.sort(neighbors,\
    \ compare)\n        for _, neighbor in ipairs(neighbors) do\n            local\
    \ path = get_min_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n\
    \                path[#path + 1] = get(x, y)\n                if not min_path\
    \ or compare(path, min_path) then\n                    min_path = path\n     \
    \           end\n            end\n        end\n        return min_path\n    end\n\
    \    local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n    \
    \        local path = get_min_path(i, j, k)\n            if path then\n      \
    \          path[#path + 1] = get(i, j)\n                if not min_path or compare(path,\
    \ min_path) then", "    local n = #grid\n    local function isValid(x, y)\n  \
    \      return x >= 1 and x <= n and y >= 1 and y <= n\n    end\n    local function\
    \ getValue(x, y)\n        return grid[x][y]\n    end\n    local function getNeighbors(x,\
    \ y)\n        local neighbors = {}\n        if isValid(x - 1, y) then\n      \
    \      neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if isValid(x\
    \ + 1, y) then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if isValid(x, y - 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y - 1}\n        end\n        if isValid(x, y + 1) then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, #a do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function getPath(x, y, k)\n        local path = {{x, y}}\n\
    \        local value = getValue(x, y)\n        local min = {value}\n        for\
    \ i = 1, k - 1 do\n            local neighbors = getNeighbors(x, y)\n        \
    \    local minValue = math.huge\n            local minX, minY\n            for\
    \ _, neighbor in ipairs(neighbors) do\n                local nx, ny = neighbor[1],\
    \ neighbor[2]\n                local nValue = getValue(nx, ny)\n             \
    \   if nValue < minValue then\n                    minValue = nValue\n       \
    \             minX, minY = nx, ny\n                end\n            end\n    \
    \        x, y = minX, minY\n            value = minValue\n            path[#path\
    \ + 1] = {x, y}\n            min[#min + 1] = value\n        end\n        return\
    \ path,", "    local n = #grid\n    local function isValid(x, y)\n        return\
    \ x >= 1 and x <= n and y >= 1 and y <= n\n    end\n    local function getValue(x,\
    \ y)\n        return grid[x][y]\n    end\n    local function getNeighbors(x, y)\n\
    \        local neighbors = {}\n        if isValid(x - 1, y) then\n           \
    \ neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if isValid(x +\
    \ 1, y) then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if isValid(x, y - 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y - 1}\n        end\n        if isValid(x, y + 1) then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function getPaths(x, y, k)\n        if k == 0 then\n            return {{}}\n\
    \        end\n        local paths = {}\n        for _, neighbor in ipairs(getNeighbors(x,\
    \ y)) do\n            local x1, y1 = neighbor[1], neighbor[2]\n            for\
    \ _, path in ipairs(getPaths(x1, y1, k - 1)) do\n                table.insert(path,\
    \ 1, getValue(x, y))\n                table.insert(paths, path)\n            end\n\
    \        end\n        return paths\n    end\n    local function comparePaths(path1,\
    \ path2)\n        for i = 1, #path1 do\n            if path1[i] < path2[i] then\n\
    \                return true\n            elseif path1[i] > path2[i] then\n  \
    \              return false\n            end\n        end\n        return false\n\
    \    end\n    local minPath = {}\n    for i = 1, n do\n        for j = 1, n do\n\
    \            for _, path in ipairs(getPaths(i, j, k)) do\n                if #minPath\
    \ == 0 or comparePaths(path, minPath) then\n                    minPath = path",
  "    local n = #grid\n    local function get(i, j)\n        return grid[i][j]\n\
    \    end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n\
    \        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n \
    \       end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_min_path(i, j, k)\n        if k == 1 then\n            return {get(i,\
    \ j)}\n        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_min_path(neighbor[1], neighbor[2], k -\
    \ 1)\n            if min_path == nil or path < min_path then\n               \
    \ min_path = path\n            end\n        end\n        min_path[#min_path +\
    \ 1] = get(i, j)\n        return min_path\n    end\n    local min_path = nil\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path = get_min_path(i,\
    \ j, k)\n            if min_path == nil or path < min_path then\n            \
    \    min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(i, j)\n        return grid[i][j]\n\
    \    end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n\
    \        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n \
    \       end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(i, j)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if min_path == nil\
    \ or path < min_path then\n                min_path = path\n            end\n\
    \        end\n        return {get(i, j)} .. min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if min_path == nil or path < min_path then\n\
    \                min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function get(x, y)\n       \
    \ if x < 1 or x > n or y < 1 or y > n then\n            return math.huge\n   \
    \     end\n        return grid[x][y]\n    end\n    local function get_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ a = get(x - 1, y)\n        local b = get(x + 1, y)\n        local c = get(x,\
    \ y - 1)\n        local d = get(x, y + 1)\n        local min = math.min(a, b,\
    \ c, d)\n        if min == a then\n            return {grid[x][y]} .. get_path(x\
    \ - 1, y, k - 1)\n        elseif min == b then\n            return {grid[x][y]}\
    \ .. get_path(x + 1, y, k - 1)\n        elseif min == c then\n            return\
    \ {grid[x][y]} .. get_path(x, y - 1, k - 1)\n        else\n            return\
    \ {grid[x][y]} .. get_path(x, y + 1, k - 1)\n        end\n    end\n    local path\
    \ = get_path(1, 1, k)\n    for i = 1, n do\n        for j = 1, n do\n        \
    \    local p = get_path(i, j, k)\n            if p < path then\n             \
    \   path = p\n            end\n        end\n    end\n    return path\nend", " \
    \   local N = #grid\n    local function get_neighbors(i, j)\n        local neighbors\
    \ = {}\n        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1,\
    \ j}\n        end\n        if i < N then\n            neighbors[#neighbors + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            if not min_path or compare(path, min_path) then\n               \
    \ min_path = path\n            end\n            return\n        end\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                dfs(ni, nj, {unpack(path), grid[ni][nj]}, visited)\n\
    \                visited[ni][nj] = false\n            end\n        end\n    end\n\
    \    local min_path\n    for i = 1, N do\n        for j = 1, N do\n          \
    \  dfs(i, j, {grid[i][j]}, {})\n        end\n    end\n    return min_path\nend",
  "    local n = #grid\n    local function get_neighbors(i, j)\n        local res\
    \ = {}\n        if i > 1 then\n            res[#res + 1] = {i - 1, j}\n      \
    \  end\n        if i < n then\n            res[#res + 1] = {i + 1, j}\n      \
    \  end\n        if j > 1 then\n            res[#res + 1] = {i, j - 1}\n      \
    \  end\n        if j < n then\n            res[#res + 1] = {i, j + 1}\n      \
    \  end\n        return res\n    end\n    local function get_path(i, j, k)\n  \
    \      local res = {}\n        if k == 0 then\n            return res\n      \
    \  end\n        local neighbors = get_neighbors(i, j)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if min_path == nil\
    \ or path < min_path then\n                min_path = path\n            end\n\
    \        end\n        res[#res + 1] = grid[i][j]\n        for _, v in ipairs(min_path)\
    \ do\n            res[#res + 1] = v\n        end\n        return res\n    end\n\
    \    local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n    \
    \        local path = get_path(i, j, k)\n            if min_path == nil or path\
    \ < min_path then\n                min_path = path\n            end\n        end\n\
    \    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function less(x, y)\n\
    \        return x.sum < y.sum or (x.sum == y.sum and x.path < y.path)\n    end\n\
    \    local function getNeighbors(x, y)\n        local neighbors = {}\n       \
    \ if x > 1 then\n            neighbors[#neighbors + 1] = {x = x - 1, y = y}\n\
    \        end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ = x + 1, y = y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x = x, y = y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x = x, y = y + 1}\n        end\n        return neighbors\n    end\n\
    \    local function getPath(x, y, k)\n        local path = {}\n        local sum\
    \ = 0\n        for i = 1, k do\n            path[i] = get(x, y)\n            sum\
    \ = sum + path[i]\n            local neighbors = getNeighbors(x, y)\n        \
    \    table.sort(neighbors, function(a, b)\n                return get(a.x, a.y)\
    \ < get(b.x, b.y)\n            end)\n            x, y = neighbors[1].x, neighbors[1].y\n\
    \        end\n        return {path = path, sum = sum}\n    end\n    local min\
    \ = getPath(1, 1, k)\n    for i = 1, n do\n        for j = 1, n do\n         \
    \   local path = getPath(i, j, k)\n            if less(path, min) then\n     \
    \           min = path\n            end\n        end\n    end\n    return min.path\n\
    end", "    local N = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > N or y < 1 or y > N then\n            return -1\n        end\n        return\
    \ grid[x][y]\n    end\n    local function cmp(a, b)\n        for i = 1, k do\n\
    \            if a[i] < b[i] then\n                return true\n            elseif\
    \ a[i] > b[i] then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function dfs(x, y, k, path)\n      \
    \  if k == 0 then\n            return path\n        end\n        local min_path\
    \ = nil\n        local min_val = nil\n        for _, d in ipairs({{-1, 0}, {1,\
    \ 0}, {0, -1}, {0, 1}}) do\n            local nx, ny = x + d[1], y + d[2]\n  \
    \          local val = get(nx, ny)\n            if val ~= -1 then\n          \
    \      local new_path = dfs(nx, ny, k - 1, path .. val)\n                if min_path\
    \ == nil or cmp(new_path, min_path) then\n                    min_path = new_path\n\
    \                    min_val = val\n                end\n            end\n   \
    \     end\n        return min_path\n    end\n    local min_path = nil\n    local\
    \ min_val = nil\n    for i = 1, N do\n        for j = 1, N do\n            local\
    \ val = get(i, j)\n            local new_path = dfs(i, j, k - 1, val)\n      \
    \      if min_path == nil or cmp(new_path, min_path) then\n                min_path\
    \ = new_path\n                min_val = val\n            end\n        end\n  \
    \  end\n    return min_path\nend", "    local n = #grid\n    local m = {}\n  \
    \  for i = 1, n do\n        m[i] = {}\n        for j = 1, n do\n            m[i][j]\
    \ = {grid[i][j]}\n        end\n    end\n    for i = 1, k - 1 do\n        local\
    \ t = {}\n        for i = 1, n do\n            t[i] = {}\n            for j =\
    \ 1, n do\n                t[i][j] = {}\n            end\n        end\n      \
    \  for i = 1, n do\n            for j = 1, n do\n                local v = m[i][j]\n\
    \                if i > 1 then\n                    local u = m[i - 1][j]\n  \
    \                  if #u < #v then\n                        v = u\n          \
    \          elseif #u == #v then\n                        for k = 1, #u do\n  \
    \                          if u[k] < v[k] then\n                             \
    \   v = u\n                                break\n                           \
    \ elseif u[k] > v[k] then\n                                break\n           \
    \                 end\n                        end\n                    end\n\
    \                end\n                if j > 1 then\n                    local\
    \ u = m[i][j - 1]\n                    if #u < #v then\n                     \
    \   v = u\n                    elseif #u == #v then\n                        for\
    \ k = 1, #u do\n                            if u[k] < v[k] then\n            \
    \                    v = u\n                                break\n          \
    \                  elseif u[k] > v[k] then\n                                break\n\
    \                            end\n                        end\n              \
    \      end\n                end\n                if i < n then\n             \
    \       local u = m[i + 1][j]\n                    if #u < #v then\n         \
    \               v = u\n                    elseif #u == #v then\n            \
    \            for k = 1, #u do\n                            if u[k] < v[k] then\n\
    \                                v = u\n                                break\n\
    \                            elseif u[k] > v[k] then\n                       \
    \         break\n                            end\n                        end\n\
    \                    end\n                end\n                if j < n then\n\
    \                    local u = m[i][j + 1]\n                    if #u < #v then\n\
    \                        v =", "    local N = #grid\n    local function get(i,\
    \ j)\n        return grid[i][j]\n    end\n    local function set(i, j, v)\n  \
    \      grid[i][j] = v\n    end\n    local function is_valid(i, j)\n        return\
    \ i >= 1 and i <= N and j >= 1 and j <= N\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        for _, d in ipairs({{-1, 0}, {1, 0},\
    \ {0, -1}, {0, 1}}) do\n            local ni, nj = i + d[1], j + d[2]\n      \
    \      if is_valid(ni, nj) then\n                table.insert(neighbors, {ni,\
    \ nj})\n            end\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        local path = {}\n        for _ = 1, k do\n\
    \            table.insert(path, get(i, j))\n            local neighbors = get_neighbors(i,\
    \ j)\n            local min_neighbor = neighbors[1]\n            for _, neighbor\
    \ in ipairs(neighbors) do\n                if get(neighbor[1], neighbor[2]) <\
    \ get(min_neighbor[1], min_neighbor[2]) then\n                    min_neighbor\
    \ = neighbor\n                end\n            end\n            i, j = min_neighbor[1],\
    \ min_neighbor[2]\n        end\n        return path\n    end\n    local min_path\
    \ = get_path(1, 1, k)\n    for i = 1, N do\n        for j = 1, N do\n        \
    \    local path = get_path(i, j, k)\n            if path < min_path then\n   \
    \             min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function get_neighbors(i, j)\n\
    \        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[i][j]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(i, j)) do\n                local ni, nj = neighbor[1],\
    \ neighbor[2]\n                for _, path in ipairs(get_paths(ni, nj, k - 1))\
    \ do\n                    paths[#paths + 1] = {grid[i][j]}\n                 \
    \   for _, value in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = value\n                    end\n                end\n            end\n\
    \        end\n        return paths\n    end\n    local min_path = nil\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            for _, path in ipairs(get_paths(i,\
    \ j, k)) do\n                if not min_path or path < min_path then\n       \
    \             min_path = path\n                end\n            end\n        end\n\
    \    end\n    return min_path\nend", "    local function dfs(i, j, k, path)\n\
    \        if k == 0 then\n            return path\n        end\n        local min_path\
    \ = nil\n        if i > 1 then\n            min_path = dfs(i - 1, j, k - 1, {grid[i][j]})\n\
    \        end\n        if j > 1 then\n            local path = dfs(i, j - 1, k\
    \ - 1, {grid[i][j]})\n            if min_path == nil or path < min_path then\n\
    \                min_path = path\n            end\n        end\n        if i <\
    \ #grid then\n            local path = dfs(i + 1, j, k - 1, {grid[i][j]})\n  \
    \          if min_path == nil or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n        if j < #grid then\n          \
    \  local path = dfs(i, j + 1, k - 1, {grid[i][j]})\n            if min_path ==\
    \ nil or path < min_path then\n                min_path = path\n            end\n\
    \        end\n        return min_path\n    end\n    local min_path = nil\n   \
    \ for i = 1, #grid do\n        for j = 1, #grid do\n            local path = dfs(i,\
    \ j, k, {})\n            if min_path == nil or path < min_path then\n        \
    \        min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get_neighbors(i, j)\n        local\
    \ neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = grid[i][j]\n    \
    \            if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = grid[i][j]\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function isValid(i, j)\n        return i >= 1 and\
    \ i <= n and j >= 1 and j <= n\n    end\n    local function getNeighbors(i, j)\n\
    \        local neighbors = {}\n        if isValid(i - 1, j) then\n           \
    \ neighbors[#neighbors + 1] = {i - 1, j}\n        end\n        if isValid(i +\
    \ 1, j) then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n\
    \        if isValid(i, j - 1) then\n            neighbors[#neighbors + 1] = {i,\
    \ j - 1}\n        end\n        if isValid(i, j + 1) then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function getPath(i, j, k)\n        if k == 0 then\n            return {}\n \
    \       end\n        local neighbors = getNeighbors(i, j)\n        local path\
    \ = {}\n        local minPath = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local p = getPath(neighbor[1], neighbor[2], k - 1)\n       \
    \     if p then\n                p[#p + 1] = grid[i][j]\n                if not\
    \ minPath or p < minPath then\n                    minPath = p\n             \
    \   end\n            end\n        end\n        return minPath\n    end\n    local\
    \ minPath = nil\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ p = getPath(i, j, k)\n            if p then\n                p[#p + 1] = grid[i][j]\n\
    \                if not minPath or p < minPath then\n                    minPath\
    \ = p\n                end\n            end\n        end\n    end\n    return\
    \ minPath\nend", "    local n = #grid\n    local function get(i, j)\n        return\
    \ grid[i][j]\n    end\n    local function get_neighbors(i, j)\n        local neighbors\
    \ = {}\n        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1,\
    \ j}\n        end\n        if i < n then\n            neighbors[#neighbors + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(i, j)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            path[#path + 1] = get(i, j)\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = get(i, j)\n                if not min_path or path < min_path then\n  \
    \                  min_path = path\n                end\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n     \
    \       return 0\n        end\n        return grid[i][j]\n    end\n    local function\
    \ get_path(i, j, k)\n        if k == 0 then\n            return {}\n        end\n\
    \        local paths = {}\n        local function add_path(path)\n           \
    \ table.insert(paths, path)\n        end\n        local function add_paths(paths)\n\
    \            for _, path in ipairs(paths) do\n                add_path(path)\n\
    \            end\n        end\n        add_paths(get_path(i - 1, j, k - 1))\n\
    \        add_paths(get_path(i + 1, j, k - 1))\n        add_paths(get_path(i, j\
    \ - 1, k - 1))\n        add_paths(get_path(i, j + 1, k - 1))\n        for i, path\
    \ in ipairs(paths) do\n            table.insert(path, 1, get(i, j))\n        end\n\
    \        return paths\n    end\n    local function less(path1, path2)\n      \
    \  for i = 1, #path1 do\n            if path1[i] < path2[i] then\n           \
    \     return true\n            elseif path1[i] > path2[i] then\n             \
    \   return false\n            end\n        end\n        return false\n    end\n\
    \    local function min(paths)\n        local min_path = paths[1]\n        for\
    \ _, path in ipairs(paths) do\n            if less(path, min_path) then\n    \
    \            min_path = path\n            end\n        end\n        return min_path\n\
    \    end\n    local paths = {}\n    for i = 1, n do\n        for j = 1, n do\n\
    \            local path = get_path(i, j, k)\n            if #path > 0 then\n \
    \               table.insert(paths, path)\n            end\n        end\n    end\n\
    \    return min(paths)\nend", "    local N = #grid\n    local function get_value(i,\
    \ j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function get_path(i, j, k)\n        local path = {}\n    \
    \    for _ = 1, k do\n            path[#path + 1] = get_value(i, j)\n        \
    \    local neighbors = get_neighbors(i, j)\n            local min_neighbor = neighbors[1]\n\
    \            for _, neighbor in ipairs(neighbors) do\n                if compare(neighbor,\
    \ min_neighbor) then\n                    min_neighbor = neighbor\n          \
    \      end\n            end\n            i, j = min_neighbor[1], min_neighbor[2]\n\
    \        end\n        return path\n    end\n    local min_path = get_path(1, 1,\
    \ k)\n    for i = 1, N do\n        for j = 1, N do\n            local path = get_path(i,\
    \ j, k)\n            if compare(path, min_path) then\n                min_path\
    \ = path\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        local min_path = nil\n        for _, n in ipairs(neighbors) do\n\
    \            local p = dfs(n[1], n[2], k - 1, path .. get(n[1], n[2]))\n     \
    \       if min_path == nil or compare(p, min_path) then\n                min_path\
    \ = p\n            end\n        end\n        return min_path\n    end\n    local\
    \ min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ p = dfs(i, j, k - 1, get(i, j))\n            if min_path == nil or compare(p,\
    \ min_path) then\n                min_path = p\n            end\n        end\n\
    \    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get(i, j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local path = {}\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local neighbor_path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if neighbor_path then\n\
    \                path[#path + 1] = get(neighbor[1], neighbor[2])\n           \
    \     if not min_path or path < min_path then\n                    min_path =\
    \ path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = get(i, j)\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ N = #grid\n    local function get(x, y)\n        return grid[x][y]\n    end\n\
    \    local function get_neighbors(x, y)\n        local res = {}\n        if x\
    \ > 1 then\n            res[#res + 1] = {x - 1, y}\n        end\n        if x\
    \ < N then\n            res[#res + 1] = {x + 1, y}\n        end\n        if y\
    \ > 1 then\n            res[#res + 1] = {x, y - 1}\n        end\n        if y\
    \ < N then\n            res[#res + 1] = {x, y + 1}\n        end\n        return\
    \ res\n    end\n    local function compare(a, b)\n        for i = 1, k do\n  \
    \          if a[i] < b[i] then\n                return true\n            elseif\
    \ a[i] > b[i] then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function get_path(x, y, k)\n       \
    \ local res = {}\n        for i = 1, k do\n            res[i] = get(x, y)\n  \
    \          local neighbors = get_neighbors(x, y)\n            local min = neighbors[1]\n\
    \            for j = 2, #neighbors do\n                if compare(get_path(neighbors[j][1],\
    \ neighbors[j][2], k - i), get_path(min[1], min[2], k - i)) then\n           \
    \         min = neighbors[j]\n                end\n            end\n         \
    \   x, y = min[1], min[2]\n        end\n        return res\n    end\n    return\
    \ get_path(1, 1, k)\nend", "    local function get_neighbors(i, j)\n        local\
    \ res = {}\n        if i > 1 then\n            table.insert(res, {i - 1, j})\n\
    \        end\n        if i < #grid then\n            table.insert(res, {i + 1,\
    \ j})\n        end\n        if j > 1 then\n            table.insert(res, {i, j\
    \ - 1})\n        end\n        if j < #grid then\n            table.insert(res,\
    \ {i, j + 1})\n        end\n        return res\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ res = {}\n        for _, n in ipairs(get_neighbors(i, j)) do\n            local\
    \ path = get_path(n[1], n[2], k - 1)\n            table.insert(path, 1, grid[i][j])\n\
    \            table.insert(res, path)\n        end\n        table.sort(res, function(a,\
    \ b)\n            for i = 1, #a do\n                if a[i] < b[i] then\n    \
    \                return true\n                elseif a[i] > b[i] then\n      \
    \              return false\n                end\n            end\n          \
    \  return false\n        end)\n        return res[1]\n    end\n    local res =\
    \ {}\n    for i = 1, #grid do\n        for j = 1, #grid do\n            local\
    \ path = get_path(i, j, k)\n            if #res == 0 or path < res then\n    \
    \            res = path\n            end\n        end\n    end\n    return res\n\
    end", "    local N = #grid\n    local function isValid(x, y)\n        return x\
    \ >= 1 and x <= N and y >= 1 and y <= N\n    end\n    local function getNeighbors(x,\
    \ y)\n        local neighbors = {}\n        for i = -1, 1 do\n            for\
    \ j = -1, 1 do\n                if i ~= 0 or j ~= 0 then\n                   \
    \ local nx, ny = x + i, y + j\n                    if isValid(nx, ny) then\n \
    \                       table.insert(neighbors, {nx, ny})\n                  \
    \  end\n                end\n            end\n        end\n        return neighbors\n\
    \    end\n    local function getPath(x, y, k)\n        if k == 0 then\n      \
    \      return {}\n        end\n        local neighbors = getNeighbors(x, y)\n\
    \        local minPath = nil\n        for _, neighbor in ipairs(neighbors) do\n\
    \            local nx, ny = neighbor[1], neighbor[2]\n            local path =\
    \ getPath(nx, ny, k - 1)\n            if path then\n                local newPath\
    \ = {grid[x][y]}\n                for _, v in ipairs(path) do\n              \
    \      table.insert(newPath, v)\n                end\n                if not minPath\
    \ or newPath < minPath then\n                    minPath = newPath\n         \
    \       end\n            end\n        end\n        return minPath\n    end\n \
    \   local minPath = nil\n    for i = 1, N do\n        for j = 1, N do\n      \
    \      local path = getPath(i, j, k)\n            if path then\n             \
    \   if not minPath or path < minPath then\n                    minPath = path\n\
    \                end\n            end\n        end\n    end\n    return minPath\n\
    end", "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function set(x, y, v)\n        grid[x][y] = v\n    end\n \
    \   local function get_neighbors(x, y)\n        local res = {}\n        if x >\
    \ 1 then\n            res[#res + 1] = {x - 1, y}\n        end\n        if x <\
    \ n then\n            res[#res + 1] = {x + 1, y}\n        end\n        if y >\
    \ 1 then\n            res[#res + 1] = {x, y - 1}\n        end\n        if y <\
    \ n then\n            res[#res + 1] = {x, y + 1}\n        end\n        return\
    \ res\n    end\n    local function cmp(a, b)\n        for i = 1, k do\n      \
    \      if a[i] < b[i] then\n                return true\n            elseif a[i]\
    \ > b[i] then\n                return false\n            end\n        end\n  \
    \      return false\n    end\n    local function dfs(x, y, path, depth)\n    \
    \    if depth == k then\n            if not path[1] or cmp(path, {get(x, y)})\
    \ then\n                path[1] = {get(x, y)}\n            end\n            return\n\
    \        end\n        for _, n in ipairs(get_neighbors(x, y)) do\n           \
    \ local nx, ny = n[1], n[2]\n            local v = get(nx, ny)\n            if\
    \ v ~= -1 then\n                set(nx, ny, -1)\n                dfs(nx, ny, path,\
    \ depth + 1)\n                set(nx, ny, v)\n            end\n        end\n \
    \   end\n    local path = {}\n    for i = 1, n do\n        for j = 1, n do\n \
    \           dfs(i, j, path, 1)\n        end\n    end\n    return path[1]\nend",
  "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function set(x, y, v)\n        grid[x][y] = v\n    end\n \
    \   local function isValid(x, y)\n        return x >= 1 and x <= n and y >= 1\
    \ and y <= n\n    end\n    local function getNeighbors(x, y)\n        local neighbors\
    \ = {}\n        if isValid(x - 1, y) then\n            neighbors[#neighbors +\
    \ 1] = {x - 1, y}\n        end\n        if isValid(x + 1, y) then\n          \
    \  neighbors[#neighbors + 1] = {x + 1, y}\n        end\n        if isValid(x,\
    \ y - 1) then\n            neighbors[#neighbors + 1] = {x, y - 1}\n        end\n\
    \        if isValid(x, y + 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function getPath(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ minPath = nil\n        for _, neighbor in ipairs(getNeighbors(x, y)) do\n  \
    \          local path = getPath(neighbor[1], neighbor[2], k - 1)\n           \
    \ if path then\n                path[#path + 1] = get(x, y)\n                if\
    \ not minPath or path < minPath then\n                    minPath = path\n   \
    \             end\n            end\n        end\n        return minPath\n    end\n\
    \    local minPath = nil\n    for i = 1, n do\n        for j = 1, n do\n     \
    \       local path = getPath(i, j, k)\n            if path then\n            \
    \    path[#path + 1] = get(i, j)\n                if not minPath or path < minPath\
    \ then\n                    minPath = path\n                end\n            end\n\
    \        end\n    end\n    return minPath\nend", "    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < #grid then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < #grid then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = grid[i][j]\n    \
    \            if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, #grid do\n        for j = 1,\
    \ #grid do\n            local path = get_path(i, j, k)\n            if path then\n\
    \                path[#path + 1] = grid[i][j]\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        local min_path = {}\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local nx, ny = neighbor[1], neighbor[2]\n            local new_path\
    \ = dfs(nx, ny, k - 1, path)\n            if #min_path == 0 or compare(new_path,\
    \ min_path) then\n                min_path = new_path\n            end\n     \
    \   end\n        return min_path\n    end\n    local min_path = {}\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            local path = dfs(i, j, k, {get(i,\
    \ j)})\n            if #min_path == 0 or compare(path, min_path) then\n      \
    \          min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function get_neighbors(i, j)\n\
    \        local res = {}\n        if i > 1 then\n            res[#res + 1] = {i\
    \ - 1, j}\n        end\n        if i < n then\n            res[#res + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            res[#res + 1] = {i,\
    \ j - 1}\n        end\n        if j < n then\n            res[#res + 1] = {i,\
    \ j + 1}\n        end\n        return res\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ res = {}\n        for _, n in ipairs(get_neighbors(i, j)) do\n            local\
    \ path = get_path(n[1], n[2], k - 1)\n            if #path > 0 then\n        \
    \        path[#path + 1] = grid[i][j]\n                res[#res + 1] = path\n\
    \            end\n        end\n        if #res == 0 then\n            return {}\n\
    \        end\n        local min_path = res[1]\n        for i = 2, #res do\n  \
    \          if res[i] < min_path then\n                min_path = res[i]\n    \
    \        end\n        end\n        return min_path\n    end\n    local res = {}\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path = get_path(i,\
    \ j, k)\n            if #path > 0 then\n                path[#path + 1] = grid[i][j]\n\
    \                res[#res + 1] = path\n            end\n        end\n    end\n\
    \    local min_path = res[1]\n    for i = 2, #res do\n        if res[i] < min_path\
    \ then\n            min_path = res[i]\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get_neighbors(x, y)\n        local\
    \ res = {}\n        if x > 1 then\n            res[#res + 1] = {x - 1, y}\n  \
    \      end\n        if x < n then\n            res[#res + 1] = {x + 1, y}\n  \
    \      end\n        if y > 1 then\n            res[#res + 1] = {x, y - 1}\n  \
    \      end\n        if y < n then\n            res[#res + 1] = {x, y + 1}\n  \
    \      end\n        return res\n    end\n    local function get_path(x, y, k)\n\
    \        if k == 0 then\n            return {}\n        end\n        local res\
    \ = {}\n        for _, n in ipairs(get_neighbors(x, y)) do\n            local\
    \ path = get_path(n[1], n[2], k - 1)\n            if #path > 0 then\n        \
    \        path[#path + 1] = grid[x][y]\n                res[#res + 1] = path\n\
    \            end\n        end\n        table.sort(res, function(a, b)\n      \
    \      for i = 1, #a do\n                if a[i] < b[i] then\n               \
    \     return true\n                elseif a[i] > b[i] then\n                 \
    \   return false\n                end\n            end\n            return false\n\
    \        end)\n        return res[1] or {}\n    end\n    local res = {}\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            local path = get_path(i, j,\
    \ k)\n            if #path > 0 then\n                path[#path + 1] = grid[i][j]\n\
    \                res[#res + 1] = path\n            end\n        end\n    end\n\
    \    table.sort(res, function(a, b)\n        for i = 1, #a do\n            if\
    \ a[i] < b[i] then\n                return true\n            elseif a[i] > b[i]\
    \ then\n                return false\n            end\n        end\n        return\
    \ false\n    end)\n    return res[1] or {}\nend\n", "    local n = #grid\n   \
    \ local function get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n\
    \            return math.huge\n        end\n        return grid[i][j]\n    end\n\
    \    local function get_neighbors(i, j)\n        return {\n            {i - 1,\
    \ j},\n            {i + 1, j},\n            {i, j - 1},\n            {i, j + 1}\n\
    \        }\n    end\n    local function get_path(i, j, k)\n        if k == 0 then\n\
    \            return {}\n        end\n        local min_path, min_value = nil,\
    \ math.huge\n        for _, neighbor in ipairs(get_neighbors(i, j)) do\n     \
    \       local path = get_path(neighbor[1], neighbor[2], k - 1)\n            if\
    \ path then\n                local value = get(neighbor[1], neighbor[2])\n   \
    \             if value < min_value then\n                    min_path = path\n\
    \                    min_value = value\n                end\n            end\n\
    \        end\n        if min_path then\n            table.insert(min_path, 1,\
    \ get(i, j))\n            return min_path\n        end\n    end\n    local min_path,\
    \ min_value = nil, math.huge\n    for i = 1, n do\n        for j = 1, n do\n \
    \           local path = get_path(i, j, k - 1)\n            if path then\n   \
    \             local value = get(i, j)\n                if value < min_value then\n\
    \                    min_path = path\n                    min_value = value\n\
    \                end\n            end\n        end\n    end\n    if min_path then\n\
    \        table.insert(min_path, 1, get(i, j))\n        return min_path\n    end\n\
    end", "    local n = #grid\n    local function get_neighbors(i, j)\n        local\
    \ neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[i][j]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(i, j)) do\n                local ni, nj = neighbor[1],\
    \ neighbor[2]\n                for _, path in ipairs(get_paths(ni, nj, k - 1))\
    \ do\n                    paths[#paths + 1] = {grid[i][j]}\n                 \
    \   for _, v in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = v\n                    end\n                end\n            end\n  \
    \      end\n        return paths\n    end\n    local min_path = nil\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            for _, path in ipairs(get_paths(i,\
    \ j, k)) do\n                if min_path == nil or path < min_path then\n    \
    \                min_path = path\n                end\n            end\n     \
    \   end\n    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n            return\
    \ math.huge\n        end\n        return grid[i][j]\n    end\n    local function\
    \ get_min(i, j)\n        return math.min(get(i - 1, j), get(i + 1, j), get(i,\
    \ j - 1), get(i, j + 1))\n    end\n    local function get_min_path(i, j, k)\n\
    \        if k == 0 then\n            return {}\n        end\n        local min_val\
    \ = get_min(i, j)\n        local min_path\n        if get(i - 1, j) == min_val\
    \ then\n            min_path = get_min_path(i - 1, j, k - 1)\n        elseif get(i\
    \ + 1, j) == min_val then\n            min_path = get_min_path(i + 1, j, k - 1)\n\
    \        elseif get(i, j - 1) == min_val then\n            min_path = get_min_path(i,\
    \ j - 1, k - 1)\n        else\n            min_path = get_min_path(i, j + 1, k\
    \ - 1)\n        end\n        table.insert(min_path, 1, grid[i][j])\n        return\
    \ min_path\n    end\n    local min_path\n    for i = 1, n do\n        for j =\
    \ 1, n do\n            local path = get_min_path(i, j, k)\n            if not\
    \ min_path or path < min_path then\n                min_path = path\n        \
    \    end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get_neighbors(x, y)\n        local res = {}\n        if x\
    \ > 1 then\n            res[#res + 1] = {x - 1, y}\n        end\n        if x\
    \ < n then\n            res[#res + 1] = {x + 1, y}\n        end\n        if y\
    \ > 1 then\n            res[#res + 1] = {x, y - 1}\n        end\n        if y\
    \ < n then\n            res[#res + 1] = {x, y + 1}\n        end\n        return\
    \ res\n    end\n    local function get_path(x, y, k)\n        local res = {}\n\
    \        local function dfs(x, y, k)\n            if k == 0 then\n           \
    \     return\n            end\n            res[#res + 1] = grid[x][y]\n      \
    \      for _, n in ipairs(get_neighbors(x, y)) do\n                dfs(n[1], n[2],\
    \ k - 1)\n            end\n        end\n        dfs(x, y, k)\n        return res\n\
    \    end\n    local min_path = {}\n    for i = 1, n do\n        for j = 1, n do\n\
    \            local path = get_path(i, j, k)\n            if #min_path == 0 or\
    \ path < min_path then\n                min_path = path\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get_neighbors(i, j)\n        local neighbors = {}\n        if i > 1\
    \ then\n            neighbors[#neighbors + 1] = {i - 1, j}\n        end\n    \
    \    if i < n then\n            neighbors[#neighbors + 1] = {i + 1, j}\n     \
    \   end\n        if j > 1 then\n            neighbors[#neighbors + 1] = {i, j\
    \ - 1}\n        end\n        if j < n then\n            neighbors[#neighbors +\
    \ 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local function\
    \ get_path(i, j, k)\n        local path = {}\n        local function dfs(i, j,\
    \ k)\n            if k == 0 then\n                return true\n            end\n\
    \            local neighbors = get_neighbors(i, j)\n            for _, neighbor\
    \ in ipairs(neighbors) do\n                local ni, nj = neighbor[1], neighbor[2]\n\
    \                if not path[ni] or not path[ni][nj] then\n                  \
    \  path[ni] = path[ni] or {}\n                    path[ni][nj] = true\n      \
    \              if dfs(ni, nj, k - 1) then\n                        return true\n\
    \                    end\n                    path[ni][nj] = nil\n           \
    \     end\n            end\n            return false\n        end\n        dfs(i,\
    \ j, k)\n        return path\n    end\n    local function get_path_value(path)\n\
    \        local values = {}\n        for i = 1, n do\n            for j = 1, n\
    \ do\n                if path[i] and path[i][j] then\n                    values[#values\
    \ + 1] = grid[i][j]\n                end\n            end\n        end\n     \
    \   return values\n    end\n    local min_path = nil\n    local min_path_value\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            local path_value = get_path_value(path)\n \
    \           if not min_path_value or path_value", "    local n = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function set(x,\
    \ y, v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        local path = {}\n        local function\
    \ dfs(x, y, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            local neighbors = get_neighbors(x, y)\n            for\
    \ _, neighbor in ipairs(neighbors) do\n                local nx, ny = neighbor[1],\
    \ neighbor[2]\n                local v = get(nx, ny)\n                if v then\n\
    \                    set(nx, ny, nil)\n                    path[#path + 1] = v\n\
    \                    if dfs(nx, ny, k - 1) then\n                        return\
    \ true\n                    end\n                    path[#path] = nil\n     \
    \               set(nx, ny, v)\n                end\n            end\n       \
    \     return false\n        end\n        dfs(x, y, k)\n        return path\n \
    \   end\n    local function compare(path1, path2)\n        for i = 1, k do\n \
    \           if path1[i] < path2[i] then\n                return true\n       \
    \     elseif path1[i] > path2[i] then\n                return false\n        \
    \    end\n        end\n        return false\n    end\n    local min_path = {}\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path =", "  \
    \  local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = get(x, y)\n     \
    \           if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = get(i, j)\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ n = #grid\n    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n    \
    \    for j = 1, n do\n            dp[i][j] = {}\n        end\n    end\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            dp[i][j][1] = {grid[i][j]}\n\
    \        end\n    end\n    for l = 2, k do\n        for i = 1, n do\n        \
    \    for j = 1, n do\n                local min = nil\n                if i >\
    \ 1 then\n                    local tmp = {}\n                    for _, v in\
    \ ipairs(dp[i - 1][j][l - 1]) do\n                        table.insert(tmp, v)\n\
    \                    end\n                    table.insert(tmp, grid[i][j])\n\
    \                    if min == nil or tmp < min then\n                       \
    \ min = tmp\n                    end\n                end\n                if\
    \ i < n then\n                    local tmp = {}\n                    for _, v\
    \ in ipairs(dp[i + 1][j][l - 1]) do\n                        table.insert(tmp,\
    \ v)\n                    end\n                    table.insert(tmp, grid[i][j])\n\
    \                    if min == nil or tmp < min then\n                       \
    \ min = tmp\n                    end\n                end\n                if\
    \ j > 1 then\n                    local tmp = {}\n                    for _, v\
    \ in ipairs(dp[i][j - 1][l - 1]) do\n                        table.insert(tmp,\
    \ v)\n                    end\n                    table.insert(tmp, grid[i][j])\n\
    \                    if min == nil or tmp < min then\n                       \
    \ min = tmp\n                    end\n                end\n                if\
    \ j < n then\n                    local tmp = {}\n                    for _, v\
    \ in ipairs(dp[i][j + 1][l - 1]) do\n                        table.insert(tmp,\
    \ v)\n                    end\n                    table.insert(tmp, grid[i][j])\n\
    \                    if min == nil or tmp < min then\n                       \
    \ min = tmp\n                    end\n                end\n                dp[i][j][l]\
    \ = min\n            end\n        end\n    end\n    local min = nil\n    for i\
    \ = 1, n do\n", "    local function get_neighbors(grid, i, j)\n        local neighbors\
    \ = {}\n        if i > 1 then\n            table.insert(neighbors, {i - 1, j})\n\
    \        end\n        if i < #grid then\n            table.insert(neighbors, {i\
    \ + 1, j})\n        end\n        if j > 1 then\n            table.insert(neighbors,\
    \ {i, j - 1})\n        end\n        if j < #grid then\n            table.insert(neighbors,\
    \ {i, j + 1})\n        end\n        return neighbors\n    end\n    local function\
    \ get_paths(grid, i, j, k)\n        if k == 0 then\n            return {{}}\n\
    \        end\n        local paths = {}\n        for _, neighbor in ipairs(get_neighbors(grid,\
    \ i, j)) do\n            local i, j = neighbor[1], neighbor[2]\n            for\
    \ _, path in ipairs(get_paths(grid, i, j, k - 1)) do\n                table.insert(path,\
    \ 1, grid[i][j])\n                table.insert(paths, path)\n            end\n\
    \        end\n        return paths\n    end\n    local function compare_paths(path1,\
    \ path2)\n        for i = 1, #path1 do\n            if path1[i] < path2[i] then\n\
    \                return true\n            elseif path1[i] > path2[i] then\n  \
    \              return false\n            end\n        end\n        return false\n\
    \    end\n    local min_path\n    for i = 1, #grid do\n        for j = 1, #grid\
    \ do\n            for _, path in ipairs(get_paths(grid, i, j, k)) do\n       \
    \         if not min_path or compare_paths(path, min_path) then\n            \
    \        min_path = path\n                end\n            end\n        end\n\
    \    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        for _, neighbor in ipairs(neighbors) do\n            local nx, ny\
    \ = neighbor[1], neighbor[2]\n            if not visited[nx][ny] then\n      \
    \          visited[nx][ny] = true\n                local new_path = dfs(nx, ny,\
    \ path, visited)\n                if new_path then\n                    return\
    \ new_path\n                end\n                visited[nx][ny] = false\n   \
    \         end\n        end\n    end\n    local min_path = nil\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            local path = dfs(i, j, {get(i, j)},\
    \ {})\n            if not min_path or compare(path, min_path) then\n         \
    \       min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > n or y < 1 or y > n then\n            return math.huge\n        end\n  \
    \      return grid[x][y]\n    end\n    local function cmp(a, b)\n        for i\
    \ = 1, #a do\n            if a[i] < b[i] then\n                return true\n \
    \           elseif a[i] > b[i] then\n                return false\n          \
    \  end\n        end\n        return false\n    end\n    local function dfs(x,\
    \ y, k, path)\n        if k == 0 then\n            return path\n        end\n\
    \        local min_path = nil\n        local min_val = math.huge\n        for\
    \ i = -1, 1 do\n            for j = -1, 1 do\n                if i ~= 0 or j ~=\
    \ 0 then\n                    local val = get(x + i, y + j)\n                \
    \    if val < min_val then\n                        min_val = val\n          \
    \              min_path = dfs(x + i, y + j, k - 1, {val, unpack(path)})\n    \
    \                elseif val == min_val then\n                        local path_\
    \ = dfs(x + i, y + j, k - 1, {val, unpack(path)})\n                        if\
    \ cmp(path_, min_path) then\n                            min_path = path_\n  \
    \                      end\n                    end\n                end\n   \
    \         end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    local min_val = math.huge\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local val = get(i, j)\n            if val < min_val then\n\
    \                min_val = val\n                min_path = dfs(i, j, k - 1, {val})\n\
    \            elseif val == min_val then\n                local path = dfs(i, j,\
    \ k - 1, {val})\n                if cmp(path, min_path) then\n               \
    \     min_path = path\n                end\n            end\n        end\n   \
    \ end\n    return min_path\nend", "    local n = #grid\n    local function get(x,\
    \ y)\n        if x < 1 or x > n or y < 1 or y > n then\n            return math.huge\n\
    \        end\n        return grid[x][y]\n    end\n    local function get_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        local min_value = math.huge\n        for dx = -1, 1\
    \ do\n            for dy = -1, 1 do\n                if dx ~= 0 or dy ~= 0 then\n\
    \                    local path = get_path(x + dx, y + dy, k - 1)\n          \
    \          if path then\n                        local value = get(x, y)\n   \
    \                     if value < min_value then\n                            min_value\
    \ = value\n                            min_path = path\n                     \
    \   end\n                    end\n                end\n            end\n     \
    \   end\n        if min_path then\n            table.insert(min_path, 1, min_value)\n\
    \            return min_path\n        end\n    end\n    local min_path = nil\n\
    \    local min_value = math.huge\n    for x = 1, n do\n        for y = 1, n do\n\
    \            local path = get_path(x, y, k)\n            if path then\n      \
    \          local value = get(x, y)\n                if value < min_value then\n\
    \                    min_value = value\n                    min_path = path\n\
    \                end\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, path, visited)\n        visited[x][y] =\
    \ true\n        path[#path + 1] = get(x, y)\n        if #path == k then\n    \
    \        if not min_path or compare(path, min_path) then\n                min_path\
    \ = path\n            end\n        else\n            for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n                local x, y = neighbor[1], neighbor[2]\n            \
    \    if not visited[x][y] then\n                    dfs(x, y, path, visited)\n\
    \                end\n            end\n        end\n        visited[x][y] = false\n\
    \        path[#path] = nil\n    end\n    local visited = {}\n    for i = 1, n\
    \ do\n        visited[i] = {}\n    end\n    local min_path\n    for i = 1, n do\n\
    \        for j = 1, n do\n            dfs(i, j, {}, visited)\n        end\n  \
    \  end\n    return min_path\nend", "    local n = #grid\n    local function get(i,\
    \ j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                local new_path = dfs(ni, nj, {unpack(path), get(ni,\
    \ nj)}, visited)\n                if not min_path or compare(new_path, min_path)\
    \ then\n                    min_path = new_path\n                end\n       \
    \         visited[ni][nj] = false\n            end\n        end\n        return\
    \ min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local visited = {}\n            for i = 1, n do\n \
    \               visited[i] = {}\n            end\n            visited[i][j] =\
    \ true\n            local new_path = dfs(i, j, {get(i, j)}, visited)\n", "   \
    \ local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n \
    \   end\n    local function set(x, y, v)\n        grid[x][y] = v\n    end\n  \
    \  local function get_neighbors(x, y)\n        local res = {}\n        if x >\
    \ 1 then\n            res[#res + 1] = {x - 1, y}\n        end\n        if x <\
    \ n then\n            res[#res + 1] = {x + 1, y}\n        end\n        if y >\
    \ 1 then\n            res[#res + 1] = {x, y - 1}\n        end\n        if y <\
    \ n then\n            res[#res + 1] = {x, y + 1}\n        end\n        return\
    \ res\n    end\n    local function get_path(x, y, k)\n        if k == 0 then\n\
    \            return {}\n        end\n        local res = {}\n        local v =\
    \ get(x, y)\n        for _, n in ipairs(get_neighbors(x, y)) do\n            local\
    \ nx, ny = n[1], n[2]\n            local nv = get(nx, ny)\n            if nv <\
    \ v then\n                local path = get_path(nx, ny, k - 1)\n             \
    \   if #path > 0 then\n                    res[#res + 1] = {nv, path}\n      \
    \          end\n            end\n        end\n        table.sort(res, function(a,\
    \ b)\n            return a[1] < b[1]\n        end)\n        if #res > 0 then\n\
    \            return {v, res[1][2]}\n        end\n        return {}\n    end\n\
    \    local res = {}\n    for i = 1, n do\n        for j = 1, n do\n          \
    \  local path = get_path(i, j, k)\n            if #path > 0 then\n           \
    \     res[#res + 1] = path\n            end\n        end\n    end\n    table.sort(res,\
    \ function(a, b)\n        for i = 1, k do\n            if a[i] < b[i] then\n \
    \               return true", "    local N = #grid\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        local path = {}\n        local function\
    \ dfs(i, j, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, neighbor in ipairs(get_neighbors(i, j)) do\n\
    \                local ni, nj = neighbor[1], neighbor[2]\n                if not\
    \ visited[ni][nj] then\n                    visited[ni][nj] = true\n         \
    \           path[#path + 1] = grid[ni][nj]\n                    if dfs(ni, nj,\
    \ k - 1) then\n                        return true\n                    end\n\
    \                    path[#path] = nil\n                    visited[ni][nj] =\
    \ false\n                end\n            end\n            return false\n    \
    \    end\n        dfs(i, j, k)\n        return path\n    end\n    local visited\
    \ = {}\n    for i = 1, N do\n        visited[i] = {}\n    end\n    local min_path\n\
    \    for i = 1, N do\n        for j = 1, N do\n            visited[i][j] = true\n\
    \            local path = {grid[i][j]}\n            path[#path + 1] = get_path(i,\
    \ j, k - 1)\n            if not min_path or path < min_path then\n           \
    \     min_path = path\n            end\n            visited[i][j] = false\n  \
    \      end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        return grid[i][j]\n    end\n    local function set(i,\
    \ j, v)\n        grid[i][j] = v\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j)\n        local path = {}\n        local function go(i,\
    \ j)\n            path[#path + 1] = get(i, j)\n            if #path == k then\n\
    \                return\n            end\n            local neighbors = get_neighbors(i,\
    \ j)\n            table.sort(neighbors, function(a, b)\n                return\
    \ get(a[1], a[2]) < get(b[1], b[2])\n            end)\n            for _, neighbor\
    \ in ipairs(neighbors) do\n                go(neighbor[1], neighbor[2])\n    \
    \            if #path == k then\n                    return\n                end\n\
    \            end\n            path[#path] = nil\n        end\n        go(i, j)\n\
    \        return path\n    end\n    local function get_min_path()\n        local\
    \ min_path = {}\n        for i = 1, n do\n            for j = 1, n do\n      \
    \          local path = get_path(i, j)\n                if #min_path == 0 or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    return get_min_path()\n\
    end", "    local n = #grid\n    local m = {}\n    for i = 1, n do\n        m[i]\
    \ = {}\n        for j = 1, n do\n            m[i][j] = {}\n        end\n    end\n\
    \    for i = 1, n do\n        for j = 1, n do\n            m[i][j][1] = {grid[i][j]}\n\
    \        end\n    end\n    for l = 2, k do\n        for i = 1, n do\n        \
    \    for j = 1, n do\n                local t = {}\n                if i > 1 then\n\
    \                    table.insert(t, m[i - 1][j][l - 1])\n                end\n\
    \                if i < n then\n                    table.insert(t, m[i + 1][j][l\
    \ - 1])\n                end\n                if j > 1 then\n                \
    \    table.insert(t, m[i][j - 1][l - 1])\n                end\n              \
    \  if j < n then\n                    table.insert(t, m[i][j + 1][l - 1])\n  \
    \              end\n                table.sort(t, function(a, b)\n           \
    \         for i = 1, l do\n                        if a[i] < b[i] then\n     \
    \                       return true\n                        elseif a[i] > b[i]\
    \ then\n                            return false\n                        end\n\
    \                    end\n                    return false\n                end)\n\
    \                m[i][j][l] = t[1]\n            end\n        end\n    end\n  \
    \  return m[1][1][k]\nend", "    local n = #grid\n    local function get(x, y)\n\
    \        return grid[x][y]\n    end\n    local function set(x, y, v)\n       \
    \ grid[x][y] = v\n    end\n    local function get_neighbors(x, y)\n        local\
    \ neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors + 1]\
    \ = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_min_path(x, y, k)\n        if k == 0 then\n            return {get(x,\
    \ y)}\n        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_min_path(neighbor[1], neighbor[2], k -\
    \ 1)\n            if min_path == nil or path < min_path then\n               \
    \ min_path = path\n            end\n        end\n        return {get(x, y)} ..\
    \ min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local path = get_min_path(i, j, k)\n            if\
    \ min_path == nil or path < min_path then\n                min_path = path\n \
    \           end\n        end\n    end\n    return min_path\nend", "    local n\
    \ = #grid\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(x, y, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[x][y]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(x, y)) do\n                for _, path in ipairs(get_paths(neighbor[1],\
    \ neighbor[2], k - 1)) do\n                    paths[#paths + 1] = {grid[x][y]}\n\
    \                    for _, value in ipairs(path) do\n                       \
    \ paths[#paths][#paths[#paths] + 1] = value\n                    end\n       \
    \         end\n            end\n        end\n        return paths\n    end\n \
    \   local min_path = {}\n    for i = 1, n do\n        for j = 1, n do\n      \
    \      for _, path in ipairs(get_paths(i, j, k)) do\n                if #min_path\
    \ == 0 or path < min_path then\n                    min_path = path\n        \
    \        end\n            end\n        end\n    end\n    return min_path\nend",
  "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function is_valid(x, y)\n        return x >= 1 and x <= n\
    \ and y >= 1 and y <= n\n    end\n    local function get_neighbors(x, y)\n   \
    \     local neighbors = {}\n        for dx = -1, 1 do\n            for dy = -1,\
    \ 1 do\n                if dx ~= 0 or dy ~= 0 then\n                    local\
    \ nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny) then\n    \
    \                    table.insert(neighbors, {nx, ny})\n                    end\n\
    \                end\n            end\n        end\n        return neighbors\n\
    \    end\n    local function get_path(x, y, k)\n        if k == 0 then\n     \
    \       return {}\n        end\n        local min_path = nil\n        for _, neighbor\
    \ in ipairs(get_neighbors(x, y)) do\n            local nx, ny = neighbor[1], neighbor[2]\n\
    \            local path = get_path(nx, ny, k - 1)\n            if path then\n\
    \                table.insert(path, 1, get(x, y))\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n        return min_path\n    end\n    local\
    \ min_path = nil\n    for x = 1, n do\n        for y = 1, n do\n            local\
    \ path = get_path(x, y, k)\n            if path then\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get_neighbors(i, j)\n        local neighbors\
    \ = {}\n        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1,\
    \ j}\n        end\n        if i < n then\n            neighbors[#neighbors + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[i][j]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(i, j)) do\n                local i1, j1 = neighbor[1],\
    \ neighbor[2]\n                for _, path in ipairs(get_paths(i1, j1, k - 1))\
    \ do\n                    paths[#paths + 1] = {grid[i][j]}\n                 \
    \   for _, value in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = value\n                    end\n                end\n            end\n\
    \        end\n        return paths\n    end\n    local min_path\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            local paths = get_paths(i, j, k)\n\
    \            for _, path in ipairs(paths) do\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local m = #grid[1]\n    local function get(x, y)\n  \
    \      return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n  \
    \      local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < m then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(x, y, k)\n        if k == 0 then\n            return {{}}\n\
    \        end\n        local paths = {}\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local x, y = neighbor[1], neighbor[2]\n            for _,\
    \ path in ipairs(get_paths(x, y, k - 1)) do\n                paths[#paths + 1]\
    \ = {get(x, y)}\n                for _, value in ipairs(path) do\n           \
    \         paths[#paths][#paths[#paths] + 1] = value\n                end\n   \
    \         end\n        end\n        return paths\n    end\n    local function\
    \ compare(a, b)\n        for i = 1, #a do\n            if a[i] < b[i] then\n \
    \               return true\n            elseif a[i] > b[i] then\n           \
    \     return false\n            end\n        end\n        return false\n    end\n\
    \    local min_path = {}\n    for i = 1, n do\n        for j = 1, m do\n     \
    \       for _, path in ipairs(get_paths(i, j, k)) do\n                if #min_path\
    \ == 0 or compare(path, min_path) then\n                    min_path = path\n\
    \                end\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get_neighbors(i, j)\n        local\
    \ res = {}\n        if i > 1 then\n            res[#res + 1] = {i - 1, j}\n  \
    \      end\n        if i < n then\n            res[#res + 1] = {i + 1, j}\n  \
    \      end\n        if j > 1 then\n            res[#res + 1] = {i, j - 1}\n  \
    \      end\n        if j < n then\n            res[#res + 1] = {i, j + 1}\n  \
    \      end\n        return res\n    end\n    local function get_path(i, j, k)\n\
    \        local res = {}\n        if k == 0 then\n            return res\n    \
    \    end\n        local neighbors = get_neighbors(i, j)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            path[#path + 1] = grid[i][j]\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local res\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = grid[i][j]\n                if not res or path < res then\n           \
    \         res = path\n                end\n            end\n        end\n    end\n\
    \    return res\nend", "    local N = #grid\n    local function get(x, y)\n  \
    \      return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n  \
    \      local t = {}\n        if x > 1 then\n            t[#t + 1] = {x - 1, y}\n\
    \        end\n        if x < N then\n            t[#t + 1] = {x + 1, y}\n    \
    \    end\n        if y > 1 then\n            t[#t + 1] = {x, y - 1}\n        end\n\
    \        if y < N then\n            t[#t + 1] = {x, y + 1}\n        end\n    \
    \    return t\n    end\n    local function get_path(x, y, k)\n        if k ==\
    \ 0 then\n            return {}\n        end\n        local min_path = nil\n \
    \       for _, neighbor in ipairs(get_neighbors(x, y)) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path ~= nil then\n\
    \                path[#path + 1] = get(x, y)\n                if min_path == nil\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n        return min_path\n    end\n    local\
    \ min_path = nil\n    for i = 1, N do\n        for j = 1, N do\n            local\
    \ path = get_path(i, j, k)\n            if path ~= nil then\n                path[#path\
    \ + 1] = get(i, j)\n                if min_path == nil or path < min_path then\n\
    \                    min_path = path\n                end\n            end\n \
    \       end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        return grid[i][j]\n    end\n    local function set(i,\
    \ j, v)\n        grid[i][j] = v\n    end\n    local function get_neighbors(i,\
    \ j)\n        local res = {}\n        if i > 1 then\n            res[#res + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            res[#res + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            res[#res + 1]\
    \ = {i, j - 1}\n        end\n        if j < n then\n            res[#res + 1]\
    \ = {i, j + 1}\n        end\n        return res\n    end\n    local function get_min_neighbor(i,\
    \ j)\n        local min_i, min_j\n        local min_v = math.huge\n        for\
    \ _, n in ipairs(get_neighbors(i, j)) do\n            local v = get(n[1], n[2])\n\
    \            if v < min_v then\n                min_v = v\n                min_i,\
    \ min_j = n[1], n[2]\n            end\n        end\n        return min_i, min_j\n\
    \    end\n    local function get_path(i, j)\n        local res = {}\n        while\
    \ k > 0 do\n            res[#res + 1] = get(i, j)\n            i, j = get_min_neighbor(i,\
    \ j)\n            k = k - 1\n        end\n        return res\n    end\n    local\
    \ min_i, min_j\n    local min_v = math.huge\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local v = get(i, j)\n            if v < min_v then\n\
    \                min_v = v\n                min_i, min_j = i, j\n            end\n\
    \        end\n    end\n    return get_path(min_i, min_j)\nend", "    local n =\
    \ #grid\n    local function get(i, j)\n        return grid[i][j]\n    end\n  \
    \  local function get_neighbors(i, j)\n        local neighbors = {}\n        if\
    \ i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n        end\n\
    \        if i < n then\n            neighbors[#neighbors + 1] = {i + 1, j}\n \
    \       end\n        if j > 1 then\n            neighbors[#neighbors + 1] = {i,\
    \ j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = get(i, j)\n     \
    \           if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = get(i, j)\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ n = #grid\n    local function get(x, y)\n        return grid[x][y]\n    end\n\
    \    local function get_neighbors(x, y)\n        local neighbors = {}\n      \
    \  if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n       \
    \ end\n        if x < n then\n            neighbors[#neighbors + 1] = {x + 1,\
    \ y}\n        end\n        if y > 1 then\n            neighbors[#neighbors + 1]\
    \ = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local min_path = nil\n        for _,\
    \ neighbor in ipairs(get_neighbors(x, y)) do\n            local new_path = dfs(neighbor[1],\
    \ neighbor[2], k - 1, path)\n            if not min_path or compare(new_path,\
    \ min_path) then\n                min_path = new_path\n            end\n     \
    \   end\n        return min_path\n    end\n    local min_path = nil\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            local path = dfs(i, j, k, {get(i,\
    \ j)})\n            if not min_path or compare(path, min_path) then\n        \
    \        min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > n or y < 1 or y > n then\n            return math.huge\n        end\n  \
    \      return grid[x][y]\n    end\n    local function get_path(x, y, k)\n    \
    \    if k == 0 then\n            return {get(x, y)}\n        end\n        local\
    \ path = {get(x, y)}\n        local min_path = math.huge\n        for _, d in\
    \ ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local p = get_path(x\
    \ + d[1], y + d[2], k - 1)\n            if p < min_path then\n               \
    \ min_path = p\n            end\n        end\n        for _, v in ipairs(min_path)\
    \ do\n            table.insert(path, v)\n        end\n        return path\n  \
    \  end\n    local min_path = math.huge\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local p = get_path(i, j, k - 1)\n            if p < min_path\
    \ then\n                min_path = p\n            end\n        end\n    end\n\
    \    return min_path\nend", "    local function get_neighbors(x, y)\n        local\
    \ neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors + 1]\
    \ = {x - 1, y}\n        end\n        if x < #grid then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < #grid then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        local path = {}\n        local function\
    \ dfs(x, y, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, n in ipairs(get_neighbors(x, y)) do\n       \
    \         local nx, ny = n[1], n[2]\n                if not visited[nx][ny] then\n\
    \                    visited[nx][ny] = true\n                    path[#path +\
    \ 1] = grid[nx][ny]\n                    if dfs(nx, ny, k - 1) then\n        \
    \                return true\n                    end\n                    visited[nx][ny]\
    \ = false\n                    path[#path] = nil\n                end\n      \
    \      end\n            return false\n        end\n        dfs(x, y, k)\n    \
    \    return path\n    end\n    local visited = {}\n    for i = 1, #grid do\n \
    \       visited[i] = {}\n    end\n    local min_path = {}\n    for i = 1, #grid\
    \ do\n        for j = 1, #grid do\n            local path = get_path(i, j, k)\n\
    \            if #path > 0 then\n                if #min_path == 0 or path < min_path\
    \ then\n                    min_path = path\n                end\n           \
    \ end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local dp = {}\n    for i = 1, n do\n        dp[i]\
    \ = {}\n        for j = 1, m do\n            dp[i][j] = {}\n        end\n    end\n\
    \    for i = 1, n do\n        for j = 1, m do\n            dp[i][j][1] = {grid[i][j]}\n\
    \        end\n    end\n    for i = 1, n do\n        for j = 1, m do\n        \
    \    for l = 2, k do\n                local min = nil\n                if i >\
    \ 1 then\n                    local tmp = dp[i - 1][j][l - 1]\n              \
    \      if not min or tmp < min then\n                        min = tmp\n     \
    \               end\n                end\n                if i < n then\n    \
    \                local tmp = dp[i + 1][j][l - 1]\n                    if not min\
    \ or tmp < min then\n                        min = tmp\n                    end\n\
    \                end\n                if j > 1 then\n                    local\
    \ tmp = dp[i][j - 1][l - 1]\n                    if not min or tmp < min then\n\
    \                        min = tmp\n                    end\n                end\n\
    \                if j < m then\n                    local tmp = dp[i][j + 1][l\
    \ - 1]\n                    if not min or tmp < min then\n                   \
    \     min = tmp\n                    end\n                end\n              \
    \  if min then\n                    dp[i][j][l] = {grid[i][j]}\n             \
    \       for _, v in ipairs(min) do\n                        table.insert(dp[i][j][l],\
    \ v)\n                    end\n                end\n            end\n        end\n\
    \    end\n    local min = nil\n    for i = 1, n do\n        for j = 1, m do\n\
    \            local tmp = dp[i][j][k]\n            if not min or tmp < min then\n\
    \                min = tmp\n            end\n        end\n    end\n    return\
    \ min\nend", "    local N = #grid\n    local function get(x, y)\n        return\
    \ grid[x][y]\n    end\n    local function set(x, y, v)\n        grid[x][y] = v\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < N then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < N then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(x, y)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            path[#path + 1] = get(x, y)\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, N do\n        for j = 1, N do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = get(i, j)\n                if not min_path or path < min_path then\n  \
    \                  min_path = path\n                end\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local N = #grid\n    local\
    \ function get_neighbors(i, j)\n        local ret = {}\n        if i > 1 then\n\
    \            table.insert(ret, {i - 1, j})\n        end\n        if i < N then\n\
    \            table.insert(ret, {i + 1, j})\n        end\n        if j > 1 then\n\
    \            table.insert(ret, {i, j - 1})\n        end\n        if j < N then\n\
    \            table.insert(ret, {i, j + 1})\n        end\n        return ret\n\
    \    end\n    local function get_path(i, j, k)\n        if k == 0 then\n     \
    \       return {}\n        end\n        local min_path = {}\n        for _, neighbor\
    \ in ipairs(get_neighbors(i, j)) do\n            local path = get_path(neighbor[1],\
    \ neighbor[2], k - 1)\n            table.insert(path, 1, grid[i][j])\n       \
    \     if #min_path == 0 or path < min_path then\n                min_path = path\n\
    \            end\n        end\n        return min_path\n    end\n    return get_path(1,\
    \ 1, k)\nend", "    local n = #grid\n    local function get_neighbors(i, j)\n\
    \        local res = {}\n        if i > 1 then\n            res[#res + 1] = {i\
    \ - 1, j}\n        end\n        if i < n then\n            res[#res + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            res[#res + 1] = {i,\
    \ j - 1}\n        end\n        if j < n then\n            res[#res + 1] = {i,\
    \ j + 1}\n        end\n        return res\n    end\n    local function dfs(i,\
    \ j, k, path)\n        if k == 0 then\n            return path\n        end\n\
    \        local res = {}\n        for _, neighbor in ipairs(get_neighbors(i, j))\
    \ do\n            local new_path = dfs(neighbor[1], neighbor[2], k - 1, path ..\
    \ grid[neighbor[1]][neighbor[2]])\n            if #res == 0 or new_path < res\
    \ then\n                res = new_path\n            end\n        end\n       \
    \ return res\n    end\n    local res = ''\n    for i = 1, n do\n        for j\
    \ = 1, n do\n            local new_path = dfs(i, j, k, grid[i][j])\n         \
    \   if #res == 0 or new_path < res then\n                res = new_path\n    \
    \        end\n        end\n    end\n    local res_list = {}\n    for i = 1, #res\
    \ do\n        res_list[#res_list + 1] = tonumber(res:sub(i, i))\n    end\n   \
    \ return res_list\nend", "    local n = #grid\n    local function get(i, j)\n\
    \        return grid[i][j]\n    end\n    local function get_neighbors(i, j)\n\
    \        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        local path = {}\n        local function\
    \ dfs(i, j, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, neighbor in ipairs(get_neighbors(i, j)) do\n\
    \                local ni, nj = neighbor[1], neighbor[2]\n                if not\
    \ path[ni] or not path[ni][nj] then\n                    path[ni] = path[ni] or\
    \ {}\n                    path[ni][nj] = true\n                    if dfs(ni,\
    \ nj, k - 1) then\n                        return true\n                    end\n\
    \                    path[ni][nj] = nil\n                end\n            end\n\
    \            return false\n        end\n        dfs(i, j, k)\n        return path\n\
    \    end\n    local function get_path_value(path)\n        local value = {}\n\
    \        for i = 1, n do\n            for j = 1, n do\n                if path[i]\
    \ and path[i][j] then\n                    value[#value + 1] = get(i, j)\n   \
    \             end\n            end\n        end\n        return value\n    end\n\
    \    local function get_path_value_cmp(path_value)\n        return function(a,\
    \ b)\n            for i = 1, #path_value do\n                if a[path_value[i]]\
    \ ~= b[path_value[i]] then\n                    return a[path_", "    local n\
    \ = #grid\n    local function get(i, j)\n        return grid[i][j]\n    end\n\
    \    local function get_neighbors(i, j)\n        local neighbors = {}\n      \
    \  if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n       \
    \ end\n        if i < n then\n            neighbors[#neighbors + 1] = {i + 1,\
    \ j}\n        end\n        if j > 1 then\n            neighbors[#neighbors + 1]\
    \ = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                local new_path = dfs(ni, nj, path .. get(ni, nj), visited)\n\
    \                if not min_path or compare(new_path, min_path) then\n       \
    \             min_path = new_path\n                end\n                visited[ni][nj]\
    \ = false\n            end\n        end\n        return min_path\n    end\n  \
    \  local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n      \
    \      local visited = {}\n            for i = 1, n do\n                visited[i]\
    \ = {}\n            end\n            visited[i][j] = true\n            local new_path\
    \ = dfs(i, j, get(i, j), visited)\n            if not min_path or", "    local\
    \ n = #grid\n    local function get_neighbors(i, j)\n        local neighbors =\
    \ {}\n        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n\
    \        end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            if not min_path or compare(path, min_path) then\n               \
    \ min_path = path\n            end\n            return\n        end\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                dfs(ni, nj, {unpack(path), grid[ni][nj]}, visited)\n\
    \                visited[ni][nj] = false\n            end\n        end\n    end\n\
    \    local min_path\n    for i = 1, n do\n        for j = 1, n do\n          \
    \  dfs(i, j, {grid[i][j]}, {})\n        end\n    end\n    return min_path\nend",
  "    local n = #grid\n    local function get(x, y)\n        if x < 1 or x > n or\
    \ y < 1 or y > n then\n            return math.huge\n        end\n        return\
    \ grid[x][y]\n    end\n    local function less(a, b)\n        for i = 1, k do\n\
    \            if a[i] < b[i] then\n                return true\n            elseif\
    \ a[i] > b[i] then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function copy(a)\n        local b =\
    \ {}\n        for i = 1, k do\n            b[i] = a[i]\n        end\n        return\
    \ b\n    end\n    local function add(a, x)\n        local b = copy(a)\n      \
    \  b[#b + 1] = x\n        return b\n    end\n    local function dfs(x, y, k, path)\n\
    \        if k == 0 then\n            return path\n        end\n        local min\
    \ = math.huge\n        local minPath = nil\n        for i = -1, 1 do\n       \
    \     for j = -1, 1 do\n                if i ~= 0 or j ~= 0 then\n           \
    \         local nx = x + i\n                    local ny = y + j\n           \
    \         local npath = add(path, get(nx, ny))\n                    if less(npath,\
    \ min) then\n                        min = npath\n                        minPath\
    \ = dfs(nx, ny, k - 1, npath)\n                    end\n                end\n\
    \            end\n        end\n        return minPath\n    end\n    local min\
    \ = math.huge\n    local minPath = nil\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local path = dfs(i, j, k, {get(i, j)})\n            if less(path,\
    \ min) then\n                min = path\n                minPath = path\n    \
    \        end\n        end\n    end\n    return minPath\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if x\
    \ < n then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if y > 1 then\n            neighbors[#neighbors + 1] = {x, y - 1}\n \
    \       end\n        if y < n then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function compare(a,\
    \ b)\n        for i = 1, k do\n            if a[i] < b[i] then\n             \
    \   return true\n            elseif a[i] > b[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end\n    local function\
    \ dfs(x, y, path, visited)\n        if #path == k then\n            return path\n\
    \        end\n        local neighbors = get_neighbors(x, y)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local nx,\
    \ ny = neighbor[1], neighbor[2]\n            if not visited[nx][ny] then\n   \
    \             visited[nx][ny] = true\n                local new_path = dfs(nx,\
    \ ny, {unpack(path), get(nx, ny)}, visited)\n                if not min_path or\
    \ compare(new_path, min_path) then\n                    min_path = new_path\n\
    \                end\n                visited[nx][ny] = false\n            end\n\
    \        end\n        return min_path\n    end\n    local min_path = nil\n   \
    \ for i = 1, n do\n        for j = 1, n do\n            local visited = {}\n \
    \           for i = 1, n do\n                visited[i] = {}\n            end\n\
    \            visited[i][j] = true\n            local new_path = dfs(i, j", " \
    \   local n = #grid\n    local function get(i, j)\n        if i < 1 or i > n or\
    \ j < 1 or j > n then\n            return math.huge\n        end\n        return\
    \ grid[i][j]\n    end\n    local function get_path(i, j, k)\n        if k == 0\
    \ then\n            return {}\n        end\n        local min_path = nil\n   \
    \     local min_value = math.huge\n        for di = -1, 1 do\n            for\
    \ dj = -1, 1 do\n                if di ~= 0 or dj ~= 0 then\n                \
    \    local path = get_path(i + di, j + dj, k - 1)\n                    if path\
    \ then\n                        local value = get(i, j)\n                    \
    \    table.insert(path, 1, value)\n                        if value < min_value\
    \ or (value == min_value and path < min_path) then\n                         \
    \   min_path = path\n                            min_value = value\n         \
    \               end\n                    end\n                end\n          \
    \  end\n        end\n        return min_path\n    end\n    return get_path(1,\
    \ 1, k)\nend", "    local n = #grid\n    local function get(x, y)\n        return\
    \ grid[x][y]\n    end\n    local function set(x, y, v)\n        grid[x][y] = v\n\
    \    end\n    local function cmp(x1, y1, x2, y2)\n        return get(x1, y1) <\
    \ get(x2, y2)\n    end\n    local function swap(x1, y1, x2, y2)\n        local\
    \ tmp = get(x1, y1)\n        set(x1, y1, get(x2, y2))\n        set(x2, y2, tmp)\n\
    \    end\n    local function siftDown(x, y, n)\n        local left = 2 * x\n \
    \       local right = 2 * x + 1\n        local largest = x\n        if left <=\
    \ n and cmp(left, y, largest, y) then\n            largest = left\n        end\n\
    \        if right <= n and cmp(right, y, largest, y) then\n            largest\
    \ = right\n        end\n        if largest ~= x then\n            swap(x, y, largest,\
    \ y)\n            siftDown(largest, y, n)\n        end\n    end\n    local function\
    \ buildHeap(y)\n        for i = math.floor(n / 2), 1, -1 do\n            siftDown(i,\
    \ y, n)\n        end\n    end\n    local function heapSort(y)\n        buildHeap(y)\n\
    \        for i = n, 2, -1 do\n            swap(1, y, i, y)\n            siftDown(1,\
    \ y, i - 1)\n        end\n    end\n    for i = 1, n do\n        heapSort(i)\n\
    \    end\n    local function getMin(x, y)\n        local min = get(x, y)\n   \
    \     if x > 1 and cmp(x - 1, y, x, y) then\n            min = get(x - 1, y)\n\
    \        end\n        if x < n and cmp(x + 1, y, x, y) then\n            min =\
    \ get(x + 1, y)\n        end\n       ", "    local function get_min_path(grid,\
    \ k, i, j, visited)\n        if k == 0 then\n            return {}, 0\n      \
    \  end\n        local min_path, min_sum = {}, math.huge\n        local function\
    \ get_neighbors(i, j)\n            local neighbors = {}\n            if i > 1\
    \ and not visited[i - 1][j] then\n                neighbors[#neighbors + 1] =\
    \ {i - 1, j}\n            end\n            if i < #grid and not visited[i + 1][j]\
    \ then\n                neighbors[#neighbors + 1] = {i + 1, j}\n            end\n\
    \            if j > 1 and not visited[i][j - 1] then\n                neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n            end\n            if j < #grid and not visited[i][j\
    \ + 1] then\n                neighbors[#neighbors + 1] = {i, j + 1}\n        \
    \    end\n            return neighbors\n        end\n        for _, neighbor in\
    \ ipairs(get_neighbors(i, j)) do\n            local path, sum = get_min_path(grid,\
    \ k - 1, neighbor[1], neighbor[2], visited)\n            if sum < min_sum then\n\
    \                min_path, min_sum = path, sum\n            end\n        end\n\
    \        min_path[#min_path + 1] = grid[i][j]\n        min_sum = min_sum + grid[i][j]\n\
    \        return min_path, min_sum\n    end\n    local visited = {}\n    for i\
    \ = 1, #grid do\n        visited[i] = {}\n        for j = 1, #grid do\n      \
    \      visited[i][j] = false\n        end\n    end\n    local min_path, min_sum\
    \ = {}, math.huge\n    for i = 1, #grid do\n        for j = 1, #grid do\n    \
    \        local path, sum = get_min_path(grid, k, i, j, visited)\n            if\
    \ sum < min_sum then\n                min_path, min_sum = path, sum\n        \
    \    end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ set(x, y, v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_min_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local neighbor_x, neighbor_y = neighbor[1], neighbor[2]\n\
    \            local path = get_min_path(neighbor_x, neighbor_y, k - 1)\n      \
    \      if path then\n                local value = get(neighbor_x, neighbor_y)\n\
    \                path[#path + 1] = value\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_min_path(i, j, k)\n            if path then\n                local value\
    \ = get(i, j)\n                path[#path + 1] = value\n                if not\
    \ min_path or path < min_path then\n                    min_path = path\n    \
    \            end\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > n or y < 1 or y > n then\n            return math.huge\n        end\n  \
    \      return grid[x][y]\n    end\n    local function get_min(x, y, k)\n     \
    \   if k == 0 then\n            return {}\n        end\n        local min = math.huge\n\
    \        local min_path = {}\n        for i = -1, 1 do\n            for j = -1,\
    \ 1 do\n                if i ~= 0 or j ~= 0 then\n                    local path\
    \ = get_min(x + i, y + j, k - 1)\n                    if path[1] < min then\n\
    \                        min = path[1]\n                        min_path = {min}\n\
    \                        for _, v in ipairs(path) do\n                       \
    \     min_path[#min_path + 1] = v\n                        end\n             \
    \       end\n                end\n            end\n        end\n        return\
    \ min_path\n    end\n    local min = math.huge\n    local min_path = {}\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            local path = get_min(i, j,\
    \ k)\n            if path[1] < min then\n                min = path[1]\n     \
    \           min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local N = #grid\n    local function get_neighbors(i, j)\n\
    \        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        local path = {}\n        local function\
    \ dfs(i, j, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, neighbor in ipairs(get_neighbors(i, j)) do\n\
    \                local ni, nj = neighbor[1], neighbor[2]\n                if not\
    \ path[ni] or not path[ni][nj] then\n                    path[ni] = path[ni] or\
    \ {}\n                    path[ni][nj] = true\n                    if dfs(ni,\
    \ nj, k - 1) then\n                        return true\n                    end\n\
    \                    path[ni][nj] = nil\n                end\n            end\n\
    \            return false\n        end\n        if dfs(i, j, k) then\n       \
    \     local result = {}\n            for i, row in ipairs(path) do\n         \
    \       for j, _ in pairs(row) do\n                    result[#result + 1] = grid[i][j]\n\
    \                end\n            end\n            return result\n        end\n\
    \    end\n    local result\n    for i = 1, N do\n        for j = 1, N do\n   \
    \         local path = get_path(i, j, k)\n            if path then\n         \
    \       if not result or path < result then\n                    result = path\n\
    \                end\n            end\n        end\n    end\n    return result\n\
    end", "    local n = #grid\n    local function get_neighbors(i, j)\n        local\
    \ res = {}\n        if i > 1 then\n            res[#res + 1] = {i - 1, j}\n  \
    \      end\n        if i < n then\n            res[#res + 1] = {i + 1, j}\n  \
    \      end\n        if j > 1 then\n            res[#res + 1] = {i, j - 1}\n  \
    \      end\n        if j < n then\n            res[#res + 1] = {i, j + 1}\n  \
    \      end\n        return res\n    end\n    local function get_path(i, j, k)\n\
    \        if k == 0 then\n            return {}\n        end\n        local res\
    \ = {}\n        for _, n in ipairs(get_neighbors(i, j)) do\n            local\
    \ path = get_path(n[1], n[2], k - 1)\n            if #path > 0 then\n        \
    \        res[#res + 1] = {grid[i][j], path}\n            end\n        end\n  \
    \      table.sort(res, function(a, b)\n            return a[1] < b[1]\n      \
    \  end)\n        return res[1] and res[1][2] or {}\n    end\n    local res = {}\n\
    \    for i = 1, n do\n        for j = 1, n do\n            local path = get_path(i,\
    \ j, k)\n            if #path > 0 then\n                res[#res + 1] = {grid[i][j],\
    \ path}\n            end\n        end\n    end\n    table.sort(res, function(a,\
    \ b)\n        local i = 1\n        while i <= #a[2] and i <= #b[2] do\n      \
    \      if a[2][i] < b[2][i] then\n                return true\n            elseif\
    \ a[2][i] > b[2][i] then\n                return false\n            end\n    \
    \        i = i + 1\n        end\n        return #a[2] < #b[2]\n    end)\n    return\
    \ {res[1][1], unpack(res[1][2])}\nend", "    local n = #grid\n    local function\
    \ isValid(x, y)\n        return x >= 1 and x <= n and y >= 1 and y <= n\n    end\n\
    \    local function getNeighbors(x, y)\n        local neighbors = {}\n       \
    \ if isValid(x - 1, y) then\n            neighbors[#neighbors + 1] = {x - 1, y}\n\
    \        end\n        if isValid(x + 1, y) then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if isValid(x, y - 1) then\n        \
    \    neighbors[#neighbors + 1] = {x, y - 1}\n        end\n        if isValid(x,\
    \ y + 1) then\n            neighbors[#neighbors + 1] = {x, y + 1}\n        end\n\
    \        return neighbors\n    end\n    local function getPaths(x, y, k)\n   \
    \     if k == 0 then\n            return {{}}\n        end\n        local paths\
    \ = {}\n        for _, neighbor in ipairs(getNeighbors(x, y)) do\n           \
    \ local x1, y1 = neighbor[1], neighbor[2]\n            for _, path in ipairs(getPaths(x1,\
    \ y1, k - 1)) do\n                path[#path + 1] = grid[x][y]\n             \
    \   paths[#paths + 1] = path\n            end\n        end\n        return paths\n\
    \    end\n    local function compare(path1, path2)\n        for i = 1, #path1\
    \ do\n            if path1[i] < path2[i] then\n                return true\n \
    \           elseif path1[i] > path2[i] then\n                return false\n  \
    \          end\n        end\n        return false\n    end\n    local minPath\
    \ = {}\n    for i = 1, n do\n        for j = 1, n do\n            for _, path\
    \ in ipairs(getPaths(i, j, k)) do\n                if #minPath == 0 or compare(path,\
    \ minPath) then\n                    minPath = path\n                end\n   \
    \         end\n        end\n    end\n    return minPath\nend", "    local n =\
    \ #grid\n    local function get(x, y)\n        if x < 1 or x > n or y < 1 or y\
    \ > n then\n            return math.huge\n        end\n        return grid[x][y]\n\
    \    end\n    local function less(a, b)\n        for i = 1, k do\n           \
    \ if a[i] < b[i] then\n                return true\n            elseif a[i] >\
    \ b[i] then\n                return false\n            end\n        end\n    \
    \    return false\n    end\n    local function get_path(x, y, k)\n        if k\
    \ == 0 then\n            return {}\n        end\n        local paths = {}\n  \
    \      for i = -1, 1 do\n            for j = -1, 1 do\n                if i ~=\
    \ 0 or j ~= 0 then\n                    local path = get_path(x + i, y + j, k\
    \ - 1)\n                    if path then\n                        table.insert(path,\
    \ get(x, y))\n                        table.insert(paths, path)\n            \
    \        end\n                end\n            end\n        end\n        if #paths\
    \ == 0 then\n            return nil\n        end\n        table.sort(paths, less)\n\
    \        return paths[1]\n    end\n    local path = get_path(1, 1, k)\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            local p = get_path(i, j, k)\n\
    \            if p and less(p, path) then\n                path = p\n         \
    \   end\n        end\n    end\n    return path\nend", "    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < #grid then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < #grid then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[i][j]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(i, j)) do\n                local i_neighbor,\
    \ j_neighbor = neighbor[1], neighbor[2]\n                for _, path in ipairs(get_paths(i_neighbor,\
    \ j_neighbor, k - 1)) do\n                    paths[#paths + 1] = {grid[i][j]}\n\
    \                    for _, value in ipairs(path) do\n                       \
    \ paths[#paths][#paths[#paths] + 1] = value\n                    end\n       \
    \         end\n            end\n        end\n        return paths\n    end\n \
    \   local min_path = nil\n    for i = 1, #grid do\n        for j = 1, #grid do\n\
    \            for _, path in ipairs(get_paths(i, j, k)) do\n                if\
    \ min_path == nil or path < min_path then\n                    min_path = path\n\
    \                end\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local m = {}\n    for i = 1, n do\n        m[i]\
    \ = {}\n        for j = 1, n do\n            m[i][j] = {grid[i][j]}\n        end\n\
    \    end\n    for l = 2, k do\n        for i = 1, n do\n            for j = 1,\
    \ n do\n                local v = m[i][j][l - 1]\n                local t = {}\n\
    \                if i > 1 then\n                    table.insert(t, m[i - 1][j][l\
    \ - 1])\n                end\n                if i < n then\n                \
    \    table.insert(t, m[i + 1][j][l - 1])\n                end\n              \
    \  if j > 1 then\n                    table.insert(t, m[i][j - 1][l - 1])\n  \
    \              end\n                if j < n then\n                    table.insert(t,\
    \ m[i][j + 1][l - 1])\n                end\n                table.sort(t)\n  \
    \              local p = 1\n                while p <= #t and t[p] < v do\n  \
    \                  p = p + 1\n                end\n                table.insert(t,\
    \ p, v)\n                m[i][j][l] = t\n            end\n        end\n    end\n\
    \    local min = m[1][1][k]\n    for i = 1, n do\n        for j = 1, n do\n  \
    \          if m[i][j][k] < min then\n                min = m[i][j][k]\n      \
    \      end\n        end\n    end\n    return min\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ set(x, y, v)\n        grid[x][y] = v\n    end\n    local function less(x1, y1,\
    \ x2, y2)\n        return get(x1, y1) < get(x2, y2)\n    end\n    local function\
    \ swap(x1, y1, x2, y2)\n        local t = get(x1, y1)\n        set(x1, y1, get(x2,\
    \ y2))\n        set(x2, y2, t)\n    end\n    local function bubbleSort(x, y, dx,\
    \ dy)\n        for i = 1, n - 1 do\n            for j = 1, n - i do\n        \
    \        if less(x + j * dx, y + j * dy, x + (j + 1) * dx, y + (j + 1) * dy) then\n\
    \                    swap(x + j * dx, y + j * dy, x + (j + 1) * dx, y + (j + 1)\
    \ * dy)\n                end\n            end\n        end\n    end\n    local\
    \ function sortRow(x, y)\n        bubbleSort(x, y, 1, 0)\n    end\n    local function\
    \ sortCol(x, y)\n        bubbleSort(x, y, 0, 1)\n    end\n    local function sortDiag(x,\
    \ y)\n        bubbleSort(x, y, 1, 1)\n    end\n    local function sortAntiDiag(x,\
    \ y)\n        bubbleSort(x, y, 1, -1)\n    end\n    local function sortGrid()\n\
    \        for i = 1, n do\n            sortRow(i, 1)\n            sortCol(1, i)\n\
    \        end\n        sortDiag(1, 1)\n        sortAntiDiag(1, n)\n    end\n  \
    \  local function getMinPath()\n        local path = {}\n        local x, y =\
    \ 1, 1\n        local dx, dy = 1, 1\n        for i = 1, k do\n            path[i]\
    \ = get(x, y)\n", "    local n = #grid\n    local function get(x, y)\n       \
    \ return grid[x][y]\n    end\n    local function set(x, y, v)\n        grid[x][y]\
    \ = v\n    end\n    local function get_neighbors(x, y)\n        local result =\
    \ {}\n        if x > 1 then\n            table.insert(result, {x - 1, y})\n  \
    \      end\n        if x < n then\n            table.insert(result, {x + 1, y})\n\
    \        end\n        if y > 1 then\n            table.insert(result, {x, y -\
    \ 1})\n        end\n        if y < n then\n            table.insert(result, {x,\
    \ y + 1})\n        end\n        return result\n    end\n    local function compare(a,\
    \ b)\n        local function get_value(x, y)\n            return get(x, y)\n \
    \       end\n        local function get_path(x, y)\n            local result =\
    \ {}\n            for i = 1, k do\n                table.insert(result, get_value(x,\
    \ y))\n                local neighbors = get_neighbors(x, y)\n               \
    \ local min_value = math.huge\n                local min_x, min_y\n          \
    \      for _, neighbor in ipairs(neighbors) do\n                    local neighbor_x,\
    \ neighbor_y = neighbor[1], neighbor[2]\n                    local neighbor_value\
    \ = get_value(neighbor_x, neighbor_y)\n                    if neighbor_value <\
    \ min_value then\n                        min_value = neighbor_value\n       \
    \                 min_x, min_y = neighbor_x, neighbor_y\n                    end\n\
    \                end\n                x, y = min_x, min_y\n            end\n \
    \           return result\n        end\n        local path_a = get_path(a[1],\
    \ a[2])\n        local path_b = get_path(b[1], b[2])\n        for i = 1, k do\n\
    \            if path_a[i] < path_b[i] then\n                return true\n    \
    \        elseif path_a[i] > path_b[i] then\n                return false\n   \
    \         end\n        end\n       ", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function set(x, y,\
    \ v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x, y)\n\
    \        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        if a[1] < b[1] then\n            return true\n\
    \        elseif a[1] > b[1] then\n            return false\n        else\n   \
    \         return a[2] < b[2]\n        end\n    end\n    local function get_min_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        local neighbors = get_neighbors(x, y)\n        table.sort(neighbors,\
    \ compare)\n        for _, neighbor in ipairs(neighbors) do\n            local\
    \ path = get_min_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n\
    \                path[#path + 1] = get(x, y)\n                if not min_path\
    \ or compare(path, min_path) then\n                    min_path = path\n     \
    \           end\n            end\n        end\n        return min_path\n    end\n\
    \    local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n    \
    \        local path = get_min_path(i, j, k)\n            if path then\n      \
    \          path[#path + 1] = get(i, j)\n                if not min_path or compare(path,\
    \ min_path) then", "    local n = #grid\n    local function get(x, y)\n      \
    \  return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n      \
    \  local result = {}\n        if x > 1 then\n            table.insert(result,\
    \ {x - 1, y})\n        end\n        if x < n then\n            table.insert(result,\
    \ {x + 1, y})\n        end\n        if y > 1 then\n            table.insert(result,\
    \ {x, y - 1})\n        end\n        if y < n then\n            table.insert(result,\
    \ {x, y + 1})\n        end\n        return result\n    end\n    local function\
    \ get_key(x, y)\n        return x * n + y\n    end\n    local function get_value(key)\n\
    \        return math.floor(key / n), key % n\n    end\n    local function get_path(key)\n\
    \        local path = {}\n        while key ~= 0 do\n            local x, y =\
    \ get_value(key)\n            table.insert(path, 1, get(x, y))\n            key\
    \ = prev[key]\n        end\n        return path\n    end\n    local function get_path_key(path)\n\
    \        local key = 0\n        for i = 1, #path do\n            key = key * n\
    \ + path[i]\n        end\n        return key\n    end\n    local function get_path_value(path)\n\
    \        local x, y = 1, 1\n        for i = 1, #path do\n            local value\
    \ = path[i]\n            for j = 1, n do\n                for k = 1, n do\n  \
    \                  if grid[j][k] == value then\n                        x, y =\
    \ j, k\n                        break\n                    end\n             \
    \   end\n            end\n        end\n        return x, y\n    end\n    local\
    \ function get_path_length(path)\n        return #path\n    end\n    local function\
    \ get_path_weight(path)\n        local weight = 0\n        for i = 1, #path do\n\
    \            weight = weight * n + path[i]\n        end\n        return weight\n\
    \    end\n    local function compare_paths(path1", "    local n = #grid\n    local\
    \ function get(x, y)\n        if x < 1 or x > n or y < 1 or y > n then\n     \
    \       return math.huge\n        end\n        return grid[x][y]\n    end\n  \
    \  local function cmp(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local min_path = nil\n        for i\
    \ = -1, 1 do\n            for j = -1, 1 do\n                if i ~= 0 or j ~=\
    \ 0 then\n                    local p = dfs(x + i, y + j, k - 1, {get(x + i, y\
    \ + j)})\n                    if not min_path or cmp(p, min_path) then\n     \
    \                   min_path = p\n                    end\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    return dfs(1,\
    \ 1, k, {})\nend", "    local n = #grid\n    local function get(x, y)\n      \
    \  if x >= 1 and x <= n and y >= 1 and y <= n then\n            return grid[x][y]\n\
    \        end\n    end\n    local function cmp(a, b)\n        for i = 1, k do\n\
    \            if a[i] ~= b[i] then\n                return a[i] < b[i]\n      \
    \      end\n        end\n        return false\n    end\n    local function dfs(x,\
    \ y, k, path)\n        if k == 0 then\n            return path\n        end\n\
    \        local minPath = nil\n        for i = -1, 1 do\n            for j = -1,\
    \ 1 do\n                if i ~= 0 or j ~= 0 then\n                    local nx,\
    \ ny = x + i, y + j\n                    local npath = get(nx, ny)\n         \
    \           if npath then\n                        local p = dfs(nx, ny, k - 1,\
    \ {npath, unpack(path)})\n                        if not minPath or cmp(p, minPath)\
    \ then\n                            minPath = p\n                        end\n\
    \                    end\n                end\n            end\n        end\n\
    \        return minPath\n    end\n    local minPath = nil\n    for i = 1, n do\n\
    \        for j = 1, n do\n            local path = dfs(i, j, k, {})\n        \
    \    if not minPath or cmp(path, minPath) then\n                minPath = path\n\
    \            end\n        end\n    end\n    return minPath\nend", "  local n =\
    \ #grid\n  local function get(i, j)\n    return grid[i][j]\n  end\n  local function\
    \ get_neighbors(i, j)\n    local n = {}\n    if i > 1 then\n      n[#n + 1] =\
    \ {i - 1, j}\n    end\n    if i < n then\n      n[#n + 1] = {i + 1, j}\n    end\n\
    \    if j > 1 then\n      n[#n + 1] = {i, j - 1}\n    end\n    if j < n then\n\
    \      n[#n + 1] = {i, j + 1}\n    end\n    return n\n  end\n  local function\
    \ get_paths(i, j, k)\n    local paths = {}\n    if k == 1 then\n      paths[#paths\
    \ + 1] = {get(i, j)}\n    else\n      for _, n in ipairs(get_neighbors(i, j))\
    \ do\n        for _, p in ipairs(get_paths(n[1], n[2], k - 1)) do\n          paths[#paths\
    \ + 1] = {get(i, j)}\n          for _, v in ipairs(p) do\n            paths[#paths][#paths[#paths]\
    \ + 1] = v\n          end\n        end\n      end\n    end\n    return paths\n\
    \  end\n  local paths = {}\n  for i = 1, n do\n    for j = 1, n do\n      for\
    \ _, p in ipairs(get_paths(i, j, k)) do\n        paths[#paths + 1] = p\n     \
    \ end\n    end\n  end\n  local function compare(a, b)\n    for i = 1, k do\n \
    \     if a[i] < b[i] then\n        return true\n      elseif a[i] > b[i] then\n\
    \        return false\n      end\n    end\n    return false\n  end\n  table.sort(paths,\
    \ compare)\n  return paths[1]\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local result = {}\n        if x > 1 then\n            table.insert(result,\
    \ {x - 1, y})\n        end\n        if x < n then\n            table.insert(result,\
    \ {x + 1, y})\n        end\n        if y > 1 then\n            table.insert(result,\
    \ {x, y - 1})\n        end\n        if y < n then\n            table.insert(result,\
    \ {x, y + 1})\n        end\n        return result\n    end\n    local function\
    \ get_path(x, y, k)\n        if k == 0 then\n            return {}\n        end\n\
    \        local result = {}\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local nx, ny = neighbor[1], neighbor[2]\n            local\
    \ path = get_path(nx, ny, k - 1)\n            if #path > 0 then\n            \
    \    table.insert(path, 1, get(x, y))\n                table.insert(result, path)\n\
    \            end\n        end\n        table.sort(result, function(a, b)\n   \
    \         for i = 1, k do\n                if a[i] ~= b[i] then\n            \
    \        return a[i] < b[i]\n                end\n            end\n          \
    \  return false\n        end)\n        return result[1] or {}\n    end\n    local\
    \ result = {}\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ path = get_path(i, j, k)\n            if #path > 0 then\n                table.insert(result,\
    \ path)\n            end\n        end\n    end\n    table.sort(result, function(a,\
    \ b)\n        for i = 1, k do\n            if a[i] ~= b[i] then\n            \
    \    return a[i] < b[i]\n            end\n        end\n        return false\n\
    \    end)\n    return result[1] or {}\nend", "    local N = #grid\n    local function\
    \ get(x, y)\n        if x >= 1 and x <= N and y >= 1 and y <= N then\n       \
    \     return grid[x][y]\n        end\n    end\n    local function get_neighbors(x,\
    \ y)\n        return {\n            {x = x - 1, y = y, value = get(x - 1, y)},\n\
    \            {x = x + 1, y = y, value = get(x + 1, y)},\n            {x = x, y\
    \ = y - 1, value = get(x, y - 1)},\n            {x = x, y = y + 1, value = get(x,\
    \ y + 1)},\n        }\n    end\n    local function get_min_path(x, y, k)\n   \
    \     if k == 0 then\n            return {grid[x][y]}\n        end\n        local\
    \ min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x, y)) do\n\
    \            if neighbor.value then\n                local path = get_min_path(neighbor.x,\
    \ neighbor.y, k - 1)\n                if not min_path or path < min_path then\n\
    \                    min_path = path\n                end\n            end\n \
    \       end\n        return {grid[x][y]} .. min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, N do\n        for j = 1, N do\n            local path\
    \ = get_min_path(i, j, k)\n            if not min_path or path < min_path then\n\
    \                min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local m = #grid[1]\n    local function\
    \ get(x, y)\n        if x < 1 or x > n or y < 1 or y > m then\n            return\
    \ nil\n        end\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        for _, d in ipairs({{1, 0}, {-1, 0},\
    \ {0, 1}, {0, -1}}) do\n            local x1, y1 = x + d[1], y + d[2]\n      \
    \      local v = get(x1, y1)\n            if v then\n                neighbors[v]\
    \ = {x1, y1}\n            end\n        end\n        return neighbors\n    end\n\
    \    local function get_path(x, y, k)\n        local v = get(x, y)\n        if\
    \ k == 1 then\n            return {v}\n        end\n        local neighbors =\
    \ get_neighbors(x, y)\n        local paths = {}\n        for i = 1, n * m do\n\
    \            if neighbors[i] then\n                local path = get_path(neighbors[i][1],\
    \ neighbors[i][2], k - 1)\n                if path then\n                    table.insert(path,\
    \ 1, v)\n                    table.insert(paths, path)\n                end\n\
    \            end\n        end\n        if #paths == 0 then\n            return\
    \ nil\n        end\n        table.sort(paths, function(a, b)\n            for\
    \ i = 1, k do\n                if a[i] < b[i] then\n                    return\
    \ true\n                elseif a[i] > b[i] then\n                    return false\n\
    \                end\n            end\n            return false\n        end)\n\
    \        return paths[1]\n    end\n    for i = 1, n do\n        for j = 1, m do\n\
    \            local path = get_path(i, j, k)\n            if path then\n      \
    \          return path\n            end\n        end\n    end\n    return nil\n\
    end", "    local n = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > n or y < 1 or y > n then\n            return math.huge\n        end\n  \
    \      return grid[x][y]\n    end\n    local function get_path(x, y, k)\n    \
    \    if k == 0 then\n            return {}\n        end\n        local min_path\
    \ = {math.huge}\n        local min_val = math.huge\n        for dx = -1, 1 do\n\
    \            for dy = -1, 1 do\n                if dx ~= 0 or dy ~= 0 then\n \
    \                   local val = get(x + dx, y + dy)\n                    if val\
    \ < min_val then\n                        min_val = val\n                    \
    \    min_path = {val}\n                    elseif val == min_val then\n      \
    \                  table.insert(min_path, val)\n                    end\n    \
    \            end\n            end\n        end\n        local path = get_path(x\
    \ + dx, y + dy, k - 1)\n        table.insert(path, 1, min_val)\n        return\
    \ path\n    end\n    local min_path = {math.huge}\n    for x = 1, n do\n     \
    \   for y = 1, n do\n            local path = get_path(x, y, k)\n            if\
    \ path < min_path then\n                min_path = path\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local N = #grid\n    local\
    \ function get_path(i, j, k)\n        local path = {}\n        local function\
    \ dfs(i, j, k)\n            if k == 0 then\n                return\n         \
    \   end\n            table.insert(path, grid[i][j])\n            if i > 1 then\n\
    \                dfs(i - 1, j, k - 1)\n            end\n            if i < N then\n\
    \                dfs(i + 1, j, k - 1)\n            end\n            if j > 1 then\n\
    \                dfs(i, j - 1, k - 1)\n            end\n            if j < N then\n\
    \                dfs(i, j + 1, k - 1)\n            end\n        end\n        dfs(i,\
    \ j, k)\n        return path\n    end\n    local min_path = {}\n    for i = 1,\
    \ N do\n        for j = 1, N do\n            local path = get_path(i, j, k)\n\
    \            if #min_path == 0 or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(i, j)\n        return grid[i][j]\n\
    \    end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n\
    \        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n \
    \       end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                local new_path = dfs(ni, nj, {unpack(path), get(ni,\
    \ nj)}, visited)\n                if not min_path or compare(new_path, min_path)\
    \ then\n                    min_path = new_path\n                end\n       \
    \         visited[ni][nj] = false\n            end\n        end\n        return\
    \ min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local visited = {}\n            for i = 1, n do\n \
    \               visited[i] = {}\n            end\n            visited[i][j] =\
    \ true\n            local new_path = dfs(i, j, {get(i, j)}, visited)\n", "   \
    \ local n = #grid\n    local function isValid(i, j)\n        return i >= 1 and\
    \ i <= n and j >= 1 and j <= n\n    end\n    local function getNeighbors(i, j)\n\
    \        local res = {}\n        if isValid(i - 1, j) then res[#res + 1] = {i\
    \ - 1, j} end\n        if isValid(i + 1, j) then res[#res + 1] = {i + 1, j} end\n\
    \        if isValid(i, j - 1) then res[#res + 1] = {i, j - 1} end\n        if\
    \ isValid(i, j + 1) then res[#res + 1] = {i, j + 1} end\n        return res\n\
    \    end\n    local function getPaths(i, j, k)\n        local res = {}\n     \
    \   if k == 1 then\n            res[#res + 1] = {grid[i][j]}\n        else\n \
    \           for _, n in ipairs(getNeighbors(i, j)) do\n                local i1,\
    \ j1 = n[1], n[2]\n                for _, p in ipairs(getPaths(i1, j1, k - 1))\
    \ do\n                    res[#res + 1] = {grid[i][j]}\n                    for\
    \ _, v in ipairs(p) do\n                        res[#res][#res[#res] + 1] = v\n\
    \                    end\n                end\n            end\n        end\n\
    \        return res\n    end\n    local function compare(a, b)\n        for i\
    \ = 1, k do\n            if a[i] < b[i] then\n                return true\n  \
    \          elseif a[i] > b[i] then\n                return false\n           \
    \ end\n        end\n        return false\n    end\n    local res = nil\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            for _, p in ipairs(getPaths(i,\
    \ j, k)) do\n                if res == nil or compare(p, res) then\n         \
    \           res = p\n                end\n            end\n        end\n    end\n\
    \    return res\nend", "    local n = #grid\n    local function get(i, j)\n  \
    \      if i < 1 or i > n or j < 1 or j > n then\n            return math.huge\n\
    \        end\n        return grid[i][j]\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = {}\n        local min_val = math.huge\n        for di = -1, 1 do\n\
    \            for dj = -1, 1 do\n                if di ~= 0 or dj ~= 0 then\n \
    \                   local val = get(i + di, j + dj)\n                    if val\
    \ < min_val then\n                        min_val = val\n                    \
    \    min_path = get_path(i + di, j + dj, k - 1)\n                    elseif val\
    \ == min_val then\n                        local path = get_path(i + di, j + dj,\
    \ k - 1)\n                        if path < min_path then\n                  \
    \          min_path = path\n                        end\n                    end\n\
    \                end\n            end\n        end\n        return {min_val, unpack(min_path)}\n\
    \    end\n    return get_path(1, 1, k)\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function get_min_path(i, j, k)\n        local min_path = {}\n\
    \        for i = 1, k do\n            min_path[i] = n * n + 1\n        end\n \
    \       local function dfs(i, j, k, path)\n            if k == 0 then\n      \
    \          if compare(path, min_path) then\n                    min_path = path\n\
    \                end\n                return\n            end\n            for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n                local new_path\
    \ = {}\n                for i = 1, #path do\n                    new_path[i] =\
    \ path[i]\n                end\n                new_path[#new_path + 1] = get(neighbor[1],\
    \ neighbor[2])\n                dfs(neighbor[1], neighbor[2], k - 1, new_path)\n\
    \            end\n        end\n        dfs(i, j, k, {get(i, j)})\n        return\
    \ min_path\n    end\n    local min_path = {}\n    for i = 1, k do\n        min_path[i]\
    \ = n * n + 1\n    end\n", "    local n = #grid\n    local function get(x, y)\n\
    \        return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n\
    \        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, path, visited)\n        visited[x][y] =\
    \ true\n        path[#path + 1] = get(x, y)\n        if #path == k then\n    \
    \        if not result or compare(path, result) then\n                result =\
    \ path\n            end\n        else\n            for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n                local x1, y1 = neighbor[1], neighbor[2]\n          \
    \      if not visited[x1][y1] then\n                    dfs(x1, y1, path, visited)\n\
    \                end\n            end\n        end\n        visited[x][y] = false\n\
    \        path[#path] = nil\n    end\n    local result\n    local visited = {}\n\
    \    for i = 1, n do\n        visited[i] = {}\n    end\n    for i = 1, n do\n\
    \        for j = 1, n do\n            dfs(i, j, {}, visited)\n        end\n  \
    \  end\n    return result\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ set(x, y, v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < m then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y)\n        local path = {}\n        local function add(x,\
    \ y)\n            path[#path + 1] = get(x, y)\n        end\n        add(x, y)\n\
    \        local neighbors = get_neighbors(x, y)\n        for i = 1, #neighbors\
    \ do\n            local nx, ny = unpack(neighbors[i])\n            if get(nx,\
    \ ny) < get(x, y) then\n                add(nx, ny)\n                return path\n\
    \            end\n        end\n        for i = 1, #neighbors do\n            local\
    \ nx, ny = unpack(neighbors[i])\n            if get(nx, ny) > get(x, y) then\n\
    \                add(nx, ny)\n                return path\n            end\n \
    \       end\n        return path\n    end\n    local function compare(path1, path2)\n\
    \        for i = 1, k do\n            if path1[i] < path2[i] then\n          \
    \      return true\n            elseif path1[i] > path2[i] then\n            \
    \    return false\n            end\n        end\n        return false\n    end\n\
    \    local function get_min_path(x, y)\n        local", "    local n = #grid\n\
    \    local function get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n\
    \            return math.huge\n        end\n        return grid[i][j]\n    end\n\
    \    local function get_path(i, j, k)\n        if k == 0 then\n            return\
    \ {}\n        end\n        local v = get(i, j)\n        local min_path = {v}\n\
    \        local min_value = v\n        for _, p in ipairs({{i - 1, j}, {i + 1,\
    \ j}, {i, j - 1}, {i, j + 1}}) do\n            local path = get_path(p[1], p[2],\
    \ k - 1)\n            local value = get(p[1], p[2])\n            if value < min_value\
    \ then\n                min_path = {v}\n                min_value = value\n  \
    \          end\n            if value == min_value then\n                table.insert(min_path,\
    \ value)\n                for _, v in ipairs(path) do\n                    table.insert(min_path,\
    \ v)\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    return get_path(1, 1, k)\nend", "    local n = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function set(x,\
    \ y, v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y)\n        local path = {}\n        local function dfs(x,\
    \ y)\n            if x < 1 or x > n or y < 1 or y > n then\n                return\n\
    \            end\n            local v = get(x, y)\n            if v == -1 then\n\
    \                return\n            end\n            path[#path + 1] = v\n  \
    \          set(x, y, -1)\n            for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n                dfs(neighbor[1], neighbor[2])\n            end\n   \
    \     end\n        dfs(x, y)\n        return path\n    end\n    local function\
    \ compare(path1, path2)\n        for i = 1, k do\n            if path1[i] < path2[i]\
    \ then\n                return true\n            elseif path1[i] > path2[i] then\n\
    \                return false\n            end\n        end\n        return false\n\
    \    end\n    local min_path\n    for i = 1, n do\n        for j = 1, n do\n \
    \           local path = get_path(i, j)\n            if #path == k then\n    \
    \            if not min_path or compare(path, min_path) then\n               \
    \     min_path = path\n                end\n            end\n        end\n   \
    \ end\n   ", "    local n = #grid\n    local function get(x, y)\n        return\
    \ grid[x][y]\n    end\n    local function get_neighbors(x, y)\n        local neighbors\
    \ = {}\n        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1,\
    \ y}\n        end\n        if x < n then\n            neighbors[#neighbors + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function get_path(x, y, k)\n        local path = {}\n    \
    \    for i = 1, k do\n            path[i] = get(x, y)\n            local neighbors\
    \ = get_neighbors(x, y)\n            local min_neighbor = neighbors[1]\n     \
    \       for j = 2, #neighbors do\n                if compare(get_path(neighbors[j][1],\
    \ neighbors[j][2], k - i),\n                           get_path(min_neighbor[1],\
    \ min_neighbor[2], k - i)) then\n                    min_neighbor = neighbors[j]\n\
    \                end\n            end\n            x, y = min_neighbor[1], min_neighbor[2]\n\
    \        end\n        return path\n    end\n    return get_path(1, 1, k)\nend",
  "    local N = #grid\n    local function get(i, j)\n        if i < 1 or i > N or\
    \ j < 1 or j > N then\n            return math.huge\n        end\n        return\
    \ grid[i][j]\n    end\n    local function less(a, b)\n        for i = 1, k do\n\
    \            if a[i] < b[i] then\n                return true\n            elseif\
    \ a[i] > b[i] then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function dfs(i, j, k, path)\n      \
    \  if k == 0 then\n            return path\n        end\n        local min = {math.huge}\n\
    \        for x = -1, 1 do\n            for y = -1, 1 do\n                if x\
    \ ~= 0 or y ~= 0 then\n                    local p = dfs(i + x, j + y, k - 1,\
    \ {path[1], get(i + x, j + y)})\n                    if less(p, min) then\n  \
    \                      min = p\n                    end\n                end\n\
    \            end\n        end\n        return min\n    end\n    local min = {math.huge}\n\
    \    for i = 1, N do\n        for j = 1, N do\n            local p = dfs(i, j,\
    \ k, {get(i, j)})\n            if less(p, min) then\n                min = p\n\
    \            end\n        end\n    end\n    return min\nend", "    local n = #grid\n\
    \    local function get(i, j)\n        return grid[i][j]\n    end\n    local function\
    \ set(i, j, v)\n        grid[i][j] = v\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_min_neighbor(i, j)\n        local min_neighbor = {i, j}\n     \
    \   local min_value = get(i, j)\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local value = get(neighbor[1], neighbor[2])\n          \
    \  if value < min_value then\n                min_neighbor = neighbor\n      \
    \          min_value = value\n            end\n        end\n        return min_neighbor\n\
    \    end\n    local function get_path(i, j)\n        local path = {}\n       \
    \ while k > 0 do\n            local neighbor = get_min_neighbor(i, j)\n      \
    \      path[#path + 1] = get(neighbor[1], neighbor[2])\n            i, j = neighbor[1],\
    \ neighbor[2]\n            k = k - 1\n        end\n        return path\n    end\n\
    \    local min_path = get_path(1, 1)\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local path = get_path(i, j)\n            if path < min_path\
    \ then\n                min_path = path\n            end\n        end\n    end\n\
    \    return min_path\nend", "    local N = #grid\n    local function get(x, y)\n\
    \        if x < 1 or x > N or y < 1 or y > N then\n            return 0\n    \
    \    end\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        for i = -1, 1 do\n            for\
    \ j = -1, 1 do\n                if i ~= 0 or j ~= 0 then\n                   \
    \ local n = get(x + i, y + j)\n                    if n ~= 0 then\n          \
    \              neighbors[#neighbors + 1] = n\n                    end\n      \
    \          end\n            end\n        end\n        return neighbors\n    end\n\
    \    local function get_min_path(x, y, k)\n        local min_path = {}\n     \
    \   local min_value = math.huge\n        local function get_path(x, y, k, path)\n\
    \            if k == 0 then\n                local value = 0\n               \
    \ for i = 1, #path do\n                    value = value * N * N + path[i]\n \
    \               end\n                if value < min_value then\n             \
    \       min_value = value\n                    min_path = path\n             \
    \   end\n                return\n            end\n            local neighbors\
    \ = get_neighbors(x, y)\n            for i = 1, #neighbors do\n              \
    \  local n = neighbors[i]\n                local path_copy = {}\n            \
    \    for j = 1, #path do\n                    path_copy[j] = path[j]\n       \
    \         end\n                path_copy[#path_copy + 1] = n\n               \
    \ get_path(x, y, k - 1, path_copy)\n            end\n        end\n        get_path(x,\
    \ y, k, {get(x, y)})\n        return min_path\n    end\n    local min_path = {}\n\
    \    local min_value = math.huge\n    for i = 1, N do\n        for j = 1, N do\n\
    \            local path = get_min_path(i, j, k)\n            local value = 0\n\
    \            for i = 1, #path do\n                value = value * N * N + path[i]\n\
    \            end\n            if", "    local n = #grid\n    local function get(x,\
    \ y)\n        return grid[x][y]\n    end\n    local function set(x, y, v)\n  \
    \      grid[x][y] = v\n    end\n    local function less(x1, y1, x2, y2)\n    \
    \    return get(x1, y1) < get(x2, y2)\n    end\n    local function swap(x1, y1,\
    \ x2, y2)\n        local t = get(x1, y1)\n        set(x1, y1, get(x2, y2))\n \
    \       set(x2, y2, t)\n    end\n    local function sort(x, y)\n        for i\
    \ = x, n do\n            for j = y, n do\n                for ii = x, n do\n \
    \                   for jj = y, n do\n                        if less(ii, jj,\
    \ i, j) then\n                            swap(ii, jj, i, j)\n               \
    \         end\n                    end\n                end\n            end\n\
    \        end\n    end\n    sort(1, 1)\n    local function getPath(x, y, k)\n \
    \       if k == 0 then\n            return {}\n        end\n        local paths\
    \ = {}\n        if x > 1 then\n            local path = getPath(x - 1, y, k -\
    \ 1)\n            table.insert(path, get(x, y))\n            table.insert(paths,\
    \ path)\n        end\n        if x < n then\n            local path = getPath(x\
    \ + 1, y, k - 1)\n            table.insert(path, get(x, y))\n            table.insert(paths,\
    \ path)\n        end\n        if y > 1 then\n            local path = getPath(x,\
    \ y - 1, k - 1)\n            table.insert(path, get(x, y))\n            table.insert(paths,\
    \ path)\n        end\n        if y < n then\n            local path = getPath(x,\
    \ y + 1, k - 1)\n            table.insert(path, get(x, y))\n            table.insert(paths,\
    \ path)\n        end\n        local minPath =", "    local N = #grid\n    local\
    \ min_path = {}\n    local min_path_sum = math.huge\n    local min_path_lex =\
    \ math.huge\n    local function dfs(i, j, path, path_sum, path_lex)\n        if\
    \ i < 1 or i > N or j < 1 or j > N then\n            return\n        end\n   \
    \     if #path == k then\n            if path_sum < min_path_sum then\n      \
    \          min_path_sum = path_sum\n                min_path_lex = path_lex\n\
    \                min_path = path\n            elseif path_sum == min_path_sum\
    \ and path_lex < min_path_lex then\n                min_path_lex = path_lex\n\
    \                min_path = path\n            end\n            return\n      \
    \  end\n        local v = grid[i][j]\n        local path_sum_new = path_sum +\
    \ v\n        local path_lex_new = path_lex * N * N + v\n        table.insert(path,\
    \ v)\n        dfs(i - 1, j, path, path_sum_new, path_lex_new)\n        dfs(i +\
    \ 1, j, path, path_sum_new, path_lex_new)\n        dfs(i, j - 1, path, path_sum_new,\
    \ path_lex_new)\n        dfs(i, j + 1, path, path_sum_new, path_lex_new)\n   \
    \     table.remove(path)\n    end\n    dfs(1, 1, {}, 0, 0)\n    return min_path\n\
    end", "    local n = #grid\n    local function get_value(x, y)\n        return\
    \ grid[x][y]\n    end\n    local function get_neighbors(x, y)\n        local neighbors\
    \ = {}\n        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1,\
    \ y}\n        end\n        if x < n then\n            neighbors[#neighbors + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = get_value(x, y)\n\
    \                if not min_path or path < min_path then\n                   \
    \ min_path = path\n                end\n            end\n        end\n       \
    \ return min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n  \
    \      for j = 1, n do\n            local path = get_path(i, j, k)\n         \
    \   if path then\n                path[#path + 1] = get_value(i, j)\n        \
    \        if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function get(x, y)\n       \
    \ return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n       \
    \ local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = get(x, y)\n     \
    \           if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = get(i, j)\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ n = #grid\n    local function get(x, y)\n        if x < 1 or x > n or y < 1\
    \ or y > n then\n            return math.huge\n        end\n        return grid[x][y]\n\
    \    end\n    local function compare(a, b)\n        for i = 1, k do\n        \
    \    if a[i] < b[i] then\n                return true\n            elseif a[i]\
    \ > b[i] then\n                return false\n            end\n        end\n  \
    \      return false\n    end\n    local function dfs(x, y, k, path)\n        if\
    \ k == 0 then\n            return path\n        end\n        local min = {math.huge}\n\
    \        local next = {{x, y + 1}, {x, y - 1}, {x + 1, y}, {x - 1, y}}\n     \
    \   for _, v in ipairs(next) do\n            local nx, ny = v[1], v[2]\n     \
    \       local val = get(nx, ny)\n            if val < math.huge then\n       \
    \         local newPath = {table.unpack(path)}\n                table.insert(newPath,\
    \ val)\n                local ret = dfs(nx, ny, k - 1, newPath)\n            \
    \    if compare(ret, min) then\n                    min = ret\n              \
    \  end\n            end\n        end\n        return min\n    end\n    local min\
    \ = {math.huge}\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ ret = dfs(i, j, k, {grid[i][j]})\n            if compare(ret, min) then\n  \
    \              min = ret\n            end\n        end\n    end\n    return min\n\
    end", "    local N = #grid\n    local function isValid(i, j)\n        return i\
    \ >= 1 and i <= N and j >= 1 and j <= N\n    end\n    local function getNeighbors(i,\
    \ j)\n        local neighbors = {}\n        if isValid(i - 1, j) then\n      \
    \      neighbors[#neighbors + 1] = {i - 1, j}\n        end\n        if isValid(i\
    \ + 1, j) then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n\
    \        if isValid(i, j - 1) then\n            neighbors[#neighbors + 1] = {i,\
    \ j - 1}\n        end\n        if isValid(i, j + 1) then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function getPaths(i, j, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[i][j]}\n        else\n            for _,\
    \ neighbor in ipairs(getNeighbors(i, j)) do\n                local ni, nj = neighbor[1],\
    \ neighbor[2]\n                for _, path in ipairs(getPaths(ni, nj, k - 1))\
    \ do\n                    paths[#paths + 1] = {grid[i][j]}\n                 \
    \   for _, val in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = val\n                    end\n                end\n            end\n\
    \        end\n        return paths\n    end\n    local minPath = nil\n    for\
    \ i = 1, N do\n        for j = 1, N do\n            for _, path in ipairs(getPaths(i,\
    \ j, k)) do\n                if minPath == nil or path < minPath then\n      \
    \              minPath = path\n                end\n            end\n        end\n\
    \    end\n    return minPath\nend", "    local N = #grid\n    local function isValid(x,\
    \ y)\n        return x >= 1 and x <= N and y >= 1 and y <= N\n    end\n    local\
    \ function getNeighbors(x, y)\n        local neighbors = {}\n        if isValid(x\
    \ - 1, y) then\n            neighbors[#neighbors + 1] = {x - 1, y}\n        end\n\
    \        if isValid(x + 1, y) then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if isValid(x, y - 1) then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if isValid(x, y + 1) then\n        \
    \    neighbors[#neighbors + 1] = {x, y + 1}\n        end\n        return neighbors\n\
    \    end\n    local function compare(a, b)\n        for i = 1, #a do\n       \
    \     if a[i] < b[i] then\n                return true\n            elseif a[i]\
    \ > b[i] then\n                return false\n            end\n        end\n  \
    \      return false\n    end\n    local function dfs(x, y, k, path)\n        if\
    \ k == 0 then\n            return path\n        end\n        local neighbors =\
    \ getNeighbors(x, y)\n        local minPath = nil\n        for _, neighbor in\
    \ ipairs(neighbors) do\n            local newPath = dfs(neighbor[1], neighbor[2],\
    \ k - 1, path)\n            if minPath == nil or compare(newPath, minPath) then\n\
    \                minPath = newPath\n            end\n        end\n        return\
    \ minPath\n    end\n    local minPath = nil\n    for i = 1, N do\n        for\
    \ j = 1, N do\n            local path = dfs(i, j, k, {grid[i][j]})\n         \
    \   if minPath == nil or compare(path, minPath) then\n                minPath\
    \ = path\n            end\n        end\n    end\n    return minPath\nend", " \
    \   local N = #grid\n    local function get(x, y)\n        if x < 1 or x > N or\
    \ y < 1 or y > N then\n            return math.huge\n        end\n        return\
    \ grid[x][y]\n    end\n    local function get_neighbors(x, y)\n        return\
    \ {\n            {x - 1, y},\n            {x + 1, y},\n            {x, y - 1},\n\
    \            {x, y + 1}\n        }\n    end\n    local function get_path(x, y,\
    \ k)\n        local path = {}\n        for i = 1, k do\n            table.insert(path,\
    \ get(x, y))\n            local neighbors = get_neighbors(x, y)\n            local\
    \ min_value = math.huge\n            local min_x, min_y\n            for _, neighbor\
    \ in ipairs(neighbors) do\n                local value = get(neighbor[1], neighbor[2])\n\
    \                if value < min_value then\n                    min_value = value\n\
    \                    min_x = neighbor[1]\n                    min_y = neighbor[2]\n\
    \                end\n            end\n            x = min_x\n            y =\
    \ min_y\n        end\n        return path\n    end\n    local min_path\n    for\
    \ i = 1, N do\n        for j = 1, N do\n            local path = get_path(i, j,\
    \ k)\n            if not min_path or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = get(x, y)\n     \
    \           if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = get(i, j)\n                if not min_path or\
    \ path < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ n = #grid\n    local function get_neighbors(i, j)\n        local neighbors =\
    \ {}\n        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n\
    \        end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(i,\
    \ j)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if path then\n                path[#path + 1] = grid[i][j]\n    \
    \            if not min_path or path < min_path then\n                    min_path\
    \ = path\n                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_path(i, j, k)\n            if path then\n \
    \               path[#path + 1] = grid[i][j]\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function getNeighbors(x, y)\n        local res = {}\n    \
    \    if x > 1 then\n            res[#res + 1] = {x - 1, y}\n        end\n    \
    \    if x < n then\n            res[#res + 1] = {x + 1, y}\n        end\n    \
    \    if y > 1 then\n            res[#res + 1] = {x, y - 1}\n        end\n    \
    \    if y < n then\n            res[#res + 1] = {x, y + 1}\n        end\n    \
    \    return res\n    end\n    local function getPath(x, y, k)\n        local res\
    \ = {}\n        if k == 0 then\n            return res\n        end\n        local\
    \ minPath = nil\n        for _, n in ipairs(getNeighbors(x, y)) do\n         \
    \   local path = getPath(n[1], n[2], k - 1)\n            if path then\n      \
    \          path[#path + 1] = get(x, y)\n                if not minPath or path\
    \ < minPath then\n                    minPath = path\n                end\n  \
    \          end\n        end\n        return minPath\n    end\n    local minPath\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = getPath(i, j, k)\n            if path then\n                path[#path + 1]\
    \ = get(i, j)\n                if not minPath or path < minPath then\n       \
    \             minPath = path\n                end\n            end\n        end\n\
    \    end\n    return minPath\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1,\
    \ m do\n            dp[i][j] = {}\n        end\n    end\n    local function get(i,\
    \ j, l)\n        if i < 1 or i > n or j < 1 or j > m then\n            return\
    \ nil\n        end\n        return dp[i][j][l]\n    end\n    local function set(i,\
    \ j, l, v)\n        if i < 1 or i > n or j < 1 or j > m then\n            return\n\
    \        end\n        dp[i][j][l] = v\n    end\n    local function min(a, b)\n\
    \        if a == nil then\n            return b\n        end\n        if b ==\
    \ nil then\n            return a\n        end\n        if a < b then\n       \
    \     return a\n        end\n        return b\n    end\n    local function lexicographicallyLess(a,\
    \ b)\n        for i = 1, #a do\n            if a[i] < b[i] then\n            \
    \    return true\n            end\n            if a[i] > b[i] then\n         \
    \       return false\n            end\n        end\n        return false\n   \
    \ end\n    local function add(a, b)\n        local c = {}\n        for i = 1,\
    \ #a do\n            c[i] = a[i]\n        end\n        c[#c + 1] = b\n       \
    \ return c\n    end\n    local function getMin(i, j, l)\n        local v = get(i,\
    \ j, l)\n        if v ~= nil then\n            return v\n        end\n       \
    \ if l == 1 then\n            v = {grid[i][j]}\n            set(i, j, l, v)\n\
    \            return v\n        end\n        v = getMin(i - 1, j, l - 1)\n    \
    \    if v ~= nil then\n            v = add(v, grid[i][j])\n            set(i,\
    \ j, l, v)\n        end\n        local v1 = getMin(i + 1, j", "    local n = #grid\n\
    \    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1,\
    \ n do\n            dp[i][j] = {}\n        end\n    end\n    for i = 1, n do\n\
    \        for j = 1, n do\n            dp[i][j][1] = {grid[i][j]}\n        end\n\
    \    end\n    for i = 1, n do\n        for j = 1, n do\n            for l = 2,\
    \ k do\n                local min = {math.huge}\n                if i > 1 then\n\
    \                    local t = dp[i - 1][j][l - 1]\n                    if t[1]\
    \ < min[1] then\n                        min = t\n                    end\n  \
    \              end\n                if i < n then\n                    local t\
    \ = dp[i + 1][j][l - 1]\n                    if t[1] < min[1] then\n         \
    \               min = t\n                    end\n                end\n      \
    \          if j > 1 then\n                    local t = dp[i][j - 1][l - 1]\n\
    \                    if t[1] < min[1] then\n                        min = t\n\
    \                    end\n                end\n                if j < n then\n\
    \                    local t = dp[i][j + 1][l - 1]\n                    if t[1]\
    \ < min[1] then\n                        min = t\n                    end\n  \
    \              end\n                dp[i][j][l] = {min[1], grid[i][j]}\n     \
    \       end\n        end\n    end\n    local min = {math.huge}\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            if dp[i][j][k][1] < min[1] then\n\
    \                min = dp[i][j][k]\n            end\n        end\n    end\n  \
    \  return min\nend", "    local n = #grid\n    local m = #grid[1]\n    local dp\
    \ = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1, m do\n   \
    \         dp[i][j] = {}\n        end\n    end\n    local function get(i, j, l)\n\
    \        if i < 1 or i > n or j < 1 or j > m then\n            return nil\n  \
    \      end\n        return dp[i][j][l]\n    end\n    local function set(i, j,\
    \ l, v)\n        dp[i][j][l] = v\n    end\n    for i = 1, n do\n        for j\
    \ = 1, m do\n            set(i, j, 1, {grid[i][j]})\n        end\n    end\n  \
    \  for l = 2, k do\n        for i = 1, n do\n            for j = 1, m do\n   \
    \             local min = nil\n                for _, p in ipairs({{i - 1, j},\
    \ {i + 1, j}, {i, j - 1}, {i, j + 1}}) do\n                    local v = get(p[1],\
    \ p[2], l - 1)\n                    if v then\n                        if not\
    \ min or v < min then\n                            min = v\n                 \
    \       end\n                    end\n                end\n                if\
    \ min then\n                    set(i, j, l, {grid[i][j]})\n                 \
    \   for _, v in ipairs(min) do\n                        table.insert(dp[i][j][l],\
    \ v)\n                    end\n                end\n            end\n        end\n\
    \    end\n    local min = nil\n    for i = 1, n do\n        for j = 1, m do\n\
    \            local v = get(i, j, k)\n            if v then\n                if\
    \ not min or v < min then\n                    min = v\n                end\n\
    \            end\n        end\n    end\n    return min\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local res = {}\n        if x > 1 then\n       \
    \     res[#res + 1] = {x - 1, y}\n        end\n        if x < n then\n       \
    \     res[#res + 1] = {x + 1, y}\n        end\n        if y > 1 then\n       \
    \     res[#res + 1] = {x, y - 1}\n        end\n        if y < n then\n       \
    \     res[#res + 1] = {x, y + 1}\n        end\n        return res\n    end\n \
    \   local function cmp(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local new_path = dfs(neighbor[1], neighbor[2], k - 1, {get(neighbor[1],\
    \ neighbor[2])})\n            if min_path == nil or cmp(new_path, min_path) then\n\
    \                min_path = new_path\n            end\n        end\n        return\
    \ {get(x, y)} .. min_path\n    end\n    local min_path = nil\n    for i = 1, n\
    \ do\n        for j = 1, n do\n            local new_path = dfs(i, j, k, {})\n\
    \            if min_path == nil or cmp(new_path, min_path) then\n            \
    \    min_path = new_path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(x, y, k, path)\n        if k == 0 then\n    \
    \        return path\n        end\n        local neighbors = get_neighbors(x,\
    \ y)\n        local min_path = nil\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local new_path = dfs(neighbor[1], neighbor[2], k - 1, path)\n\
    \            if min_path == nil or compare(new_path, min_path) then\n        \
    \        min_path = new_path\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = dfs(i, j, k, {get(i, j)})\n            if min_path\
    \ == nil or compare(path, min_path) then\n                min_path = path\n  \
    \          end\n        end\n    end\n    return min_path\nend", "    local n\
    \ = #grid\n    local function get_neighbors(i, j)\n        local res = {}\n  \
    \      if i > 1 then\n            res[#res + 1] = {i - 1, j}\n        end\n  \
    \      if i < n then\n            res[#res + 1] = {i + 1, j}\n        end\n  \
    \      if j > 1 then\n            res[#res + 1] = {i, j - 1}\n        end\n  \
    \      if j < n then\n            res[#res + 1] = {i, j + 1}\n        end\n  \
    \      return res\n    end\n    local function get_path(i, j, k)\n        if k\
    \ == 0 then\n            return {}\n        end\n        local res = {}\n    \
    \    for _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni,\
    \ nj = neighbor[1], neighbor[2]\n            local path = get_path(ni, nj, k -\
    \ 1)\n            if #path > 0 then\n                path[#path + 1] = grid[i][j]\n\
    \                res[#res + 1] = path\n            end\n        end\n        table.sort(res,\
    \ function(a, b)\n            for i = 1, #a do\n                if a[i] < b[i]\
    \ then\n                    return true\n                elseif a[i] > b[i] then\n\
    \                    return false\n                end\n            end\n    \
    \        return false\n        end)\n        return res[1] or {}\n    end\n  \
    \  local res = {}\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ path = get_path(i, j, k)\n            if #path > 0 then\n                path[#path\
    \ + 1] = grid[i][j]\n                res[#res + 1] = path\n            end\n \
    \       end\n    end\n    table.sort(res, function(a, b)\n        for i = 1, #a\
    \ do\n            if a[i] < b[i] then\n                return true\n         \
    \   elseif a[i] > b[i] then\n                return false\n            end\n \
    \       end\n        return false\n    end", "    local n = #grid\n    local m\
    \ = {}\n    for i = 1, n do\n        m[i] = {}\n        for j = 1, n do\n    \
    \        m[i][j] = {}\n        end\n    end\n    local function dfs(i, j, k)\n\
    \        if k == 0 then\n            return {grid[i][j]}\n        end\n      \
    \  local res = {}\n        if i > 1 then\n            local t = m[i - 1][j][k\
    \ - 1]\n            if #t == 0 then\n                t = dfs(i - 1, j, k - 1)\n\
    \                m[i - 1][j][k - 1] = t\n            end\n            table.insert(res,\
    \ t)\n        end\n        if i < n then\n            local t = m[i + 1][j][k\
    \ - 1]\n            if #t == 0 then\n                t = dfs(i + 1, j, k - 1)\n\
    \                m[i + 1][j][k - 1] = t\n            end\n            table.insert(res,\
    \ t)\n        end\n        if j > 1 then\n            local t = m[i][j - 1][k\
    \ - 1]\n            if #t == 0 then\n                t = dfs(i, j - 1, k - 1)\n\
    \                m[i][j - 1][k - 1] = t\n            end\n            table.insert(res,\
    \ t)\n        end\n        if j < n then\n            local t = m[i][j + 1][k\
    \ - 1]\n            if #t == 0 then\n                t = dfs(i, j + 1, k - 1)\n\
    \                m[i][j + 1][k - 1] = t\n            end\n            table.insert(res,\
    \ t)\n        end\n        table.sort(res, function(a, b)\n            for i =\
    \ 1, k do\n                if a[i] < b[i] then\n                    return true\n\
    \                elseif a[i] > b[i] then\n                    return false\n \
    \               end\n            end\n            return false\n        end)\n\
    \        local t = {grid[i][j]}\n        for i = 1, k do\n", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if x\
    \ < n then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if y > 1 then\n            neighbors[#neighbors + 1] = {x, y - 1}\n \
    \       end\n        if y < n then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function compare(a,\
    \ b)\n        for i = 1, k do\n            if a[i] < b[i] then\n             \
    \   return true\n            elseif a[i] > b[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end\n    local function\
    \ get_min_path(x, y, k)\n        if k == 0 then\n            return {}\n     \
    \   end\n        local min_path = {get(x, y)}\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_min_path(neighbor[1], neighbor[2], k -\
    \ 1)\n            if compare(min_path, path) then\n                min_path =\
    \ path\n            end\n        end\n        min_path[#min_path + 1] = get(x,\
    \ y)\n        return min_path\n    end\n    return get_min_path(1, 1, k)\nend",
  "    local n = #grid\n    local function get(i, j)\n        if i < 1 or i > n or\
    \ j < 1 or j > n then\n            return 0\n        end\n        return grid[i][j]\n\
    \    end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n\
    \        for _, p in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n         \
    \   local x, y = i + p[1], j + p[2]\n            if get(x, y) > 0 then\n     \
    \           neighbors[#neighbors + 1] = {x, y}\n            end\n        end\n\
    \        return neighbors\n    end\n    local function dfs(i, j, k, path)\n  \
    \      if k == 0 then\n            return path\n        end\n        local neighbors\
    \ = get_neighbors(i, j)\n        if #neighbors == 0 then\n            return nil\n\
    \        end\n        local min_path\n        for _, p in ipairs(neighbors) do\n\
    \            local x, y = p[1], p[2]\n            local new_path = dfs(x, y, k\
    \ - 1, path .. get(x, y))\n            if new_path and (not min_path or new_path\
    \ < min_path) then\n                min_path = new_path\n            end\n   \
    \     end\n        return min_path\n    end\n    local min_path\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            local new_path = dfs(i, j, k - 1,\
    \ get(i, j))\n            if new_path and (not min_path or new_path < min_path)\
    \ then\n                min_path = new_path\n            end\n        end\n  \
    \  end\n    return min_path\nend", "    local n = #grid\n    local function dfs(i,\
    \ j, k, path)\n        if k == 0 then\n            return path\n        end\n\
    \        local minPath = nil\n        if i > 1 then\n            minPath = dfs(i\
    \ - 1, j, k - 1, {grid[i][j]})\n        end\n        if j > 1 then\n         \
    \   local path = dfs(i, j - 1, k - 1, {grid[i][j]})\n            if minPath ==\
    \ nil or path < minPath then\n                minPath = path\n            end\n\
    \        end\n        if i < n then\n            local path = dfs(i + 1, j, k\
    \ - 1, {grid[i][j]})\n            if minPath == nil or path < minPath then\n \
    \               minPath = path\n            end\n        end\n        if j < n\
    \ then\n            local path = dfs(i, j + 1, k - 1, {grid[i][j]})\n        \
    \    if minPath == nil or path < minPath then\n                minPath = path\n\
    \            end\n        end\n        return minPath\n    end\n    local minPath\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = dfs(i, j, k, {})\n            if minPath == nil or path < minPath then\n \
    \               minPath = path\n            end\n        end\n    end\n    return\
    \ minPath\nend", "    local n = #grid\n    local function isValid(x, y)\n    \
    \    return x >= 1 and x <= n and y >= 1 and y <= n\n    end\n    local function\
    \ getNeighbors(x, y)\n        local neighbors = {}\n        for _, d in ipairs({{-1,\
    \ 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local nx, ny = x + d[1], y + d[2]\n\
    \            if isValid(nx, ny) then\n                table.insert(neighbors,\
    \ {nx, ny})\n            end\n        end\n        return neighbors\n    end\n\
    \    local function getPath(x, y, k)\n        local path = {}\n        local function\
    \ dfs(x, y, k)\n            if k == 0 then\n                return true\n    \
    \        end\n            for _, n in ipairs(getNeighbors(x, y)) do\n        \
    \        local nx, ny = n[1], n[2]\n                if not path[nx] or not path[nx][ny]\
    \ then\n                    path[nx] = path[nx] or {}\n                    path[nx][ny]\
    \ = true\n                    if dfs(nx, ny, k - 1) then\n                   \
    \     return true\n                    end\n                    path[nx][ny] =\
    \ nil\n                end\n            end\n            return false\n      \
    \  end\n        dfs(x, y, k)\n        return path\n    end\n    local function\
    \ getPathValues(path)\n        local values = {}\n        for x, row in ipairs(path)\
    \ do\n            for y, _ in pairs(row) do\n                table.insert(values,\
    \ grid[x][y])\n            end\n        end\n        return values\n    end\n\
    \    local function compare(values1, values2)\n        for i = 1, #values1 do\n\
    \            if values1[i] < values2[i] then\n                return true\n  \
    \          elseif values1[i] > values2[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end\n    local minPathValues\n\
    \    for x = 1, n do\n        for y = 1", "    local n = #grid\n    local function\
    \ get_neighbors(i, j)\n        local neighbors = {}\n        if i > 1 then\n \
    \           neighbors[#neighbors + 1] = {i - 1, j}\n        end\n        if i\
    \ < n then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n\
    \        if j > 1 then\n            neighbors[#neighbors + 1] = {i, j - 1}\n \
    \       end\n        if j < n then\n            neighbors[#neighbors + 1] = {i,\
    \ j + 1}\n        end\n        return neighbors\n    end\n    local function get_path(i,\
    \ j, k)\n        local path = {}\n        local function dfs(i, j, k)\n      \
    \      if k == 0 then\n                return true\n            end\n        \
    \    for _, neighbor in ipairs(get_neighbors(i, j)) do\n                local\
    \ ni, nj = neighbor[1], neighbor[2]\n                if not path[ni] or not path[ni][nj]\
    \ then\n                    path[ni] = path[ni] or {}\n                    path[ni][nj]\
    \ = true\n                    if dfs(ni, nj, k - 1) then\n                   \
    \     return true\n                    end\n                    path[ni][nj] =\
    \ nil\n                end\n            end\n            return false\n      \
    \  end\n        path[i] = path[i] or {}\n        path[i][j] = true\n        dfs(i,\
    \ j, k - 1)\n        return path\n    end\n    local function get_path_values(path)\n\
    \        local values = {}\n        for i, row in ipairs(path) do\n          \
    \  for j, _ in pairs(row) do\n                values[#values + 1] = grid[i][j]\n\
    \            end\n        end\n        return values\n    end\n    local min_path,\
    \ min_path_values\n    for i = 1, n do\n        for j = 1, n do\n            local\
    \ path = get_path(i, j, k)\n            local path_values = get_path_values(path)\n\
    \            if not min_path_values or path_values <", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if x\
    \ < n then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if y > 1 then\n            neighbors[#neighbors + 1] = {x, y - 1}\n \
    \       end\n        if y < n then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function get_path(x,\
    \ y, k)\n        local path = {}\n        local function dfs(x, y, k)\n      \
    \      if k == 0 then\n                return true\n            end\n        \
    \    for _, neighbor in ipairs(get_neighbors(x, y)) do\n                local\
    \ nx, ny = neighbor[1], neighbor[2]\n                if not path[nx] or not path[nx][ny]\
    \ then\n                    path[nx] = path[nx] or {}\n                    path[nx][ny]\
    \ = true\n                    if dfs(nx, ny, k - 1) then\n                   \
    \     return true\n                    end\n                    path[nx][ny] =\
    \ nil\n                end\n            end\n            return false\n      \
    \  end\n        dfs(x, y, k)\n        return path\n    end\n    local min_path\n\
    \    for x = 1, n do\n        for y = 1, n do\n            local path = get_path(x,\
    \ y, k)\n            if path then\n                local values = {}\n       \
    \         for i = 1, n do\n                    for j = 1, n do\n             \
    \           if path[i] and path[i][j] then\n                            values[#values\
    \ + 1] = get(i, j)\n                        end\n                    end\n   \
    \             end\n                if not min_path or values < min_path then\n\
    \                    min_path = values\n                end\n            end\n\
    \        end\n    end\n   ", "    local N = #grid\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {grid[i][j]}\n        end\n\
    \        local paths = {}\n        if i > 1 then\n            paths[#paths + 1]\
    \ = get_path(i - 1, j, k - 1)\n        end\n        if i < N then\n          \
    \  paths[#paths + 1] = get_path(i + 1, j, k - 1)\n        end\n        if j >\
    \ 1 then\n            paths[#paths + 1] = get_path(i, j - 1, k - 1)\n        end\n\
    \        if j < N then\n            paths[#paths + 1] = get_path(i, j + 1, k -\
    \ 1)\n        end\n        local min_path = paths[1]\n        for i = 2, #paths\
    \ do\n            if paths[i] < min_path then\n                min_path = paths[i]\n\
    \            end\n        end\n        min_path[#min_path + 1] = grid[i][j]\n\
    \        return min_path\n    end\n    local min_path = get_path(1, 1, k)\n  \
    \  for i = 1, N do\n        for j = 1, N do\n            local path = get_path(i,\
    \ j, k)\n            if path < min_path then\n                min_path = path\n\
    \            end\n        end\n    end\n    return min_path\nend", "    -- Write\
    \ your code here\n    return {}\nend", "    local N = #grid\n    local function\
    \ isValid(x, y)\n        return x >= 1 and x <= N and y >= 1 and y <= N\n    end\n\
    \    local function getValue(x, y)\n        return grid[x][y]\n    end\n    local\
    \ function getNeighbors(x, y)\n        local neighbors = {}\n        if isValid(x\
    \ - 1, y) then\n            neighbors[#neighbors + 1] = {x - 1, y}\n        end\n\
    \        if isValid(x + 1, y) then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if isValid(x, y - 1) then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if isValid(x, y + 1) then\n        \
    \    neighbors[#neighbors + 1] = {x, y + 1}\n        end\n        return neighbors\n\
    \    end\n    local function compare(a, b)\n        for i = 1, #a do\n       \
    \     if a[i] < b[i] then\n                return true\n            elseif a[i]\
    \ > b[i] then\n                return false\n            end\n        end\n  \
    \      return false\n    end\n    local function dfs(x, y, path, visited)\n  \
    \      if #path == k then\n            if not result or compare(path, result)\
    \ then\n                result = path\n            end\n            return\n \
    \       end\n        for _, neighbor in ipairs(getNeighbors(x, y)) do\n      \
    \      local nx, ny = neighbor[1], neighbor[2]\n            if not visited[nx][ny]\
    \ then\n                visited[nx][ny] = true\n                dfs(nx, ny, {unpack(path),\
    \ getValue(nx, ny)}, visited)\n                visited[nx][ny] = false\n     \
    \       end\n        end\n    end\n    local result\n    for i = 1, N do\n   \
    \     for j = 1, N do\n            local visited = {}\n            for i = 1,\
    \ N do\n                visited[i] = {}\n            end\n            visited[i][j]\
    \ = true\n", "    local n = #grid\n    local m = #grid[1]\n    local function\
    \ get(i, j)\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local res = {}\n        if i > 1 then\n            res[#res + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            res[#res + 1]\
    \ = {i + 1, j}\n        end\n        if j > 1 then\n            res[#res + 1]\
    \ = {i, j - 1}\n        end\n        if j < m then\n            res[#res + 1]\
    \ = {i, j + 1}\n        end\n        return res\n    end\n    local function get_path(i,\
    \ j, k)\n        local res = {}\n        local function dfs(i, j, k)\n       \
    \     if k == 0 then\n                return\n            end\n            res[#res\
    \ + 1] = get(i, j)\n            for _, v in ipairs(get_neighbors(i, j)) do\n \
    \               dfs(v[1], v[2], k - 1)\n            end\n        end\n       \
    \ dfs(i, j, k)\n        return res\n    end\n    local function compare(a, b)\n\
    \        for i = 1, k do\n            if a[i] < b[i] then\n                return\
    \ true\n            elseif a[i] > b[i] then\n                return false\n  \
    \          end\n        end\n        return false\n    end\n    local res = {}\n\
    \    for i = 1, n do\n        for j = 1, m do\n            local path = get_path(i,\
    \ j, k)\n            if #res == 0 or compare(path, res) then\n               \
    \ res = path\n            end\n        end\n    end\n    return res\nend", " \
    \   local n = #grid\n    local function get(i, j)\n        return grid[i][j]\n\
    \    end\n    local function get_neighbors(i, j)\n        local res = {}\n   \
    \     if i > 1 then\n            res[#res + 1] = {i - 1, j}\n        end\n   \
    \     if i < n then\n            res[#res + 1] = {i + 1, j}\n        end\n   \
    \     if j > 1 then\n            res[#res + 1] = {i, j - 1}\n        end\n   \
    \     if j < n then\n            res[#res + 1] = {i, j + 1}\n        end\n   \
    \     return res\n    end\n    local function lex_less(a, b)\n        for i =\
    \ 1, #a do\n            if a[i] < b[i] then\n                return true\n   \
    \         elseif a[i] > b[i] then\n                return false\n            end\n\
    \        end\n        return false\n    end\n    local function lex_min(a, b)\n\
    \        if lex_less(a, b) then\n            return a\n        else\n        \
    \    return b\n        end\n    end\n    local function dfs(i, j, k, path)\n \
    \       if k == 0 then\n            return path\n        end\n        local neighbors\
    \ = get_neighbors(i, j)\n        local min_path = nil\n        for _, neighbor\
    \ in ipairs(neighbors) do\n            local new_path = dfs(neighbor[1], neighbor[2],\
    \ k - 1, path)\n            if min_path == nil then\n                min_path\
    \ = new_path\n            else\n                min_path = lex_min(min_path, new_path)\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local new_path\
    \ = dfs(i, j, k, {get(i, j)})\n            if min_path == nil then\n         \
    \       min_path = new_path\n            else\n                min_path = lex_min(min_path,\
    \ new_path)\n", "    local n = #grid\n    local m = {}\n    for i = 1, n do\n\
    \        m[i] = {}\n        for j = 1, n do\n            m[i][j] = {grid[i][j]}\n\
    \        end\n    end\n    for i = 1, k - 1 do\n        local t = {}\n       \
    \ for j = 1, n do\n            t[j] = {}\n            for l = 1, n do\n      \
    \          t[j][l] = {}\n            end\n        end\n        for j = 1, n do\n\
    \            for l = 1, n do\n                local x = m[j][l]\n            \
    \    local y = t[j][l]\n                if j > 1 then\n                    local\
    \ z = m[j - 1][l]\n                    for _, v in ipairs(z) do\n            \
    \            table.insert(y, v)\n                    end\n                end\n\
    \                if j < n then\n                    local z = m[j + 1][l]\n  \
    \                  for _, v in ipairs(z) do\n                        table.insert(y,\
    \ v)\n                    end\n                end\n                if l > 1 then\n\
    \                    local z = m[j][l - 1]\n                    for _, v in ipairs(z)\
    \ do\n                        table.insert(y, v)\n                    end\n  \
    \              end\n                if l < n then\n                    local z\
    \ = m[j][l + 1]\n                    for _, v in ipairs(z) do\n              \
    \          table.insert(y, v)\n                    end\n                end\n\
    \                table.sort(y)\n                for _, v in ipairs(x) do\n   \
    \                 table.insert(y, v)\n                end\n                for\
    \ _, v in ipairs(y) do\n                    table.insert(x, v)\n             \
    \   end\n            end\n        end\n        m = t\n    end\n    local ans =\
    \ {}\n    for i = 1, n do\n        for j = 1, n do\n            local x = m[i][j]\n\
    \            if #ans == 0 or x[1] < ans[1] then\n                ans = x\n   \
    \         end\n        end\n    end\n    return ans\nend", "    local n = #grid\n\
    \    local function get(i, j)\n        return grid[i][j]\n    end\n    local function\
    \ get_neighbors(i, j)\n        local neighbors = {}\n        if i > 1 then\n \
    \           neighbors[#neighbors + 1] = {i - 1, j}\n        end\n        if i\
    \ < n then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n\
    \        if j > 1 then\n            neighbors[#neighbors + 1] = {i, j - 1}\n \
    \       end\n        if j < n then\n            neighbors[#neighbors + 1] = {i,\
    \ j + 1}\n        end\n        return neighbors\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ neighbors = get_neighbors(i, j)\n        local min_path = nil\n        for _,\
    \ neighbor in ipairs(neighbors) do\n            local path = get_path(neighbor[1],\
    \ neighbor[2], k - 1)\n            if path then\n                path[#path +\
    \ 1] = get(i, j)\n                if not min_path or path < min_path then\n  \
    \                  min_path = path\n                end\n            end\n   \
    \     end\n        return min_path\n    end\n    local min_path = nil\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            local path = get_path(i, j,\
    \ k)\n            if path then\n                path[#path + 1] = get(i, j)\n\
    \                if not min_path or path < min_path then\n                   \
    \ min_path = path\n                end\n            end\n        end\n    end\n\
    \    return min_path\nend", "    local n = #grid\n    local function get(i, j)\n\
    \        return grid[i][j]\n    end\n    local function set(i, j, v)\n       \
    \ grid[i][j] = v\n    end\n    local function get_neighbors(i, j)\n        local\
    \ neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function less(a, b)\n        for i = 1, k do\n            if a[i] < b[i] then\n\
    \                return true\n            elseif a[i] > b[i] then\n          \
    \      return false\n            end\n        end\n        return false\n    end\n\
    \    local function get_min_path(i, j, k)\n        if k == 0 then\n          \
    \  return {}\n        end\n        local min_path = {get(i, j)}\n        local\
    \ neighbors = get_neighbors(i, j)\n        for _, neighbor in ipairs(neighbors)\
    \ do\n            local path = get_min_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if less(path, min_path) then\n                min_path = path\n \
    \           end\n        end\n        min_path[#min_path + 1] = get(i, j)\n  \
    \      return min_path\n    end\n    local min_path = {get(1, 1)}\n    for i =\
    \ 1, n do\n        for j = 1, n do\n            local path = get_min_path(i, j,\
    \ k)\n            if less(path, min_path) then\n                min_path = path\n\
    \            end\n        end\n    end\n    return min_path\nend", "    local\
    \ N = #grid\n    local function get(x, y)\n        return grid[x][y]\n    end\n\
    \    local function set(x, y, v)\n        grid[x][y] = v\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if x\
    \ < N then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if y > 1 then\n            neighbors[#neighbors + 1] = {x, y - 1}\n \
    \       end\n        if y < N then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function get_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x, y)) do\n\
    \            local path = get_path(neighbor[1], neighbor[2], k - 1)\n        \
    \    if path then\n                path[#path + 1] = get(x, y)\n             \
    \   if not min_path or path < min_path then\n                    min_path = path\n\
    \                end\n            end\n        end\n        return min_path\n\
    \    end\n    for x = 1, N do\n        for y = 1, N do\n            local path\
    \ = get_path(x, y, k)\n            if path then\n                return path\n\
    \            end\n        end\n    end\nend", "    local n = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local res = {}\n        if x > 1 then\n            res[#res + 1]\
    \ = {x - 1, y}\n        end\n        if x < n then\n            res[#res + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            res[#res + 1]\
    \ = {x, y - 1}\n        end\n        if y < n then\n            res[#res + 1]\
    \ = {x, y + 1}\n        end\n        return res\n    end\n    local function get_value(x,\
    \ y)\n        return grid[x][y]\n    end\n    local function get_path(x, y, k)\n\
    \        local res = {}\n        local cur = {x, y}\n        for i = 1, k do\n\
    \            res[i] = get_value(cur[1], cur[2])\n            local neighbors =\
    \ get_neighbors(cur[1], cur[2])\n            local min_neighbor = neighbors[1]\n\
    \            for j = 2, #neighbors do\n                if get_value(neighbors[j][1],\
    \ neighbors[j][2]) < get_value(min_neighbor[1], min_neighbor[2]) then\n      \
    \              min_neighbor = neighbors[j]\n                end\n            end\n\
    \            cur = min_neighbor\n        end\n        return res\n    end\n  \
    \  local min_path = get_path(1, 1, k)\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local path = get_path(i, j, k)\n            if path < min_path\
    \ then\n                min_path = path\n            end\n        end\n    end\n\
    \    return min_path\nend", "    local n = #grid\n    local function get(i, j)\n\
    \        if i < 1 or i > n or j < 1 or j > n then\n            return math.huge\n\
    \        end\n        return grid[i][j]\n    end\n    local function cmp(a, b)\n\
    \        for i = 1, k do\n            if a[i] < b[i] then\n                return\
    \ true\n            elseif a[i] > b[i] then\n                return false\n  \
    \          end\n        end\n        return false\n    end\n    local function\
    \ dfs(i, j, k, path)\n        if k == 0 then\n            return path\n      \
    \  end\n        local min = {math.huge}\n        local function update(i, j, path)\n\
    \            local new_path = table.copy(path)\n            table.insert(new_path,\
    \ get(i, j))\n            if cmp(new_path, min) then\n                min = new_path\n\
    \            end\n        end\n        update(i - 1, j, path)\n        update(i\
    \ + 1, j, path)\n        update(i, j - 1, path)\n        update(i, j + 1, path)\n\
    \        return min\n    end\n    local min = {math.huge}\n    for i = 1, n do\n\
    \        for j = 1, n do\n            local path = dfs(i, j, k, {})\n        \
    \    if cmp(path, min) then\n                min = path\n            end\n   \
    \     end\n    end\n    return min\nend", "    local n = #grid\n    local min_path\
    \ = {}\n    local min_path_sum = math.huge\n    local function dfs(i, j, path,\
    \ path_sum)\n        if i < 1 or i > n or j < 1 or j > n then\n            return\n\
    \        end\n        if #path == k then\n            if path_sum < min_path_sum\
    \ then\n                min_path_sum = path_sum\n                min_path = path\n\
    \            end\n            return\n        end\n        table.insert(path,\
    \ grid[i][j])\n        path_sum = path_sum + grid[i][j]\n        dfs(i - 1, j,\
    \ path, path_sum)\n        dfs(i + 1, j, path, path_sum)\n        dfs(i, j - 1,\
    \ path, path_sum)\n        dfs(i, j + 1, path, path_sum)\n        table.remove(path)\n\
    \    end\n    for i = 1, n do\n        for j = 1, n do\n            dfs(i, j,\
    \ {}, 0)\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get_neighbors(i, j)\n        local res = {}\n        if i\
    \ > 1 then\n            res[#res + 1] = {i - 1, j}\n        end\n        if i\
    \ < n then\n            res[#res + 1] = {i + 1, j}\n        end\n        if j\
    \ > 1 then\n            res[#res + 1] = {i, j - 1}\n        end\n        if j\
    \ < n then\n            res[#res + 1] = {i, j + 1}\n        end\n        return\
    \ res\n    end\n    local function get_path(i, j, k)\n        if k == 0 then\n\
    \            return {}\n        end\n        local res = {}\n        for _, n\
    \ in ipairs(get_neighbors(i, j)) do\n            local path = get_path(n[1], n[2],\
    \ k - 1)\n            if #path > 0 then\n                path[#path + 1] = grid[i][j]\n\
    \                res[#res + 1] = path\n            end\n        end\n        if\
    \ #res == 0 then\n            return {}\n        end\n        table.sort(res,\
    \ function(a, b)\n            for i = 1, k + 1 do\n                if a[i] < b[i]\
    \ then\n                    return true\n                elseif a[i] > b[i] then\n\
    \                    return false\n                end\n            end\n    \
    \        return false\n        end)\n        return res[1]\n    end\n    local\
    \ res = {}\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if #path > 0 then\n                path[#path\
    \ + 1] = grid[i][j]\n                res[#res + 1] = path\n            end\n \
    \       end\n    end\n    if #res == 0 then\n        return {}\n    end\n    table.sort(res,\
    \ function(a, b)\n        for i = 1, k + 1 do\n            if a[i] < b[i] then\n\
    \                return true\n            elseif a[i] > b[i] then", "    local\
    \ n = #grid\n    local function get_cell(i, j)\n        return grid[i][j]\n  \
    \  end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n\
    \        if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n \
    \       end\n        if i < n then\n            neighbors[#neighbors + 1] = {i\
    \ + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local path = {}\n        local min_path = {}\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local neighbor_path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if #neighbor_path <\
    \ #min_path or #min_path == 0 then\n                path[1] = get_cell(i, j)\n\
    \                for i = 1, #neighbor_path do\n                    path[i + 1]\
    \ = neighbor_path[i]\n                end\n                min_path = path\n \
    \           end\n        end\n        return min_path\n    end\n    local min_path\
    \ = {}\n    for i = 1, n do\n        for j = 1, n do\n            local path =\
    \ get_path(i, j, k)\n            if #path < #min_path or #min_path == 0 then\n\
    \                min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend", "    local n = #grid\n    local function dfs(i, j, k, path)\n\
    \        if k == 0 then\n            return path\n        end\n        local min_path\
    \ = nil\n        if i > 1 then\n            local new_path = dfs(i - 1, j, k -\
    \ 1, path .. grid[i - 1][j])\n            if not min_path or new_path < min_path\
    \ then\n                min_path = new_path\n            end\n        end\n  \
    \      if i < n then\n            local new_path = dfs(i + 1, j, k - 1, path ..\
    \ grid[i + 1][j])\n            if not min_path or new_path < min_path then\n \
    \               min_path = new_path\n            end\n        end\n        if\
    \ j > 1 then\n            local new_path = dfs(i, j - 1, k - 1, path .. grid[i][j\
    \ - 1])\n            if not min_path or new_path < min_path then\n           \
    \     min_path = new_path\n            end\n        end\n        if j < n then\n\
    \            local new_path = dfs(i, j + 1, k - 1, path .. grid[i][j + 1])\n \
    \           if not min_path or new_path < min_path then\n                min_path\
    \ = new_path\n            end\n        end\n        return min_path\n    end\n\
    \    local min_path = nil\n    for i = 1, n do\n        for j = 1, n do\n    \
    \        local new_path = dfs(i, j, k, tostring(grid[i][j]))\n            if not\
    \ min_path or new_path < min_path then\n                min_path = new_path\n\
    \            end\n        end\n    end\n    local res = {}\n    for i = 1, k do\n\
    \        res[i] = tonumber(min_path:sub(i, i))\n    end\n    return res\nend",
  "    local N = #grid\n    local min_path = {}\n    local min_path_value = math.huge\n\
    \    local function dfs(i, j, path, path_value)\n        if #path == k then\n\
    \            if path_value < min_path_value then\n                min_path = path\n\
    \                min_path_value = path_value\n            end\n            return\n\
    \        end\n        if i > 1 then\n            dfs(i - 1, j, {unpack(path),\
    \ grid[i - 1][j]}, path_value * N + grid[i - 1][j])\n        end\n        if i\
    \ < N then\n            dfs(i + 1, j, {unpack(path), grid[i + 1][j]}, path_value\
    \ * N + grid[i + 1][j])\n        end\n        if j > 1 then\n            dfs(i,\
    \ j - 1, {unpack(path), grid[i][j - 1]}, path_value * N + grid[i][j - 1])\n  \
    \      end\n        if j < N then\n            dfs(i, j + 1, {unpack(path), grid[i][j\
    \ + 1]}, path_value * N + grid[i][j + 1])\n        end\n    end\n    for i = 1,\
    \ N do\n        for j = 1, N do\n            dfs(i, j, {grid[i][j]}, grid[i][j])\n\
    \        end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ min = {}\n    local min_sum = math.huge\n    local function dfs(i, j, path,\
    \ sum)\n        if #path == k then\n            if sum < min_sum then\n      \
    \          min_sum = sum\n                min = path\n            elseif sum ==\
    \ min_sum then\n                for i = 1, k do\n                    if path[i]\
    \ < min[i] then\n                        min = path\n                        break\n\
    \                    elseif path[i] > min[i] then\n                        break\n\
    \                    end\n                end\n            end\n            return\n\
    \        end\n        if i > 1 then\n            dfs(i - 1, j, {unpack(path),\
    \ grid[i - 1][j]}, sum + grid[i - 1][j])\n        end\n        if i < n then\n\
    \            dfs(i + 1, j, {unpack(path), grid[i + 1][j]}, sum + grid[i + 1][j])\n\
    \        end\n        if j > 1 then\n            dfs(i, j - 1, {unpack(path),\
    \ grid[i][j - 1]}, sum + grid[i][j - 1])\n        end\n        if j < n then\n\
    \            dfs(i, j + 1, {unpack(path), grid[i][j + 1]}, sum + grid[i][j + 1])\n\
    \        end\n    end\n    for i = 1, n do\n        for j = 1, n do\n        \
    \    dfs(i, j, {grid[i][j]}, grid[i][j])\n        end\n    end\n    return min\n\
    end", "    local n = #grid\n    local function get(x, y)\n        if x < 1 or\
    \ x > n or y < 1 or y > n then\n            return math.huge\n        end\n  \
    \      return grid[x][y]\n    end\n    local function get_neighbors(x, y)\n  \
    \      return {\n            {x - 1, y},\n            {x + 1, y},\n          \
    \  {x, y - 1},\n            {x, y + 1}\n        }\n    end\n    local function\
    \ get_path(x, y, k)\n        if k == 0 then\n            return {}\n        end\n\
    \        local min_path = nil\n        local min_value = math.huge\n        for\
    \ _, neighbor in ipairs(get_neighbors(x, y)) do\n            local neighbor_x,\
    \ neighbor_y = neighbor[1], neighbor[2]\n            local neighbor_value = get(neighbor_x,\
    \ neighbor_y)\n            if neighbor_value < min_value then\n              \
    \  local path = get_path(neighbor_x, neighbor_y, k - 1)\n                if path\
    \ then\n                    min_path = {neighbor_value}\n                    for\
    \ _, value in ipairs(path) do\n                        min_path[#min_path + 1]\
    \ = value\n                    end\n                    min_value = neighbor_value\n\
    \                end\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path = nil\n    local min_value = math.huge\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            local value = get(i, j)\n  \
    \          if value < min_value then\n                local path = get_path(i,\
    \ j, k - 1)\n                if path then\n                    min_path = {value}\n\
    \                    for _, value in ipairs(path) do\n                       \
    \ min_path[#min_path + 1] = value\n                    end\n                 \
    \   min_value = value\n                end\n            end\n        end\n   \
    \ end\n    return min_path\nend", "    local n = #grid\n    local function get(i,\
    \ j)\n        if i < 1 or i > n or j < 1 or j > n then\n            return nil\n\
    \        end\n        return grid[i][j]\n    end\n    local function get_neighbors(i,\
    \ j)\n        local neighbors = {}\n        local neighbor = get(i - 1, j)\n \
    \       if neighbor then\n            neighbors[#neighbors + 1] = neighbor\n \
    \       end\n        neighbor = get(i + 1, j)\n        if neighbor then\n    \
    \        neighbors[#neighbors + 1] = neighbor\n        end\n        neighbor =\
    \ get(i, j - 1)\n        if neighbor then\n            neighbors[#neighbors +\
    \ 1] = neighbor\n        end\n        neighbor = get(i, j + 1)\n        if neighbor\
    \ then\n            neighbors[#neighbors + 1] = neighbor\n        end\n      \
    \  return neighbors\n    end\n    local function get_min_neighbor(i, j)\n    \
    \    local neighbors = get_neighbors(i, j)\n        local min_neighbor = neighbors[1]\n\
    \        for _, neighbor in ipairs(neighbors) do\n            if neighbor < min_neighbor\
    \ then\n                min_neighbor = neighbor\n            end\n        end\n\
    \        return min_neighbor\n    end\n    local function get_min_path(i, j, k)\n\
    \        if k == 1 then\n            return {grid[i][j]}\n        end\n      \
    \  local min_path = nil\n        local min_neighbor = get_min_neighbor(i, j)\n\
    \        local neighbor_i, neighbor_j = nil, nil\n        for i = 1, n do\n  \
    \          for j = 1, n do\n                if grid[i][j] == min_neighbor then\n\
    \                    neighbor_i, neighbor_j = i, j\n                    break\n\
    \                end\n            end\n        end\n        local path = get_min_path(neighbor_i,\
    \ neighbor_j, k - 1)\n        path[#path + 1] = grid[i][j]\n        return path\n\
    \    end\n    local min_path = nil\n    for i = 1,", "    local n = #grid\n  \
    \  local m = #grid[1]\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function set(x, y, v)\n        grid[x][y] = v\n    end\n \
    \   local function is_valid(x, y)\n        return x >= 1 and x <= n and y >= 1\
    \ and y <= m\n    end\n    local function get_neighbors(x, y)\n        local neighbors\
    \ = {}\n        if is_valid(x - 1, y) then\n            neighbors[#neighbors +\
    \ 1] = {x - 1, y}\n        end\n        if is_valid(x + 1, y) then\n         \
    \   neighbors[#neighbors + 1] = {x + 1, y}\n        end\n        if is_valid(x,\
    \ y - 1) then\n            neighbors[#neighbors + 1] = {x, y - 1}\n        end\n\
    \        if is_valid(x, y + 1) then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function get_min_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x, y)) do\n\
    \            local neighbor_x, neighbor_y = neighbor[1], neighbor[2]\n       \
    \     local neighbor_value = get(neighbor_x, neighbor_y)\n            local path\
    \ = get_min_path(neighbor_x, neighbor_y, k - 1)\n            if path then\n  \
    \              path[#path + 1] = neighbor_value\n                if not min_path\
    \ or path < min_path then\n                    min_path = path\n             \
    \   end\n            end\n        end\n        return min_path\n    end\n    local\
    \ min_path = nil\n    for i = 1, n do\n        for j = 1, m do\n            local\
    \ path = get_min_path(i, j, k)\n            if path then\n                path[#path\
    \ + 1] = get(i, j)\n", "    local n = #grid\n    local function get(i, j)\n  \
    \      return grid[i][j]\n    end\n    local function get_neighbors(i, j)\n  \
    \      local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function dfs(i, j, path, visited)\n        if #path == k then\n\
    \            return path\n        end\n        local min_path = nil\n        for\
    \ _, neighbor in ipairs(get_neighbors(i, j)) do\n            local ni, nj = neighbor[1],\
    \ neighbor[2]\n            if not visited[ni][nj] then\n                visited[ni][nj]\
    \ = true\n                local new_path = dfs(ni, nj, {unpack(path), get(ni,\
    \ nj)}, visited)\n                if not min_path or compare(new_path, min_path)\
    \ then\n                    min_path = new_path\n                end\n       \
    \         visited[ni][nj] = false\n            end\n        end\n        return\
    \ min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local visited = {}\n            for i = 1, n do\n \
    \               visited[i] = {}\n            end\n            visited[i][j] =\
    \ true\n            local new_path = dfs(i, j, {get(i, j)}, visited)\n", "   \
    \ local N = #grid\n    local function get(x, y)\n        if x < 1 or x > N or\
    \ y < 1 or y > N then\n            return math.huge\n        end\n        return\
    \ grid[x][y]\n    end\n    local function get_neighbors(x, y)\n        return\
    \ {\n            {x - 1, y},\n            {x + 1, y},\n            {x, y - 1},\n\
    \            {x, y + 1},\n        }\n    end\n    local function get_path(x, y,\
    \ k)\n        if k == 0 then\n            return {get(x, y)}\n        end\n  \
    \      local min_path = {}\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_path(neighbor[1], neighbor[2], k - 1)\n\
    \            if #path < #min_path or #min_path == 0 then\n                min_path\
    \ = path\n            end\n        end\n        table.insert(min_path, 1, get(x,\
    \ y))\n        return min_path\n    end\n    return get_path(1, 1, k)\nend", " \
    \   local n = #grid\n    local function get_neighbors(x, y)\n        local res\
    \ = {}\n        if x > 1 then\n            res[#res + 1] = {x - 1, y}\n      \
    \  end\n        if x < n then\n            res[#res + 1] = {x + 1, y}\n      \
    \  end\n        if y > 1 then\n            res[#res + 1] = {x, y - 1}\n      \
    \  end\n        if y < n then\n            res[#res + 1] = {x, y + 1}\n      \
    \  end\n        return res\n    end\n    local function get_path(x, y, k)\n  \
    \      if k == 0 then\n            return {}\n        end\n        local res =\
    \ {}\n        for _, n in ipairs(get_neighbors(x, y)) do\n            local path\
    \ = get_path(n[1], n[2], k - 1)\n            if #path > 0 then\n             \
    \   res[#res + 1] = {grid[x][y], path}\n            end\n        end\n       \
    \ table.sort(res, function(a, b)\n            local lst_a = {a[1]}\n         \
    \   for _, v in ipairs(a[2]) do\n                lst_a[#lst_a + 1] = v\n     \
    \       end\n            local lst_b = {b[1]}\n            for _, v in ipairs(b[2])\
    \ do\n                lst_b[#lst_b + 1] = v\n            end\n            for\
    \ i = 1, #lst_a do\n                if lst_a[i] < lst_b[i] then\n            \
    \        return true\n                elseif lst_a[i] > lst_b[i] then\n      \
    \              return false\n                end\n            end\n          \
    \  return false\n        end)\n        return res[1][2]\n    end\n    local res\
    \ = get_path(1, 1, k)\n    res[#res + 1] = grid[1][1]\n    return res\nend", " \
    \   local n = #grid\n    local function get_neighbors(x, y)\n        local neighbors\
    \ = {}\n        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1,\
    \ y}\n        end\n        if x < n then\n            neighbors[#neighbors + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_paths(x, y, k)\n        local paths = {}\n        if k == 1 then\n\
    \            paths[#paths + 1] = {grid[x][y]}\n        else\n            for _,\
    \ neighbor in ipairs(get_neighbors(x, y)) do\n                local x1, y1 = neighbor[1],\
    \ neighbor[2]\n                for _, path in ipairs(get_paths(x1, y1, k - 1))\
    \ do\n                    paths[#paths + 1] = {grid[x][y]}\n                 \
    \   for _, v in ipairs(path) do\n                        paths[#paths][#paths[#paths]\
    \ + 1] = v\n                    end\n                end\n            end\n  \
    \      end\n        return paths\n    end\n    local min_path = {}\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            for _, path in ipairs(get_paths(i,\
    \ j, k)) do\n                if #min_path == 0 or path < min_path then\n     \
    \               min_path = path\n                end\n            end\n      \
    \  end\n    end\n    return min_path\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local res = {}\n        if x > 1 then\n            res[#res + 1]\
    \ = {x - 1, y}\n        end\n        if x < n then\n            res[#res + 1]\
    \ = {x + 1, y}\n        end\n        if y > 1 then\n            res[#res + 1]\
    \ = {x, y - 1}\n        end\n        if y < n then\n            res[#res + 1]\
    \ = {x, y + 1}\n        end\n        return res\n    end\n    local function dfs(x,\
    \ y, k, path)\n        if k == 0 then\n            return path\n        end\n\
    \        local neighbors = get_neighbors(x, y)\n        local min_path\n     \
    \   for _, neighbor in ipairs(neighbors) do\n            local nx, ny = neighbor[1],\
    \ neighbor[2]\n            local new_path = dfs(nx, ny, k - 1, path .. get(nx,\
    \ ny))\n            if min_path == nil or new_path < min_path then\n         \
    \       min_path = new_path\n            end\n        end\n        return min_path\n\
    \    end\n    local min_path\n    for i = 1, n do\n        for j = 1, n do\n \
    \           local path = dfs(i, j, k - 1, get(i, j))\n            if min_path\
    \ == nil or path < min_path then\n                min_path = path\n          \
    \  end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get(i, j)\n        return grid[i][j]\n    end\n    local function\
    \ get_neighbors(i, j)\n        local res = {}\n        if i > 1 then\n       \
    \     res[#res + 1] = {i - 1, j}\n        end\n        if i < n then\n       \
    \     res[#res + 1] = {i + 1, j}\n        end\n        if j > 1 then\n       \
    \     res[#res + 1] = {i, j - 1}\n        end\n        if j < n then\n       \
    \     res[#res + 1] = {i, j + 1}\n        end\n        return res\n    end\n \
    \   local function get_path(i, j, k)\n        if k == 0 then\n            return\
    \ {}\n        end\n        local res = {}\n        for _, n in ipairs(get_neighbors(i,\
    \ j)) do\n            local ni, nj = n[1], n[2]\n            local path = get_path(ni,\
    \ nj, k - 1)\n            if #path > 0 then\n                path[#path + 1] =\
    \ get(i, j)\n                res[#res + 1] = path\n            end\n        end\n\
    \        return res\n    end\n    local function compare(a, b)\n        for i\
    \ = 1, #a do\n            if a[i] < b[i] then\n                return true\n \
    \           elseif a[i] > b[i] then\n                return false\n          \
    \  end\n        end\n        return false\n    end\n    local function get_min(paths)\n\
    \        local res = paths[1]\n        for i = 2, #paths do\n            if compare(paths[i],\
    \ res) then\n                res = paths[i]\n            end\n        end\n  \
    \      return res\n    end\n    local res = {}\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local paths = get_path(i, j, k - 1)\n            if\
    \ #paths > 0 then\n                for _, path in ipairs(paths) do\n         \
    \           path[#path + 1] = get(i,", "    local n = #grid\n    local function\
    \ get(x, y)\n        return grid[x][y]\n    end\n    local function set(x, y,\
    \ v)\n        grid[x][y] = v\n    end\n    local function get_neighbors(x, y)\n\
    \        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < n then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y)\n        local path = {}\n        for i = 1, k do\n\
    \            path[i] = get(x, y)\n            local neighbors = get_neighbors(x,\
    \ y)\n            local min_neighbor = neighbors[1]\n            for _, neighbor\
    \ in ipairs(neighbors) do\n                if get(neighbor[1], neighbor[2]) <\
    \ get(min_neighbor[1], min_neighbor[2]) then\n                    min_neighbor\
    \ = neighbor\n                end\n            end\n            x, y = min_neighbor[1],\
    \ min_neighbor[2]\n        end\n        return path\n    end\n    local min_path\
    \ = get_path(1, 1)\n    for i = 1, n do\n        for j = 1, n do\n           \
    \ local path = get_path(i, j)\n            if path < min_path then\n         \
    \       min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    local n = #grid\n    local function get_neighbors(i, j)\n        local\
    \ neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors + 1]\
    \ = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local path = {}\n        local neighbors = get_neighbors(i,\
    \ j)\n        for _, neighbor in ipairs(neighbors) do\n            local neighbor_path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if #neighbor_path +\
    \ 1 < k then\n                path = neighbor_path\n                break\n  \
    \          end\n        end\n        path[#path + 1] = grid[i][j]\n        return\
    \ path\n    end\n    local min_path = {}\n    for i = 1, n do\n        for j =\
    \ 1, n do\n            local path = get_path(i, j, k)\n            if #path <\
    \ k then\n                min_path = path\n                break\n           \
    \ end\n        end\n    end\n    return min_path\nend", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local res = {}\n        if x > 1 then\n       \
    \     res[#res + 1] = {x - 1, y}\n        end\n        if x < n then\n       \
    \     res[#res + 1] = {x + 1, y}\n        end\n        if y > 1 then\n       \
    \     res[#res + 1] = {x, y - 1}\n        end\n        if y < n then\n       \
    \     res[#res + 1] = {x, y + 1}\n        end\n        return res\n    end\n \
    \   local function get_neighbors_values(x, y)\n        local res = {}\n      \
    \  for _, v in ipairs(get_neighbors(x, y)) do\n            res[#res + 1] = get(v[1],\
    \ v[2])\n        end\n        return res\n    end\n    local function get_min_neighbor(x,\
    \ y)\n        local min_value = math.huge\n        local min_x, min_y\n      \
    \  for _, v in ipairs(get_neighbors(x, y)) do\n            local value = get(v[1],\
    \ v[2])\n            if value < min_value then\n                min_value = value\n\
    \                min_x, min_y = v[1], v[2]\n            end\n        end\n   \
    \     return min_x, min_y\n    end\n    local function get_min_neighbor_value(x,\
    \ y)\n        local min_x, min_y = get_min_neighbor(x, y)\n        return get(min_x,\
    \ min_y)\n    end\n    local function get_min_neighbor_values(x, y)\n        local\
    \ res = {}\n        for _, v in ipairs(get_neighbors(x, y)) do\n            local\
    \ value = get(v[1], v[2])\n            if value == get_min_neighbor_value(x, y)\
    \ then\n                res[#res + 1] = value\n           ", "    local n = #grid\n\
    \    local function get(x, y)\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x - 1, y}\n        end\n        if x\
    \ < n then\n            neighbors[#neighbors + 1] = {x + 1, y}\n        end\n\
    \        if y > 1 then\n            neighbors[#neighbors + 1] = {x, y - 1}\n \
    \       end\n        if y < n then\n            neighbors[#neighbors + 1] = {x,\
    \ y + 1}\n        end\n        return neighbors\n    end\n    local function get_min_path(x,\
    \ y, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x, y)) do\n\
    \            local path = get_min_path(neighbor[1], neighbor[2], k - 1)\n    \
    \        if not min_path or path < min_path then\n                min_path = path\n\
    \            end\n        end\n        min_path[#min_path + 1] = get(x, y)\n \
    \       return min_path\n    end\n    local min_path = nil\n    for i = 1, n do\n\
    \        for j = 1, n do\n            local path = get_min_path(i, j, k)\n   \
    \         if not min_path or path < min_path then\n                min_path =\
    \ path\n            end\n        end\n    end\n    return min_path\nend", "  \
    \  local n = #grid\n    local function minPathRec(grid, k, i, j, visited)\n  \
    \      if k == 0 then\n            return {}\n        end\n        local minPath\
    \ = nil\n        for di = -1, 1 do\n            for dj = -1, 1 do\n          \
    \      if di ~= 0 or dj ~= 0 then\n                    local ni, nj = i + di,\
    \ j + dj\n                    if ni >= 1 and ni <= n and nj >= 1 and nj <= n then\n\
    \                        local nvisited = {}\n                        for k, v\
    \ in pairs(visited) do\n                            nvisited[k] = v\n        \
    \                end\n                        nvisited[ni * n + nj] = true\n \
    \                       local npath = minPathRec(grid, k - 1, ni, nj, nvisited)\n\
    \                        if npath then\n                            npath[#npath\
    \ + 1] = grid[i][j]\n                            if not minPath or npath < minPath\
    \ then\n                                minPath = npath\n                    \
    \        end\n                        end\n                    end\n         \
    \       end\n            end\n        end\n        return minPath\n    end\n \
    \   local minPath = nil\n    for i = 1, n do\n        for j = 1, n do\n      \
    \      local path = minPathRec(grid, k, i, j, {})\n            if path then\n\
    \                path[#path + 1] = grid[i][j]\n                if not minPath\
    \ or path < minPath then\n                    minPath = path\n               \
    \ end\n            end\n        end\n    end\n    return minPath\nend", "  local\
    \ n = #grid\n  local function get(i, j)\n    if i < 1 or i > n or j < 1 or j >\
    \ n then\n      return math.huge\n    end\n    return grid[i][j]\n  end\n  local\
    \ function get_path(i, j, k)\n    if k == 0 then\n      return {}, 0\n    end\n\
    \    local min_path, min_value = nil, math.huge\n    for di = -1, 1 do\n     \
    \ for dj = -1, 1 do\n        if di ~= 0 or dj ~= 0 then\n          local path,\
    \ value = get_path(i + di, j + dj, k - 1)\n          if value < min_value then\n\
    \            min_path, min_value = path, value\n          end\n        end\n \
    \     end\n    end\n    return {get(i, j)} .. min_path, min_value + get(i, j)\n\
    \  end\n  local min_path, min_value = nil, math.huge\n  for i = 1, n do\n    for\
    \ j = 1, n do\n      local path, value = get_path(i, j, k)\n      if value < min_value\
    \ then\n        min_path, min_value = path, value\n      end\n    end\n  end\n\
    \  return min_path\nend", "    local n = #grid\n    local m = {}\n    for i =\
    \ 1, n do\n        m[i] = {}\n        for j = 1, n do\n            m[i][j] = {grid[i][j]}\n\
    \        end\n    end\n    for i = 1, k - 1 do\n        local t = {}\n       \
    \ for j = 1, n do\n            t[j] = {}\n            for k = 1, n do\n      \
    \          t[j][k] = {}\n            end\n        end\n        for j = 1, n do\n\
    \            for k = 1, n do\n                local v = m[j][k]\n            \
    \    if j > 1 then\n                    local v1 = m[j - 1][k]\n             \
    \       if #v1 < #v or (#v1 == #v and v1[#v1] < v[#v]) then\n                \
    \        v = v1\n                    end\n                end\n              \
    \  if j < n then\n                    local v1 = m[j + 1][k]\n               \
    \     if #v1 < #v or (#v1 == #v and v1[#v1] < v[#v]) then\n                  \
    \      v = v1\n                    end\n                end\n                if\
    \ k > 1 then\n                    local v1 = m[j][k - 1]\n                   \
    \ if #v1 < #v or (#v1 == #v and v1[#v1] < v[#v]) then\n                      \
    \  v = v1\n                    end\n                end\n                if k\
    \ < n then\n                    local v1 = m[j][k + 1]\n                    if\
    \ #v1 < #v or (#v1 == #v and v1[#v1] < v[#v]) then\n                        v\
    \ = v1\n                    end\n                end\n                t[j][k]\
    \ = v\n                t[j][k][#v + 1] = grid[j][k]\n            end\n       \
    \ end\n        m = t\n    end\n    return m[1][1]\nend", "    local n = #grid\n\
    \    local function isValid(i, j)\n        return i >= 1 and i <= n and j >= 1\
    \ and j <= n\n    end\n    local function getNeighbors(i, j)\n        local neighbors\
    \ = {}\n        if isValid(i - 1, j) then\n            neighbors[#neighbors +\
    \ 1] = {i - 1, j}\n        end\n        if isValid(i + 1, j) then\n          \
    \  neighbors[#neighbors + 1] = {i + 1, j}\n        end\n        if isValid(i,\
    \ j - 1) then\n            neighbors[#neighbors + 1] = {i, j - 1}\n        end\n\
    \        if isValid(i, j + 1) then\n            neighbors[#neighbors + 1] = {i,\
    \ j + 1}\n        end\n        return neighbors\n    end\n    local function getPath(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ neighbors = getNeighbors(i, j)\n        local minPath = nil\n        for _,\
    \ neighbor in ipairs(neighbors) do\n            local path = getPath(neighbor[1],\
    \ neighbor[2], k - 1)\n            if path then\n                path[#path +\
    \ 1] = grid[i][j]\n                if not minPath or path < minPath then\n   \
    \                 minPath = path\n                end\n            end\n     \
    \   end\n        return minPath\n    end\n    local minPath = nil\n    for i =\
    \ 1, n do\n        for j = 1, n do\n            local path = getPath(i, j, k)\n\
    \            if path then\n                path[#path + 1] = grid[i][j]\n    \
    \            if not minPath or path < minPath then\n                    minPath\
    \ = path\n                end\n            end\n        end\n    end\n    return\
    \ minPath\nend", "    local N = #grid\n    local function get_neighbors(i, j)\n\
    \        local res = {}\n        if i > 1 then\n            table.insert(res,\
    \ {i - 1, j})\n        end\n        if i < N then\n            table.insert(res,\
    \ {i + 1, j})\n        end\n        if j > 1 then\n            table.insert(res,\
    \ {i, j - 1})\n        end\n        if j < N then\n            table.insert(res,\
    \ {i, j + 1})\n        end\n        return res\n    end\n    local function get_path(i,\
    \ j, k)\n        if k == 0 then\n            return {}\n        end\n        local\
    \ res = {}\n        for _, n in ipairs(get_neighbors(i, j)) do\n            local\
    \ ni, nj = n[1], n[2]\n            local path = get_path(ni, nj, k - 1)\n    \
    \        if #path > 0 then\n                table.insert(path, 1, grid[i][j])\n\
    \                if #res == 0 or path < res then\n                    res = path\n\
    \                end\n            end\n        end\n        return res\n    end\n\
    \    local res = {}\n    for i = 1, N do\n        for j = 1, N do\n          \
    \  local path = get_path(i, j, k)\n            if #path > 0 then\n           \
    \     if #res == 0 or path < res then\n                    res = path\n      \
    \          end\n            end\n        end\n    end\n    return res\nend", " \
    \   local n = #grid\n    local visited = {}\n    local function dfs(i, j, k, path)\n\
    \        if k == 0 then\n            return path\n        end\n        visited[i]\
    \ = visited[i] or {}\n        visited[i][j] = true\n        local min_path\n \
    \       if i > 1 and not visited[i - 1][j] then\n            min_path = dfs(i\
    \ - 1, j, k - 1, path .. grid[i - 1][j])\n        end\n        if i < n and not\
    \ visited[i + 1][j] then\n            local path = dfs(i + 1, j, k - 1, path ..\
    \ grid[i + 1][j])\n            if not min_path or path < min_path then\n     \
    \           min_path = path\n            end\n        end\n        if j > 1 and\
    \ not visited[i][j - 1] then\n            local path = dfs(i, j - 1, k - 1, path\
    \ .. grid[i][j - 1])\n            if not min_path or path < min_path then\n  \
    \              min_path = path\n            end\n        end\n        if j < n\
    \ and not visited[i][j + 1] then\n            local path = dfs(i, j + 1, k - 1,\
    \ path .. grid[i][j + 1])\n            if not min_path or path < min_path then\n\
    \                min_path = path\n            end\n        end\n        visited[i][j]\
    \ = false\n        return min_path\n    end\n    local min_path\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            local path = dfs(i, j, k, grid[i][j])\n\
    \            if not min_path or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n    end\n    return min_path\nend", " \
    \   local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(x, y)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            local new_path = {get(x, y)}\n                for _, value in ipairs(path)\
    \ do\n                    new_path[#new_path + 1] = value\n                end\n\
    \                if not min_path or new_path < min_path then\n               \
    \     min_path = new_path\n                end\n            end\n        end\n\
    \        return min_path\n    end\n    local min_path = nil\n    for i = 1, n\
    \ do\n        for j = 1, n do\n            local path = get_path(i, j, k)\n  \
    \          if path then\n                if not min_path or path < min_path then\n\
    \                    min_path = path\n                end\n            end\n \
    \       end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(i, j)\n        if i < 1 or i > n or j < 1 or j > n then\n     \
    \       return nil\n        end\n        return grid[i][j]\n    end\n    local\
    \ function get_neighbors(i, j)\n        local neighbors = {}\n        for _, d\
    \ in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local x, y = i\
    \ + d[1], j + d[2]\n            local v = get(x, y)\n            if v then\n \
    \               neighbors[v] = {x, y}\n            end\n        end\n        return\
    \ neighbors\n    end\n    local function get_path(i, j, k)\n        if k == 0\
    \ then\n            return {}\n        end\n        local neighbors = get_neighbors(i,\
    \ j)\n        local min_path = nil\n        for v, p in pairs(neighbors) do\n\
    \            local path = get_path(p[1], p[2], k - 1)\n            if path then\n\
    \                path[#path + 1] = v\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = grid[i][j]\n                if not min_path or path < min_path then\n \
    \                   min_path = path\n                end\n            end\n  \
    \      end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function less(a,\
    \ b)\n        for i = 1, k do\n            if a[i] < b[i] then\n             \
    \   return true\n            elseif a[i] > b[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end\n    local function\
    \ get_neighbors(x, y)\n        local neighbors = {}\n        if x > 1 then\n \
    \           neighbors[#neighbors + 1] = {x = x - 1, y = y}\n        end\n    \
    \    if x < n then\n            neighbors[#neighbors + 1] = {x = x + 1, y = y}\n\
    \        end\n        if y > 1 then\n            neighbors[#neighbors + 1] = {x\
    \ = x, y = y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x = x, y = y + 1}\n        end\n        return neighbors\n    end\n\
    \    local function get_path(x, y, k)\n        local path = {}\n        for i\
    \ = 1, k do\n            path[i] = get(x, y)\n            local neighbors = get_neighbors(x,\
    \ y)\n            local min_neighbor = neighbors[1]\n            for j = 2, #neighbors\
    \ do\n                if less(get_path(neighbors[j].x, neighbors[j].y, k - i),\n\
    \                        get_path(min_neighbor.x, min_neighbor.y, k - i)) then\n\
    \                    min_neighbor = neighbors[j]\n                end\n      \
    \      end\n            x = min_neighbor.x\n            y = min_neighbor.y\n \
    \       end\n        return path\n    end\n    return get_path(1, 1, k)\nend",
  "    local n = #grid\n    local function get(x, y)\n        return grid[x][y]\n\
    \    end\n    local function get_neighbors(x, y)\n        local neighbors = {}\n\
    \        if x > 1 then\n            neighbors[#neighbors + 1] = {x - 1, y}\n \
    \       end\n        if x < n then\n            neighbors[#neighbors + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < n then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(x, y, k)\n        if k == 0 then\n            return {}\n\
    \        end\n        local neighbors = get_neighbors(x, y)\n        local min_path\
    \ = nil\n        for _, neighbor in ipairs(neighbors) do\n            local path\
    \ = get_path(neighbor[1], neighbor[2], k - 1)\n            if path then\n    \
    \            path[#path + 1] = get(x, y)\n                if not min_path or path\
    \ < min_path then\n                    min_path = path\n                end\n\
    \            end\n        end\n        return min_path\n    end\n    local min_path\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local path\
    \ = get_path(i, j, k)\n            if path then\n                path[#path +\
    \ 1] = get(i, j)\n                if not min_path or path < min_path then\n  \
    \                  min_path = path\n                end\n            end\n   \
    \     end\n    end\n    return min_path\nend", "    local n = #grid\n    local\
    \ function get_neighbors(i, j)\n        local neighbors = {}\n        if i > 1\
    \ then table.insert(neighbors, {i - 1, j}) end\n        if i < n then table.insert(neighbors,\
    \ {i + 1, j}) end\n        if j > 1 then table.insert(neighbors, {i, j - 1}) end\n\
    \        if j < n then table.insert(neighbors, {i, j + 1}) end\n        return\
    \ neighbors\n    end\n    local function get_path(i, j, k)\n        local path\
    \ = {}\n        local function dfs(i, j, k)\n            if k == 0 then return\
    \ end\n            table.insert(path, grid[i][j])\n            local neighbors\
    \ = get_neighbors(i, j)\n            table.sort(neighbors, function(a, b)\n  \
    \              return grid[a[1]][a[2]] < grid[b[1]][b[2]]\n            end)\n\
    \            for _, neighbor in ipairs(neighbors) do\n                dfs(neighbor[1],\
    \ neighbor[2], k - 1)\n            end\n        end\n        dfs(i, j, k)\n  \
    \      return path\n    end\n    local min_path = get_path(1, 1, k)\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            local path = get_path(i, j,\
    \ k)\n            if path < min_path then min_path = path end\n        end\n \
    \   end\n    return min_path\nend", "    local n = #grid\n    local function get(i,\
    \ j)\n        return grid[i][j]\n    end\n    local function set(i, j, v)\n  \
    \      grid[i][j] = v\n    end\n    local function get_neighbors(i, j)\n     \
    \   local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i - 1, j}\n        end\n        if i < n then\n            neighbors[#neighbors\
    \ + 1] = {i + 1, j}\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = {i, j - 1}\n        end\n        if j < n then\n            neighbors[#neighbors\
    \ + 1] = {i, j + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function get_path(i, j)\n        local path = {}\n        local function dfs(i,\
    \ j)\n            if get(i, j) == -1 then\n                return\n          \
    \  end\n            path[#path + 1] = get(i, j)\n            set(i, j, -1)\n \
    \           for _, neighbor in ipairs(get_neighbors(i, j)) do\n              \
    \  dfs(unpack(neighbor))\n            end\n        end\n        dfs(i, j)\n  \
    \      return path\n    end\n    local function get_min_path(i, j)\n        local\
    \ path = get_path(i, j)\n        local min_path = path\n        for i = 1, n do\n\
    \            for j = 1, n do\n                local path = get_path(i, j)\n  \
    \              if path and #path == k then\n                    if path < min_path\
    \ then\n                        min_path = path\n                    end\n   \
    \             end\n            end\n        end\n        return min_path\n   \
    \ end\n    return get_min_path(1, 1)\nend", "    local n = #grid\n    local function\
    \ get(x, y)\n        if x < 1 or x > n or y < 1 or y > n then\n            return\
    \ math.huge\n        end\n        return grid[x][y]\n    end\n    local function\
    \ get_neighbors(x, y)\n        return {\n            {x = x - 1, y = y, val =\
    \ get(x - 1, y)},\n            {x = x + 1, y = y, val = get(x + 1, y)},\n    \
    \        {x = x, y = y - 1, val = get(x, y - 1)},\n            {x = x, y = y +\
    \ 1, val = get(x, y + 1)},\n        }\n    end\n    local function get_min_path(x,\
    \ y, k)\n        if k == 0 then\n            return {grid[x][y]}\n        end\n\
    \        local min_path = nil\n        for _, neighbor in ipairs(get_neighbors(x,\
    \ y)) do\n            local path = get_min_path(neighbor.x, neighbor.y, k - 1)\n\
    \            if not min_path or path < min_path then\n                min_path\
    \ = path\n            end\n        end\n        return {grid[x][y]} .. min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1, n\
    \ do\n            local path = get_min_path(i, j, k)\n            if not min_path\
    \ or path < min_path then\n                min_path = path\n            end\n\
    \        end\n    end\n    return min_path\nend", "    local N = #grid\n    local\
    \ function get(x, y)\n        return grid[x][y]\n    end\n    local function get_neighbors(x,\
    \ y)\n        local neighbors = {}\n        if x > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x - 1, y}\n        end\n        if x < N then\n            neighbors[#neighbors\
    \ + 1] = {x + 1, y}\n        end\n        if y > 1 then\n            neighbors[#neighbors\
    \ + 1] = {x, y - 1}\n        end\n        if y < N then\n            neighbors[#neighbors\
    \ + 1] = {x, y + 1}\n        end\n        return neighbors\n    end\n    local\
    \ function compare(a, b)\n        for i = 1, k do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    local function get_min(x, y, k)\n        local min = {get(x, y)}\n\
    \        for _, neighbor in ipairs(get_neighbors(x, y)) do\n            local\
    \ path = get_min(neighbor[1], neighbor[2], k - 1)\n            if compare(path,\
    \ min) then\n                min = path\n            end\n        end\n      \
    \  min[#min + 1] = get(x, y)\n        return min\n    end\n    local min = {get(1,\
    \ 1)}\n    for i = 1, N do\n        for j = 1, N do\n            local path =\
    \ get_min(i, j, k)\n            if compare(path, min) then\n                min\
    \ = path\n            end\n        end\n    end\n    return min\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
