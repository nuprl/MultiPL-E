language: lua
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz80v_8bw.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpz80v_8bw.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeovvtmcy.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpeovvtmcy.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 0
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  if is_good(lst[1])\
    \ and is_good(lst[2]) then\n    return 'Yes'\n  end\n  if is_good(lst[1] .. lst[2])\
    \ then\n    return 'Yes'\n  end\n  if is_good(lst[2] .. lst[1]) then\n    return\
    \ 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local cnt = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq_6l4_25.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpq_6l4_25.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local open, close = 0, 0\n    for i =\
    \ 1, #s1 do\n        if s1:sub(i, i) == '(' then\n            open = open + 1\n\
    \        else\n            close = close + 1\n        end\n    end\n    for i\
    \ = 1, #s2 do\n        if s2:sub(i, i) == '(' then\n            open = open +\
    \ 1\n        else\n            close = close + 1\n        end\n    end\n    if\
    \ open == close then\n        return 'Yes'\n    else\n        return 'No'\n  \
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnsjpa5s3.lua:50:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpnsjpa5s3.lua:50:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local cnt = 0\n    for i = 1, #s do\n \
    \     if s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt\
    \ = cnt - 1\n      end\n    end\n    return cnt\n  end\n  local function is_good(s)\n\
    \    return count_parens(s) == 0\n  end\n  local function concat(s1, s2)\n   \
    \ return s1 .. s2\n  end\n  local function concat_all(lst)\n    local res = ''\n\
    \    for _, s in ipairs(lst) do\n      res = concat(res, s)\n    end\n    return\
    \ res\n  end\n  local function permute(lst)\n    local res = {}\n    for i = 1,\
    \ #lst do\n      local s = lst[i]\n      local rest = {}\n      for j = 1, #lst\
    \ do\n        if j ~= i then\n          table.insert(rest, lst[j])\n        end\n\
    \      end\n      if #rest == 0 then\n        table.insert(res, {s})\n      else\n\
    \        for _, p in ipairs(permute(rest)) do\n          table.insert(res, {s,\
    \ unpack(p)})\n        end\n      end\n    end\n    return res\n  end\n  for _,\
    \ p in ipairs(permute(lst)) do\n    if is_good(concat_all(p)) then\n      return\
    \ 'Yes'\n    end\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl68o5fa3.lua:79:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpl68o5fa3.lua:79:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 < 0 then\n        return 'Yes'\n\
    \    elseif c1 < 0 and c2 == 0 then\n        return 'Yes'\n    elseif c1 < 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp87ve2ae6.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp87ve2ae6.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local n = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        n = n + 1\n      else\n        n = n - 1\n\
    \      end\n      if n < 0 then\n        return false\n      end\n    end\n  \
    \  return n == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp48nkg8s4.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp48nkg8s4.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdd218dlx.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpdd218dlx.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptthcqb2p.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptthcqb2p.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for c in s:gmatch('.') do\n\
    \      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0w_irecv.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp0w_irecv.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptthcqb2p.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptthcqb2p.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for c in str:gmatch('.')\
    \ do\n      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt =\
    \ cnt - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n\
    \    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr2tle7_v.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpr2tle7_v.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuj24yo1o.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpuj24yo1o.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local n = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        n = n + 1\n      else\n        n = n - 1\n\
    \      end\n      if n < 0 then\n        return false\n      end\n    end\n  \
    \  return n == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp48nkg8s4.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp48nkg8s4.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local c = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c -\
    \ 1\n      end\n    end\n    return c\n  end\n  local c1, c2 = count_parens(lst[1]),\
    \ count_parens(lst[2])\n  if c1 == 0 and c2 == 0 then\n    return 'Yes'\n  elseif\
    \ c1 * c2 < 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb6v27hwt.lua:41:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpb6v27hwt.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 0
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  if is_good(s1\
    \ .. s2) then\n    return 'Yes'\n  elseif is_good(s2 .. s1) then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdd218dlx.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpdd218dlx.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(str)\n    local count = 0\n    for c in str:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n    end\n    return count\n  end\n  local s1, s2 = lst[1],\
    \ lst[2]\n  local c1, c2 = count_parens(s1), count_parens(s2)\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 == 0 and c2 < 0 then\n    return\
    \ 'Yes'\n  elseif c1 > 0 and c2 == 0 then\n    return 'Yes'\n  elseif c1 > 0 and\
    \ c2 < 0 and c1 + c2 == 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptpe6egd8.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptpe6egd8.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
- exit_code: 1
  program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvvb5pfo8.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpvvb5pfo8.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750280
