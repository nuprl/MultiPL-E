name: HumanEval_144_simplify
language: lua
prompt: "-- Your task is to implement a function that will simplify the expression\n\
  -- x * n. The function returns True if x * n evaluates to a whole number and False\n\
  -- otherwise. Both x and n, are string representation of a fraction, and have the\
  \ following format,\n-- <numerator>/<denominator> where both numerator and denominator\
  \ are positive whole numbers.\n-- You can assume that x, and n are valid fractions,\
  \ and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n\
  -- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\n\
  local function simplify(x, n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n\
  \    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/6',\
  \ '2/1'), false)\n    lu.assertEquals(candidate('5/1', '3/1'), true)\n    lu.assertEquals(candidate('7/10',\
  \ '10/2'), false)\n    lu.assertEquals(candidate('2/10', '50/10'), true)\n    lu.assertEquals(candidate('7/2',\
  \ '4/2'), true)\n    lu.assertEquals(candidate('11/6', '6/1'), true)\n    lu.assertEquals(candidate('2/3',\
  \ '5/2'), false)\n    lu.assertEquals(candidate('5/2', '3/5'), false)\n    lu.assertEquals(candidate('2/4',\
  \ '8/4'), true)\n    lu.assertEquals(candidate('2/4', '4/2'), true)\n    lu.assertEquals(candidate('1/5',\
  \ '5/1'), true)\n    lu.assertEquals(candidate('1/5', '1/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n   \
    \ local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n    local numerator\
    \ = tonumber(x_numerator) * tonumber(n_denominator)\n    local denominator = tonumber(x_denominator)\
    \ * tonumber(n_numerator)\n    return numerator % denominator == 0\nend", "  local\
    \ x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n  local n_numerator, n_denominator\
    \ = n:match('(%d+)/(%d+)')\n  local numerator = x_numerator * n_numerator\n  local\
    \ denominator = x_denominator * n_denominator\n  local whole_number = numerator\
    \ / denominator\n  return whole_number % 1 == 0\nend", "  local function gcd(a,\
    \ b)\n    if b == 0 then return a end\n    return gcd(b, a % b)\n  end\n  local\
    \ function lcm(a, b)\n    return a * b / gcd(a, b)\n  end\n  local function parse(s)\n\
    \    local n, d = s:match('(%d+)/(%d+)')\n    return tonumber(n), tonumber(d)\n\
    \  end\n  local xn, xd = parse(x)\n  local nn, nd = parse(n)\n  return lcm(xd,\
    \ nd) % (xn * nn) == 0\nend", "    local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n\
    \    local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n    local numerator\
    \ = x_numerator * n_denominator\n    local denominator = x_denominator * n_numerator\n\
    \    local gcd = math.gcd(numerator, denominator)\n    return numerator / gcd\
    \ == denominator / gcd\nend", "  local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n\
    \  local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n  local numerator\
    \ = x_numerator * n_numerator\n  local denominator = x_denominator * n_denominator\n\
    \  local result = numerator / denominator\n  return result % 1 == 0\nend", " \
    \   -- your code here\nend", "  local function gcd(a, b)\n    if b == 0 then return\
    \ a end\n    return gcd(b, a % b)\n  end\n  local function lcm(a, b)\n    return\
    \ a * b / gcd(a, b)\n  end\n  local function to_number(s)\n    local a, b = s:match('(%d+)/(%d+)')\n\
    \    return tonumber(a) / tonumber(b)\n  end\n  local function to_fraction(n)\n\
    \    local a, b = math.modf(n)\n    if b == 0 then return tostring(a) .. '/1'\
    \ end\n    local g = gcd(a, b)\n    return tostring(a / g) .. '/' .. tostring(b\
    \ / g)\n  end\n  local function multiply(x, n)\n    return to_fraction(to_number(x)\
    \ * to_number(n))\n  end\n  local function is_whole_number(n)\n    return n:match('%d+/1')\
    \ ~= nil\n  end\n  return is_whole_number(multiply(x, n))\nend", "  local x_num,\
    \ x_den = x:match('(%d+)/(%d+)')\n  local n_num, n_den = n:match('(%d+)/(%d+)')\n\
    \  local x_num, x_den = tonumber(x_num), tonumber(x_den)\n  local n_num, n_den\
    \ = tonumber(n_num), tonumber(n_den)\n  local x_num, x_den = x_num * n_den, x_den\
    \ * n_num\n  local x_num, x_den = x_num / math.gcd(x_num, x_den), x_den / math.gcd(x_num,\
    \ x_den)\n  return x_num % x_den == 0\nend", "    local function gcd(a, b)\n \
    \       if b == 0 then\n            return a\n        else\n            return\
    \ gcd(b, a % b)\n        end\n    end", "    local x_numerator, x_denominator\
    \ = x:match('(%d+)/(%d+)')\n    local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n\
    \    local result_numerator = x_numerator * n_numerator\n    local result_denominator\
    \ = x_denominator * n_denominator\n    local result = result_numerator / result_denominator\n\
    \    return result % 1 == 0\nend", "    local function gcd(a, b)\n        if b\
    \ == 0 then\n            return a\n        else\n            return gcd(b, a %\
    \ b)\n        end\n    end", "  local function gcd(a, b)\n    if b == 0 then return\
    \ a end\n    return gcd(b, a % b)\n  end\n  local function lcm(a, b)\n    return\
    \ a * b / gcd(a, b)\n  end\n  local function simplify_fraction(x)\n    local numerator,\
    \ denominator = x:match('(%d+)/(%d+)')\n    local gcd_num_den = gcd(numerator,\
    \ denominator)\n    return numerator / gcd_num_den, denominator / gcd_num_den\n\
    \  end\n  local x_num, x_den = simplify_fraction(x)\n  local n_num, n_den = simplify_fraction(n)\n\
    \  local lcm_den = lcm(x_den, n_den)\n  local num = x_num * (lcm_den / x_den)\
    \ * n_num\n  local den = lcm_den\n  local gcd_num_den = gcd(num, den)\n  num =\
    \ num / gcd_num_den\n  den = den / gcd_num_den\n  return num % den == 0\nend",
  "  local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n  local n_numerator,\
    \ n_denominator = n:match('(%d+)/(%d+)')\n  local numerator = tonumber(x_numerator)\
    \ * tonumber(n_denominator)\n  local denominator = tonumber(x_denominator) * tonumber(n_numerator)\n\
    \  return numerator % denominator == 0\nend", "  local x_num, x_den = x:match('(%d+)/(%d+)')\n\
    \  local n_num, n_den = n:match('(%d+)/(%d+)')\n  local num = x_num * n_num\n\
    \  local den = x_den * n_den\n  local gcd = math.gcd(num, den)\n  return num /\
    \ gcd == den / gcd\nend", "  local x_num, x_den = x:match('(%d+)/(%d+)')\n  local\
    \ n_num, n_den = n:match('(%d+)/(%d+)')\n  local num = x_num * n_num\n  local\
    \ den = x_den * n_den\n  local gcd = math.gcd(num, den)\n  return den / gcd ==\
    \ num / gcd\nend", "  local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n\
    \  local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n  local result =\
    \ x_numerator * n_denominator * n_numerator * x_denominator\n  return result %\
    \ (x_denominator * n_denominator) == 0\nend", "  local x_numerator, x_denominator\
    \ = x:match('(%d+)/(%d+)')\n  local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n\
    \  local numerator = x_numerator * n_numerator\n  local denominator = x_denominator\
    \ * n_denominator\n  return numerator % denominator == 0\nend", "    local function\
    \ gcd(a, b)\n        while b ~= 0 do\n            local r = a % b\n          \
    \  a = b\n            b = r\n        end\n        return a\n    end\n    local\
    \ function lcm(a, b)\n        return a * b / gcd(a, b)\n    end\n    local function\
    \ simplify(x)\n        local numerator, denominator = x:match('(%d+)/(%d+)')\n\
    \        numerator, denominator = tonumber(numerator), tonumber(denominator)\n\
    \        local g = gcd(numerator, denominator)\n        return numerator / g,\
    \ denominator / g\n    end\n    local xn, xd = simplify(x)\n    local nn, nd =\
    \ simplify(n)\n    local l = lcm(xd, nd)\n    return (xn * l / xd) % (nn * l /\
    \ nd) == 0\nend", "    local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n\
    \    local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n    local numerator\
    \ = tonumber(x_numerator) * tonumber(n_denominator)\n    local denominator = tonumber(x_denominator)\
    \ * tonumber(n_numerator)\n    local result = numerator / denominator\n    return\
    \ result % 1 == 0\nend", "  local x_num, x_den = x:match('(%d+)/(%d+)')\n  local\
    \ n_num, n_den = n:match('(%d+)/(%d+)')\n  local num = x_num * n_num\n  local\
    \ den = x_den * n_den\n  local gcd = math.gcd(num, den)\n  return num / gcd ==\
    \ den / gcd\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
