name: HumanEval_10_make_palindrome
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Find the shortest palindrome that begins with a supplied string.\n\
  \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
  \ string that is a palindrome.\n    // - Append to the end of the string reverse\
  \ of a string prefix that comes before the palindromic suffix.\n    // >>> MakePalindrome((\"\
  \"))\n    // (\"\")\n    // >>> MakePalindrome((\"cat\"))\n    // (\"catac\")\n\
  \    // >>> MakePalindrome((\"cata\"))\n    // (\"catac\")\n    public static string\
  \ MakePalindrome(string str) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(MakePalindrome((\"\
  \")).Equals((\"\")));\n    Debug.Assert(MakePalindrome((\"x\")).Equals((\"x\")));\n\
  \    Debug.Assert(MakePalindrome((\"xyz\")).Equals((\"xyzyx\")));\n    Debug.Assert(MakePalindrome((\"\
  xyx\")).Equals((\"xyx\")));\n    Debug.Assert(MakePalindrome((\"jerry\")).Equals((\"\
  jerryrrej\")));\n    }\n\n}\n"
completions: ["        // Find the longest palindromic suffix of the string.\n   \
    \     int suffixLength = 0;\n        for (int i = 0; i < str.Length; i++) {\n\
    \            if (str[i] == str[str.Length - 1 - i]) {\n                suffixLength++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    // Append the reverse of the prefix to the end of the string.\n        return\
    \ str + new string(str.Substring(0, str.Length - suffixLength).Reverse().ToArray());",
  "        var longestPalindrome = LongestPalindrome(str);\n        var prefix = str.Substring(0,\
    \ str.Length - longestPalindrome.Length);\n        var prefixReversed = new string(prefix.Reverse().ToArray());\n\
    \        return str + prefixReversed;", "        if (str.Length == 0) {\n    \
    \        return str;\n        }\n        int n = str.Length;\n        int[] p\
    \ = new int[n];\n        p[0] = 0;\n        for (int i = 1; i < n; i++) {\n  \
    \          int j = p[i - 1];\n            while (j > 0 && str[i] != str[j]) {\n\
    \                j = p[j - 1];\n            }\n            if (str[i] == str[j])\
    \ {\n                j++;\n            }\n            p[i] = j;\n        }\n \
    \       int suffixLength = n - p[n - 1];\n        return str + str.Substring(suffixLength).Reverse();",
  "        // Find the longest palindromic suffix of the string.\n        int suffixLength\
    \ = 0;\n        for (int i = 0; i < str.Length; i++) {\n            if (str[i]\
    \ == str[str.Length - 1 - i]) {\n                suffixLength++;\n           \
    \ } else {\n                break;\n            }\n        }\n        // Append\
    \ the reverse of the prefix to the end of the string.\n        return str + new\
    \ string(str.Substring(0, str.Length - suffixLength).Reverse().ToArray());", " \
    \       var sb = new StringBuilder(str);\n        var suffix = new StringBuilder();\n\
    \        for (int i = str.Length - 1; i >= 0; i--) {\n            if (IsPalindrome(str.Substring(i)))\
    \ {\n                suffix.Append(str.Substring(0, i));\n                break;\n\
    \            }\n        }\n        sb.Append(suffix.ToString().Reverse());\n \
    \       return sb.ToString();", "        // Find the longest palindromic suffix.\n\
    \        int suffix_len = 0;\n        for (int i = 0; i < str.Length; i++) {\n\
    \            if (str[i] == str[str.Length - 1 - i]) {\n                suffix_len++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    // Append the reverse of the prefix to the end of the string.\n        return\
    \ str + new string(str.Substring(0, str.Length - suffix_len).Reverse().ToArray());",
  "        var sb = new StringBuilder(str);\n        var suffix = new StringBuilder();\n\
    \        for (int i = str.Length - 1; i >= 0; i--) {\n            if (IsPalindrome(str.Substring(i)))\
    \ {\n                suffix.Append(str.Substring(0, i));\n                break;\n\
    \            }\n        }\n        sb.Append(suffix.ToString().Reverse());\n \
    \       return sb.ToString();", "        if (str.Length == 0) {\n            return\
    \ str;\n        }\n        int palindromeLength = 0;\n        for (int i = 0;\
    \ i < str.Length; i++) {\n            if (str[i] == str[str.Length - 1 - i]) {\n\
    \                palindromeLength++;\n            } else {\n                break;\n\
    \            }\n        }\n        return str + new string(str.Take(str.Length\
    \ - palindromeLength).Reverse().ToArray());", "        var suffix = SuffixPalindrome(str);\n\
    \        var prefix = str.Substring(0, str.Length - suffix.Length);\n        var\
    \ reversed = new string(prefix.Reverse().ToArray());\n        return str + reversed;",
  "        // Find the longest palindromic suffix.\n        int suffix_length = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            if (str[i] == str[str.Length\
    \ - 1 - i]) {\n                suffix_length++;\n            } else {\n      \
    \          break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return str + new string(str.Substring(0, str.Length - suffix_length).Reverse().ToArray());",
  "        int n = str.Length;\n        if (n == 0) {\n            return \"\";\n\
    \        }\n        int[] z = new int[n];\n        z[0] = 0;\n        int l =\
    \ 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i > r) {\n\
    \                l = r = i;\n                while (r < n && str[r - l] == str[r])\
    \ {\n                    r++;\n                }\n                z[i] = r - l;\n\
    \                r--;\n            } else {\n                int k = i - l;\n\
    \                if (z[k] < r - i + 1) {\n                    z[i] = z[k];\n \
    \               } else {\n                    l = i;\n                    while\
    \ (r < n && str[r - l] == str[r]) {\n                        r++;\n          \
    \          }\n                    z[i] = r - l;\n                    r--;\n  \
    \              }\n            }\n        }\n        int max = 0;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (z[i] == n - i) {\n              \
    \  max = n - i;\n                break;\n            }\n        }\n        string\
    \ prefix = str.Substring(0, n - max);\n        StringBuilder sb = new StringBuilder();\n\
    \        for (int i = prefix.Length - 1; i >= 0; i--) {\n            sb.Append(prefix[i]);\n\
    \        }\n        return str + sb.ToString();", "        int n = str.Length;\n\
    \        int[] z = new int[n];\n        z[0] = n;\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n  \
    \          }\n            if (i + z[i] - 1 > r) {\n                l = i;\n  \
    \              r = i + z[i] - 1;\n            }\n        }\n        int max =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            if (z[i] == i) {\n  \
    \              max = i;\n            }\n        }\n        return str + new string(str.Substring(0,\
    \ n - max).Reverse().ToArray());", "        var sb = new StringBuilder(str);\n\
    \        var sb2 = new StringBuilder();\n        for (int i = str.Length - 1;\
    \ i >= 0; i--) {\n            sb2.Append(str[i]);\n            if (IsPalindrome(sb.ToString()\
    \ + sb2.ToString())) {\n                return sb.ToString() + sb2.ToString();\n\
    \            }\n        }\n        return \"\";", "        if (str.Length == 0)\
    \ {\n            return str;\n        }\n        int maxPalindromeLength = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            int palindromeLength\
    \ = 0;\n            for (int j = 0; j <= i; j++) {\n                if (str[i\
    \ - j] == str[i + j]) {\n                    palindromeLength += 1;\n        \
    \        } else {\n                    break;\n                }\n           \
    \ }\n            maxPalindromeLength = Math.Max(maxPalindromeLength, palindromeLength);\n\
    \        }\n        StringBuilder sb = new StringBuilder(str);\n        for (int\
    \ i = str.Length - maxPalindromeLength - 1; i >= 0; i--) {\n            sb.Append(str[i]);\n\
    \        }\n        return sb.ToString();", "        if (str.Length == 0) {\n\
    \            return str;\n        }\n        int n = str.Length;\n        int[]\
    \ p = new int[n];\n        int c = 0;\n        int r = 0;\n        for (int i\
    \ = 1; i < n; i++) {\n            int mirror = 2 * c - i;\n            if (i <\
    \ r) {\n                p[i] = Math.Min(r - i, p[mirror]);\n            }\n  \
    \          while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && str[i + 1 + p[i]] ==\
    \ str[i - 1 - p[i]]) {\n                p[i]++;\n            }\n            if\
    \ (i + p[i] > r) {\n                c = i;\n                r = i + p[i];\n  \
    \          }\n        }\n        int max_len = 0;\n        int center_index =\
    \ 0;\n        for (int i = 1; i < n; i++) {\n            if (i - p[i] == 0) {\n\
    \                if (p[i] > max_len) {\n                    max_len = p[i];\n\
    \                    center_index = i;\n                }\n            }\n   \
    \     }\n        StringBuilder sb = new StringBuilder();\n        sb.Append(str);\n\
    \        for (int i = center_index - max_len - 1; i >= 0; i--) {\n           \
    \ sb.Append(str[i]);\n        }\n        return sb.ToString();", "        int\
    \ n = str.Length;\n        int[] z = new int[n];\n        z[0] = n;\n        int\
    \ l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n            \
    \    z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n           \
    \     l = i;\n                r = i + z[i] - 1;\n            }\n        }\n  \
    \      int max = 0;\n        for (int i = 1; i < n; i++) {\n            if (z[i]\
    \ == i) {\n                max = i;\n            }\n        }\n        return\
    \ str + str.Substring(max).Reverse();", "        // Find the longest postfix that\
    \ is a palindrome.\n        int palindrome_length = 0;\n        for (int i = 0;\
    \ i < str.Length; i++) {\n            if (str[i] == str[str.Length - 1 - i]) {\n\
    \                palindrome_length++;\n            } else {\n                break;\n\
    \            }\n        }\n        // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        return\
    \ str + new string(str.Substring(0, str.Length - palindrome_length).Reverse().ToArray());",
  "        int n = str.Length;\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\n   \
    \             z[i] = Math.Min(r - i + 1, z[i - l]);\n            while (i + z[i]\
    \ < n && str[z[i]] == str[i + z[i]])\n                z[i]++;\n            if\
    \ (i + z[i] - 1 > r) {\n                l = i;\n                r = i + z[i] -\
    \ 1;\n            }\n        }\n        int max = 0;\n        for (int i = 1;\
    \ i < n; i++)\n            if (z[i] == n - i && z[i] > max)\n                max\
    \ = z[i];\n        StringBuilder sb = new StringBuilder();\n        for (int i\
    \ = 0; i < n - max; i++)\n            sb.Append(str[i]);\n        for (int i =\
    \ n - 1; i >= max; i--)\n            sb.Append(str[i]);\n        return sb.ToString();",
  "        // Find the longest palindromic suffix.\n        int suffix_len = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            if (IsPalindrome(str,\
    \ i, str.Length - 1)) {\n                suffix_len = str.Length - i;\n      \
    \          break;\n            }\n        }\n        // Append reverse of the\
    \ prefix to the end of the string.\n        return str + Reverse(str.Substring(0,\
    \ str.Length - suffix_len));", "        int n = str.Length;\n        int[] p =\
    \ new int[n];\n        int c = 0, r = 0;\n        for (int i = 1; i < n; i++)\
    \ {\n            int j = 2 * c - i;\n            if (i <= r) {\n             \
    \   p[i] = Math.Min(r - i, p[j]);\n            }\n            while (i + p[i]\
    \ + 1 < n && i - p[i] - 1 >= 0 && str[i + p[i] + 1] == str[i - p[i] - 1]) {\n\
    \                p[i]++;\n            }\n            if (i + p[i] > r) {\n   \
    \             c = i;\n                r = i + p[i];\n            }\n        }\n\
    \        int max = 0;\n        for (int i = 1; i < n; i++) {\n            if (i\
    \ + p[i] == n - 1) {\n                max = i;\n            }\n        }\n   \
    \     return str + new string(str.Substring(0, max).Reverse().ToArray());"]
stop_tokens:
- "\n    }\n"
