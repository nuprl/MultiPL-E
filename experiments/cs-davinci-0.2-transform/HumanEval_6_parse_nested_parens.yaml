name: HumanEval_6_parse_nested_parens
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Input to this function is a string represented multiple groups\
  \ for nested parentheses separated by spaces.\n    // For each of the group, output\
  \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two\
  \ levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"(()())\
  \ ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string paren_string)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
  (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
  \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
  \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
  \ long[]{(long)4L}))));\n    }\n\n}\n"
completions: ["        var res = new List<long>();\n        var cur = 0L;\n      \
    \  var max = 0L;\n        foreach (var c in paren_string) {\n            if (c\
    \ == '(') {\n                cur++;\n                max = Math.Max(max, cur);\n\
    \            } else if (c == ')') {\n                cur--;\n            } else\
    \ if (c == ' ') {\n                res.Add(max);\n                max = 0L;\n\
    \                cur = 0L;\n            }\n        }\n        res.Add(max);\n\
    \        return res;", "        // Fill in your code here.\n        var result\
    \ = new List<long>();\n        var groups = paren_string.Split(' ');\n       \
    \ foreach (var group in groups) {\n            var stack = new Stack<char>();\n\
    \            var max = 0;\n            var current = 0;\n            foreach (var\
    \ c in group) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    current++;\n                    max = Math.Max(max, current);\n\
    \                } else if (c == ')') {\n                    if (stack.Count >\
    \ 0) {\n                        stack.Pop();\n                        current--;\n\
    \                    }\n                }\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var paren_groups = paren_string.Split(' ');\n        foreach (var paren_group\
    \ in paren_groups) {\n            var stack = new Stack<char>();\n           \
    \ var max_depth = 0L;\n            var depth = 0L;\n            foreach (var c\
    \ in paren_group) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    depth += 1L;\n                    max_depth = Math.Max(max_depth,\
    \ depth);\n                } else if (c == ')') {\n                    if (stack.Count\
    \ == 0) {\n                        throw new Exception(\"Unbalanced parens\");\n\
    \                    }\n                    stack.Pop();\n                   \
    \ depth -= 1L;\n                } else {\n                    throw new Exception(\"\
    Invalid character\");\n                }\n            }\n            if (stack.Count\
    \ != 0) {\n                throw new Exception(\"Unbalanced parens\");\n     \
    \       }\n            result.Add(max_depth);\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ parens = paren_string.Split(' ');\n        var result = new List<long>();\n\
    \        foreach (var paren in parens) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    depth += 1L;\n                  \
    \  max_depth = Math.Max(max_depth, depth);\n                } else {\n       \
    \             depth -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        // >>> ParseNestedParens(\"(()())\
    \ ((())) () ((())()())\")\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        List<long> result = new List<long>();\n     \
    \   // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        string[]\
    \ paren_groups = paren_string.Split(new string[]{\" \"}, StringSplitOptions.None);\n\
    \        // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   foreach (string paren_group in paren_groups) {\n            // >>> ParseNestedParens(\"\
    (()()) ((())) () ((())()())\")\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            long max_depth = 0L;\n        \
    \    // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n            //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \       long current_depth = 0L;\n            // >>> ParseNestedParens(\"(()())\
    \ ((())) () ((())()())\")\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            foreach (char c in paren_group)\
    \ {\n                // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\"\
    )\n                // (new List<long>(new long[]{(long)2L, (long)3", "       \
    \ List<long> result = new List<long>();\n        int max_depth = 0;\n        int\
    \ depth = 0;\n        foreach (char c in paren_string) {\n            if (c ==\
    \ '(') {\n                depth += 1;\n                max_depth = Math.Max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth -= 1;\n \
    \           } else if (c == ' ') {\n                result.Add(max_depth);\n \
    \               max_depth = 0;\n                depth = 0;\n            }\n  \
    \      }\n        result.Add(max_depth);\n        return result;", "        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var current_depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    current_depth += 1L;\n\
    \                    max_depth = Math.Max(max_depth, current_depth);\n       \
    \         } else if (c == ')') {\n                    current_depth -= 1L;\n \
    \               }\n            }\n            result.Add(max_depth);\n       \
    \ }\n        return result;", "        var result = new List<long>();\n      \
    \  var parens = paren_string.Split(' ');\n        foreach (var paren in parens)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren) {\n                if (c == '(') {\n             \
    \       depth++;\n                    if (depth > max_depth) {\n             \
    \           max_depth = depth;\n                    }\n                }\n   \
    \             else {\n                    depth--;\n                }\n      \
    \      }\n            result.Add(max_depth);\n        }\n        return result;",
  "        // Write your code here\n        List<long> result = new List<long>();\n\
    \        string[] parens = paren_string.Split(' ');\n        foreach (string paren\
    \ in parens) {\n            long max = 0;\n            long count = 0;\n     \
    \       foreach (char c in paren) {\n                if (c == '(') {\n       \
    \             count++;\n                    if (count > max) {\n             \
    \           max = count;\n                    }\n                } else if (c\
    \ == ')') {\n                    count--;\n                }\n            }\n\
    \            result.Add(max);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_depth = 0L;\n        long depth\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                depth++;\n                if (depth > max_depth) {\n    \
    \                max_depth = depth;\n                }\n            } else if\
    \ (c == ')') {\n                depth--;\n            } else if (c == ' ') {\n\
    \                result.Add(max_depth);\n                max_depth = 0L;\n   \
    \             depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // Write your code here\n        return new List<long>();", "        var result\
    \ = new List<long>();\n        var groups = paren_string.Split(' ');\n       \
    \ foreach (var group in groups) {\n            var max_depth = 0L;\n         \
    \   var depth = 0L;\n            foreach (var c in group) {\n                if\
    \ (c == '(') {\n                    depth++;\n                    if (depth >\
    \ max_depth) {\n                        max_depth = depth;\n                 \
    \   }\n                } else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        int max_nesting = 0;\n        int current_nesting = 0;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_nesting++;\n\
    \                max_nesting = Math.Max(max_nesting, current_nesting);\n     \
    \       } else if (c == ')') {\n                current_nesting--;\n         \
    \   } else if (c == ' ') {\n                result.Add(max_nesting);\n       \
    \         max_nesting = 0;\n                current_nesting = 0;\n           \
    \ }\n        }\n        result.Add(max_nesting);\n        return result;", " \
    \       List<long> result = new List<long>();\n        long current_level = 0L;\n\
    \        long max_level = 0L;\n        foreach (char c in paren_string) {\n  \
    \          if (c == '(') {\n                current_level += 1L;\n           \
    \     max_level = Math.Max(max_level, current_level);\n            } else if (c\
    \ == ')') {\n                current_level -= 1L;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_level);\n                max_level =\
    \ 0L;\n                current_level = 0L;\n            }\n        }\n       \
    \ result.Add(max_level);\n        return result;", "        List<long> result\
    \ = new List<long>();\n        int max_depth = 0;\n        int depth = 0;\n  \
    \      foreach (char c in paren_string) {\n            if (c == '(') {\n     \
    \           depth++;\n                max_depth = Math.Max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                depth--;\n            } else\
    \ if (c == ' ') {\n                result.Add(max_depth);\n                max_depth\
    \ = 0;\n                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_depth = 0L;\n            var depth = 0L;\n\
    \            foreach (var c in paren_group) {\n                if (c == '(') {\n\
    \                    depth++;\n                    if (depth > max_depth) {\n\
    \                        max_depth = depth;\n                    }\n         \
    \       }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long max_depth = 0L;\n        long depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;"]
stop_tokens:
- "\n    }\n"
