name: HumanEval_6_parse_nested_parens
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Input to this function is a string represented multiple groups\
  \ for nested parentheses separated by spaces.\n    // For each of the group, output\
  \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two\
  \ levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"(()())\
  \ ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string paren_string)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
  (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
  \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
  \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
  \ long[]{(long)4L}))));\n    }\n\n}\n"
completions: ["        var res = new List<long>();\n        var cur = 0L;\n      \
    \  var max = 0L;\n        foreach (var c in paren_string) {\n            if (c\
    \ == '(') {\n                cur++;\n                max = Math.Max(max, cur);\n\
    \            } else if (c == ')') {\n                cur--;\n            } else\
    \ if (c == ' ') {\n                res.Add(max);\n                max = 0L;\n\
    \                cur = 0L;\n            }\n        }\n        res.Add(max);\n\
    \        return res;", "        // Fill in your code here.\n        var result\
    \ = new List<long>();\n        var groups = paren_string.Split(' ');\n       \
    \ foreach (var group in groups) {\n            var stack = new Stack<char>();\n\
    \            var max = 0;\n            var current = 0;\n            foreach (var\
    \ c in group) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    current++;\n                    max = Math.Max(max, current);\n\
    \                } else if (c == ')') {\n                    if (stack.Count >\
    \ 0) {\n                        stack.Pop();\n                        current--;\n\
    \                    }\n                }\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var paren_groups = paren_string.Split(' ');\n        foreach (var paren_group\
    \ in paren_groups) {\n            var stack = new Stack<char>();\n           \
    \ var max_depth = 0L;\n            var depth = 0L;\n            foreach (var c\
    \ in paren_group) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    depth += 1L;\n                    max_depth = Math.Max(max_depth,\
    \ depth);\n                } else if (c == ')') {\n                    if (stack.Count\
    \ == 0) {\n                        throw new Exception(\"Unbalanced parens\");\n\
    \                    }\n                    stack.Pop();\n                   \
    \ depth -= 1L;\n                } else {\n                    throw new Exception(\"\
    Invalid character\");\n                }\n            }\n            if (stack.Count\
    \ != 0) {\n                throw new Exception(\"Unbalanced parens\");\n     \
    \       }\n            result.Add(max_depth);\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ parens = paren_string.Split(' ');\n        var result = new List<long>();\n\
    \        foreach (var paren in parens) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    depth += 1L;\n                  \
    \  max_depth = Math.Max(max_depth, depth);\n                } else {\n       \
    \             depth -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        // >>> ParseNestedParens(\"(()())\
    \ ((())) () ((())()())\")\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        List<long> result = new List<long>();\n     \
    \   // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        string[]\
    \ paren_groups = paren_string.Split(new string[]{\" \"}, StringSplitOptions.None);\n\
    \        // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   foreach (string paren_group in paren_groups) {\n            // >>> ParseNestedParens(\"\
    (()()) ((())) () ((())()())\")\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            long max_depth = 0L;\n        \
    \    // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n            //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \       long current_depth = 0L;\n            // >>> ParseNestedParens(\"(()())\
    \ ((())) () ((())()())\")\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            foreach (char c in paren_group)\
    \ {\n                // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\"\
    )\n                // (new List<long>(new long[]{(long)2L, (long)3", "       \
    \ List<long> result = new List<long>();\n        int max_depth = 0;\n        int\
    \ depth = 0;\n        foreach (char c in paren_string) {\n            if (c ==\
    \ '(') {\n                depth += 1;\n                max_depth = Math.Max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth -= 1;\n \
    \           } else if (c == ' ') {\n                result.Add(max_depth);\n \
    \               max_depth = 0;\n                depth = 0;\n            }\n  \
    \      }\n        result.Add(max_depth);\n        return result;", "        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var current_depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    current_depth += 1L;\n\
    \                    max_depth = Math.Max(max_depth, current_depth);\n       \
    \         } else if (c == ')') {\n                    current_depth -= 1L;\n \
    \               }\n            }\n            result.Add(max_depth);\n       \
    \ }\n        return result;", "        var result = new List<long>();\n      \
    \  var parens = paren_string.Split(' ');\n        foreach (var paren in parens)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren) {\n                if (c == '(') {\n             \
    \       depth++;\n                    if (depth > max_depth) {\n             \
    \           max_depth = depth;\n                    }\n                }\n   \
    \             else {\n                    depth--;\n                }\n      \
    \      }\n            result.Add(max_depth);\n        }\n        return result;",
  "        // Write your code here\n        List<long> result = new List<long>();\n\
    \        string[] parens = paren_string.Split(' ');\n        foreach (string paren\
    \ in parens) {\n            long max = 0;\n            long count = 0;\n     \
    \       foreach (char c in paren) {\n                if (c == '(') {\n       \
    \             count++;\n                    if (count > max) {\n             \
    \           max = count;\n                    }\n                } else if (c\
    \ == ')') {\n                    count--;\n                }\n            }\n\
    \            result.Add(max);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_depth = 0L;\n        long depth\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                depth++;\n                if (depth > max_depth) {\n    \
    \                max_depth = depth;\n                }\n            } else if\
    \ (c == ')') {\n                depth--;\n            } else if (c == ' ') {\n\
    \                result.Add(max_depth);\n                max_depth = 0L;\n   \
    \             depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // Write your code here\n        return new List<long>();", "        var result\
    \ = new List<long>();\n        var groups = paren_string.Split(' ');\n       \
    \ foreach (var group in groups) {\n            var max_depth = 0L;\n         \
    \   var depth = 0L;\n            foreach (var c in group) {\n                if\
    \ (c == '(') {\n                    depth++;\n                    if (depth >\
    \ max_depth) {\n                        max_depth = depth;\n                 \
    \   }\n                } else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        int max_nesting = 0;\n        int current_nesting = 0;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_nesting++;\n\
    \                max_nesting = Math.Max(max_nesting, current_nesting);\n     \
    \       } else if (c == ')') {\n                current_nesting--;\n         \
    \   } else if (c == ' ') {\n                result.Add(max_nesting);\n       \
    \         max_nesting = 0;\n                current_nesting = 0;\n           \
    \ }\n        }\n        result.Add(max_nesting);\n        return result;", " \
    \       List<long> result = new List<long>();\n        long current_level = 0L;\n\
    \        long max_level = 0L;\n        foreach (char c in paren_string) {\n  \
    \          if (c == '(') {\n                current_level += 1L;\n           \
    \     max_level = Math.Max(max_level, current_level);\n            } else if (c\
    \ == ')') {\n                current_level -= 1L;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_level);\n                max_level =\
    \ 0L;\n                current_level = 0L;\n            }\n        }\n       \
    \ result.Add(max_level);\n        return result;", "        List<long> result\
    \ = new List<long>();\n        int max_depth = 0;\n        int depth = 0;\n  \
    \      foreach (char c in paren_string) {\n            if (c == '(') {\n     \
    \           depth++;\n                max_depth = Math.Max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                depth--;\n            } else\
    \ if (c == ' ') {\n                result.Add(max_depth);\n                max_depth\
    \ = 0;\n                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_depth = 0L;\n            var depth = 0L;\n\
    \            foreach (var c in paren_group) {\n                if (c == '(') {\n\
    \                    depth++;\n                    if (depth > max_depth) {\n\
    \                        max_depth = depth;\n                    }\n         \
    \       }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long max_depth = 0L;\n        long depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ List<long> result = new List<long>();\n        long max_depth = 0L;\n      \
    \  long current_depth = 0L;\n        foreach (char c in paren_string) {\n    \
    \        if (c == '(') {\n                current_depth++;\n                if\
    \ (current_depth > max_depth) {\n                    max_depth = current_depth;\n\
    \                }\n            } else if (c == ')') {\n                current_depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        List<long> result = new List<long>();\n        long max_nesting = 0L;\n\
    \        long current_nesting = 0L;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         if (current_nesting > max_nesting) {\n                    max_nesting\
    \ = current_nesting;\n                }\n            } else if (c == ')') {\n\
    \                current_nesting--;\n            } else if (c == ' ') {\n    \
    \            result.Add(max_nesting);\n                max_nesting = 0L;\n   \
    \             current_nesting = 0L;\n            }\n        }\n        result.Add(max_nesting);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_depth = 0L;\n        long depth\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                depth++;\n                if (depth > max_depth) {\n    \
    \                max_depth = depth;\n                }\n            } else if\
    \ (c == ')') {\n                depth--;\n            } else if (c == ' ') {\n\
    \                result.Add(max_depth);\n                max_depth = 0L;\n   \
    \             depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long count = 0L;\n        long max = 0L;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                count++;\n                if\
    \ (count > max) {\n                    max = count;\n                }\n     \
    \       } else if (c == ')') {\n                count--;\n            } else if\
    \ (c == ' ') {\n                result.Add(max);\n                max = 0L;\n\
    \                count = 0L;\n            }\n        }\n        result.Add(max);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ stack = new Stack<int>();\n        var max = 0;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                stack.Push(0);\n           \
    \ } else if (c == ')') {\n                var count = stack.Pop();\n         \
    \       if (stack.Count == 0) {\n                    result.Add(count);\n    \
    \                max = Math.Max(max, count);\n                } else {\n     \
    \               stack.Push(stack.Pop() + count + 1);\n                }\n    \
    \        }\n        }\n        return result;", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        var paren_groups = paren_string.Split('\
    \ ');\n        var result = new List<long>();\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_depth = 0L;\n            var depth =\
    \ 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    depth += 1L;\n                    if (depth > max_depth)\
    \ {\n                        max_depth = depth;\n                    }\n     \
    \           }\n                else {\n                    depth -= 1L;\n    \
    \            }\n            }\n            result.Add(max_depth);\n        }\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long current_depth = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_depth\
    \ += 1L;\n                max_depth = Math.Max(max_depth, current_depth);\n  \
    \          } else if (c == ')') {\n                current_depth -= 1L;\n    \
    \        } else if (c == ' ') {\n                result.Add(max_depth);\n    \
    \            max_depth = 0L;\n                current_depth = 0L;\n          \
    \  }\n        }\n        result.Add(max_depth);\n        return result;", "  \
    \      var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_nesting\
    \ = 0L;\n            var current_nesting = 0L;\n            foreach (var c in\
    \ paren_group) {\n                if (c == '(') {\n                    current_nesting\
    \ += 1L;\n                    max_nesting = Math.Max(max_nesting, current_nesting);\n\
    \                }\n                else if (c == ')') {\n                   \
    \ current_nesting -= 1L;\n                }\n            }\n            result.Add(max_nesting);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var parens = paren_string.Split(' ');\n        foreach (var paren in\
    \ parens) {\n            var max_nesting = 0L;\n            var current_nesting\
    \ = 0L;\n            foreach (var c in paren) {\n                if (c == '(')\
    \ {\n                    current_nesting += 1L;\n                    max_nesting\
    \ = Math.Max(max_nesting, current_nesting);\n                }\n             \
    \   else {\n                    current_nesting -= 1L;\n                }\n  \
    \          }\n            result.Add(max_nesting);\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        long count\
    \ = 0L;\n        long max = 0L;\n        foreach (char c in paren_string) {\n\
    \            if (c == '(') {\n                count++;\n                if (count\
    \ > max) {\n                    max = count;\n                }\n            }\
    \ else if (c == ')') {\n                count--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max);\n                max = 0L;\n      \
    \          count = 0L;\n            }\n        }\n        result.Add(max);\n \
    \       return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_depth = 0L;\n            var depth = 0L;\n\
    \            foreach (var c in paren_group) {\n                if (c == '(') {\n\
    \                    depth++;\n                    if (depth > max_depth) {\n\
    \                        max_depth = depth;\n                    }\n         \
    \       }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        // >>> ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\n\
    \                else if (c == ')') {\n                    depth--;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        List<long> result = new List<long>();\n      \
    \  long max_depth = 0L;\n        long depth = 0L;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                depth++;\n                if\
    \ (depth > max_depth) {\n                    max_depth = depth;\n            \
    \    }\n            } else if (c == ')') {\n                depth--;\n       \
    \     } else if (c == ' ') {\n                result.Add(max_depth);\n       \
    \         max_depth = 0L;\n                depth = 0L;\n            }\n      \
    \  }\n        result.Add(max_depth);\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_level = 0L;\n        long current_level\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                current_level++;\n                if (current_level > max_level)\
    \ {\n                    max_level = current_level;\n                }\n     \
    \       } else if (c == ')') {\n                current_level--;\n           \
    \ } else if (c == ' ') {\n                result.Add(max_level);\n           \
    \     max_level = 0L;\n                current_level = 0L;\n            }\n  \
    \      }\n        result.Add(max_level);\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var result = new List<long>();\n\
    \        var stack = new Stack<long>();\n        var max = 0L;\n        foreach\
    \ (var c in paren_string) {\n            if (c == '(') {\n                stack.Push(1L);\n\
    \            } else if (c == ')') {\n                var count = 0L;\n       \
    \         while (stack.Count > 0 && stack.Peek() > 0) {\n                    count\
    \ += stack.Pop();\n                }\n                stack.Push(count + 1);\n\
    \                max = Math.Max(max, count + 1);\n            } else if (c ==\
    \ ' ') {\n                result.Add(max);\n                max = 0L;\n      \
    \          stack.Clear();\n            }\n        }\n        result.Add(max);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        var result = new List<long>();\n        var parens = paren_string.Split('\
    \ ');\n        foreach (var paren in parens) {\n            var depth = 0L;\n\
    \            var max_depth = 0L;\n            foreach (var c in paren) {\n   \
    \             if (c == '(') {\n                    depth += 1L;\n            \
    \        if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else {\n          \
    \          depth -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var stack = new Stack<long>();\n        var max_depth = 0L;\n       \
    \ foreach (var c in paren_string) {\n            if (c == '(') {\n           \
    \     stack.Push(max_depth);\n                max_depth = max_depth + 1L;\n  \
    \          } else if (c == ')') {\n                result.Add(max_depth);\n  \
    \              max_depth = stack.Pop();\n            }\n        }\n        return\
    \ result;", "        var ret = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_nesting\
    \ = 0L;\n            var cur_nesting = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    cur_nesting++;\n   \
    \                 max_nesting = Math.Max(max_nesting, cur_nesting);\n        \
    \        } else if (c == ')') {\n                    cur_nesting--;\n        \
    \        }\n            }\n            ret.Add(max_nesting);\n        }\n    \
    \    return ret;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\n\
    \                else if (c == ')') {\n                    depth--;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var group in paren_groups) {\n\
    \            var max_depth = 0L;\n            var depth = 0L;\n            foreach\
    \ (var c in group) {\n                if (c == '(') {\n                    depth\
    \ += 1L;\n                    max_depth = Math.Max(max_depth, depth);\n      \
    \          } else if (c == ')') {\n                    depth -= 1L;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        List<long> result = new List<long>();\n      \
    \  long cur_max = 0L;\n        long cur_val = 0L;\n        for (long i = 0L; i\
    \ < paren_string.Length; i++) {\n            if (paren_string[(int)i] == '(')\
    \ {\n                cur_val += 1L;\n                cur_max = Math.Max(cur_max,\
    \ cur_val);\n            } else if (paren_string[(int)i] == ')') {\n         \
    \       if (cur_val > 0L) {\n                    cur_val -= 1L;\n            \
    \    } else {\n                    result.Add(cur_max);\n                    cur_max\
    \ = 0L;\n                    cur_val = 0L;\n                }\n            } else\
    \ if (paren_string[(int)i] == ' ') {\n                result.Add(cur_max);\n \
    \               cur_max = 0L;\n                cur_val = 0L;\n            }\n\
    \        }\n        result.Add(cur_max);\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var result = new List<long>();\n\
    \        var paren_groups = paren_string.Split(' ');\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_level = 0L;\n            var level =\
    \ 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    level += 1L;\n                    if (level > max_level)\
    \ {\n                        max_level = level;\n                    }\n     \
    \           }\n                else if (c == ')') {\n                    level\
    \ -= 1L;\n                }\n            }\n            result.Add(max_level);\n\
    \        }\n        return result;", "        var groups = paren_string.Split('\
    \ ');\n        var result = new List<long>();\n        foreach (var group in groups)\
    \ {\n            var stack = new Stack<char>();\n            var max_depth = 0L;\n\
    \            var depth = 0L;\n            foreach (var c in group) {\n       \
    \         if (c == '(') {\n                    stack.Push(c);\n              \
    \      depth += 1L;\n                    max_depth = Math.Max(max_depth, depth);\n\
    \                } else if (c == ')') {\n                    if (stack.Count ==\
    \ 0) {\n                        throw new Exception(\"Unbalanced parentheses\"\
    );\n                    }\n                    stack.Pop();\n                \
    \    depth -= 1L;\n                } else {\n                    throw new Exception(\"\
    Invalid character\");\n                }\n            }\n            if (stack.Count\
    \ != 0) {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            result.Add(max_depth);\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        int max_nesting\
    \ = 0;\n        int current_nesting = 0;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                current_nesting += 1;\n    \
    \            max_nesting = Math.Max(max_nesting, current_nesting);\n         \
    \   } else if (c == ')') {\n                current_nesting -= 1;\n          \
    \  } else if (c == ' ') {\n                result.Add(max_nesting);\n        \
    \        max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \        }\n        result.Add(max_nesting);\n        return result;", "     \
    \   List<long> result = new List<long>();\n        int current_level = 0;\n  \
    \      int max_level = 0;\n        for (int i = 0; i < paren_string.Length; i++)\
    \ {\n            if (paren_string[i] == '(') {\n                current_level++;\n\
    \                if (current_level > max_level) {\n                    max_level\
    \ = current_level;\n                }\n            } else if (paren_string[i]\
    \ == ')') {\n                current_level--;\n            } else if (paren_string[i]\
    \ == ' ') {\n                result.Add(max_level);\n                max_level\
    \ = 0;\n                current_level = 0;\n            }\n        }\n       \
    \ result.Add(max_level);\n        return result;", "        List<long> res = new\
    \ List<long>();\n        int curr_level = 0;\n        int max_level = 0;\n   \
    \     for (int i = 0; i < paren_string.Length; i++) {\n            if (paren_string[i]\
    \ == '(') {\n                curr_level++;\n                max_level = Math.Max(max_level,\
    \ curr_level);\n            } else if (paren_string[i] == ')') {\n           \
    \     curr_level--;\n            } else if (paren_string[i] == ' ') {\n      \
    \          res.Add(max_level);\n                max_level = 0;\n             \
    \   curr_level = 0;\n            }\n        }\n        res.Add(max_level);\n \
    \       return res;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var paren in paren_group) {\n                if (paren == '(') {\n\
    \                    depth++;\n                    if (depth > max_depth) {\n\
    \                        max_depth = depth;\n                    }\n         \
    \       } else if (paren == ')') {\n                    depth--;\n           \
    \     }\n            }\n            result.Add(max_depth);\n        }\n      \
    \  return result;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var group in paren_groups) {\n\
    \            var max_depth = 0L;\n            var depth = 0L;\n            foreach\
    \ (var c in group) {\n                if (c == '(') {\n                    depth++;\n\
    \                    if (depth > max_depth) {\n                        max_depth\
    \ = depth;\n                    }\n                } else if (c == ')') {\n  \
    \                  depth--;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var depth = 0L;\n        var max_depth = 0L;\n        foreach (var c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \       }\n        result.Add(max_depth);\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var parens = paren_string.Split('\
    \ ');\n        var max_levels = new List<long>();\n        foreach (var paren\
    \ in parens) {\n            var max_level = 0L;\n            var level = 0L;\n\
    \            foreach (var c in paren) {\n                if (c == '(') {\n   \
    \                 level++;\n                    if (level > max_level) {\n   \
    \                     max_level = level;\n                    }\n            \
    \    } else {\n                    level--;\n                }\n            }\n\
    \            max_levels.Add(max_level);\n        }\n        return max_levels;",
  "        var result = new List<long>();\n        var stack = new Stack<long>();\n\
    \        var max = 0L;\n        foreach (var c in paren_string) {\n          \
    \  if (c == '(') {\n                stack.Push(1L);\n            } else if (c\
    \ == ')') {\n                var depth = stack.Pop();\n                max = Math.Max(max,\
    \ depth);\n                if (stack.Count > 0) {\n                    stack.Push(stack.Pop()\
    \ + 1);\n                }\n            } else if (c == ' ') {\n             \
    \   result.Add(max);\n                max = 0L;\n            }\n        }\n  \
    \      result.Add(max);\n        return result;", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        var parens = paren_string.Split(' ');\n\
    \        var result = new List<long>();\n        foreach (var paren in parens)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren) {\n                if (c == '(') {\n             \
    \       depth += 1L;\n                    max_depth = Math.Max(max_depth, depth);\n\
    \                } else {\n                    depth -= 1L;\n                }\n\
    \            }\n            result.Add(max_depth);\n        }\n        return\
    \ result;", "        var result = new List<long>();\n        var parens = paren_string.Split('\
    \ ');\n        foreach (var paren in parens) {\n            var max_level = 0L;\n\
    \            var level = 0L;\n            foreach (var c in paren) {\n       \
    \         if (c == '(') {\n                    level++;\n                    if\
    \ (level > max_level) {\n                        max_level = level;\n        \
    \            }\n                }\n                else if (c == ')') {\n    \
    \                level--;\n                }\n            }\n            result.Add(max_level);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long current_level = 0L;\n        long max_level = 0L;\n        foreach\
    \ (var c in paren_string) {\n            if (c == '(') {\n                current_level++;\n\
    \                max_level = Math.Max(max_level, current_level);\n           \
    \ } else if (c == ')') {\n                current_level--;\n            } else\
    \ if (c == ' ') {\n                result.Add(max_level);\n                max_level\
    \ = 0L;\n                current_level = 0L;\n            }\n        }\n     \
    \   result.Add(max_level);\n        return result;", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        List<long> result = new List<long>();\n\
    \        long max_level = 0L;\n        long current_level = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_level\
    \ += 1L;\n                if (current_level > max_level) {\n                 \
    \   max_level = current_level;\n                }\n            }\n           \
    \ else if (c == ')') {\n                current_level -= 1L;\n            }\n\
    \            else if (c == ' ') {\n                result.Add(max_level);\n  \
    \              max_level = 0L;\n                current_level = 0L;\n        \
    \    }\n        }\n        result.Add(max_level);\n        return result;", " \
    \       // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   List<long> ret = new List<long>();\n        long max_depth = 0L;\n       \
    \ long depth = 0L;\n        foreach (char c in paren_string) {\n            if\
    \ (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            else if (c == ')') {\n                depth--;\n            }\n \
    \           else if (c == ' ') {\n                ret.Add(max_depth);\n      \
    \          max_depth = 0L;\n                depth = 0L;\n            }\n     \
    \   }\n        ret.Add(max_depth);\n        return ret;", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        var paren_groups = paren_string.Split('\
    \ ');\n        var result = new List<long>();\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_depth = 0L;\n            var cur_depth\
    \ = 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    cur_depth += 1L;\n                    max_depth\
    \ = Math.Max(max_depth, cur_depth);\n                } else if (c == ')') {\n\
    \                    cur_depth -= 1L;\n                }\n            }\n    \
    \        result.Add(max_depth);\n        }\n        return result;", "       \
    \ var result = new List<long>();\n        var stack = new Stack<long>();\n   \
    \     var max = 0L;\n        foreach (var c in paren_string) {\n            if\
    \ (c == '(') {\n                stack.Push(1L);\n            } else if (c == ')')\
    \ {\n                if (stack.Count == 0) {\n                    throw new Exception(\"\
    Unmatched closing parenthesis\");\n                }\n                var count\
    \ = stack.Pop();\n                if (stack.Count > 0) {\n                   \
    \ stack.Push(stack.Pop() + count);\n                } else {\n               \
    \     result.Add(count);\n                }\n            } else if (c == ' ')\
    \ {\n                if (stack.Count > 0) {\n                    throw new Exception(\"\
    Unmatched opening parenthesis\");\n                }\n            } else {\n \
    \               throw new Exception(\"Invalid character\");\n            }\n \
    \       }\n        if (stack.Count > 0) {\n            throw new Exception(\"\
    Unmatched opening parenthesis\");\n        }\n        return result;", "     \
    \   List<long> result = new List<long>();\n        long max_depth = 0L;\n    \
    \    long depth = 0L;\n        foreach (var c in paren_string) {\n           \
    \ if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        List<long> max_nesting = new List<long>();\n        long\
    \ max_nesting_level = 0L;\n        long nesting_level = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                nesting_level++;\n\
    \                if (nesting_level > max_nesting_level) {\n                  \
    \  max_nesting_level = nesting_level;\n                }\n            }\n    \
    \        else if (c == ')') {\n                nesting_level--;\n            }\n\
    \            else if (c == ' ') {\n                max_nesting.Add(max_nesting_level);\n\
    \                max_nesting_level = 0L;\n                nesting_level = 0L;\n\
    \            }\n        }\n        max_nesting.Add(max_nesting_level);\n     \
    \   return max_nesting;", "        List<long> ans = new List<long>();\n      \
    \  long curr_max = 0L;\n        long curr_level = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                curr_level++;\n\
    \                curr_max = Math.Max(curr_max, curr_level);\n            } else\
    \ if (c == ')') {\n                curr_level--;\n            } else if (c ==\
    \ ' ') {\n                ans.Add(curr_max);\n                curr_max = 0L;\n\
    \                curr_level = 0L;\n            }\n        }\n        ans.Add(curr_max);\n\
    \        return ans;", "        // Your code goes here.\n        List<long> result\
    \ = new List<long>();\n        string[] groups = paren_string.Split(' ');\n  \
    \      foreach (string group in groups) {\n            long max = 0;\n       \
    \     long current = 0;\n            foreach (char c in group) {\n           \
    \     if (c == '(') {\n                    current++;\n                    if\
    \ (current > max) {\n                        max = current;\n                \
    \    }\n                } else if (c == ')') {\n                    current--;\n\
    \                }\n            }\n            result.Add(max);\n        }\n \
    \       return result;", "        var result = new List<long>();\n        var\
    \ current_level = 0L;\n        var max_level = 0L;\n        foreach (var c in\
    \ paren_string) {\n            if (c == '(') {\n                current_level\
    \ += 1L;\n                max_level = Math.Max(max_level, current_level);\n  \
    \          } else if (c == ')') {\n                current_level -= 1L;\n    \
    \        } else if (c == ' ') {\n                result.Add(max_level);\n    \
    \            max_level = 0L;\n                current_level = 0L;\n          \
    \  }\n        }\n        result.Add(max_level);\n        return result;", "  \
    \      var result = new List<long>();\n        var current_level = 0L;\n     \
    \   var max_level = 0L;\n        foreach (var c in paren_string) {\n         \
    \   if (c == '(') {\n                current_level++;\n                max_level\
    \ = Math.Max(max_level, current_level);\n            } else if (c == ')') {\n\
    \                current_level--;\n            } else if (c == ' ') {\n      \
    \          result.Add(max_level);\n                max_level = 0L;\n         \
    \       current_level = 0L;\n            }\n        }\n        result.Add(max_level);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     // >>> paren_string\n        // \"(()()) ((())) () ((())()())\"\n      \
    \  // >>> paren_string.Split(' ')\n        // (new string[]{\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"})\n        foreach (string paren_group in paren_string.Split('\
    \ ')) {\n            // >>> paren_group\n            // \"(()())\"\n         \
    \   // >>> paren_group.Length\n            // 7\n            long max_depth =\
    \ 0L;\n            long current_depth = 0L;\n            for (long i = 0L; i <\
    \ paren_group.Length; i++) {\n                // >>> paren_group[i]\n        \
    \        // '('\n                // >>> paren_group[i] == '('\n              \
    \  // true\n                if (paren_group[i] == '(') {\n                   \
    \ current_depth++;\n                    if (current_depth > max_depth) {\n   \
    \                     max_depth = current_depth;\n                    }\n    \
    \            }\n                else {\n                    current_depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long max_level = 0L;\n        long level = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                level++;\n\
    \                if (level > max_level) {\n                    max_level = level;\n\
    \                }\n            } else if (c == ')') {\n                level--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                max_level = 0L;\n                level = 0L;\n            }\n\
    \        }\n        result.Add(max_level);\n        return result;", "       \
    \ var result = new List<long>();\n        var stack = new Stack<long>();\n   \
    \     var max_depth = 0L;\n        foreach (var c in paren_string) {\n       \
    \     if (c == '(') {\n                stack.Push(1L);\n                max_depth\
    \ += 1L;\n            } else if (c == ')') {\n                if (stack.Count\
    \ == 0) {\n                    throw new Exception(\"Unbalanced parentheses\"\
    );\n                }\n                stack.Pop();\n            } else if (c\
    \ == ' ') {\n                if (stack.Count == 0) {\n                    result.Add(max_depth);\n\
    \                    max_depth = 0L;\n                }\n            } else {\n\
    \                throw new Exception(\"Invalid character\");\n            }\n\
    \        }\n        if (stack.Count != 0) {\n            throw new Exception(\"\
    Unbalanced parentheses\");\n        }\n        if (max_depth != 0L) {\n      \
    \      result.Add(max_depth);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_level\
    \ = 0L;\n            var level = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    level += 1L;\n     \
    \               max_level = Math.Max(max_level, level);\n                } else\
    \ if (c == ')') {\n                    level -= 1L;\n                }\n     \
    \       }\n            result.Add(max_level);\n        }\n        return result;",
  "        // Your code goes here.\n        List<long> result = new List<long>();\n\
    \        string[] groups = paren_string.Split(' ');\n        foreach (string group\
    \ in groups) {\n            int max = 0;\n            int current = 0;\n     \
    \       foreach (char c in group) {\n                if (c == '(') {\n       \
    \             current++;\n                    if (current > max) {\n         \
    \               max = current;\n                    }\n                } else\
    \ if (c == ')') {\n                    current--;\n                }\n       \
    \     }\n            result.Add(max);\n        }\n        return result;", " \
    \       // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var paren_groups = paren_string.Split(new char[] { ' ' });\n        var result\
    \ = new List<long>();\n        foreach (var paren_group in paren_groups) {\n \
    \           var max_level = 0L;\n            var cur_level = 0L;\n           \
    \ foreach (var c in paren_group) {\n                if (c == '(') {\n        \
    \            cur_level++;\n                    if (cur_level > max_level) {\n\
    \                        max_level = cur_level;\n                    }\n     \
    \           } else if (c == ')') {\n                    cur_level--;\n       \
    \         }\n            }\n            result.Add(max_level);\n        }\n  \
    \      return result;", "        var result = new List<long>();\n        var stack\
    \ = new Stack<long>();\n        long max = 0;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                stack.Push(1);\n           \
    \ } else if (c == ')') {\n                if (stack.Count == 0) {\n          \
    \          throw new Exception(\"Invalid parentheses\");\n                }\n\
    \                stack.Pop();\n            } else if (c == ' ') {\n          \
    \      max = Math.Max(max, stack.Count);\n            }\n        }\n        if\
    \ (stack.Count != 0) {\n            throw new Exception(\"Invalid parentheses\"\
    );\n        }\n        result.Add(max);\n        return result;", "        List<long>\
    \ result = new List<long>();\n        // TODO: Implement this function.\n    \
    \    return result;", "        List<long> result = new List<long>();\n       \
    \ long max_depth = 0L;\n        long current_depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                current_depth\
    \ += 1L;\n                max_depth = Math.Max(max_depth, current_depth);\n  \
    \          }\n            else if (c == ')') {\n                current_depth\
    \ -= 1L;\n            }\n            else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_level\
    \ = 0L;\n            var level = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    level += 1L;\n     \
    \               max_level = Math.Max(max_level, level);\n                } else\
    \ if (c == ')') {\n                    level -= 1L;\n                }\n     \
    \       }\n            result.Add(max_level);\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        var groups = paren_string.Split(' ');\n        var result\
    \ = new List<long>();\n        foreach (var group in groups) {\n            var\
    \ max_depth = 0L;\n            var depth = 0L;\n            foreach (var c in\
    \ group) {\n                if (c == '(') {\n                    depth++;\n  \
    \                  if (depth > max_depth) {\n                        max_depth\
    \ = depth;\n                    }\n                } else if (c == ')') {\n  \
    \                  depth--;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        int depth = 0;\n        int max_depth = 0;\n        foreach (char c in\
    \ paren_string) {\n            if (c == '(') {\n                depth += 1;\n\
    \                max_depth = Math.Max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth -= 1;\n            } else if (c == ' ')\
    \ {\n                result.Add(max_depth);\n                max_depth = 0;\n\
    \                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        var paren_groups = paren_string.Split(new char[]{' '},\
    \ StringSplitOptions.RemoveEmptyEntries);\n        var max_nesting = new List<long>();\n\
    \        foreach (var paren_group in paren_groups) {\n            var max_nesting_level\
    \ = 0L;\n            var nesting_level = 0L;\n            foreach (var paren in\
    \ paren_group) {\n                if (paren == '(') {\n                    nesting_level\
    \ += 1L;\n                    if (nesting_level > max_nesting_level) {\n     \
    \                   max_nesting_level = nesting_level;\n                    }\n\
    \                } else if (paren == ')') {\n                    nesting_level\
    \ -= 1L;\n                }\n            }\n            max_nesting.Add(max_nesting_level);\n\
    \        }\n        return max_nesting;", "        List<long> result = new List<long>();\n\
    \        long depth = 0L;\n        long max_depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        List<long>\
    \ result = new List<long>();\n        long max_depth = 0L;\n        long current_depth\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                current_depth += 1L;\n                if (current_depth >\
    \ max_depth) {\n                    max_depth = current_depth;\n             \
    \   }\n            }\n            else if (c == ')') {\n                current_depth\
    \ -= 1L;\n            }\n            else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var current_depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    current_depth += 1L;\n\
    \                    max_depth = Math.Max(max_depth, current_depth);\n       \
    \         } else if (c == ')') {\n                    current_depth -= 1L;\n \
    \               }\n            }\n            result.Add(max_depth);\n       \
    \ }\n        return result;", "        var result = new List<long>();\n      \
    \  var parens = paren_string.Split(' ');\n        foreach (var paren in parens)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren) {\n                if (c == '(') {\n             \
    \       depth++;\n                    if (depth > max_depth) {\n             \
    \           max_depth = depth;\n                    }\n                }\n   \
    \             else {\n                    depth--;\n                }\n      \
    \      }\n            result.Add(max_depth);\n        }\n        return result;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var parens = paren_string.Split(' ');\n        List<long> max_nesting = new\
    \ List<long>();\n        foreach (var paren in parens) {\n            long max_depth\
    \ = 0L;\n            long depth = 0L;\n            foreach (var c in paren) {\n\
    \                if (c == '(') {\n                    depth += 1L;\n         \
    \       }\n                else {\n                    depth -= 1L;\n        \
    \        }\n                max_depth = Math.Max(max_depth, depth);\n        \
    \    }\n            max_nesting.Add(max_depth);\n        }\n        return max_nesting;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var groups = paren_string.Split(' ');\n        var result = new List<long>();\n\
    \        foreach (var group in groups) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in group) {\n         \
    \       if (c == '(') {\n                    depth += 1L;\n                  \
    \  if (depth > max_depth) {\n                        max_depth = depth;\n    \
    \                }\n                }\n                else if (c == ')') {\n\
    \                    depth -= 1L;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long current_level = 0L;\n        long max_level\
    \ = 0L;\n        foreach (var c in paren_string) {\n            if (c == '(')\
    \ {\n                current_level += 1L;\n                max_level = Math.Max(max_level,\
    \ current_level);\n            } else if (c == ')') {\n                current_level\
    \ -= 1L;\n            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                max_level = 0L;\n                current_level = 0L;\n      \
    \      }\n        }\n        result.Add(max_level);\n        return result;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   List<long> result = new List<long>();\n        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        string[] groups = paren_string.Split('\
    \ ');\n        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n \
    \       // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        foreach (string group in groups) {\n            // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            long max_depth = 0L;\n        \
    \    // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n           \
    \ // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n  \
    \          long current_depth = 0L;\n            // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n            // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n            foreach (char c in group) {\n \
    \               // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n\
    \                // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long cur_depth = 0L;\n        foreach (var c in paren_string) {\n    \
    \        if (c == '(') {\n                cur_depth++;\n                max_depth\
    \ = Math.Max(max_depth, cur_depth);\n            } else if (c == ')') {\n    \
    \            cur_depth--;\n            } else if (c == ' ') {\n              \
    \  result.Add(max_depth);\n                max_depth = 0L;\n                cur_depth\
    \ = 0L;\n            }\n        }\n        result.Add(max_depth);\n        return\
    \ result;", "        List<long> result = new List<long>();\n        int depth\
    \ = 0;\n        int max_depth = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (paren_string[i] == ')') {\n       \
    \         depth--;\n            } else if (paren_string[i] == ' ') {\n       \
    \         result.Add(max_depth);\n                max_depth = 0;\n           \
    \     depth = 0;\n            }\n        }\n        result.Add(max_depth);\n \
    \       return result;", "        var result = new List<long>();\n        var\
    \ current_level = 0L;\n        var max_level = 0L;\n        foreach (var c in\
    \ paren_string) {\n            if (c == '(') {\n                current_level\
    \ += 1L;\n                max_level = Math.Max(max_level, current_level);\n  \
    \          } else if (c == ')') {\n                current_level -= 1L;\n    \
    \        } else if (c == ' ') {\n                result.Add(max_level);\n    \
    \            max_level = 0L;\n                current_level = 0L;\n          \
    \  }\n        }\n        result.Add(max_level);\n        return result;", "  \
    \      List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        // TODO: Implement this function.\n    \
    \    return result;", "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    ))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        List<long> ret = new List<long>();\n        long max_depth = 0L;\n  \
    \      long depth = 0L;\n        foreach (char c in paren_string) {\n        \
    \    if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            else if (c == ')') {\n                depth--;\n            }\n \
    \           else if (c == ' ') {\n                ret.Add(max_depth);\n      \
    \          max_depth = 0L;\n                depth = 0L;\n            }\n     \
    \   }\n        ret.Add(max_depth);\n        return ret;", "        // Your code\
    \ goes here\n        List<long> result = new List<long>();\n        string[] groups\
    \ = paren_string.Split(' ');\n        foreach (string group in groups) {\n   \
    \         int max = 0;\n            int count = 0;\n            foreach (char\
    \ c in group) {\n                if (c == '(') {\n                    count++;\n\
    \                    if (count > max) {\n                        max = count;\n\
    \                    }\n                } else if (c == ')') {\n             \
    \       count--;\n                }\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long max_depth = 0L;\n        long depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // Fill in your code here.\n        List<long> result = new List<long>();\n\
    \        string[] groups = paren_string.Split(' ');\n        foreach (string group\
    \ in groups) {\n            int max_level = 0;\n            int level = 0;\n \
    \           foreach (char c in group) {\n                if (c == '(') {\n   \
    \                 level++;\n                    if (level > max_level) {\n   \
    \                     max_level = level;\n                    }\n            \
    \    } else if (c == ')') {\n                    level--;\n                }\n\
    \            }\n            result.Add(max_level);\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        int max =\
    \ 0;\n        int count = 0;\n        foreach (char c in paren_string) {\n   \
    \         if (c == '(') {\n                count++;\n                if (count\
    \ > max) {\n                    max = count;\n                }\n            }\n\
    \            else if (c == ')') {\n                count--;\n            }\n \
    \           else if (c == ' ') {\n                result.Add(max);\n         \
    \       max = 0;\n                count = 0;\n            }\n        }\n     \
    \   result.Add(max);\n        return result;", "        List<long> result = new\
    \ List<long>();\n        long max_depth = 0L;\n        long depth = 0L;\n    \
    \    for (long i = 0L; i < paren_string.Length; i++) {\n            if (paren_string[(int)i]\
    \ == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (paren_string[(int)i] == ')') {\n                depth--;\n        \
    \    } else if (paren_string[(int)i] == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // Fill in your code here.\n        List<long> res = new List<long>();\n   \
    \     int max = 0;\n        int cur = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == '(') {\n                cur++;\n\
    \                max = Math.Max(max, cur);\n            } else if (paren_string[i]\
    \ == ')') {\n                cur--;\n            } else if (paren_string[i] ==\
    \ ' ') {\n                res.Add(max);\n                max = 0;\n          \
    \      cur = 0;\n            }\n        }\n        res.Add(max);\n        return\
    \ res;", "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n\
    \        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        var parens = paren_string.Split(' ');\n        var result = new List<long>();\n\
    \        foreach (var paren in parens) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    depth++;\n                    if\
    \ (depth > max_depth) {\n                        max_depth = depth;\n        \
    \            }\n                } else {\n                    depth--;\n     \
    \           }\n            }\n            result.Add(max_depth);\n        }\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (var c in\
    \ paren_string) {\n            if (c == '(') {\n                depth++;\n   \
    \             if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var paren_groups =\
    \ paren_string.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\
    \        var max_nesting = new List<long>();\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_nesting_level = 0L;\n            var\
    \ current_nesting_level = 0L;\n            foreach (var paren in paren_group)\
    \ {\n                if (paren == '(') {\n                    current_nesting_level\
    \ += 1L;\n                    if (current_nesting_level > max_nesting_level) {\n\
    \                        max_nesting_level = current_nesting_level;\n        \
    \            }\n                } else if (paren == ')') {\n                 \
    \   current_nesting_level -= 1L;\n                }\n            }\n         \
    \   max_nesting.Add(max_nesting_level);\n        }\n        return max_nesting;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   List<long> result = new List<long>();\n        long max_depth = 0L;\n    \
    \    long depth = 0L;\n        foreach (char c in paren_string) {\n          \
    \  if (c == '(') {\n                depth += 1L;\n                max_depth =\
    \ Math.Max(max_depth, depth);\n            }\n            else if (c == ')') {\n\
    \                depth -= 1L;\n            }\n            else if (c == ' ') {\n\
    \                result.Add(max_depth);\n                max_depth = 0L;\n   \
    \             depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long current_depth = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_depth\
    \ += 1L;\n                max_depth = Math.Max(max_depth, current_depth);\n  \
    \          }\n            else if (c == ')') {\n                current_depth\
    \ -= 1L;\n            }\n            else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var curr_level = 0L;\n        var max_level\
    \ = 0L;\n        foreach (var c in paren_string) {\n            if (c == '(')\
    \ {\n                curr_level += 1L;\n                max_level = Math.Max(max_level,\
    \ curr_level);\n            } else if (c == ')') {\n                curr_level\
    \ -= 1L;\n            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                max_level = 0L;\n                curr_level = 0L;\n         \
    \   }\n        }\n        result.Add(max_level);\n        return result;", " \
    \       var result = new List<long>();\n        var current_level = 0L;\n    \
    \    var max_level = 0L;\n        foreach (var c in paren_string) {\n        \
    \    if (c == '(') {\n                current_level += 1L;\n                max_level\
    \ = Math.Max(max_level, current_level);\n            } else if (c == ')') {\n\
    \                current_level -= 1L;\n            } else if (c == ' ') {\n  \
    \              result.Add(max_level);\n                max_level = 0L;\n     \
    \           current_level = 0L;\n            }\n        }\n        result.Add(max_level);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long current_level = 0L;\n        long max_level = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_level\
    \ += 1L;\n                max_level = Math.Max(max_level, current_level);\n  \
    \          } else if (c == ')') {\n                current_level -= 1L;\n    \
    \        } else if (c == ' ') {\n                result.Add(max_level);\n    \
    \            max_level = 0L;\n                current_level = 0L;\n          \
    \  }\n        }\n        result.Add(max_level);\n        return result;", "  \
    \      // Fill in the code here.\n        List<long> result = new List<long>();\n\
    \        int max = 0;\n        int count = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++)\n        {\n            if (paren_string[i] == '(')\n            {\n  \
    \              count++;\n                if (count > max)\n                {\n\
    \                    max = count;\n                }\n            }\n        \
    \    else if (paren_string[i] == ')')\n            {\n                count--;\n\
    \            }\n            else if (paren_string[i] == ' ')\n            {\n\
    \                result.Add(max);\n                max = 0;\n                count\
    \ = 0;\n            }\n        }\n        result.Add(max);\n        return result;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var parens = paren_string.Split(' ');\n        var max_nesting = new List<long>();\n\
    \        foreach (var paren in parens) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    depth += 1L;\n                } else\
    \ {\n                    depth -= 1L;\n                }\n                if (depth\
    \ > max_depth) {\n                    max_depth = depth;\n                }\n\
    \            }\n            max_nesting.Add(max_depth);\n        }\n        return\
    \ max_nesting;", "        List<long> result = new List<long>();\n        long\
    \ max_depth = 0L;\n        long cur_depth = 0L;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                cur_depth++;\n             \
    \   if (cur_depth > max_depth) {\n                    max_depth = cur_depth;\n\
    \                }\n            } else if (c == ')') {\n                cur_depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                cur_depth = 0L;\n          \
    \  }\n        }\n        result.Add(max_depth);\n        return result;", "  \
    \      List<long> result = new List<long>();\n        int count = 0;\n       \
    \ int max = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n    \
    \        if (paren_string[i] == '(') {\n                count++;\n           \
    \     if (count > max) {\n                    max = count;\n                }\n\
    \            }\n            else if (paren_string[i] == ')') {\n             \
    \   count--;\n            }\n            else if (paren_string[i] == ' ') {\n\
    \                result.Add(max);\n                max = 0;\n                count\
    \ = 0;\n            }\n        }\n        result.Add(max);\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var stack = new Stack<long>();\n       \
    \ var max = 0L;\n        foreach (var c in paren_string) {\n            if (c\
    \ == '(') {\n                stack.Push(1L);\n            } else if (c == ')')\
    \ {\n                var sum = 0L;\n                while (stack.Peek() != 1L)\
    \ {\n                    sum += stack.Pop();\n                }\n            \
    \    stack.Pop();\n                stack.Push(sum + 1L);\n            } else if\
    \ (c == ' ') {\n                var sum = 0L;\n                while (stack.Count\
    \ > 0) {\n                    sum += stack.Pop();\n                }\n       \
    \         result.Add(sum);\n            }\n        }\n        var sum_1 = 0L;\n\
    \        while (stack.Count > 0) {\n            sum_1 += stack.Pop();\n      \
    \  }\n        result.Add(sum_1);\n        return result;", "        var result\
    \ = new List<long>();\n        var parens = paren_string.Split(' ');\n       \
    \ foreach (var paren in parens) {\n            var max_depth = 0L;\n         \
    \   var depth = 0L;\n            foreach (var c in paren) {\n                if\
    \ (c == '(') {\n                    depth += 1L;\n                    if (depth\
    \ > max_depth) {\n                        max_depth = depth;\n               \
    \     }\n                }\n                else {\n                    depth\
    \ -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var paren_groups = paren_string.Split(' ');\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_depth = 0L;\n            var depth =\
    \ 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    depth++;\n                    if (depth > max_depth)\
    \ {\n                        max_depth = depth;\n                    }\n     \
    \           }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long depth = 0L;\n        long max_depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var groups = paren_string.Split(' ');\n\
    \        foreach (var group in groups) {\n            var stack = new Stack<char>();\n\
    \            var max_depth = 0L;\n            var depth = 0L;\n            foreach\
    \ (var c in group) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    depth += 1L;\n                    max_depth = Math.Max(max_depth,\
    \ depth);\n                } else if (c == ')') {\n                    if (stack.Count\
    \ == 0) {\n                        throw new Exception(\"Unmatched right paren\"\
    );\n                    }\n                    stack.Pop();\n                \
    \    depth -= 1L;\n                } else {\n                    throw new Exception(\"\
    Invalid character\");\n                }\n            }\n            if (stack.Count\
    \ != 0) {\n                throw new Exception(\"Unmatched left paren\");\n  \
    \          }\n            result.Add(max_depth);\n        }\n        return result;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var result = new List<long>();\n        var stack = new Stack<long>();\n \
    \       var max = 0L;\n        foreach (var c in paren_string) {\n           \
    \ if (c == '(') {\n                stack.Push(1L);\n            } else if (c ==\
    \ ')') {\n                if (stack.Count == 0) {\n                    result.Add(max);\n\
    \                    max = 0L;\n                    continue;\n              \
    \  }\n                var count = stack.Pop();\n                if (stack.Count\
    \ == 0) {\n                    max = Math.Max(max, count);\n                }\
    \ else {\n                    stack.Push(stack.Pop() + count);\n             \
    \   }\n            } else if (c == ' ') {\n                result.Add(max);\n\
    \                max = 0L;\n            }\n        }\n        result.Add(max);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        List<long> result = new List<long>();\n        long max_depth\
    \ = 0L;\n        long depth = 0L;\n        foreach (char c in paren_string) {\n\
    \            if (c == '(') {\n                depth++;\n                if (depth\
    \ > max_depth) {\n                    max_depth = depth;\n                }\n\
    \            }\n            else if (c == ')') {\n                depth--;\n \
    \           }\n            else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ result = new List<long>();\n        var stack = new Stack<long>();\n       \
    \ var max = 0L;\n        foreach (var c in paren_string) {\n            if (c\
    \ == '(') {\n                stack.Push(1L);\n            } else if (c == ')')\
    \ {\n                var count = 0L;\n                while (stack.Count > 0 &&\
    \ stack.Peek() > 0) {\n                    count += stack.Pop();\n           \
    \     }\n                stack.Push(count + 1);\n                max = Math.Max(max,\
    \ count + 1);\n            } else if (c == ' ') {\n                result.Add(max);\n\
    \                max = 0L;\n                stack.Clear();\n            }\n  \
    \      }\n        result.Add(max);\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_depth = 0L;\n        long current_depth\
    \ = 0L;\n        foreach (var c in paren_string) {\n            if (c == '(')\
    \ {\n                current_depth++;\n                max_depth = Math.Max(max_depth,\
    \ current_depth);\n            } else if (c == ')') {\n                current_depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        List<long> result = new List<long>();\n        long depth = 0L;\n     \
    \   long max_depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_depth = 0L;\n            var depth = 0L;\n\
    \            foreach (var c in paren_group) {\n                if (c == '(') {\n\
    \                    depth++;\n                    if (depth > max_depth) {\n\
    \                        max_depth = depth;\n                    }\n         \
    \       }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        // Your code here.\n        return new\
    \ List<long>();", "        List<long> result = new List<long>();\n        long\
    \ max_depth = 0L;\n        long depth = 0L;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                depth++;\n                if\
    \ (depth > max_depth) {\n                    max_depth = depth;\n            \
    \    }\n            } else if (c == ')') {\n                depth--;\n       \
    \     } else if (c == ' ') {\n                result.Add(max_depth);\n       \
    \         max_depth = 0L;\n                depth = 0L;\n            }\n      \
    \  }\n        result.Add(max_depth);\n        return result;", "        List<long>\
    \ result = new List<long>();\n        int depth = 0;\n        int max_depth =\
    \ 0;\n        foreach (char c in paren_string) {\n            if (c == '(') {\n\
    \                depth += 1;\n                max_depth = Math.Max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth -= 1;\n \
    \           } else if (c == ' ') {\n                result.Add(max_depth);\n \
    \               max_depth = 0;\n                depth = 0;\n            }\n  \
    \      }\n        result.Add(max_depth);\n        return result;", "        var\
    \ result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_nesting\
    \ = 0L;\n            var current_nesting = 0L;\n            foreach (var c in\
    \ paren_group) {\n                if (c == '(') {\n                    current_nesting\
    \ += 1L;\n                    max_nesting = Math.Max(max_nesting, current_nesting);\n\
    \                } else if (c == ')') {\n                    current_nesting -=\
    \ 1L;\n                }\n            }\n            result.Add(max_nesting);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long current_level = 0L;\n        long max_level = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_level\
    \ += 1L;\n                max_level = Math.Max(max_level, current_level);\n  \
    \          } else if (c == ')') {\n                current_level -= 1L;\n    \
    \        } else if (c == ' ') {\n                result.Add(max_level);\n    \
    \            max_level = 0L;\n                current_level = 0L;\n          \
    \  }\n        }\n        result.Add(max_level);\n        return result;", "  \
    \      // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var paren_groups = paren_string.Split(' ');\n        var result = new List<long>();\n\
    \        foreach (var paren_group in paren_groups) {\n            var max_level\
    \ = 0L;\n            var level = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    level += 1L;\n     \
    \               if (level > max_level) {\n                        max_level =\
    \ level;\n                    }\n                }\n                else if (c\
    \ == ')') {\n                    level -= 1L;\n                }\n           \
    \ }\n            result.Add(max_level);\n        }\n        return result;", " \
    \       List<long> result = new List<long>();\n        long max_depth = 0L;\n\
    \        long depth = 0L;\n        foreach (char c in paren_string) {\n      \
    \      if (c == '(') {\n                depth++;\n                if (depth >\
    \ max_depth) {\n                    max_depth = depth;\n                }\n  \
    \          } else if (c == ')') {\n                depth--;\n            } else\
    \ if (c == ' ') {\n                result.Add(max_depth);\n                max_depth\
    \ = 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     int max_depth = 0;\n        int depth = 0;\n        for (int i = 0; i <\
    \ paren_string.Length; i++) {\n            if (paren_string[i] == '(') {\n   \
    \             depth++;\n                if (depth > max_depth) {\n           \
    \         max_depth = depth;\n                }\n            } else if (paren_string[i]\
    \ == ')') {\n                depth--;\n            } else if (paren_string[i]\
    \ == ' ') {\n                result.Add(max_depth);\n                max_depth\
    \ = 0;\n                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     int max_depth = 0;\n        int depth = 0;\n        for (int i = 0; i <\
    \ paren_string.Length; i++) {\n            if (paren_string[i] == '(') {\n   \
    \             depth++;\n                if (depth > max_depth) {\n           \
    \         max_depth = depth;\n                }\n            } else if (paren_string[i]\
    \ == ')') {\n                depth--;\n            } else if (paren_string[i]\
    \ == ' ') {\n                result.Add(max_depth);\n                max_depth\
    \ = 0;\n                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_depth = 0L;\n            var current_depth\
    \ = 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    current_depth++;\n                    max_depth\
    \ = Math.Max(max_depth, current_depth);\n                } else if (c == ')')\
    \ {\n                    current_depth--;\n                }\n            }\n\
    \            result.Add(max_depth);\n        }\n        return result;", "   \
    \     // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var parens = paren_string.Split(' ');\n        var max_nesting = new List<long>();\n\
    \        foreach (var paren in parens) {\n            var max_nest = 0L;\n   \
    \         var nest = 0L;\n            foreach (var c in paren) {\n           \
    \     if (c == '(') {\n                    nest++;\n                    if (nest\
    \ > max_nest) {\n                        max_nest = nest;\n                  \
    \  }\n                } else if (c == ')') {\n                    nest--;\n  \
    \              }\n            }\n            max_nesting.Add(max_nest);\n    \
    \    }\n        return max_nesting;", "        List<long> result = new List<long>();\n\
    \        long max_nesting = 0L;\n        long current_nesting = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_nesting++;\n\
    \                if (current_nesting > max_nesting) {\n                    max_nesting\
    \ = current_nesting;\n                }\n            } else if (c == ')') {\n\
    \                current_nesting--;\n            } else if (c == ' ') {\n    \
    \            result.Add(max_nesting);\n                max_nesting = 0L;\n   \
    \             current_nesting = 0L;\n            }\n        }\n        result.Add(max_nesting);\n\
    \        return result;", "        var result = new List<long>();\n        foreach\
    \ (var paren_group in paren_string.Split(' ')) {\n            var max_depth =\
    \ 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           max_depth = Math.Max(max_depth, depth);\n                } else if\
    \ (c == ')') {\n                    depth--;\n                }\n            }\n\
    \            result.Add(max_depth);\n        }\n        return result;", "   \
    \     List<long> result = new List<long>();\n        long max_depth = 0L;\n  \
    \      long current_depth = 0L;\n        foreach (char c in paren_string) {\n\
    \            if (c == '(') {\n                current_depth++;\n             \
    \   if (current_depth > max_depth) {\n                    max_depth = current_depth;\n\
    \                }\n            } else if (c == ')') {\n                current_depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var curr_level = 0L;\n        var max_level\
    \ = 0L;\n        foreach (var c in paren_string) {\n            if (c == '(')\
    \ {\n                curr_level += 1L;\n                max_level = Math.Max(max_level,\
    \ curr_level);\n            } else if (c == ')') {\n                curr_level\
    \ -= 1L;\n            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                curr_level = 0L;\n                max_level = 0L;\n         \
    \   }\n        }\n        result.Add(max_level);\n        return result;", " \
    \       // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var paren_groups = paren_string.Split(' ');\n        var max_nesting = new\
    \ List<long>();\n        foreach (var paren_group in paren_groups) {\n       \
    \     var max_nesting_level = 0L;\n            var current_nesting_level = 0L;\n\
    \            foreach (var paren in paren_group) {\n                if (paren ==\
    \ '(') {\n                    current_nesting_level += 1L;\n                 \
    \   if (current_nesting_level > max_nesting_level) {\n                       \
    \ max_nesting_level = current_nesting_level;\n                    }\n        \
    \        } else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1L;\n                }\n            }\n            max_nesting.Add(max_nesting_level);\n\
    \        }\n        return max_nesting;", "        List<long> result = new List<long>();\n\
    \        long max_depth = 0L;\n        long depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var parens = paren_string.Split(' ');\n\
    \        foreach (var paren in parens) {\n            var max_level = 0L;\n  \
    \          var level = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    level++;\n                    if\
    \ (level > max_level) {\n                        max_level = level;\n        \
    \            }\n                }\n                else if (c == ')') {\n    \
    \                level--;\n                }\n            }\n            result.Add(max_level);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long max_depth = 0L;\n        long depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var paren in paren_group)\
    \ {\n                if (paren == '(') {\n                    depth++;\n     \
    \               if (depth > max_depth) {\n                        max_depth =\
    \ depth;\n                    }\n                } else if (paren == ')') {\n\
    \                    depth--;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var paren_groups = paren_string.Split(' ');\n        foreach (var paren_group\
    \ in paren_groups) {\n            var max_depth = 0L;\n            var depth =\
    \ 0L;\n            foreach (var c in paren_group) {\n                if (c ==\
    \ '(') {\n                    depth++;\n                    if (depth > max_depth)\
    \ {\n                        max_depth = depth;\n                    }\n     \
    \           }\n                else if (c == ')') {\n                    depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        // >>> ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var parens = paren_string.Split(' ');\n     \
    \   var result = new List<long>();\n        foreach (var paren in parens) {\n\
    \            var stack = new Stack<char>();\n            var max = 0L;\n     \
    \       var curr = 0L;\n            foreach (var c in paren) {\n             \
    \   if (c == '(') {\n                    stack.Push(c);\n                    curr++;\n\
    \                    if (curr > max) {\n                        max = curr;\n\
    \                    }\n                } else if (c == ')') {\n             \
    \       if (stack.Count == 0) {\n                        throw new Exception(\"\
    Invalid parens\");\n                    }\n                    stack.Pop();\n\
    \                    curr--;\n                }\n            }\n            if\
    \ (stack.Count != 0) {\n                throw new Exception(\"Invalid parens\"\
    );\n            }\n            result.Add(max);\n        }\n        return result;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long depth = 0L;\n        long max_depth\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                depth += 1L;\n                max_depth = Math.Max(max_depth,\
    \ depth);\n            }\n            else if (c == ')') {\n                depth\
    \ -= 1L;\n            }\n            else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max_nesting = 0L;\n        long current_nesting\
    \ = 0L;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                current_nesting++;\n                if (current_nesting >\
    \ max_nesting) {\n                    max_nesting = current_nesting;\n       \
    \         }\n            } else if (c == ')') {\n                current_nesting--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_nesting);\n\
    \                max_nesting = 0L;\n                current_nesting = 0L;\n  \
    \          }\n        }\n        result.Add(max_nesting);\n        return result;",
  "        List<long> result = new List<long>();\n        long current = 0;\n    \
    \    long max = 0;\n        for (long i = 0; i < paren_string.Length; i++) {\n\
    \            if (paren_string[(int)i] == '(') {\n                current++;\n\
    \                if (current > max) {\n                    max = current;\n  \
    \              }\n            }\n            else if (paren_string[(int)i] ==\
    \ ')') {\n                current--;\n            }\n            else if (paren_string[(int)i]\
    \ == ' ') {\n                result.Add(max);\n                max = 0;\n    \
    \            current = 0;\n            }\n        }\n        result.Add(max);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ paren_groups = paren_string.Split(' ');\n        foreach (var paren_group in\
    \ paren_groups) {\n            var max_nesting = 0L;\n            var current_nesting\
    \ = 0L;\n            foreach (var paren in paren_group) {\n                if\
    \ (paren == '(') {\n                    current_nesting += 1L;\n             \
    \       max_nesting = Math.Max(max_nesting, current_nesting);\n              \
    \  } else if (paren == ')') {\n                    current_nesting -= 1L;\n  \
    \              }\n            }\n            result.Add(max_nesting);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        int max_depth = 0;\n        int depth = 0;\n        foreach (char c in\
    \ paren_string) {\n            if (c == '(') {\n                depth += 1;\n\
    \                max_depth = Math.Max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth -= 1;\n            } else if (c == ' ')\
    \ {\n                result.Add(max_depth);\n                max_depth = 0;\n\
    \                depth = 0;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        // Write your code here.\n        List<long>\
    \ result = new List<long>();\n        string[] groups = paren_string.Split(' ');\n\
    \        foreach (string group in groups) {\n            long max = 0;\n     \
    \       long current = 0;\n            foreach (char c in group) {\n         \
    \       if (c == '(') {\n                    current++;\n                    max\
    \ = Math.Max(max, current);\n                } else if (c == ')') {\n        \
    \            current--;\n                }\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        // >>> ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        List<long> ret = new List<long>();\n        int\
    \ i = 0;\n        int j = 0;\n        int k = 0;\n        int l = 0;\n       \
    \ int m = 0;\n        int n = 0;\n        int o = 0;\n        int p = 0;\n   \
    \     int q = 0;\n        int r = 0;\n        int s = 0;\n        int t = 0;\n\
    \        int u = 0;\n        int v = 0;\n        int w = 0;\n        int x = 0;\n\
    \        int y = 0;\n        int z = 0;\n        int aa = 0;\n        int ab =\
    \ 0;\n        int ac = 0;\n        int ad = 0;\n        int ae = 0;\n        int\
    \ af = 0;\n        int ag = 0;\n        int ah = 0;\n        int ai = 0;\n   \
    \     int aj = 0;\n        int ak = 0;\n        int al = 0;\n        int am =\
    \ 0;\n        int an = 0;\n        int ao = 0;\n        int ap = 0;\n        int\
    \ aq = 0;\n        int ar = 0;\n        int as_ = 0;\n        int at = 0;\n  \
    \      int au = 0;\n        int av = 0;\n        int aw = 0;\n        int ax =\
    \ 0;\n        int ay = 0;\n        int az = 0;\n        int ba = 0;\n        int\
    \ bb = 0;\n        int bc = 0;\n        int bd = 0;\n        int be = 0;\n   \
    \     int bf = 0;\n        int bg = 0;\n        int bh = 0;\n        int bi =\
    \ 0;\n        int bj = 0;\n        int bk = 0;\n        int bl = 0;\n        int\
    \ bm = 0;\n        int bn = 0;\n        int bo = 0;\n        int bp", "      \
    \  var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_level\
    \ = 0L;\n            var level = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    level++;\n         \
    \           max_level = Math.Max(max_level, level);\n                } else if\
    \ (c == ')') {\n                    level--;\n                }\n            }\n\
    \            result.Add(max_level);\n        }\n        return result;", "   \
    \     List<long> result = new List<long>();\n        long current_level = 0L;\n\
    \        long max_level = 0L;\n        foreach (char c in paren_string) {\n  \
    \          if (c == '(') {\n                current_level += 1L;\n           \
    \     max_level = Math.Max(max_level, current_level);\n            } else if (c\
    \ == ')') {\n                current_level -= 1L;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_level);\n                max_level =\
    \ 0L;\n                current_level = 0L;\n            }\n        }\n       \
    \ result.Add(max_level);\n        return result;", "        List<long> result\
    \ = new List<long>();\n        long depth = 0L;\n        long max_depth = 0L;\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             depth++;\n                if (depth > max_depth) {\n           \
    \         max_depth = depth;\n                }\n            } else if (c == ')')\
    \ {\n                depth--;\n            } else if (c == ' ') {\n          \
    \      result.Add(max_depth);\n                max_depth = 0L;\n             \
    \   depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n  \
    \      return result;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\n\
    \                else if (c == ')') {\n                    depth--;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        List<long> result = new List<long>();\n      \
    \  long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c in\
    \ paren_string) {\n            if (c == '(') {\n                depth++;\n   \
    \             if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ List<long> result = new List<long>();\n        long max_depth = 0L;\n      \
    \  long current_depth = 0L;\n        for (long i = 0L; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[(int)i] == '(') {\n                current_depth\
    \ += 1L;\n                if (current_depth > max_depth) {\n                 \
    \   max_depth = current_depth;\n                }\n            }\n           \
    \ else if (paren_string[(int)i] == ')') {\n                current_depth -= 1L;\n\
    \            }\n            else if (paren_string[(int)i] == ' ') {\n        \
    \        result.Add(max_depth);\n                max_depth = 0L;\n           \
    \     current_depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long current_depth = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == '(') {\n                current_depth++;\n\
    \                if (current_depth > max_depth) {\n                    max_depth\
    \ = current_depth;\n                }\n            } else if (c == ')') {\n  \
    \              current_depth--;\n            } else if (c == ' ') {\n        \
    \        result.Add(max_depth);\n                max_depth = 0L;\n           \
    \     current_depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        var result = new List<long>();\n        var\
    \ parens = paren_string.Split(' ');\n        foreach (var paren in parens) {\n\
    \            var max_depth = 0L;\n            var depth = 0L;\n            foreach\
    \ (var c in paren) {\n                if (c == '(') {\n                    depth++;\n\
    \                    if (depth > max_depth) {\n                        max_depth\
    \ = depth;\n                    }\n                }\n                else if\
    \ (c == ')') {\n                    depth--;\n                }\n            }\n\
    \            result.Add(max_depth);\n        }\n        return result;", "   \
    \     var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_nesting\
    \ = 0L;\n            var current_nesting = 0L;\n            foreach (var c in\
    \ paren_group) {\n                if (c == '(') {\n                    current_nesting++;\n\
    \                    max_nesting = Math.Max(max_nesting, current_nesting);\n \
    \               } else if (c == ')') {\n                    current_nesting--;\n\
    \                }\n            }\n            result.Add(max_nesting);\n    \
    \    }\n        return result;", "        var groups = paren_string.Split(' ');\n\
    \        var result = new List<long>();\n        foreach (var group in groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in group) {\n                if (c == '(') {\n             \
    \       depth++;\n                    max_depth = Math.Max(max_depth, depth);\n\
    \                } else if (c == ')') {\n                    depth--;\n      \
    \          }\n            }\n            result.Add(max_depth);\n        }\n \
    \       return result;", "        List<long> result = new List<long>();\n    \
    \    long depth = 0L;\n        long max_depth = 0L;\n        foreach (char c in\
    \ paren_string) {\n            if (c == '(') {\n                depth++;\n   \
    \             if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ List<long> result = new List<long>();\n        long max_nesting = 0L;\n    \
    \    long current_nesting = 0L;\n        foreach (char c in paren_string) {\n\
    \            if (c == '(') {\n                current_nesting++;\n           \
    \     if (current_nesting > max_nesting) {\n                    max_nesting =\
    \ current_nesting;\n                }\n            } else if (c == ')') {\n  \
    \              current_nesting--;\n            } else if (c == ' ') {\n      \
    \          result.Add(max_nesting);\n                max_nesting = 0L;\n     \
    \           current_nesting = 0L;\n            }\n        }\n        result.Add(max_nesting);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long max_depth = 0L;\n        long depth = 0L;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth += 1L;\n     \
    \               if (depth > max_depth) {\n                        max_depth =\
    \ depth;\n                    }\n                }\n                else if (c\
    \ == ')') {\n                    depth -= 1L;\n                }\n           \
    \ }\n            result.Add(max_depth);\n        }\n        return result;", " \
    \       var result = new List<long>();\n        var parens = paren_string.Split('\
    \ ');\n        foreach (var paren in parens) {\n            var max_depth = 0L;\n\
    \            var depth = 0L;\n            foreach (var c in paren) {\n       \
    \         if (c == '(') {\n                    depth++;\n                    if\
    \ (depth > max_depth) {\n                        max_depth = depth;\n        \
    \            }\n                }\n                else if (c == ')') {\n    \
    \                depth--;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        // >>> ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var parens = paren_string.Split(' ');\n     \
    \   var max_nesting = new List<long>();\n        foreach (var paren in parens)\
    \ {\n            var max_nesting_in_paren = 0L;\n            var current_nesting\
    \ = 0L;\n            foreach (var c in paren) {\n                if (c == '(')\
    \ {\n                    current_nesting++;\n                    if (current_nesting\
    \ > max_nesting_in_paren) {\n                        max_nesting_in_paren = current_nesting;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    current_nesting--;\n                }\n            }\n\
    \            max_nesting.Add(max_nesting_in_paren);\n        }\n        return\
    \ max_nesting;", "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    ))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        var paren_groups = paren_string.Split(' ');\n        var max_nesting\
    \ = new List<long>();\n        foreach (var paren_group in paren_groups) {\n \
    \           var max_nesting_level = 0L;\n            var current_nesting_level\
    \ = 0L;\n            foreach (var paren in paren_group) {\n                if\
    \ (paren == '(') {\n                    current_nesting_level += 1L;\n       \
    \             if (current_nesting_level > max_nesting_level) {\n             \
    \           max_nesting_level = current_nesting_level;\n                    }\n\
    \                } else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1L;\n                }\n            }\n            max_nesting.Add(max_nesting_level);\n\
    \        }\n        return max_nesting;", "        // Write your code here\n \
    \       List<long> result = new List<long>();\n        int max = 0;\n        int\
    \ count = 0;\n        foreach (char c in paren_string) {\n            if (c ==\
    \ '(') {\n                count++;\n                if (count > max) {\n     \
    \               max = count;\n                }\n            } else if (c == ')')\
    \ {\n                count--;\n            } else if (c == ' ') {\n          \
    \      result.Add(max);\n                max = 0;\n                count = 0;\n\
    \            }\n        }\n        result.Add(max);\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long depth = 0L;\n        foreach (char c in paren_string) {\n       \
    \     if (c == '(') {\n                depth++;\n                if (depth > max_depth)\
    \ {\n                    max_depth = depth;\n                }\n            }\
    \ else if (c == ')') {\n                depth--;\n            } else if (c ==\
    \ ' ') {\n                result.Add(max_depth);\n                max_depth =\
    \ 0L;\n                depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     // >>> paren_string\n        // \"(()()) ((())) () ((())()())\"\n      \
    \  // >>> paren_string.Split(' ')\n        // (new string[]{(string)\"(()())\"\
    , (string)\"((()))\", (string)\"()\", (string)\"((())()())\"})\n        foreach\
    \ (string parens in paren_string.Split(' ')) {\n            // >>> parens\n  \
    \          // \"(()())\"\n            // >>> parens.Length\n            // (long)7L\n\
    \            long max_depth = 0L;\n            long current_depth = 0L;\n    \
    \        for (long i = 0L; i < parens.Length; i++) {\n                // >>> parens[i]\n\
    \                // (char)'('\n                // >>> parens[i] == '('\n     \
    \           // (bool)true\n                if (parens[i] == '(') {\n         \
    \           current_depth++;\n                    max_depth = Math.Max(max_depth,\
    \ current_depth);\n                } else {\n                    current_depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long depth = 0L;\n        long max_depth = 0L;\n        foreach (var\
    \ c in paren_string) {\n            if (c == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        result.Add(max_depth);\n        return result;", "       \
    \ List<long> result = new List<long>();\n        int max_depth = 0;\n        int\
    \ cur_depth = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n  \
    \          if (paren_string[i] == '(') {\n                cur_depth++;\n     \
    \           max_depth = Math.Max(max_depth, cur_depth);\n            } else if\
    \ (paren_string[i] == ')') {\n                cur_depth--;\n            } else\
    \ if (paren_string[i] == ' ') {\n                result.Add(max_depth);\n    \
    \            max_depth = 0;\n                cur_depth = 0;\n            }\n \
    \       }\n        result.Add(max_depth);\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var result = new List<long>();\n\
    \        var stack = new Stack<long>();\n        long depth = 0L;\n        foreach\
    \ (var c in paren_string) {\n            if (c == '(') {\n                stack.Push(depth);\n\
    \                depth++;\n            } else if (c == ')') {\n              \
    \  result.Add(stack.Pop());\n                depth--;\n            }\n       \
    \ }\n        return result;", "        // >>> ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var group in paren_groups) {\n\
    \            var max_nesting = 0L;\n            var current_nesting = 0L;\n  \
    \          foreach (var paren in group) {\n                if (paren == '(') {\n\
    \                    current_nesting += 1L;\n                    if (current_nesting\
    \ > max_nesting) {\n                        max_nesting = current_nesting;\n \
    \                   }\n                }\n                else {\n           \
    \         current_nesting -= 1L;\n                }\n            }\n         \
    \   result.Add(max_nesting);\n        }\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var paren_groups =\
    \ paren_string.Split(' ');\n        var max_nesting = new List<long>();\n    \
    \    foreach (var paren_group in paren_groups) {\n            var max_nesting_level\
    \ = 0L;\n            var nesting_level = 0L;\n            foreach (var paren in\
    \ paren_group) {\n                if (paren == '(') {\n                    nesting_level++;\n\
    \                    if (nesting_level > max_nesting_level) {\n              \
    \          max_nesting_level = nesting_level;\n                    }\n       \
    \         } else if (paren == ')') {\n                    nesting_level--;\n \
    \               }\n            }\n            max_nesting.Add(max_nesting_level);\n\
    \        }\n        return max_nesting;", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        var res = new List<long>();\n     \
    \   var stack = new Stack<long>();\n        long max = 0L;\n        foreach (var\
    \ c in paren_string) {\n            if (c == '(') {\n                stack.Push(1L);\n\
    \            }\n            else if (c == ')') {\n                if (stack.Count\
    \ == 0) {\n                    res.Add(max);\n                    max = 0L;\n\
    \                }\n                else {\n                    var top = stack.Pop();\n\
    \                    if (stack.Count == 0) {\n                        max = Math.Max(max,\
    \ top);\n                    }\n                    else {\n                 \
    \       stack.Push(top + 1L);\n                    }\n                }\n    \
    \        }\n            else if (c == ' ') {\n                res.Add(max);\n\
    \                max = 0L;\n            }\n        }\n        res.Add(max);\n\
    \        return res;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\n\
    \                else if (c == ')') {\n                    depth--;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    ))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_depth\
    \ = 0L;\n            var depth = 0L;\n            foreach (var c in paren_group)\
    \ {\n                if (c == '(') {\n                    depth++;\n         \
    \           if (depth > max_depth) {\n                        max_depth = depth;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    result.Add(max_depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        // TODO: implement this function.\n    \
    \    return result;", "        var result = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\n\
    \                else if (c == ')') {\n                    depth--;\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        List<long> result = new List<long>();\n      \
    \  long max_depth = 0L;\n        long current_depth = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                current_depth++;\n\
    \                if (current_depth > max_depth) {\n                    max_depth\
    \ = current_depth;\n                }\n            } else if (c == ')') {\n  \
    \              current_depth--;\n            } else if (c == ' ') {\n        \
    \        result.Add(max_depth);\n                max_depth = 0L;\n           \
    \     current_depth = 0L;\n            }\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long curr_max = 0L;\n        long curr_level = 0L;\n        for (long i\
    \ = 0L; i < paren_string.Length; i++) {\n            if (paren_string[(int)i]\
    \ == '(') {\n                curr_level += 1L;\n                curr_max = Math.Max(curr_max,\
    \ curr_level);\n            } else if (paren_string[(int)i] == ')') {\n      \
    \          curr_level -= 1L;\n            } else if (paren_string[(int)i] == '\
    \ ') {\n                result.Add(curr_max);\n                curr_max = 0L;\n\
    \                curr_level = 0L;\n            }\n        }\n        result.Add(curr_max);\n\
    \        return result;", "        // >>> ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))\n        var parens = paren_string.Split(' ');\n        var result\
    \ = new List<long>();\n        foreach (var paren in parens) {\n            var\
    \ stack = new Stack<char>();\n            var max_depth = 0L;\n            var\
    \ depth = 0L;\n            foreach (var c in paren) {\n                if (c ==\
    \ '(') {\n                    stack.Push(c);\n                    depth += 1L;\n\
    \                    if (depth > max_depth) {\n                        max_depth\
    \ = depth;\n                    }\n                } else if (c == ')') {\n  \
    \                  if (stack.Count == 0) {\n                        throw new\
    \ Exception(\"Invalid paren string\");\n                    }\n              \
    \      stack.Pop();\n                    depth -= 1L;\n                } else\
    \ {\n                    throw new Exception(\"Invalid paren string\");\n    \
    \            }\n            }\n            if (stack.Count != 0) {\n         \
    \       throw new Exception(\"Invalid paren string\");\n            }\n      \
    \      result.Add(max_depth);\n        }\n        return result;", "        //\
    \ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var result = new List<long>();\n\
    \        var stack = new Stack<long>();\n        var max = 0L;\n        foreach\
    \ (var c in paren_string) {\n            if (c == '(') {\n                stack.Push(1L);\n\
    \            } else if (c == ')') {\n                var count = 0L;\n       \
    \         while (stack.Count > 0) {\n                    var x = stack.Pop();\n\
    \                    if (x == 1L) {\n                        break;\n        \
    \            }\n                    count += x;\n                }\n         \
    \       if (stack.Count == 0) {\n                    result.Add(max);\n      \
    \              max = 0L;\n                } else {\n                    stack.Push(count\
    \ + 1L);\n                }\n            } else if (c == ' ') {\n            \
    \    if (stack.Count > 0) {\n                    result.Add(max);\n          \
    \          max = 0L;\n                }\n            }\n            if (stack.Count\
    \ > 0) {\n                max = Math.Max(max, stack.Peek());\n            }\n\
    \        }\n        if (stack.Count > 0) {\n            result.Add(max);\n   \
    \     }\n        return result;", "        // TODO: implement this function\n\
    \        return new List<long>();", "        // >>> ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var ret = new List<long>();\n        var paren_groups\
    \ = paren_string.Split(' ');\n        foreach (var paren_group in paren_groups)\
    \ {\n            var max_depth = 0L;\n            var depth = 0L;\n          \
    \  foreach (var c in paren_group) {\n                if (c == '(') {\n       \
    \             depth++;\n                    if (depth > max_depth) {\n       \
    \                 max_depth = depth;\n                    }\n                }\
    \ else if (c == ')') {\n                    depth--;\n                }\n    \
    \        }\n            ret.Add(max_depth);\n        }\n        return ret;",
  "        var result = new List<long>();\n        var paren_groups = paren_string.Split('\
    \ ');\n        foreach (var paren_group in paren_groups) {\n            var max_nesting\
    \ = 0L;\n            var current_nesting = 0L;\n            foreach (var paren\
    \ in paren_group) {\n                if (paren == '(') {\n                   \
    \ current_nesting += 1L;\n                    max_nesting = Math.Max(max_nesting,\
    \ current_nesting);\n                } else if (paren == ')') {\n            \
    \        current_nesting -= 1L;\n                }\n            }\n          \
    \  result.Add(max_nesting);\n        }\n        return result;", "        var\
    \ result = new List<long>();\n        var parens = paren_string.Split(' ');\n\
    \        foreach (var paren in parens) {\n            var max_depth = 0L;\n  \
    \          var depth = 0L;\n            foreach (var c in paren) {\n         \
    \       if (c == '(') {\n                    depth += 1L;\n                  \
    \  if (depth > max_depth) {\n                        max_depth = depth;\n    \
    \                }\n                }\n                else {\n              \
    \      depth -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;"]
stop_tokens:
- "\n    }\n"
