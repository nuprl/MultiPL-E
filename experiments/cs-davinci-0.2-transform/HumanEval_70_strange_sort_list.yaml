name: HumanEval_70_strange_sort_list
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given list of integers, return list in strange order.\n    //\
  \ Strange sorting, is when you start with the minimum value,\n    // then maximum\
  \ of the remaining integers, then minimum and so on.\n    // Examples:\n    // >>>\
  \ StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))\n\
  \    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))\n \
  \   // >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L,\
  \ (long)5L})))\n    // (new List<long>(new long[]{(long)5L, (long)5L, (long)5L,\
  \ (long)5L}))\n    // >>> StrangeSortList((new List<long>()))\n    // (new List<long>())\n\
  \    public static List<long> StrangeSortList(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new\
  \ List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));\n\
  \    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L,\
  \ (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L,\
  \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new\
  \ long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));\n\
  \    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L,\
  \ (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L,\
  \ (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>())).Equals((new\
  \ List<long>())));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L,\
  \ (long)4L, (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new\
  \ long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L,\
  \ (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L,\
  \ (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));\n    Debug.Assert(StrangeSortList((new\
  \ List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));\n\
  \    }\n\n}\n"
completions: ["        List<long> res = new List<long>();\n        List<long> lst2\
    \ = new List<long>(lst);\n        lst2.Sort();\n        int i = 0;\n        while\
    \ (lst2.Count > 0) {\n            if (i % 2 == 0) {\n                res.Add(lst2[0]);\n\
    \                lst2.RemoveAt(0);\n            } else {\n                res.Add(lst2[lst2.Count\
    \ - 1]);\n                lst2.RemoveAt(lst2.Count - 1);\n            }\n    \
    \        i++;\n        }\n        return res;", "        List<long> result = new\
    \ List<long>();\n        List<long> lst2 = new List<long>(lst);\n        lst2.Sort();\n\
    \        int i = 0;\n        while (lst2.Count > 0) {\n            if (i % 2 ==\
    \ 0) {\n                result.Add(lst2[0]);\n                lst2.RemoveAt(0);\n\
    \            } else {\n                result.Add(lst2[lst2.Count - 1]);\n   \
    \             lst2.RemoveAt(lst2.Count - 1);\n            }\n            i++;\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        List<long> lstCopy = new List<long>(lst);\n        bool isMin = true;\n\
    \        while (lstCopy.Count > 0) {\n            long min = lstCopy.Min();\n\
    \            long max = lstCopy.Max();\n            if (isMin) {\n           \
    \     result.Add(min);\n                lstCopy.Remove(min);\n            } else\
    \ {\n                result.Add(max);\n                lstCopy.Remove(max);\n\
    \            }\n            isMin = !isMin;\n        }\n        return result;",
  "        var result = new List<long>();\n        var min = lst.Min();\n        var\
    \ max = lst.Max();\n        var minIndex = lst.IndexOf(min);\n        var maxIndex\
    \ = lst.IndexOf(max);\n        var minCount = lst.Count(x => x == min);\n    \
    \    var maxCount = lst.Count(x => x == max);\n        var minList = new List<long>();\n\
    \        var maxList = new List<long>();\n        for (int i = 0; i < minCount;\
    \ i++) {\n            minList.Add(min);\n        }\n        for (int i = 0; i\
    \ < maxCount; i++) {\n            maxList.Add(max);\n        }\n        var minListIndex\
    \ = 0;\n        var maxListIndex = 0;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (i % 2 == 0) {\n                result.Add(minList[minListIndex]);\n\
    \                minListIndex++;\n            } else {\n                result.Add(maxList[maxListIndex]);\n\
    \                maxListIndex++;\n            }\n        }\n        return result;",
  "        if (lst.Count == 0) {\n            return new List<long>();\n        }\n\
    \        List<long> result = new List<long>();\n        List<long> remaining =\
    \ new List<long>(lst);\n        while (remaining.Count > 0) {\n            long\
    \ min = remaining.Min();\n            long max = remaining.Max();\n          \
    \  result.Add(min);\n            remaining.Remove(min);\n            if (remaining.Count\
    \ > 0) {\n                result.Add(max);\n                remaining.Remove(max);\n\
    \            }\n        }\n        return result;", "        List<long> result\
    \ = new List<long>();\n        if (lst.Count == 0) {\n            return result;\n\
    \        }\n        long min = lst.Min();\n        long max = lst.Max();\n   \
    \     long min_index = lst.IndexOf(min);\n        long max_index = lst.IndexOf(max);\n\
    \        lst.RemoveAt((int)min_index);\n        lst.RemoveAt((int)max_index);\n\
    \        result.Add(min);\n        result.Add(max);\n        while (lst.Count\
    \ > 0) {\n            min = lst.Min();\n            max = lst.Max();\n       \
    \     min_index = lst.IndexOf(min);\n            max_index = lst.IndexOf(max);\n\
    \            lst.RemoveAt((int)min_index);\n            lst.RemoveAt((int)max_index);\n\
    \            result.Add(min);\n            result.Add(max);\n        }\n     \
    \   return result;", "        var result = new List<long>();\n        var sorted\
    \ = lst.OrderBy(x => x).ToList();\n        var min = sorted.First();\n       \
    \ var max = sorted.Last();\n        var minIndex = lst.IndexOf(min);\n       \
    \ var maxIndex = lst.IndexOf(max);\n        var minCount = 0;\n        var maxCount\
    \ = 0;\n        var minFound = false;\n        var maxFound = false;\n       \
    \ for (int i = 0; i < lst.Count; i++) {\n            if (i == minIndex) {\n  \
    \              result.Add(min);\n                minFound = true;\n          \
    \      minCount++;\n            } else if (i == maxIndex) {\n                result.Add(max);\n\
    \                maxFound = true;\n                maxCount++;\n            }\
    \ else {\n                if (minFound && maxFound) {\n                    min\
    \ = sorted[minCount];\n                    max = sorted[sorted.Count - maxCount\
    \ - 1];\n                    minIndex = lst.IndexOf(min);\n                  \
    \  maxIndex = lst.IndexOf(max);\n                    minFound = false;\n     \
    \               maxFound = false;\n                }\n            }\n        }\n\
    \        return result;", "        if (lst.Count == 0) {\n            return lst;\n\
    \        }\n        var min = lst.Min();\n        var max = lst.Max();\n     \
    \   var result = new List<long>();\n        var minIndex = lst.IndexOf(min);\n\
    \        var maxIndex = lst.IndexOf(max);\n        var minRemaining = lst.Where((x,\
    \ i) => i != minIndex).ToList();\n        var maxRemaining = lst.Where((x, i)\
    \ => i != maxIndex).ToList();\n        var minRemainingSorted = minRemaining.OrderBy(x\
    \ => x).ToList();\n        var maxRemainingSorted = maxRemaining.OrderByDescending(x\
    \ => x).ToList();\n        var minRemainingSortedIndex = 0;\n        var maxRemainingSortedIndex\
    \ = 0;\n        var minRemainingSortedCount = minRemainingSorted.Count;\n    \
    \    var maxRemainingSortedCount = maxRemainingSorted.Count;\n        var minRemainingSortedIndexMax\
    \ = minRemainingSortedCount - 1;\n        var maxRemainingSortedIndexMax = maxRemainingSortedCount\
    \ - 1;\n        var minRemainingSortedIndexMin = 0;\n        var maxRemainingSortedIndexMin\
    \ = 0;\n        var minRemainingSortedIndexMinMax = minRemainingSortedIndexMax;\n\
    \        var maxRemainingSortedIndexMinMax = maxRemainingSortedIndexMax;\n   \
    \     var minRemainingSortedIndexMinMaxCount = minRemainingSortedIndexMax + 1;\n\
    \        var maxRemainingSortedIndexMinMaxCount = maxRemainingSortedIndexMax +\
    \ 1;\n        var minRemainingSortedIndexMinMaxCountHalf = minRemainingSortedIndexMinMaxCount\
    \ / 2;\n        var maxRemainingSortedIndexMinMaxCountHalf = maxRemainingSortedIndexMinMaxCount\
    \ / 2;\n        var minRemainingSortedIndexMinMaxCountHalfMinusOne = minRemainingSortedIndexMinMaxCountHalf\
    \ - 1;\n        var maxRemainingSortedIndexMinMaxCountHalfMinusOne = maxRemainingSortedIndexMinMaxCountHalf\
    \ - 1;\n        var minRemainingSortedIndexMin", "        if (lst.Count == 0)\
    \ {\n            return lst;\n        }\n        List<long> res = new List<long>();\n\
    \        long min = lst.Min();\n        long max = lst.Max();\n        bool min_first\
    \ = true;\n        while (lst.Count > 0) {\n            if (min_first) {\n   \
    \             res.Add(min);\n                lst.Remove(min);\n              \
    \  min_first = false;\n            } else {\n                res.Add(max);\n \
    \               lst.Remove(max);\n                min_first = true;\n        \
    \    }\n            if (lst.Count == 0) {\n                break;\n          \
    \  }\n            min = lst.Min();\n            max = lst.Max();\n        }\n\
    \        return res;", "        List<long> result = new List<long>();\n      \
    \  List<long> lstCopy = new List<long>(lst);\n        bool isMin = true;\n   \
    \     while (lstCopy.Count > 0) {\n            long min = lstCopy.Min();\n   \
    \         long max = lstCopy.Max();\n            if (isMin) {\n              \
    \  result.Add(min);\n                lstCopy.Remove(min);\n            } else\
    \ {\n                result.Add(max);\n                lstCopy.Remove(max);\n\
    \            }\n            isMin = !isMin;\n        }\n        return result;",
  "        // Your code goes here.\n        return lst;", "        List<long> result\
    \ = new List<long>();\n        List<long> sorted = lst.OrderBy(x => x).ToList();\n\
    \        int i = 0;\n        while (sorted.Count > 0) {\n            if (i % 2\
    \ == 0) {\n                result.Add(sorted[0]);\n                sorted.RemoveAt(0);\n\
    \            } else {\n                result.Add(sorted[sorted.Count - 1]);\n\
    \                sorted.RemoveAt(sorted.Count - 1);\n            }\n         \
    \   i++;\n        }\n        return result;", "        List<long> result = new\
    \ List<long>();\n        List<long> lst2 = new List<long>(lst);\n        while\
    \ (lst2.Count > 0) {\n            long min = lst2.Min();\n            long max\
    \ = lst2.Max();\n            result.Add(min);\n            lst2.Remove(min);\n\
    \            if (lst2.Count > 0) {\n                result.Add(max);\n       \
    \         lst2.Remove(max);\n            }\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        List<long> lst1 = new List<long>(lst);\n\
    \        List<long> lst2 = new List<long>(lst);\n        lst1.Sort();\n      \
    \  lst2.Sort();\n        lst2.Reverse();\n        int i = 0;\n        while (i\
    \ < lst.Count) {\n            if (i % 2 == 0) {\n                result.Add(lst1[0]);\n\
    \                lst1.RemoveAt(0);\n            } else {\n                result.Add(lst2[0]);\n\
    \                lst2.RemoveAt(0);\n            }\n            i = i + 1;\n  \
    \      }\n        return result;", "        List<long> result = new List<long>();\n\
    \        List<long> lst2 = new List<long>(lst);\n        long min = lst2.Min();\n\
    \        long max = lst2.Max();\n        while (lst2.Count > 0) {\n          \
    \  result.Add(min);\n            lst2.Remove(min);\n            if (lst2.Count\
    \ > 0) {\n                result.Add(max);\n                lst2.Remove(max);\n\
    \            }\n            min = lst2.Min();\n            max = lst2.Max();\n\
    \        }\n        return result;", "        if (lst.Count == 0) {\n        \
    \    return lst;\n        }\n        long min = lst.Min();\n        long max =\
    \ lst.Max();\n        bool isMin = true;\n        List<long> res = new List<long>();\n\
    \        while (lst.Count > 0) {\n            if (isMin) {\n                res.Add(min);\n\
    \                lst.Remove(min);\n            } else {\n                res.Add(max);\n\
    \                lst.Remove(max);\n            }\n            isMin = !isMin;\n\
    \            min = lst.Min();\n            max = lst.Max();\n        }\n     \
    \   return res;", "        List<long> result = new List<long>();\n        List<long>\
    \ lst1 = new List<long>(lst);\n        List<long> lst2 = new List<long>(lst);\n\
    \        lst1.Sort();\n        lst2.Sort();\n        lst2.Reverse();\n       \
    \ for (int i = 0; i < lst.Count; i++) {\n            if (i % 2 == 0) {\n     \
    \           result.Add(lst1[0]);\n                lst1.RemoveAt(0);\n        \
    \    } else {\n                result.Add(lst2[0]);\n                lst2.RemoveAt(0);\n\
    \            }\n        }\n        return result;", "        List<long> result\
    \ = new List<long>();\n        if (lst.Count == 0) {\n            return result;\n\
    \        }\n        List<long> lst2 = new List<long>(lst);\n        while (lst2.Count\
    \ > 0) {\n            long min = lst2.Min();\n            result.Add(min);\n \
    \           lst2.Remove(min);\n            if (lst2.Count > 0) {\n           \
    \     long max = lst2.Max();\n                result.Add(max);\n             \
    \   lst2.Remove(max);\n            }\n        }\n        return result;", "  \
    \      List<long> result = new List<long>();\n        List<long> temp = new List<long>();\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            temp.Add(lst[i]);\n\
    \        }\n        while (temp.Count > 0) {\n            long min = temp[0];\n\
    \            long max = temp[0];\n            int minIndex = 0;\n            int\
    \ maxIndex = 0;\n            for (int i = 0; i < temp.Count; i++) {\n        \
    \        if (temp[i] < min) {\n                    min = temp[i];\n          \
    \          minIndex = i;\n                }\n                if (temp[i] > max)\
    \ {\n                    max = temp[i];\n                    maxIndex = i;\n \
    \               }\n            }\n            result.Add(min);\n            temp.RemoveAt(minIndex);\n\
    \            if (temp.Count > 0) {\n                result.Add(max);\n       \
    \         temp.RemoveAt(maxIndex);\n            }\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        List<long> lst2 = new List<long>(lst);\n\
    \        while (lst2.Count > 0) {\n            long min = lst2.Min();\n      \
    \      result.Add(min);\n            lst2.Remove(min);\n            if (lst2.Count\
    \ > 0) {\n                long max = lst2.Max();\n                result.Add(max);\n\
    \                lst2.Remove(max);\n            }\n        }\n        return result;"]
stop_tokens:
- "\n    }\n"
