name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same\
  \ length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n//\
  \ * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][],\
  \ capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                max_fill++;\n            }\n\
    \        }\n    }\n    while (max_fill > 0) {\n        for (let i = 0; i < grid.length;\
    \ i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n           \
    \     if (grid[i][j] === 1) {\n                    grid[i][j] = 0;\n         \
    \           max_fill--;\n                    count++;\n                }\n   \
    \         }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 0, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 0, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 10));\n", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let\
    \ j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity)\
    \ {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \    ],\n    1\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1,\
    \ 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n \
    \   [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    4\n\
    \  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let fill = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      fill += grid[i][j];\n    }\n    count += Math.ceil(fill / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1", " \
    \   let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n                grid[i][j] = 0;\n            }\n     \
    \   }\n    }\n    return count / capacity;\n}\n\nconsole.log(max_fill([[1, 1,\
    \ 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n \
    \   if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n\
    \  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1, 1, 1]], 2));\n\
    console.log(2 == max_fill([[1, 1, 1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1,\
    \ 1, 1, 1, 1]], 0));\nconsole.log(3 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1]], 2));\nconsole.log(5 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\n\
    console.log(6 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(\n\
    \  5 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2)\n);\n\
    console.log(\n  7 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1]], 1)\n);\nconsole.log(\n  9 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1]], 0)\n);", "    let max_fill = 0;\n    for (let row of grid)\
    \ {\n        let fill = 0;\n        for (let well of row) {\n            fill\
    \ += well;\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n \
    \   return max_fill;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        for (let j = 0; j < row.length; j++)\
    \ {\n            if (row[j] === 1) {\n                max++;\n            }\n\
    \        }\n    }\n    while (max > 0) {\n        for (let i = 0; i < grid.length;\
    \ i++) {\n            let row = grid[i];\n            for (let j = 0; j < row.length;\
    \ j++) {\n                if (row[j] === 1) {\n                    row[j] = 0;\n\
    \                    max--;\n                    if (max === 0) {\n          \
    \              return count + 1;\n                    }\n                }\n \
    \           }\n        }\n        count++;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n \
    \ }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1]], 10));", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n\
    \    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1", "    let count\
    \ = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  max = Math.max(max, Math.max(...grid[i]));\n    }\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] < max) {\n                grid[i][j] = max;\n      \
    \          count++;\n            }\n        }\n    }\n    return count;\n}\n\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 0));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[", "    let result = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                fill++;\n            }\n        }\n        result\
    \ += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length;\
    \ j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n\
    \            count += Math.ceil(sum / capacity);\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(1, max_fill([[1, 1, 1]], 1));\nconsole.log(2, max_fill([[1,\
    \ 1, 1]], 2));\nconsole.log(3, max_fill([[1, 1, 1]], 3));\nconsole.log(2, max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 3));\nconsole.log(3, max_fill([[1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(2, max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3, max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4, max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(3, max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 3));\nconsole.log(4, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\n\
    console.log(5, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(6,\
    \ max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(7, max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(8, max_fill([[1,", "    let\
    \ count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n\
    \        max = Math.max(...grid[i]);\n        count += Math.ceil(max / capacity);\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1,", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max =\
    \ Math.max(...grid[i]);\n        if (max > capacity) {\n            count += max\
    \ - capacity;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max =\
    \ Math.max(...grid[i]);\n        if (max > capacity) {\n            count += max\
    \ - capacity;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_", "    throw new Error(\"\
    Method not implemented.\");\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\
    \ [1, 1, 1]], 2));", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n  return\
    \ Math.ceil(count / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 2)); // 3\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 3)); // 2\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 4)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 1)); // 9\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 5)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 6)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 7)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 8)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 9)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 10)); // 1\nconsole.log", "  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n \
    \   for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if\
    \ (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n\
    \  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n\
    \        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1", "  let result = 0;\n\
    \  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let fill\
    \ = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      fill += grid[i][j];\n\
    \    }\n    if (fill > max_fill) {\n      max_fill = fill;\n    }\n  }\n  result\
    \ = Math.ceil(max_fill / capacity);\n  return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1", "    let count =\
    \ 0;\n    let max = 0;\n    let max_index = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n            max_index = i;\n        }\n\
    \        count = 0;\n    }\n    return Math.ceil(max / capacity);\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1", "    let count = 0;\n    let max_fill = 0;\n    let\
    \ max_fill_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
    \ sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum\
    \ += grid[i][j];\n        }\n        if (sum > max_fill) {\n            max_fill\
    \ = sum;\n            max_fill_index = i;\n        }\n    }\n    let bucket =\
    \ capacity;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n\
    \        }\n        if (i !== max_fill_index) {\n            bucket -= sum;\n\
    \            if (bucket < 0) {\n                count++;\n                bucket\
    \ = capacity;\n                bucket -= sum;\n            }\n        }\n    }\n\
    \    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     filled++;\n            }\n        }\n        if (filled > capacity) {\n\
    \            result += filled - capacity;\n        }\n    }\n    return result;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 0));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 100));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1]], -1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n   \
    \ let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++)\
    \ {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n\
    \  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n    \
    \  count += Math.ceil(fill / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1", "  let count = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let\
    \ j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill += 1;\n\
    \      }\n    }\n    if (fill > capacity) {\n      count += fill - capacity;\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1],\
    \ [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 0, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 0, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 0, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum +=\
    \ row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "  let result = 0;\n  let max_row = grid.length;\n  let max_col = grid[0].length;\n\
    \  let max_row_fill = 0;\n  let max_col_fill = 0;\n  for (let i = 0; i < max_row;\
    \ i++) {\n    for (let j = 0; j < max_col; j++) {\n      if (grid[i][j] === 1)\
    \ {\n        max_row_fill++;\n      }\n    }\n    result += Math.ceil(max_row_fill\
    \ / capacity);\n    max_row_fill = 0;\n  }\n  for (let i = 0; i < max_col; i++)\
    \ {\n    for (let j = 0; j < max_row; j++) {\n      if (grid[j][i] === 1) {\n\
    \        max_col_fill++;\n      }\n    }\n    result += Math.ceil(max_col_fill\
    \ / capacity);\n    max_col_fill = 0;\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1,", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                filled++;\n            }\n        }\n        count\
    \ += Math.ceil(filled / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "    let max_fill\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n     \
    \       if (row[j] === 1) {\n                fill++;\n            }\n        }\n\
    \        max_fill = Math.max(max_fill, fill);\n    }\n    return Math.ceil(max_fill\
    \ / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]", "    let result = 0;\n    let row_max = 0;\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        row_max = Math.max(...grid[i]);\n      \
    \  result += row_max;\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          grid[i][j] = row_max - grid[i][j];\n        }\n    }\n    return result;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max", "    let result = 0;\n    let max_fill = 0;\n    for\
    \ (let row of grid) {\n        let fill = 0;\n        for (let well of row) {\n\
    \            fill += well;\n        }\n        max_fill = Math.max(max_fill, fill);\n\
    \    }\n    while (max_fill > 0) {\n        result++;\n        max_fill -= capacity;\n\
    \    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1", "    throw new\
    \ Error(\"Method not implemented.\");\n}\n\nexport { max_fill }", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1", "    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n                let bucket = capacity;\n       \
    \         while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i -\
    \ 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n              \
    \          bucket--;\n                    }\n                    if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n  \
    \                      bucket--;\n                    }\n                    if\
    \ (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j -\
    \ 1] = 0;\n                        bucket--;\n                    }\n        \
    \            if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n         \
    \               grid[i][j + 1] = 0;\n                        bucket--;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let sum = row.reduce((acc, curr) => acc + curr,\
    \ 0);\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], -1));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 14));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 15));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1]], 16));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 17));\nconsole.log",
  "    let count = 0;\n    let row_max = 0;\n    let col_max = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] > row_max) {\n                row_max = grid[i][j];\n\
    \            }\n            if (grid[j][i] > col_max) {\n                col_max\
    \ = grid[j][i];\n            }\n        }\n        count += Math.min(row_max,\
    \ capacity);\n        count += Math.min(col_max, capacity);\n        row_max =\
    \ 0;\n        col_max = 0;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max =\
    \ 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max++;\n            }\n        }\n        count +=\
    \ Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      if (row[j] === 1) {\n                filled++;\n            }\n       \
    \ }\n        count += Math.ceil(filled / capacity);\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 9));\nconsole", "    let result = 0;\n    let max_row = grid.length;\n    let\
    \ max_col = grid[0].length;\n    let row = 0;\n    let col = 0;\n    let bucket\
    \ = capacity;\n    while (row < max_row) {\n        if (grid[row][col] === 1)\
    \ {\n            bucket--;\n            grid[row][col] = 0;\n        }\n     \
    \   if (bucket === 0) {\n            bucket = capacity;\n            result++;\n\
    \        }\n        col++;\n        if (col === max_col) {\n            col =\
    \ 0;\n            row++;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n\
    \        }\n        if (sum > capacity) {\n            count += Math.ceil(sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "    throw new Error(\"Method not implemented.\");\n}\n\nexport { max_fill }", " \
    \ let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n  \
    \  }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1", "    let count = 0;\n    let row_max = 0;\n   \
    \ for (let i = 0; i < grid.length; i++) {\n        row_max = 0;\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             row_max++;\n            }\n        }\n        count += Math.ceil(row_max\
    \ / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill", "    let result\
    \ = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  max = Math.max(...grid[i]);\n        result += max;\n        for (let j = 0;\
    \ j < grid[i].length; j++) {\n            grid[i][j] = Math.max(0, grid[i][j]\
    \ - max);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0,\
    \ 0], [0, 0, 0]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_",
  "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   max = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        max++;\n      }\n    }\n    count += Math.ceil(max / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n \
    \   for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if\
    \ (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n\
    \  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n", "    let count = 0;\n\
    \    for (let row of grid) {\n        let bucket = capacity;\n        for (let\
    \ i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n           \
    \     if (bucket > 0) {\n                    bucket--;\n                    row[i]\
    \ = 0;\n                } else {\n                    count++;\n             \
    \       bucket = capacity - 1;\n                    row[i] = 0;\n            \
    \    }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1", "  throw new Error(\"Method not implemented.\");\n\
    }\n\n(function() {\n  const rl = require(\"readline\").createInterface({\n   \
    \ input: process.stdin,\n    output: process.stdout\n  });\n\n  rl.question(\"\
    Enter grid: \", grid => {\n    rl.question(\"Enter capacity: \", capacity => {\n\
    \      console.log(max_fill(grid, capacity));\n      rl.close();\n    });\n  });\n\
    })();", "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      let row = grid[i];\n        let row_max = Math.max(...row);\n        if\
    \ (row_max > 0) {\n            result += Math.ceil(row_max / capacity);\n    \
    \    }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1,", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n  return count\
    \ / capacity;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = row.reduce((a, b) => a + b, 0);\n        if (sum\
    \ > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1", "    let num_fill = 0;\n    let row_max = 0;\n    let row_min = 0;\n\
    \    let row_fill = 0;\n    let col_max = 0;\n    let col_min = 0;\n    let col_fill\
    \ = 0;\n    let row_max_index = 0;\n    let row_min_index = 0;\n    let col_max_index\
    \ = 0;\n    let col_min_index = 0;\n    let row_max_count = 0;\n    let row_min_count\
    \ = 0;\n    let col_max_count = 0;\n    let col_min_count = 0;\n    let row_max_fill\
    \ = 0;\n    let row_min_fill = 0;\n    let col_max_fill = 0;\n    let col_min_fill\
    \ = 0;\n    let row_max_fill_index = 0;\n    let row_min_fill_index = 0;\n   \
    \ let col_max_fill_index = 0;\n    let col_min_fill_index = 0;\n    let row_max_fill_count\
    \ = 0;\n    let row_min_fill_count = 0;\n    let col_max_fill_count = 0;\n   \
    \ let col_min_fill_count = 0;\n    let row_max_fill_total = 0;\n    let row_min_fill_total\
    \ = 0;\n    let col_max_fill_total = 0;\n    let col_min_fill_total = 0;\n   \
    \ let row_max_fill_total_index = 0;\n    let row_min_fill_total_index = 0;\n \
    \   let col_max_fill_total_index = 0;\n    let col_min_fill_total_index = 0;\n\
    \    let row_max_fill_total_count = 0;\n    let row_min_fill_total_count = 0;\n\
    \    let col_max_fill_total_count = 0;\n    let col_min_fill_total_count = 0;\n\
    \    let row_max_fill_total_total = 0;\n    let row_min_fill_total_total = 0;\n\
    \    let col_max_fill_total_", "    let count = 0;\n    let max = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] > max) {\n                max = grid[i][j];\n\
    \            }\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ < max) {\n                grid[i][j] = max;\n                count++;\n    \
    \        }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1", "    let result = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity)\
    \ {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n\
    \    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n  \
    \          count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1,", "    let result = 0;\n    let max_row = grid.length;\n    let max_col\
    \ = grid[0].length;\n    let max_fill = 0;\n    let max_fill_row = 0;\n    let\
    \ max_fill_col = 0;\n    let max_fill_count = 0;\n    let max_fill_count_row =\
    \ 0;\n    let max_fill_count_col = 0;\n    let max_fill_count_total = 0;\n   \
    \ let max_fill_count_total_row = 0;\n    let max_fill_count_total_col = 0;\n \
    \   let max_fill_count_total_row_col = 0;\n    let max_fill_count_total_row_col_row\
    \ = 0;\n    let max_fill_count_total_row_col_col = 0;\n    let max_fill_count_total_row_col_row_col\
    \ = 0;\n    let max_fill_count_total_row_col_row_col_row = 0;\n    let max_fill_count_total_row_col_row_col_col\
    \ = 0;\n    let max_fill_count_total_row_col_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row\
    \ = 0;\n    let max_fill_count_total_row_col_row_col_row_col_col = 0;\n    let\
    \ max_fill_count_total_row_col_row_col_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_row\
    \ = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_col = 0;\n\
    \    let max_fill_count_total_row_col_row_col_row_col_row_col_row_col = 0;\n \
    \   let max_fill_count_total_row_col_row_col_row_col_row_col_row_col_row = 0;\n\
    \    let max_fill_count_total", "  let count = 0;\n  let max = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        max += 1;\n      }\n    }\n  }\n \
    \ let current = 0;\n  while (current < max) {\n    for (let i = 0; i < grid.length;\
    \ i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j]\
    \ === 1) {\n          grid[i][j] = 0;\n          current += 1;\n        }\n  \
    \    }\n    }\n    count += 1;\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b)\
    \ => a + b, 0);\n        if (row_sum > capacity) {\n            result += row_sum\
    \ / capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let\
    \ row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++)\
    \ {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    count +=\
    \ Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1",
  "    let count = 0;\n    let max_row = grid.length;\n    let max_col = grid[0].length;\n\
    \    let max_row_sum = 0;\n    let max_col_sum = 0;\n    for (let i = 0; i < max_row;\
    \ i++) {\n        let row_sum = 0;\n        for (let j = 0; j < max_col; j++)\
    \ {\n            row_sum += grid[i][j];\n        }\n        max_row_sum = Math.max(max_row_sum,\
    \ row_sum);\n    }\n    for (let j = 0; j < max_col; j++) {\n        let col_sum\
    \ = 0;\n        for (let i = 0; i < max_row; i++) {\n            col_sum += grid[i][j];\n\
    \        }\n        max_col_sum = Math.max(max_col_sum, col_sum);\n    }\n   \
    \ count += Math.ceil(max_row_sum / capacity);\n    count += Math.ceil(max_col_sum\
    \ / capacity);\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\n\
    console.log(max_fill([[1, 1", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     filled++;\n            }\n        }\n        count += Math.ceil(filled /\
    \ capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1],\
    \ [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n  \
    \  }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let filled = 0;\n    for (let j = 0; j <\
    \ row.length; j++) {\n      if (row[j] === 1) {\n        filled++;\n      }\n\
    \    }\n    if (filled > capacity) {\n      count += filled - capacity;\n    }\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log", "  let count = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a,\
    \ b) => a + b, 0);\n    if (row_sum === 0) {\n      continue;\n    }\n    count\
    \ += Math.ceil(row_sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1", "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let\
    \ row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum\
    \ > capacity) {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n\
    \  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n  \
    \  for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n\
    \    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1", "    let count = 0;\n    let max_fill = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            max_fill += grid[i][j];\n        }\n    }\n    while (max_fill\
    \ > 0) {\n        for (let i = 0; i < grid.length; i++) {\n            for (let\
    \ j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] > 0) {\n \
    \                   grid[i][j] -= capacity;\n                    max_fill -= capacity;\n\
    \                    if (grid[i][j] < 0) {\n                        max_fill +=\
    \ grid[i][j];\n                    }\n                }\n            }\n     \
    \   }\n        count++;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n    \
    \    for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n\
    \        }\n        if (sum > capacity) {\n            count += Math.ceil(sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1,", "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        max_fill = 0;\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max_fill++;\n \
    \           }\n        }\n        if (max_fill > capacity) {\n            result\
    \ += max_fill - capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,", "    let count = 0;\n\
    \    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
    \                count++;\n            }\n        }\n        if (count > max_fill)\
    \ {\n            max_fill = count;\n        }\n        count = 0;\n    }\n   \
    \ return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            let cell = row[j];\n            if\
    \ (cell === 1) {\n                fill++;\n            }\n        }\n        result\
    \ += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1", "  let result = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let count = 0;\n\
    \    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n     \
    \   count++;\n      }\n    }\n    result += Math.ceil(count / capacity);\n  }\n\
    \  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        let fill = Math.floor(sum\
    \ / capacity);\n        count += fill;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1", "    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1,", "    let result = 0;\n    let max_fill = 0;\n    for (let row\
    \ of grid) {\n        max_fill = Math.max(max_fill, Math.max(...row));\n    }\n\
    \    for (let i = 0; i < max_fill; i++) {\n        result += fill_row(grid, capacity);\n\
    \    }\n    return result;\n}\n", "  let count = 0;\n  let max_fill = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    for (let j\
    \ = 0; j < row.length; j++) {\n      let cell = row[j];\n      if (cell === 1)\
    \ {\n        count += 1;\n      }\n    }\n    if (count > max_fill) {\n      max_fill\
    \ = count;\n    }\n    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum\
    \ = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n\
    \  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    4\n  )\n);\nconsole.log(\n  max_fill(\n\
    \    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    5\n  )\n);\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n\
    \    if (sum === 0) {\n      continue;\n    }\n    count += Math.ceil(sum / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(1 === max_fill([[1, 1, 1]], 2));\nconsole.log(2\
    \ === max_fill([[1, 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1, 1]], 1));\n\
    console.log(3 === max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4 === max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(5 === max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(5\
    \ === max_fill([[1, 1, 1], [1, 1, 1]], 5));\nconsole.log(6 === max_fill([[1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(6 === max_fill([[1, 1, 1], [1, 1, 1]], 7));\n\
    console.log(7 === max_fill([[1, 1, 1], [1, 1, 1]], 8));\nconsole.log(7 === max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 9));\nconsole.log(8 === max_fill([[1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(8 === max_fill([[1, 1, 1], [1, 1, 1]], 11));\nconsole.log(9\
    \ === max_fill([[1, 1, 1], [1, 1, 1]], 12));\nconsole.log(9 === max_fill([[1,\
    \ 1,", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row\
    \ = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n \
    \     sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum\
    \ / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1,\
    \ 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 ==\
    \ max_fill([[1, 1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1, 1]], 1));\n\
    console.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 1));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(2 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 5));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 6));\n\
    console.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 7));\nconsole.log(1 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 8));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 9));\n\
    console.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 10));\nconsole.log(1 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 11));\nconsole.log(1 == max_fill", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let sum = row.reduce((acc, curr) => acc + curr, 0);\n        count += Math.ceil(sum\
    \ / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole", "    let count = 0;\n    let max_fill\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > max_fill) {\n            max_fill\
    \ = sum;\n        }\n    }\n    count = Math.ceil(max_fill / capacity);\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1,", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0;\
    \ j < row.length; j++) {\n            sum += row[j];\n        }\n        count\
    \ += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_fill = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     row_fill += 1;\n            }\n        }\n        count += Math.ceil(row_fill\
    \ / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1,", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,",
  "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if\
    \ (row_sum > capacity) {\n            result += Math.ceil(row_sum / capacity);\n\
    \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1,",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n  \
    \          count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1,", "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let\
    \ row = grid[i];\n    let row_sum = row.reduce((acc, curr) => acc + curr, 0);\n\
    \    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n\
    \    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n    \
    \  count += fill - capacity;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let well = grid[i];\n\
    \    let total = 0;\n    for (let j = 0; j < well.length; j++) {\n      total\
    \ += well[j];\n    }\n    count += Math.ceil(total / capacity);\n  }\n  return\
    \ count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [", "    let count\
    \ = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if\
    \ (grid[i][j] === 1) {\n                max++;\n            }\n        }\n   \
    \     count += Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,",
  "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity)\
    \ {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n  return result;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[1, 1, 1], [1,", "    let result = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ row_sum = row.reduce((acc, val) => acc + val, 0);\n        if (row_sum > capacity)\
    \ {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n\
    \    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[",
  "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    result += Math.ceil(fill / capacity);\n\
    \  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = row.reduce((a, b) => a + b, 0);\n    if (sum === 0) {\n      continue;\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(1\
    \ == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\n\
    console.log(3 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1,\
    \ 1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 3));\nconsole.log(4\
    \ == max_fill([[1, 1, 1, 1]], 4));\nconsole.log(5 == max_fill([[1, 1, 1, 1]],\
    \ 5));\nconsole.log(6 == max_fill([[1, 1, 1, 1]], 6));\nconsole.log(7 == max_fill([[1,\
    \ 1, 1, 1]], 7));\nconsole.log(8 == max_fill([[1, 1, 1, 1]], 8));\nconsole.log(9\
    \ == max_fill([[1, 1, 1, 1]], 9));\nconsole.log(10 == max_fill([[1, 1, 1, 1]],\
    \ 10));\nconsole.log(11 == max_fill([[1, 1, 1, 1]], 11));\nconsole.log(12 == max_fill([[1,\
    \ 1, 1, 1]], 12));\nconsole.log(13 == max_fill([[1, 1, 1, 1]], 13));\nconsole.log(14\
    \ == max_fill([[1, 1, 1, 1]], 14));\nconsole.log(15 == max_fill([[1, 1, 1, 1]],\
    \ 15));\nconsole.log(16 == max_fill([[1, 1, 1, 1]], 16));\nconsole.log(17 ==",
  "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        result += Math.ceil(sum /\
    \ capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n   \
    \     }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let total = 0;\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      total += grid[i][j];\n    }\n\
    \    if (total > capacity) {\n      count += Math.ceil(total / capacity);\n  \
    \  } else {\n      count++;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,", " \
    \ let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b)\
    \ => a + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1,", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a\
    \ + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1,", "    let result = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let count = 0;\n        for (let j =\
    \ 0; j < row.length; j++) {\n            if (row[j] === 1) {\n               \
    \ count++;\n            }\n        }\n        result += Math.ceil(count / capacity);\n\
    \    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1]], 3));", "    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));", "    let count = 0;\n    let max\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n\
    \        count += max;\n        for (let j = 0; j < grid[i].length; j++) {\n \
    \           grid[i][j] = max - grid[i][j];\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1,", "    let result = 0;\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n\
    \        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1)\
    \ {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill\
    \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\n\
    console.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1,\
    \ 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4\
    \ == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(5 == max_fill([[1, 1,\
    \ 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(7 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 2));\nconsole.log(8 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(9 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(10 == max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ row_sum = row.reduce((acc, cur) => acc + cur, 0);\n        let row_max = Math.max(...row);\n\
    \        let row_min = Math.min(...row);\n        if (row_sum > capacity) {\n\
    \            count += row_max;\n        } else {\n            count += row_min;\n\
    \        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1", "    let result = 0;\n    const max_row = grid.length;\n    const\
    \ max_col = grid[0].length;\n    for (let i = 0; i < max_row; i++) {\n       \
    \ let row_sum = 0;\n        for (let j = 0; j < max_col; j++) {\n            row_sum\
    \ += grid[i][j];\n        }\n        result += Math.ceil(row_sum / capacity);\n\
    \    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1", "    throw new Error(\"Method not implemented.\"\
    );\n}\n\nexport function main() {\n    const res = max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3);\n    console.log(res);\n}", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\
    \ [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "  let result\
    \ = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n\
    \    result += Math.ceil(max / capacity);\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1,", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let sum = row.reduce((acc, curr) => acc + curr, 0);\n    if (sum > capacity)\
    \ {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],", "    let count = 0;\n \
    \   let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             max = Math.max(max, j);\n            }\n        }\n        count\
    \ += max;\n        max = 0;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\nconsole.log(max_fill([[1, 1,",
  "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
    \   for (let well of row) {\n            max_fill += well;\n        }\n    }\n\
    \    while (max_fill > 0) {\n        for (let row of grid) {\n            for\
    \ (let well of row) {\n                if (well > 0) {\n                    well--;\n\
    \                    max_fill--;\n                }\n            }\n        }\n\
    \        result++;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],", "  let count = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    if (sum > capacity)\
    \ {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1,", "    let count = 0;\n    let max = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count +=\
    \ Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1,", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n   \
    \ }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n  \
    \  }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\n\
    console.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1,\
    \ 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(2\
    \ == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\n\
    console.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(5 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\n\
    console.log(5 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 2));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(6 == max_fill", "  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a,\
    \ b) => a + b, 0);\n    if (row_sum > capacity) {\n      count += Math.ceil(row_sum\
    \ / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1,\
    \ 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\
    \ [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1,", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0;\
    \ j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum\
    \ > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n   \
    \ }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n  \
    \  }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "    let count\
    \ = 0;\n    for (let row of grid) {\n        let row_count = 0;\n        for (let\
    \ col of row) {\n            if (col === 1) {\n                row_count++;\n\
    \            }\n        }\n        count += Math.ceil(row_count / capacity);\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 5));\n\
    console.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1,", "  let\
    \ count = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count++;\n      }\n    }\n    max_fill = Math.max(max_fill, count);\n\
    \    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [", "  let\
    \ result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n    \
    \  result += fill - capacity;\n    }\n  }\n  return result;\n}\n\nconsole.log(1\
    \ === max_fill([[1, 1, 1, 1, 1]], 2));\nconsole.log(2 === max_fill([[1, 1, 1,\
    \ 1, 1]], 1));\nconsole.log(0 === max_fill([[1, 1, 1, 1, 1]], 5));\nconsole.log(0\
    \ === max_fill([[1, 1, 1, 1, 1]], 0));\nconsole.log(0 === max_fill([[0, 0, 0,\
    \ 0, 0]], 0));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 5));\nconsole.log(0\
    \ === max_fill([[0, 0, 0, 0, 0]], 1));\nconsole.log(0 === max_fill([[0, 0, 0,\
    \ 0, 0]], 2));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 3));\nconsole.log(0\
    \ === max_fill([[0, 0, 0, 0, 0]], 4));\nconsole.log(0 === max_fill([[0, 0, 0,\
    \ 0, 0]], 5));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 6));\nconsole.log(0\
    \ === max_fill([[0, 0, 0, 0, 0]], 7));\nconsole.log(0 === max_fill([[0, 0, 0,\
    \ 0, 0]], 8));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 9));\nconsole.log(0\
    \ === max_fill([[0, 0, 0, 0, 0]], 10));", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for\
    \ (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n\
    \      }\n    }\n    if (fill > capacity) {\n      count += Math.ceil(fill / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(1 === max_fill([[1, 1, 1]], 1));\n\
    console.log(2 === max_fill([[1, 1, 1]], 2));\nconsole.log(3 === max_fill([[1,\
    \ 1, 1]], 3));\nconsole.log(2 === max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3\
    \ === max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 === max_fill([[1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(2 === max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(3\
    \ === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(4 === max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(5 === max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 6));\nconsole.log(6 === max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 7));\nconsole.", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b)\
    \ => a + b, 0);\n        let row_fill = Math.ceil(row_sum / capacity);\n     \
    \   result += row_fill;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole", "    let result\
    \ = 0;\n    for (let row of grid) {\n        let row_sum = row.reduce((a, b) =>\
    \ a + b, 0);\n        result += Math.ceil(row_sum / capacity);\n    }\n    return\
    \ result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\n\
    console.log(max_fill([[1, 1, 1, 1", "    let count = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n  \
    \      for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n  \
    \      }\n        if (sum > capacity) {\n            count += Math.ceil(sum /\
    \ capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,",
  "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        max = Math.max(...grid[i]);\n        count += max;\n        if (max\
    \ > capacity) {\n            count += max - capacity;\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\n",
  "  let times = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   max = Math.max(...grid[i]);\n    times += max;\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      grid[i][j] = Math.max(0, grid[i][j] - max);\n    }\n  }\n  return\
    \ times;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1,\
    \ 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(4\
    \ == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4\
    \ == max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(5 == max_fill([[1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1]], 5));\n\
    console.log(7 == max_fill([[1, 1, 1], [1, 1, 1]], 6));\nconsole.log(8 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 7));\nconsole.log(9 == max_fill([[1, 1, 1], [1, 1, 1]], 8));\n\
    console.log(10 == max_fill([[1, 1, 1], [1, 1, 1]], 9));\nconsole.log(11 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 10));\nconsole.log(12 == max_fill([[1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(13 ==", "  let max_fill = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let fill = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        fill++;\n      }\n    }\n    max_fill\
    \ = Math.max(max_fill, fill);\n  }\n  return Math.ceil(max_fill / capacity);\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill",
  "  let count = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n    }\n    max_fill = Math.max(max_fill, count);\n\
    \    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum\
    \ = row.reduce((a, b) => a + b, 0);\n    if (sum > capacity) {\n      count +=\
    \ Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1,", "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    max = Math.max(...grid[i]);\n    count += max;\n    for (let j =\
    \ 0; j < grid[i].length; j++) {\n      grid[i][j] = max - grid[i][j];\n    }\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1", "    let count =\
    \ 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max\
    \ = Math.max(...grid[i]);\n        count += max;\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            grid[i][j] = max - grid[i][j];\n       \
    \ }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\
    \ [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1,", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity)\
    \ {\n      count += Math.ceil(row_sum / capacity);\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1,", "    let count = 0;\n    let max_fill\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count++;\n            }\n        }\n        max_fill = Math.max(max_fill,\
    \ count);\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n\
    }\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [", "  let count\
    \ = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max\
    \ += 1;\n      }\n    }\n  }\n  while (max > 0) {\n    for (let i = 0; i < grid.length;\
    \ i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j]\
    \ === 1) {\n          grid[i][j] = 0;\n          max -= 1;\n          if (max\
    \ === 0) {\n            return count;\n          }\n        }\n      }\n    }\n\
    \    count += 1;\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1],\
    \ [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = row.reduce((a, b) => a + b, 0);\n    if (sum === 0) {\n      continue;\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(1\
    \ == max_fill([[1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1, 1, 1]], 2));\n\
    console.log(3 == max_fill([[1, 1, 1]], 3));\nconsole.log(3 == max_fill([[1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\n\
    console.log(2 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(1 == max_fill([[1,\
    \ 1, 1], [1, 1, 1]], 4));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 4));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\n\
    console.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(6\
    \ == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(1 == max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(1 == max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 6));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]", "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        max = Math.max(...grid[i]);\n        count += max;\n       \
    \ for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = Math.max(0,\
    \ grid[i][j] - max);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_",
  "    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 2));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 3));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 4));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 5));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 6));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 7));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 8));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 9));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 10));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 11));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]],\
    \ 12));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum +=\
    \ row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n   \
    \ return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n  \
    \  }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let filled = 0;\n    for (let j = 0; j <\
    \ row.length; j++) {\n      if (row[j] === 1) {\n        filled++;\n      }\n\
    \    }\n    count += Math.ceil(filled / capacity);\n  }\n  return count;\n}\n",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n  \
    \          count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[", "    let result = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n \
    \       for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1)\
    \ {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill\
    \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1],\
    \ [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\
    \ 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\n\
    console.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1,", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum\
    \ += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return\
    \ count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1]], 10));", "    throw new Error(\"Method not implemented.\");\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n\
    \        if (row_sum > capacity) {\n            count += Math.ceil(row_sum / capacity);\n\
    \        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1,", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n \
    \       let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b,\
    \ 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1,", "    let result = 0;\n    for (let row of grid) {\n        let\
    \ row_max = Math.max(...row);\n        if (row_max > 0) {\n            result\
    \ += Math.ceil(row_max / capacity);\n        }\n    }\n    return result;\n}\n\
    \nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,",
  "    let result = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let max_row = new Array(col).fill(0);\n    for (let i = 0; i < row; i++)\
    \ {\n        for (let j = 0; j < col; j++) {\n            max_row[j] = Math.max(max_row[j],\
    \ grid[i][j]);\n        }\n    }\n    for (let i = 0; i < row; i++) {\n      \
    \  for (let j = 0; j < col; j++) {\n            result += max_row[j] - grid[i][j];\n\
    \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1", "  let count = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      sum += grid[i][j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n\
    \  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n    ],\n    5\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    1\n  )\n);\nconsole.log(\n  max_fill(\n\
    \    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1,", "    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] == 1) {\n                count++;\n            }\n\
    \        }\n        max_fill = Math.max(max_fill, count);\n        count = 0;\n\
    \    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole", "    let result = 0;\n\
    \    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n \
    \       for (let well of row) {\n            fill += well;\n        }\n      \
    \  max_fill = Math.max(max_fill, fill);\n    }\n    result = Math.ceil(max_fill\
    \ / capacity);\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length;\
    \ j++) {\n            if (row[j] === 1) {\n                filled++;\n       \
    \     }\n        }\n        count += Math.ceil(filled / capacity);\n    }\n  \
    \  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 9", "  let count =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count\
    \ += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1,", "    let result = 0;\n    for (let row of grid) {\n        let row_fill\
    \ = 0;\n        for (let well of row) {\n            if (well === 1) {\n     \
    \           row_fill++;\n            }\n        }\n        result += Math.ceil(row_fill\
    \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1, 1]], 12));", "    let result = 0;\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_fill\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                row_fill++;\n            }\n        }\n        result\
    \ += Math.ceil(row_fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1", " \
    \ let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,", "    let count =\
    \ 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n   \
    \     for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count++;\n            }\n        }\n        max_fill =\
    \ Math.max(max_fill, count);\n        count = 0;\n    }\n    return Math.ceil(max_fill\
    \ / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 11));\nconsole", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            sum += grid[i][j];\n        }\n        count += Math.ceil(sum\
    \ / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1],\
    \ [1, 1, 1, 1], [1, 1, 1", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ if (sum > capacity) {\n            result += Math.ceil(sum / capacity);\n  \
    \      }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1,\
    \ 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\
    \ 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 11));\n", "    let count = 0;\n\
    \    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
    \                count++;\n            }\n        }\n        if (count > max_fill)\
    \ {\n            max_fill = count;\n        }\n        count = 0;\n    }\n   \
    \ return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      let cell = row[j];\n      sum += cell;\n    }\n    if (sum > capacity)\
    \ {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1,\
    \ 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1,\
    \ 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n \
    \   [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n\
    \      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    1\n  )\n);\nconsole.log(\n\
    \  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    5\n\
    \  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1,\
    \ 1, 1, 1, 1", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count\
    \ += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n        \
    \    if (row[j] === 1) {\n                fill++;\n            }\n        }\n\
    \        count += Math.ceil(fill / capacity);\n    }\n    return count;\n}\n",
  "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n\
    \    }\n    result += Math.ceil(sum / capacity);\n  }\n  return result;\n}\n\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j\
    \ = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n       \
    \ if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n   \
    \     }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n\
    \        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n\
    \        }\n        if (sum > capacity) {\n            count += Math.ceil(sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,",
  "    let result = 0;\n    let max_row = 0;\n    for (let row of grid) {\n      \
    \  let row_sum = 0;\n        for (let col of row) {\n            row_sum += col;\n\
    \        }\n        if (row_sum > max_row) {\n            max_row = row_sum;\n\
    \        }\n    }\n    result = Math.ceil(max_row / capacity);\n    return result;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill", "  let result = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b,\
    \ 0);\n    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n\
    \    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1,\
    \ 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1],\
    \ [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,", " \
    \   let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
    \ {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n  \
    \          count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[", "    let count = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count++;\n             \
    \   grid[i][j] = 0;\n            }\n        }\n    }\n    return Math.ceil(count\
    \ / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1", "    let result =\
    \ 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max\
    \ = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ > max) {\n                max = grid[i][j];\n            }\n        }\n    \
    \    result += max;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\
    \ 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\
    \ 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1,\
    \ 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\n\
    console.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1", "    let result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    let\
    \ col_max_index = 0;\n    let row_max_index = 0;\n    let row_max_index_prev =\
    \ 0;\n    let col_max_index_prev = 0;\n    let row_max_prev = 0;\n    let col_max_prev\
    \ = 0;\n    let row_max_prev_prev = 0;\n    let col_max_prev_prev = 0;\n    let\
    \ row_max_prev_prev_prev = 0;\n    let col_max_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev\
    \ = 0;\n    let col_max_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev\
    \ = 0;\n    let col_max_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let col_max_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let\
    \ row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n\
    \    let col_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let\
    \ row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let\
    \ col_max_prev", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0;\
    \ j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum\
    \ > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n   \
    \     }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1,\
    \ 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]],\
    \ 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n   \
    \ }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n  \
    \  }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], -1));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], -5));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 15", "    let result = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity)\
    \ {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n\
    \    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1],\
    \ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1,\
    \ 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1,\
    \ 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1,\
    \ 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1,\
    \ 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([["]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
