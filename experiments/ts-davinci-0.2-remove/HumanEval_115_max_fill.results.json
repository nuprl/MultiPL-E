{
  "language": "ts",
  "name": "HumanEval_115_max_fill",
  "results": [
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                max_fill++;\n            }\n        }\n    }\n    while (max_fill > 0) {\n        for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] === 1) {\n                    grid[i][j] = 0;\n                    max_fill--;\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 10));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n9\n\nshould loosely deep-equal\n\n5\n    at test (/tmp/tmp_nmusraz.js:52:12)\n    at Object.<anonymous> (/tmp/tmp_nmusraz.js:57:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 9,\n  expected: 5,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "8\n8\n8\n8\n8\n8\n8\n8\n8\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    1\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    4\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4yrhqwly.ts(85,1): error TS1005: ',' expected.\n../../../../tmp/tmp4yrhqwly.ts(85,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let fill = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      fill += grid[i][j];\n    }\n    count += Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsisi7nrk.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmpsisi7nrk.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n                grid[i][j] = 0;\n            }\n        }\n    }\n    return count / capacity;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpp2exgeq3.ts(40,1): error TS1005: ',' expected.\n../../../../tmp/tmpp2exgeq3.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1, 1]], 0));\nconsole.log(3 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(5 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(6 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(\n  5 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2)\n);\nconsole.log(\n  7 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1)\n);\nconsole.log(\n  9 == max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0)\n);\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpbqyqn9v7.js:39:12)\n    at Object.<anonymous> (/tmp/tmpbqyqn9v7.js:45:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "false\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let well of row) {\n            fill += well;\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    return max_fill;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpw8odpjnq.js:30:12)\n    at Object.<anonymous> (/tmp/tmpw8odpjnq.js:36:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                max++;\n            }\n        }\n    }\n    while (max > 0) {\n        for (let i = 0; i < grid.length; i++) {\n            let row = grid[i];\n            for (let j = 0; j < row.length; j++) {\n                if (row[j] === 1) {\n                    row[j] = 0;\n                    max--;\n                    if (max === 0) {\n                        return count + 1;\n                    }\n                }\n            }\n        }\n        count++;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsym2mkyn.ts(55,1): error TS1005: ',' expected.\n../../../../tmp/tmpsym2mkyn.ts(55,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 10));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n3\n9\n10\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzo7hoq0a.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpzo7hoq0a.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(max, Math.max(...grid[i]));\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] < max) {\n                grid[i][j] = max;\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpmdf_gxj_.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzo7hoq0a.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpzo7hoq0a.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(1, max_fill([[1, 1, 1]], 1));\nconsole.log(2, max_fill([[1, 1, 1]], 2));\nconsole.log(3, max_fill([[1, 1, 1]], 3));\nconsole.log(2, max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(3, max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(2, max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(3, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(4, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(5, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(6, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(7, max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(8, max_fill([[1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe_y_ocq0.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpw23_45wf.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        if (max > capacity) {\n            count += max - capacity;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps_2e9xqm.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmps_2e9xqm.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        if (max > capacity) {\n            count += max - capacity;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps_2e9xqm.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmps_2e9xqm.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmpf_h1s970.js:17\n    throw new Error(\"Method not implemented.\");\n    ^\n\nError: Method not implemented.\n    at max_fill (/tmp/tmpf_h1s970.js:17:11)\n    at Object.<anonymous> (/tmp/tmpf_h1s970.js:19:13)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333703
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n  return Math.ceil(count / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2)); // 3\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3)); // 2\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1)); // 9\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9)); // 1\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10)); // 1\nconsole.log\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n1\n\nshould loosely deep-equal\n\n2\n    at test (/tmp/tmpnv6j0rsw.js:46:12)\n    at Object.<anonymous> (/tmp/tmpnv6j0rsw.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 1,\n  expected: 2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n4\n3\n12\n3\n2\n2\n2\n2\n2\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4zwkr2_y.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmp4zwkr2_y.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let fill = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      fill += grid[i][j];\n    }\n    if (fill > max_fill) {\n      max_fill = fill;\n    }\n  }\n  result = Math.ceil(max_fill / capacity);\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2j2tc3wq.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmp2j2tc3wq.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    let max_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n            }\n        }\n        if (count > max) {\n            max = count;\n            max_index = i;\n        }\n        count = 0;\n    }\n    return Math.ceil(max / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg9o9lj9i.ts(45,1): error TS1005: ',' expected.\n../../../../tmp/tmpg9o9lj9i.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    let max_fill_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        if (sum > max_fill) {\n            max_fill = sum;\n            max_fill_index = i;\n        }\n    }\n    let bucket = capacity;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        if (i !== max_fill_index) {\n            bucket -= sum;\n            if (bucket < 0) {\n                count++;\n                bucket = capacity;\n                bucket -= sum;\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n1\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpgbhgh48n.js:58:12)\n    at Object.<anonymous> (/tmp/tmpgbhgh48n.js:64:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 1,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n1\n1\n1\n0\n0\n0\n0\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n            }\n        }\n        if (filled > capacity) {\n            result += filled - capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 100));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], -1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpbui8evfe.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpbui8evfe.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333702
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmptxpls24l.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmptxpls24l.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n      count += Math.ceil(fill / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpo09auslt.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpo09auslt.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill += 1;\n      }\n    }\n    if (fill > capacity) {\n      count += fill - capacity;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 0, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n3\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpy12e87vl.js:48:12)\n    at Object.<anonymous> (/tmp/tmpy12e87vl.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 3,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  let max_row = grid.length;\n  let max_col = grid[0].length;\n  let max_row_fill = 0;\n  let max_col_fill = 0;\n  for (let i = 0; i < max_row; i++) {\n    for (let j = 0; j < max_col; j++) {\n      if (grid[i][j] === 1) {\n        max_row_fill++;\n      }\n    }\n    result += Math.ceil(max_row_fill / capacity);\n    max_row_fill = 0;\n  }\n  for (let i = 0; i < max_col; i++) {\n    for (let j = 0; j < max_row; j++) {\n      if (grid[j][i] === 1) {\n        max_col_fill++;\n      }\n    }\n    result += Math.ceil(max_col_fill / capacity);\n    max_col_fill = 0;\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe8wvl7pf.ts(49,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n            }\n        }\n        count += Math.ceil(filled / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0h81h4c0.ts(43,1): error TS1005: ',' expected.\n../../../../tmp/tmp0h81h4c0.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let row_max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        row_max = Math.max(...grid[i]);\n        result += row_max;\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = row_max - grid[i][j];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpu4ogbcvt.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpu4ogbcvt.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let well of row) {\n            fill += well;\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    while (max_fill > 0) {\n        result++;\n        max_fill -= capacity;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxczz3axf.ts(46,1): error TS1005: ',' expected.\n../../../../tmp/tmpxczz3axf.ts(46,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nexport { max_fill }\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "(node:16058) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n(Use `node --trace-warnings ...` to show where the warning was created)\n/tmp/tmpv6qgqya5.js:19\nexport { max_fill };\n^^^^^^\n\nSyntaxError: Unexpected token 'export'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg5l8w1kx.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpc34264mj.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpc34264mj.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmpvh6jf8rj.js:17\n    throw new Error(\"Method not implemented.\");\n    ^\n\nError: Method not implemented.\n    at max_fill (/tmp/tmpvh6jf8rj.js:17:11)\n    at Object.<anonymous> (/tmp/tmpvh6jf8rj.js:19:13)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n                grid[i][j] = 0;\n                let bucket = capacity;\n                while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n                        bucket--;\n                    }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n                        bucket--;\n                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n                    }\n                    if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n                        grid[i][j + 1] = 0;\n                        bucket--;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpgjvbno_p.ts(55,1): error TS1005: ',' expected.\n../../../../tmp/tmpgjvbno_p.ts(55,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph2jfgjtt.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmph2jfgjtt.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((acc, curr) => acc + curr, 0);\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], -1));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 14));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 15));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 16));\nconsole.log(max_fill([[1, 1, 1, 1, 1]], 17));\nconsole.log\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpyzr1ecyi.js:49:12)\n    at Object.<anonymous> (/tmp/tmpyzr1ecyi.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n3\n5\nInfinity\n-5\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let row_max = 0;\n    let col_max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > row_max) {\n                row_max = grid[i][j];\n            }\n            if (grid[j][i] > col_max) {\n                col_max = grid[j][i];\n            }\n        }\n        count += Math.min(row_max, capacity);\n        count += Math.min(col_max, capacity);\n        row_max = 0;\n        col_max = 0;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpbaz78i4x.ts(47,1): error TS1005: ',' expected.\n../../../../tmp/tmpbaz78i4x.ts(47,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpsqvop8mc.js:42:12)\n    at Object.<anonymous> (/tmp/tmpsqvop8mc.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n0\n15\n9\n6\n0\n0\n0\n0\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                max++;\n            }\n        }\n        count += Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n            }\n        }\n        count += Math.ceil(filled / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_row = grid.length;\n    let max_col = grid[0].length;\n    let row = 0;\n    let col = 0;\n    let bucket = capacity;\n    while (row < max_row) {\n        if (grid[row][col] === 1) {\n            bucket--;\n            grid[row][col] = 0;\n        }\n        if (bucket === 0) {\n            bucket = capacity;\n            result++;\n        }\n        col++;\n        if (col === max_col) {\n            col = 0;\n            row++;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpukhy48a4.ts(49,1): error TS1005: ',' expected.\n../../../../tmp/tmpukhy48a4.ts(49,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nexport { max_fill }\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "(node:16058) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n(Use `node --trace-warnings ...` to show where the warning was created)\n/tmp/tmpv6qgqya5.js:19\nexport { max_fill };\n^^^^^^\n\nSyntaxError: Unexpected token 'export'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzu7d3n6i.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpzu7d3n6i.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let row_max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        row_max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                row_max++;\n            }\n        }\n        count += Math.ceil(row_max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5u6_26ns.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmp5u6_26ns.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        result += max;\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = Math.max(0, grid[i][j] - max);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkagd7kxm.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpkagd7kxm.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    max = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max++;\n      }\n    }\n    count += Math.ceil(max / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp88f4lcjl.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmp00_8cuwe.js:42:12)\n    at Object.<anonymous> (/tmp/tmp00_8cuwe.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n9\n15\n6\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let row of grid) {\n        let bucket = capacity;\n        for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n                if (bucket > 0) {\n                    bucket--;\n                    row[i] = 0;\n                } else {\n                    count++;\n                    bucket = capacity - 1;\n                    row[i] = 0;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp35kmqonb.ts(45,1): error TS1005: ',' expected.\n../../../../tmp/tmp35kmqonb.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  throw new Error(\"Method not implemented.\");\n}\n\n(function() {\n  const rl = require(\"readline\").createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n\n  rl.question(\"Enter grid: \", grid => {\n    rl.question(\"Enter capacity: \", capacity => {\n      console.log(max_fill(grid, capacity));\n      rl.close();\n    });\n  });\n})();\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6h2zhljk.ts(22,12): error TS2580: Cannot find name 'process'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`.\n../../../../tmp/tmp6h2zhljk.ts(23,13): error TS2580: Cannot find name 'process'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`.\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0) {\n            result += Math.ceil(row_max / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprvo98911.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n  return count / capacity;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpf2ozx_5q.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmptxpls24l.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmptxpls24l.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = row.reduce((a, b) => a + b, 0);\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnnnk2hs2.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmpnnnk2hs2.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let num_fill = 0;\n    let row_max = 0;\n    let row_min = 0;\n    let row_fill = 0;\n    let col_max = 0;\n    let col_min = 0;\n    let col_fill = 0;\n    let row_max_index = 0;\n    let row_min_index = 0;\n    let col_max_index = 0;\n    let col_min_index = 0;\n    let row_max_count = 0;\n    let row_min_count = 0;\n    let col_max_count = 0;\n    let col_min_count = 0;\n    let row_max_fill = 0;\n    let row_min_fill = 0;\n    let col_max_fill = 0;\n    let col_min_fill = 0;\n    let row_max_fill_index = 0;\n    let row_min_fill_index = 0;\n    let col_max_fill_index = 0;\n    let col_min_fill_index = 0;\n    let row_max_fill_count = 0;\n    let row_min_fill_count = 0;\n    let col_max_fill_count = 0;\n    let col_min_fill_count = 0;\n    let row_max_fill_total = 0;\n    let row_min_fill_total = 0;\n    let col_max_fill_total = 0;\n    let col_min_fill_total = 0;\n    let row_max_fill_total_index = 0;\n    let row_min_fill_total_index = 0;\n    let col_max_fill_total_index = 0;\n    let col_min_fill_total_index = 0;\n    let row_max_fill_total_count = 0;\n    let row_min_fill_total_count = 0;\n    let col_max_fill_total_count = 0;\n    let col_min_fill_total_count = 0;\n    let row_max_fill_total_total = 0;\n    let row_min_fill_total_total = 0;\n    let col_max_fill_total_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp236w3yk0.ts(72,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > max) {\n                max = grid[i][j];\n            }\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] < max) {\n                grid[i][j] = max;\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5fnte9bb.ts(48,1): error TS1005: ',' expected.\n../../../../tmp/tmp5fnte9bb.ts(48,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3y1bukq4.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_row = grid.length;\n    let max_col = grid[0].length;\n    let max_fill = 0;\n    let max_fill_row = 0;\n    let max_fill_col = 0;\n    let max_fill_count = 0;\n    let max_fill_count_row = 0;\n    let max_fill_count_col = 0;\n    let max_fill_count_total = 0;\n    let max_fill_count_total_row = 0;\n    let max_fill_count_total_col = 0;\n    let max_fill_count_total_row_col = 0;\n    let max_fill_count_total_row_col_row = 0;\n    let max_fill_count_total_row_col_col = 0;\n    let max_fill_count_total_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row = 0;\n    let max_fill_count_total_row_col_row_col_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row = 0;\n    let max_fill_count_total_row_col_row_col_row_col_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_row = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_row_col = 0;\n    let max_fill_count_total_row_col_row_col_row_col_row_col_row_col_row = 0;\n    let max_fill_count_total\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpaax8fct3.ts(57,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max += 1;\n      }\n    }\n  }\n  let current = 0;\n  while (current < max) {\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j] === 1) {\n          grid[i][j] = 0;\n          current += 1;\n        }\n      }\n    }\n    count += 1;\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpifhujatg.ts(50,1): error TS1005: ',' expected.\n../../../../tmp/tmpifhujatg.ts(50,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            result += row_sum / capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpfvfmzjtu.ts(38,1): error TS1005: ',' expected.\n../../../../tmp/tmpfvfmzjtu.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpo7quq2fl.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmpo7quq2fl.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_row = grid.length;\n    let max_col = grid[0].length;\n    let max_row_sum = 0;\n    let max_col_sum = 0;\n    for (let i = 0; i < max_row; i++) {\n        let row_sum = 0;\n        for (let j = 0; j < max_col; j++) {\n            row_sum += grid[i][j];\n        }\n        max_row_sum = Math.max(max_row_sum, row_sum);\n    }\n    for (let j = 0; j < max_col; j++) {\n        let col_sum = 0;\n        for (let i = 0; i < max_row; i++) {\n            col_sum += grid[i][j];\n        }\n        max_col_sum = Math.max(max_col_sum, col_sum);\n    }\n    count += Math.ceil(max_row_sum / capacity);\n    count += Math.ceil(max_col_sum / capacity);\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpyvjhvn3f.ts(48,1): error TS1005: ',' expected.\n../../../../tmp/tmpyvjhvn3f.ts(48,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n            }\n        }\n        count += Math.ceil(filled / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqtwygd_q.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmpqtwygd_q.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppnbpfbg7.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmppnbpfbg7.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplnnysi4l.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let filled = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        filled++;\n      }\n    }\n    if (filled > capacity) {\n      count += filled - capacity;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n3\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmp3hyv3eqy.js:48:12)\n    at Object.<anonymous> (/tmp/tmp3hyv3eqy.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 3,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "3\n6\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum === 0) {\n      continue;\n    }\n    count += Math.ceil(row_sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzb1fmwv_.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpzb1fmwv_.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp__ydbki4.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzu7d3n6i.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpzu7d3n6i.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            max_fill += grid[i][j];\n        }\n    }\n    while (max_fill > 0) {\n        for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] > 0) {\n                    grid[i][j] -= capacity;\n                    max_fill -= capacity;\n                    if (grid[i][j] < 0) {\n                        max_fill += grid[i][j];\n                    }\n                }\n            }\n        }\n        count++;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpggsqy9gu.ts(51,1): error TS1005: ',' expected.\n../../../../tmp/tmpggsqy9gu.ts(51,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmparl52t6r.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max_fill = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                max_fill++;\n            }\n        }\n        if (max_fill > capacity) {\n            result += max_fill - capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8jkkz5q9.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333712
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n            }\n        }\n        if (count > max_fill) {\n            max_fill = count;\n        }\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpznfsoxjn.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpznfsoxjn.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333712
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplnnysi4l.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            let cell = row[j];\n            if (cell === 1) {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1i2_1_a8.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmp1i2_1_a8.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        count++;\n      }\n    }\n    result += Math.ceil(count / capacity);\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        let fill = Math.floor(sum / capacity);\n        count += fill;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpm8sk6i24.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmpm8sk6i24.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpo2askl__.ts(33,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n        max_fill = Math.max(max_fill, Math.max(...row));\n    }\n    for (let i = 0; i < max_fill; i++) {\n        result += fill_row(grid, capacity);\n    }\n    return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx0_3kzh6.ts(23,19): error TS2304: Cannot find name 'fill_row'.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      let cell = row[j];\n      if (cell === 1) {\n        count += 1;\n      }\n    }\n    if (count > max_fill) {\n      max_fill = count;\n    }\n    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpwdi8slb6.js:37:12)\n    at Object.<anonymous> (/tmp/tmpwdi8slb6.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    4\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    5\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpowz3z2gi.ts(83,1): error TS1005: ',' expected.\n../../../../tmp/tmpowz3z2gi.ts(83,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n    if (sum === 0) {\n      continue;\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(1 === max_fill([[1, 1, 1]], 2));\nconsole.log(2 === max_fill([[1, 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(5 === max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(5 === max_fill([[1, 1, 1], [1, 1, 1]], 5));\nconsole.log(6 === max_fill([[1, 1, 1], [1, 1, 1]], 6));\nconsole.log(6 === max_fill([[1, 1, 1], [1, 1, 1]], 7));\nconsole.log(7 === max_fill([[1, 1, 1], [1, 1, 1]], 8));\nconsole.log(7 === max_fill([[1, 1, 1], [1, 1, 1]], 9));\nconsole.log(8 === max_fill([[1, 1, 1], [1, 1, 1]], 10));\nconsole.log(8 === max_fill([[1, 1, 1], [1, 1, 1]], 11));\nconsole.log(9 === max_fill([[1, 1, 1], [1, 1, 1]], 12));\nconsole.log(9 === max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpawfkxuea.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1]], 5));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 6));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 7));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 8));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 9));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 10));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 11));\nconsole.log(1 == max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3u_t12te.ts(47,1): error TS1005: ',' expected.\n../../../../tmp/tmp3u_t12te.ts(47,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = row.reduce((acc, curr) => acc + curr, 0);\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n6\n3\n3\n3\n3\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333714
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > max_fill) {\n            max_fill = sum;\n        }\n    }\n    count = Math.ceil(max_fill / capacity);\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppoe4df3x.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph2jfgjtt.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmph2jfgjtt.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                row_fill += 1;\n            }\n        }\n        count += Math.ceil(row_fill / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7o25epug.ts(37,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp24onaa6h.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((acc, curr) => acc + curr, 0);\n    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpptape_ry.ts(38,1): error TS1005: ',' expected.\n../../../../tmp/tmpptape_ry.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n      count += fill - capacity;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprrsljidx.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let well = grid[i];\n    let total = 0;\n    for (let j = 0; j < well.length; j++) {\n      total += well[j];\n    }\n    count += Math.ceil(total / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4fc9x7ry.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                max++;\n            }\n        }\n        count += Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjqwyxau_.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp29bojwb2.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333714
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((acc, val) => acc + val, 0);\n        if (row_sum > capacity) {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7pam9mic.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333713
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    result += Math.ceil(fill / capacity);\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "9\n6\n6\n3\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333714
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n    if (sum === 0) {\n      continue;\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 3));\nconsole.log(4 == max_fill([[1, 1, 1, 1]], 4));\nconsole.log(5 == max_fill([[1, 1, 1, 1]], 5));\nconsole.log(6 == max_fill([[1, 1, 1, 1]], 6));\nconsole.log(7 == max_fill([[1, 1, 1, 1]], 7));\nconsole.log(8 == max_fill([[1, 1, 1, 1]], 8));\nconsole.log(9 == max_fill([[1, 1, 1, 1]], 9));\nconsole.log(10 == max_fill([[1, 1, 1, 1]], 10));\nconsole.log(11 == max_fill([[1, 1, 1, 1]], 11));\nconsole.log(12 == max_fill([[1, 1, 1, 1]], 12));\nconsole.log(13 == max_fill([[1, 1, 1, 1]], 13));\nconsole.log(14 == max_fill([[1, 1, 1, 1]], 14));\nconsole.log(15 == max_fill([[1, 1, 1, 1]], 15));\nconsole.log(16 == max_fill([[1, 1, 1, 1]], 16));\nconsole.log(17 ==\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdfj9csho.ts(48,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333714
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        result += Math.ceil(sum / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpz0gs5wwt.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let total = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      total += grid[i][j];\n    }\n    if (total > capacity) {\n      count += Math.ceil(total / capacity);\n    } else {\n      count++;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpuu98xodv.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1v69tn8h.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4ua9z1nn.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvq7q8jd5.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let count = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                count++;\n            }\n        }\n        result += Math.ceil(count / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]], 3));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n3\n9\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmpnedjfglg.js:17\n    throw new Error(\"Method not implemented.\");\n    ^\n\nError: Method not implemented.\n    at max_fill (/tmp/tmpnedjfglg.js:17:11)\n    at Object.<anonymous> (/tmp/tmpnedjfglg.js:19:13)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += max;\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = max - grid[i][j];\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphtm97fl5.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(5 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(7 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(8 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(9 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(10 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpyzy_73ad.js:44:12)\n    at Object.<anonymous> (/tmp/tmpyzy_73ad.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "false\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((acc, cur) => acc + cur, 0);\n        let row_max = Math.max(...row);\n        let row_min = Math.min(...row);\n        if (row_sum > capacity) {\n            count += row_max;\n        } else {\n            count += row_min;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdq4len1g.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmpdq4len1g.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    const max_row = grid.length;\n    const max_col = grid[0].length;\n    for (let i = 0; i < max_row; i++) {\n        let row_sum = 0;\n        for (let j = 0; j < max_col; j++) {\n            row_sum += grid[i][j];\n        }\n        result += Math.ceil(row_sum / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe5blu89m.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpe5blu89m.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nexport function main() {\n    const res = max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3);\n    console.log(res);\n}\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "(node:16729) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n(Use `node --trace-warnings ...` to show where the warning was created)\n/tmp/tmphoh8_0j3.js:19\nexport function main() {\n^^^^^^\n\nSyntaxError: Unexpected token 'export'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n    result += Math.ceil(max / capacity);\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpl8xxl40r.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((acc, curr) => acc + curr, 0);\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprhnweaf2.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                max = Math.max(max, j);\n            }\n        }\n        count += max;\n        max = 0;\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\n\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprhxg_6f4.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n        for (let well of row) {\n            max_fill += well;\n        }\n    }\n    while (max_fill > 0) {\n        for (let row of grid) {\n            for (let well of row) {\n                if (well > 0) {\n                    well--;\n                    max_fill--;\n                }\n            }\n        }\n        result++;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1],\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp11pe4a_q.ts(50,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwf4txu7r.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += Math.ceil(max / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdkrtojaw.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpzpaq3orr.js:42:12)\n    at Object.<anonymous> (/tmp/tmpzpaq3orr.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n0\n0\n15\n9\n6\n0\n0\n0\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(5 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(5 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(6 == max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe14lbh8d.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmpe14lbh8d.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      count += Math.ceil(row_sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph2ihmo1e.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let row of grid) {\n        let row_count = 0;\n        for (let col of row) {\n            if (col === 1) {\n                row_count++;\n            }\n        }\n        count += Math.ceil(row_count / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n[1, 1, 1, 1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxn2ef3ug.ts(49,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333718
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    max_fill = Math.max(max_fill, count);\n    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpddiulk7j.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333719
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpymccwgev.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333719
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n      result += fill - capacity;\n    }\n  }\n  return result;\n}\n\nconsole.log(1 === max_fill([[1, 1, 1, 1, 1]], 2));\nconsole.log(2 === max_fill([[1, 1, 1, 1, 1]], 1));\nconsole.log(0 === max_fill([[1, 1, 1, 1, 1]], 5));\nconsole.log(0 === max_fill([[1, 1, 1, 1, 1]], 0));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 0));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 5));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 1));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 2));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 3));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 4));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 5));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 6));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 7));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 8));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 9));\nconsole.log(0 === max_fill([[0, 0, 0, 0, 0]], 10));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n3\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpt658dgj7.js:51:12)\n    at Object.<anonymous> (/tmp/tmpt658dgj7.js:57:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 3,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "false\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    if (fill > capacity) {\n      count += Math.ceil(fill / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(1 === max_fill([[1, 1, 1]], 1));\nconsole.log(2 === max_fill([[1, 1, 1]], 2));\nconsole.log(3 === max_fill([[1, 1, 1]], 3));\nconsole.log(2 === max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(2 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(3 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(3 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(4 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(5 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(6 === max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjh72esow.ts(46,9): error TS1003: Identifier expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        let row_fill = Math.ceil(row_sum / capacity);\n        result += row_fill;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxt5bf_ha.ts(40,1): error TS1005: ',' expected.\n../../../../tmp/tmpxt5bf_ha.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprn4_9huk.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        fill++;\n      }\n    }\n    count += Math.ceil(fill / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n9\n15\n6\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let row of grid) {\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        result += Math.ceil(row_sum / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_eszymlt.ts(37,1): error TS1005: ',' expected.\n../../../../tmp/tmp_eszymlt.ts(37,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += max;\n        if (max > capacity) {\n            count += max - capacity;\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n3\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpenfuz_r5.js:42:12)\n    at Object.<anonymous> (/tmp/tmpenfuz_r5.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 3,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let times = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n    times += max;\n    for (let j = 0; j < grid[i].length; j++) {\n      grid[i][j] = Math.max(0, grid[i][j] - max);\n    }\n  }\n  return times;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 2));\nconsole.log(2 == max_fill([[1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1, 1]], 1));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(5 == max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1]], 5));\nconsole.log(7 == max_fill([[1, 1, 1], [1, 1, 1]], 6));\nconsole.log(8 == max_fill([[1, 1, 1], [1, 1, 1]], 7));\nconsole.log(9 == max_fill([[1, 1, 1], [1, 1, 1]], 8));\nconsole.log(10 == max_fill([[1, 1, 1], [1, 1, 1]], 9));\nconsole.log(11 == max_fill([[1, 1, 1], [1, 1, 1]], 10));\nconsole.log(12 == max_fill([[1, 1, 1], [1, 1, 1]], 11));\nconsole.log(13 ==\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqdi3g34r.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let fill = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        fill++;\n      }\n    }\n    max_fill = Math.max(max_fill, fill);\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsc_ovu5w.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmpsc_ovu5w.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    max_fill = Math.max(max_fill, count);\n    count = 0;\n  }\n  return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmprr89j0xm.js:44:12)\n    at Object.<anonymous> (/tmp/tmprr89j0xm.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n2\n4\n1\n1\n1\n1\n1\n1\n1\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqv4kangr.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n    count += max;\n    for (let j = 0; j < grid[i].length; j++) {\n      grid[i][j] = max - grid[i][j];\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9x_lq_gx.ts(40,1): error TS1005: ',' expected.\n../../../../tmp/tmp9x_lq_gx.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += max;\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = max - grid[i][j];\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphtm97fl5.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      count += Math.ceil(row_sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpni25fmgj.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n            }\n        }\n        max_fill = Math.max(max_fill, count);\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnx77iuhz.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max += 1;\n      }\n    }\n  }\n  while (max > 0) {\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j] === 1) {\n          grid[i][j] = 0;\n          max -= 1;\n          if (max === 0) {\n            return count;\n          }\n        }\n      }\n    }\n    count += 1;\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplwbuxoge.ts(53,1): error TS1005: ',' expected.\n../../../../tmp/tmplwbuxoge.ts(53,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n    if (sum === 0) {\n      continue;\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(1 == max_fill([[1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1, 1, 1]], 2));\nconsole.log(3 == max_fill([[1, 1, 1]], 3));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1]], 3));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1]], 1));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1]], 2));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1]], 4));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(3 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(4 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(6 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(1 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(2 == max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpi8cvofc2.ts(43,1): error TS1005: ',' expected.\n../../../../tmp/tmpi8cvofc2.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = Math.max(...grid[i]);\n        count += max;\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = Math.max(0, grid[i][j] - max);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpmmxe626s.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpmmxe626s.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 2));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 3));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 4));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 5));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 6));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 7));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 8));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 9));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 10));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 11));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]], 12));\nconsole.log(max_fill([[1,1,1,1,1],[1,1,1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjxewx6hx.ts(32,1): error TS1005: ',' expected.\n../../../../tmp/tmpjxewx6hx.ts(32,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333720
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph2jfgjtt.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmph2jfgjtt.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzu7d3n6i.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpzu7d3n6i.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let filled = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        filled++;\n      }\n    }\n    count += Math.ceil(filled / capacity);\n  }\n  return count;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660333721
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpft1475e4.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333721
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5k9sxat0.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmp5k9sxat0.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333721
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzu7d3n6i.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpzu7d3n6i.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], 10));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpa4u_apii.js:36:12)\n    at Object.<anonymous> (/tmp/tmpa4u_apii.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "12\n6\n0\n",
      "timestamp": 1660333721
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    throw new Error(\"Method not implemented.\");\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmp5lpkk95n.js:17\n    throw new Error(\"Method not implemented.\");\n    ^\n\nError: Method not implemented.\n    at max_fill (/tmp/tmp5lpkk95n.js:17:11)\n    at test (/tmp/tmp5lpkk95n.js:22:22)\n    at Object.<anonymous> (/tmp/tmp5lpkk95n.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333721
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4ua9z1nn.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333716
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            count += Math.ceil(row_sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp58f1wilv.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333722
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let row of grid) {\n        let row_max = Math.max(...row);\n        if (row_max > 0) {\n            result += Math.ceil(row_max / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1lf2vwt2.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333723
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let max_row = new Array(col).fill(0);\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            max_row[j] = Math.max(max_row[j], grid[i][j]);\n        }\n    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            result += max_row[j] - grid[i][j];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjn7hmbks.ts(45,1): error TS1005: ',' expected.\n../../../../tmp/tmpjn7hmbks.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333723
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    5\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    1\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4gd8d261.ts(84,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333723
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n            }\n        }\n        max_fill = Math.max(max_fill, count);\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpakyj98tl.js:44:12)\n    at Object.<anonymous> (/tmp/tmpakyj98tl.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n2\n1\n1\n1\n1\n1\n1\n1\n1\n",
      "timestamp": 1660333723
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let well of row) {\n            fill += well;\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    result = Math.ceil(max_fill / capacity);\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp75nr7ai8.ts(43,1): error TS1005: ',' expected.\n../../../../tmp/tmp75nr7ai8.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                filled++;\n            }\n        }\n        count += Math.ceil(filled / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], 9\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5vyy2s5g.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmp5vyy2s5g.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum += grid[i][j];\n    }\n    count += Math.ceil(sum / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpu_l1o8z1.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let row of grid) {\n        let row_fill = 0;\n        for (let well of row) {\n            if (well === 1) {\n                row_fill++;\n            }\n        }\n        result += Math.ceil(row_fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 12));\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "6\n6\n3\n3\n3\n3\n3\n3\n3\n3\n3\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                row_fill++;\n            }\n        }\n        result += Math.ceil(row_fill / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpabyssxj8.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmpabyssxj8.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg5l8w1kx.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n            }\n        }\n        max_fill = Math.max(max_fill, count);\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpd4q8klrs.js:44:12)\n    at Object.<anonymous> (/tmp/tmpd4q8klrs.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "2\n2\n1\n1\n1\n1\n1\n1\n1\n1\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpucyr19k4.ts(39,1): error TS1005: ',' expected.\n../../../../tmp/tmpucyr19k4.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            result += Math.ceil(sum / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4mxljdeg.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 11));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpp5184u_e.js:42:12)\n    at Object.<anonymous> (/tmp/tmpp5184u_e.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n15\n0\n0\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n            }\n        }\n        if (count > max_fill) {\n            max_fill = count;\n        }\n        count = 0;\n    }\n    return Math.ceil(max_fill / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpntxy6lt0.ts(43,1): error TS1005: ',' expected.\n../../../../tmp/tmpntxy6lt0.ts(43,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      let cell = row[j];\n      sum += cell;\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    3\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    2\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    1\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1],\n    ],\n    5\n  )\n);\nconsole.log(\n  max_fill(\n    [\n      [1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3urqgi5a.ts(85,1): error TS1005: ',' expected.\n../../../../tmp/tmp3urqgi5a.ts(85,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmp00_8cuwe.js:42:12)\n    at Object.<anonymous> (/tmp/tmp00_8cuwe.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n9\n15\n6\n0\n0\n0\n0\n0\n",
      "timestamp": 1660333709
    },
    {
      "exit_code": 0,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n            }\n        }\n        count += Math.ceil(fill / capacity);\n    }\n    return count;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    result += Math.ceil(sum / capacity);\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpi7l_8qum.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmppig83rzo.js:33:12)\n    at Object.<anonymous> (/tmp/tmppig83rzo.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5evh9sd7.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333710
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max_row = 0;\n    for (let row of grid) {\n        let row_sum = 0;\n        for (let col of row) {\n            row_sum += col;\n        }\n        if (row_sum > max_row) {\n            max_row = row_sum;\n        }\n    }\n    result = Math.ceil(max_row / capacity);\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0__sv1ye.ts(45,1): error TS1005: ',' expected.\n../../../../tmp/tmp0__sv1ye.ts(45,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      result += Math.ceil(row_sum / capacity);\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1,\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqsjydrti.ts(39,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmps0de60jc.ts(44,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333706
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n                grid[i][j] = 0;\n            }\n        }\n    }\n    return Math.ceil(count / capacity);\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqzqbkeyl.ts(40,1): error TS1005: ',' expected.\n../../../../tmp/tmpqzqbkeyl.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > max) {\n                max = grid[i][j];\n            }\n        }\n        result += max;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8cqr3j4_.ts(42,1): error TS1005: ',' expected.\n../../../../tmp/tmp8cqr3j4_.ts(42,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333724
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    let col_max_index = 0;\n    let row_max_index = 0;\n    let row_max_index_prev = 0;\n    let col_max_index_prev = 0;\n    let row_max_prev = 0;\n    let col_max_prev = 0;\n    let row_max_prev_prev = 0;\n    let col_max_prev_prev = 0;\n    let row_max_prev_prev_prev = 0;\n    let col_max_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let row_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let col_max_prev\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcpbpub5r.ts(59,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333725
    },
    {
      "exit_code": 1,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n            count += Math.ceil(sum / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4\n\nshould loosely deep-equal\n\n6\n    at test (/tmp/tmpzpaq3orr.js:42:12)\n    at Object.<anonymous> (/tmp/tmpzpaq3orr.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4,\n  expected: 6,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "6\n0\n0\n15\n9\n6\n0\n0\n0\n",
      "timestamp": 1660333717
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 11));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 12));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 13));\nconsole.log(max_fill([[1, 1, 1], [1, 1, 1], [1, 1\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4zwkr2_y.ts(41,1): error TS1005: ',' expected.\n../../../../tmp/tmp4zwkr2_y.ts(41,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333703
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if (sum > capacity) {\n      count += Math.ceil(sum / capacity);\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 0));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], -1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], -5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 10));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 15\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkx4stll1.ts(40,1): error TS1005: ',' expected.\n../../../../tmp/tmpkx4stll1.ts(40,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333725
    },
    {
      "exit_code": 2,
      "program": "//You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > capacity) {\n            result += Math.ceil(row_sum / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 3));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 2));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 1));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 4));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 5));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 6));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 7));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 8));\nconsole.log(max_fill([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], 9));\nconsole.log(max_fill([[\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy3bn3nd3.ts(38,9): error TS1005: ',' expected.\n",
      "timestamp": 1660333725
    }
  ]
}