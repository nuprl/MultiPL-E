name: HumanEval_119_match_parens
language: ts
prompt: "//You are given a list of two strings, both strings consist of open\n// parentheses\
  \ '(' or close parentheses ')' only.\n// Your job is to check if it is possible\
  \ to concatenate the two strings in\n// some order, that the resulting string will\
  \ be good.\n// A string S is considered to be good if and only if all parentheses\
  \ in S\n// are balanced. For example: the string '(())()' is good, while the string\n\
  // '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n// Examples:\nfunction match_parens(lst: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\"\
  , \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
  ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
  ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
completions: []
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
