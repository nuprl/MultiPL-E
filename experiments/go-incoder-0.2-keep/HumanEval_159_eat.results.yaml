language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > remaining\
    \ {\n        carrots = number\n        meals = need\n    } else {\n        carrots\
    \ = remaining\n        meals = number\n    }\n    carrots -= meals\n    meals\
    \ -= number\n    meals -= carrots\n    carrots += meals\n    meals += number\n\
    \    meals += carrots\n    carrots += meals\n    meals += number\n    meals +=\
    \ carrots\n    carrots += meals\n    meals += number\n    meals += carrots\n \
    \   carrots += meals\n    meals += number\n    meals += carrots\n    carrots +=\
    \ meals\n    meals += number\n    meals += carrots\n    carrots += meals\n   \
    \ meals += number\n    meals += carrots\n    carrots += meals\n    meals += number\n\
    \    meals += carrots\n    carrots += meals\n    meals += number\n    meals +=\
    \ carrots\n    carrots += meals\n    meals += number\n    meals += carrots\n \
    \   carrots += meals\n    meals += number\n    meals += carrots\n    carrots +=\
    \ meals\n    meals += number\n    meals += carrots\n    carrots += meals\n   \
    \ meals += number\n    meals += carrots\n    carrots += meals\n    meals += number\n\
    \    meals += carrots\n    carrots += meals\n    meals += number\n    meals +=\
    \ carrots\n    carrots += meals\n    meals += number\n    meals += carrots\n \
    \   carrots += meals\n    meals += number\n    meals += carrots\n    carrots +=\
    \ meals\n    meals += number\n    meals += carrots\n    carrots += meals\n   \
    \ meals += number\n    meals += carrots\n    carrots += meals\n    meals += number\n\
    \    meals += carrots\n    carrots += meals\n    meal\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmjo77db__test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzg41ro27_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, need}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && remaining == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && remaining > 0 {\n        result\
    \ := []int{0, 0}\n        if number > need {\n            result[0] = number\n\
    \            result[1] = need\n        } else {\n            result[0] = need\n\
    \            result[1] = number\n        }\n        if remaining > 0 {\n     \
    \       result[0] = result[0] - result[1]\n            result[1] = result[1] -\
    \ result[0]\n        }\n        return result\n    }\n    return []int{0, 0}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn2w6mclp_test.go:82: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn2w6mclp_test.go:82:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn2w6mclp_test.go:82: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=-8)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn2w6mclp_test.go:82: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=9) %!s(int=-7)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpn2w6mclp_test.go:82: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn2w6mclp_test.go:82:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number < need {\n        fmt.Println(\"Not enough carrots\
    \ to eat\")\n    }\n    if number == need {\n        result[0] = number\n    \
    \    result[1] = remaining\n    } else {\n        result[0] = need\n        result[1]\
    \ = number-need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Not enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\nNot enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpumbufe4z_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpumbufe4z_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=-4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpumbufe4z_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpumbufe4z_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpumbufe4z_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpumbufe4z_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=-1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    carrots\
    \ += number\n    meals += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if meals < 0 {\n        meals = 0\n    }\n  \
    \  if carrots == 0 {\n        carrots = 1\n    }\n    if meals == 0 {\n      \
    \  meals = 1\n    }\n    return []int{carrots, meals}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpw5b54pee_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpw5b54pee_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpw5b54pee_test.go:78: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpw5b54pee_test.go:78: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpw5b54pee_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpw5b54pee_test.go:78:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    var carrots int\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        result = []int{0, 0}\n    } else {\n  \
    \      result = []int{carrots, carrots - need}\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_3yo4t06_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_3yo4t06_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_3yo4t06_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_3yo4t06_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_3yo4t06_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_3yo4t06_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=-1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjrgqtnri_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > number {\n        return []int{0, 0}\n    }\n   \
    \ if need > number {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > number {\n        return []int{0, 0}\n    }\n    if number > number\
    \ {\n        return []int{0, 0}\n    }\n    if number > number {\n        return\
    \ []int{0, 0}\n    }\n    if number > number {\n        return []int{0, 0}\n \
    \   }\n    if number > number {\n        return []int{0, 0}\n    }\n    if number\
    \ > number {\n        return []int{0, 0}\n    }\n    if number > number {\n  \
    \      return []int{0, 0}\n    }\n    if number > number {\n        return []int{0,\
    \ 0}\n    }\n    if number > number {\n        return []int{0, 0}\n    }\n   \
    \ if number > number {\n        return []int{0, 0}\n    }\n    if number > number\
    \ {\n        return []int{0, 0}\n    }\n    if number > number {\n        return\
    \ []int{0, 0}\n    }\n    if number > number {\n        return []int{0, 0}\n \
    \   }\n    if number > number {\n        return []int{0, 0}\n    }\n    if number\
    \ > number {\n        return []int{0, 0}\n    }\n    if number > number {\n  \
    \      return []int{0, 0}\n    }\n    if number > number {\n        return []int{0,\
    \ 0}\n    }\n    if number > number {\n        return []int{0, 0}\n    }\n   \
    \ if number > number {\n        return []int{0, 0}\n    }\n    if number > number\
    \ {\n        return []int{0, 0}\n    }\n    if number > number {\n        return\
    \ []int{0, 0}\n    }\n    if number > \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxu3fwpup_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{}\n    }\n    carrots := 0\n    if number >= need {\n        carrots =\
    \ number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphvwnrkay_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplsocme94_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplsocme94_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplsocme94_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplsocme94_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmplsocme94_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplsocme94_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    result := []int{0, 0}\n    carrots\
    \ := 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for\
    \ i := 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    if carrots > number {\n        carrots\
    \ = number\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    result[0] = carrots\n    result[1] = remaining\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp92c32_r8_test.go:89: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp92c32_r8_test.go:89:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp92c32_r8_test.go:89: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp92c32_r8_test.go:89: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp92c32_r8_test.go:89: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp92c32_r8_test.go:89:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n     \
    \   carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n     \
    \   carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    carrots %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ %= 1000\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n     \
    \   carrots = 0\n    }\n    carrots %= 1000\n    if carrots < 0 {\n        carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdwxgj1n_test.go:129:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = 0\n        result[1] = 0\n        return result\n   \
    \ }\n    if remaining == 0 {\n        result[0] = number\n        result[1] =\
    \ 0\n        return result\n    }\n    if number > need {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < need {\n        result[0] = need\n        result[1] = number\n    \
    \    return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = number\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw2d87zao_test.go:70:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if need > remaining {\n        result[0] =\
    \ need\n        result[1] = remaining\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = remaining\n      \
    \  return result\n    }\n    if number > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if need > number\
    \ {\n        result[0] = need\n        result[1] = number\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = need\n        result[1] = number\n        return result\n  \
    \  }\n    if need > number {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ remaining {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if need > number {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if need > number {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = need\n     \
    \   result[1] = number\n        return result\n    }\n    if need > number {\n\
    \        result[0] = need\n        result[1] = number\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = need\n        result[1] = number\n        return result\n  \
    \  }\n    if need > number {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ remaining {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if need > number {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo_8fta28_test.go:166:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = remaining\n        result[1] = remaining\n    } else\
    \ {\n        result[0] = remaining\n        result[1] = need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp69l4gp7b_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp69l4gp7b_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    carrots := 0\n    carrots = number - need\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    result[0] = carrots\n    result[1]\
    \ = remaining\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzi2kn1t7_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzi2kn1t7_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzi2kn1t7_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzi2kn1t7_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-9) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzi2kn1t7_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzi2kn1t7_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{}\n    }\n    if number == 0 && need == 0 {\n  \
    \      return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n        return\
    \ []int{0, need}\n    }\n    if number > 0 && need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n        return\
    \ []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        if number > need {\n            number -= need\n        }\n        if\
    \ remaining > need {\n            remaining -= need\n        }\n        if remaining\
    \ == 0 {\n            return []int{number, 0}\n        }\n        return []int{number,\
    \ need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining == 0\
    \ {\n        return []int{number, 0}\n    }\n    if number > 0 && need > 0 &&\
    \ remaining > 0 {\n        return []int{number, need}\n    }\n    if number >\
    \ 0 && need > 0 && remaining > 0 {\n        return []int{number, need}\n    }\n\
    \    if number > 0 && need > 0 && remaining > 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        return []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        return []int{number, need}\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        return []int{number, need}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 {\n        return []int{number, need}\n   \
    \ }\n    if number > 0 && need > 0 && remaining > 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        return []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        return []int{number, need}\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        return []int{number, need}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 {\n        return []int{number, need}\n   \
    \ }\n    if number > 0 && need > 0 && remaining > 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{number, need}\n    }\n    if number > 0 && need > 0 && \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2gmoz4dk_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 && need == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if number == 0 && need > 0 {\n      \
    \  result[0] = 0\n        result[1] = need\n        return result\n    }\n   \
    \ if number > 0 && need == 0 {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > 0 && remaining == 0 {\n \
    \       result[0] = number\n        result[1] = number\n        return result\n\
    \    }\n    if number > 0 && remaining > 0 && need > 0 {\n        result[0] =\
    \ number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && remaining > 0 && need == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && remaining >\
    \ 0 && need > 0 && number >= need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && remaining > 0 &&\
    \ need == 0 && number >= remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && remaining >\
    \ 0 && need > 0 && number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && remaining > 0 &&\
    \ need == 0 && number < remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && remaining >\
    \ 0 && need > 0 && number == need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && remaining >\
    \ 0 && need == 0 && number == remaining {\n        result[0] = number\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > 0 && remaining\
    \ > 0 && need > 0 && number > remaining {\n        result[0] = number\n      \
    \  result[1] = need\n        return result\n    }\n    if number > 0 && remaining\
    \ > 0 && need == 0 && number > remaining {\n        result[0] = number\n     \
    \   result[1] = remaining\n        return result\n    }\n    if number > 0 &&\
    \ remaining > 0 && need > 0 && number < remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > 0 &&\
    \ remaining > 0 && need == 0 && number < remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ 0 && remaining > 0 && need > 0 && number == need && number >= remaining {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > 0 && remaining > 0 && need == 0 && number == remaining\
    \ && number >= remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > 0 && remaining > 0 && need > 0\
    \ && number > remaining && number < need {\n        result[0] = number\n     \
    \   result\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpodhkqi4b_test.go:128:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Error\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number < need\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    carrots := 0\n    if number > remaining {\n        carrots\
    \ = number - remaining\n        result[0] = number\n        result[1] = carrots\n\
    \        return result\n    }\n    carrots = number - need\n    result[0] = carrots\n\
    \    result[1] = number\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpterv8xi1_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpterv8xi1_test.go:81:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpterv8xi1_test.go:81: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpterv8xi1_test.go:81: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpterv8xi1_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpterv8xi1_test.go:81:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots +=\
    \ i\n    }\n    need = need - carrots\n    remaining = remaining - carrots\n \
    \   if remaining <= 0 {\n        result[0] = carrots\n        result[1] = remaining\n\
    \        return result\n    }\n    carrots = carrots + 1\n    for i := 0; i <\
    \ need; i++ {\n        carrots += i\n    }\n    result[0] = carrots\n    result[1]\
    \ = remaining\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpyiab0f2__test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpyiab0f2__test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=3)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpyiab0f2__test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=46) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpyiab0f2__test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=47) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpyiab0f2__test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpyiab0f2__test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=6) %!s(int=-5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := []int{0, 0}\n    if number == 0 {\n      \
    \  return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = remaining\n        result[1] = number\n        return result\n    }\n    if\
    \ number < need {\n        result[0] = need\n        result[1] = number\n    \
    \    return result\n    }\n    if number < remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8q101428_test.go:61:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7vdww468_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 1000 || need > 1000 || remaining > 1000\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == need {\n        return []int{number, 0}\n \
    \   }\n    if number == remaining {\n        return []int{0, number}\n    }\n\
    \    if number > need {\n        return []int{0, number}\n    }\n    if number\
    \ > remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, number}\n    }\n    if number > remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ number}\n    }\n    if number > remaining {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, number}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, number}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, number}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, number}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, number}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, number}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, number}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, number}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpskk6_1tr_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvyx4zux_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code in JavaScript\
    \ (Node.js 8.9.4)\n    // let arr = [];\n    // let arr2 = [];\n    // let arr3\
    \ = [];\n    // let arr4 = [];\n    // let arr5 = [];\n    // let arr6 = [];\n\
    \    // let arr7 = [];\n    // let arr8 = [];\n    // let arr9 = [];\n    // let\
    \ arr10 = [];\n    // let arr11 = [];\n    // let arr12 = [];\n    // let arr13\
    \ = [];\n    // let arr14 = [];\n    // let arr15 = [];\n    // let arr16 = [];\n\
    \    // let arr17 = [];\n    // let arr18 = [];\n    // let arr19 = [];\n    //\
    \ let arr20 = [];\n    // let arr21 = [];\n    // let arr22 = [];\n    // let\
    \ arr23 = [];\n    // let arr24 = [];\n    // let arr25 = [];\n    // let arr26\
    \ = [];\n    // let arr27 = [];\n    // let arr28 = [];\n    // let arr29 = [];\n\
    \    // let arr30 = [];\n    // let arr31 = [];\n    // let arr32 = [];\n    //\
    \ let arr33 = [];\n    // let arr34 = [];\n    // let arr35 = [];\n    // let\
    \ arr36 = [];\n    // let arr37 = [];\n    // let arr38 = [];\n    // let arr39\
    \ = [];\n    // let arr40 = [];\n    // let arr41 = [];\n    // let arr42 = [];\n\
    \    // let arr43 = [];\n    // let arr44 = [];\n    // let arr45 = [];\n    //\
    \ let arr46 = [];\n    // let arr47 = [];\n    // let arr48 = [];\n    // let\
    \ arr49 = [];\n    // let arr50 = [];\n    // let arr51 = [];\n    // let arr52\
    \ = [];\n    // let arr53 = [];\n    // let arr54 = [];\n    // let arr55 = [];\n\
    \    // let arr56 = [];\n    // let arr57 = [];\n    // let arr58 = [];\n    //\
    \ let arr59 = [];\n    // let arr60 = [];\n    // let arr61 = [];\n    // let\
    \ arr62 = [];\n    // let arr63 = [];\n    // let arr64 = [];\n    // let arr65\
    \ = [];\n    // let arr66 = [];\n    // let arr67 = [];\n    // let arr68 = [];\n\
    \    // let arr69 = [];\n    // let arr70 = [];\n    // let arr71 = [];\n    //\
    \ let arr72 = [];\n    // let arr73 = [];\n    // let arr74 = [];\n    // let\
    \ arr75 = [];\n    // let arr76 = [];\n    // let arr77 = [];\n    // let arr78\
    \ = [];\n    // let arr79 = [];\n    // let arr80 = [];\n    // let arr8\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu42xcuvq_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    var carrots int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var carrots_remaining int\n    var carrots_needed int\n    var carrots_remaining\
    \ int\n    var carrots_needed int\n    var carrots_remaining int\n    var carrots_needed\
    \ int\n    var \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsewdq4rf_test.go:104:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots %= 1000\n    if carrots\
    \ < 0 {\n        carrots += 1000\n    }\n    if carrots > 1000 {\n        carrots\
    \ -= 1000\n    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5nfyfb3z_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5nfyfb3z_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5nfyfb3z_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5nfyfb3z_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp5nfyfb3z_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5nfyfb3z_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots /\
    \ 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqklvud3r_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    if number < need {\n        carrots = number\n    } else {\n        carrots\
    \ = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n \
    \   }\n    carrots = carrots + eat(number - carrots, need, remaining)\n    return\
    \ []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5n_32aw1_test.go:41:15: invalid operation: carrots + eat(number - carrots,
    need, remaining) (mismatched types int and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    for i := 0; i < number; i++ {\n        if carrots >= remaining\
    \ {\n            meals++\n            carrots -= remaining\n        } else {\n\
    \            carrots += need\n        }\n    }\n    return []int{meals, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp8a5a8eaq_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=14)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp8a5a8eaq_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=15)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp8a5a8eaq_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp8a5a8eaq_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp8a5a8eaq_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp8a5a8eaq_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=2)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number == 0 {\n        result[0] = need\n        result[1] = remaining\n   \
    \     return result\n    }\n    if need == 0 {\n        result[0] = number\n \
    \       result[1] = remaining\n        return result\n    }\n    if remaining\
    \ == 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    carrots\
    \ := 0\n    if number > remaining {\n        carrots = number - remaining\n  \
    \  }\n    if need > remaining {\n        carrots = need - remaining\n    }\n \
    \   result[0] = number\n    result[1] = carrots\n    return result\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq_650c7_test.go:87: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq_650c7_test.go:87:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpaq_650c7_test.go:87: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpaq_650c7_test.go:87: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpaq_650c7_test.go:87: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpaq_650c7_test.go:87:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    if number < need {\n        carrots = number\n    } else {\n     \
    \   carrots = need\n    }\n    carrots = carrots - remaining\n    if carrots <\
    \ 0 {\n        carrots = 0\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmc9qbuc6_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if remaining >= need {\n     \
    \   result = []int{number, 0}\n    } else {\n        result = []int{0, remaining}\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1u2uw9x5_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1u2uw9x5_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1u2uw9x5_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1u2uw9x5_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1u2uw9x5_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1u2uw9x5_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if need == 0\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if remaining == 0 {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > need {\n   \
    \     result[0] = number\n        result[1] = need\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > 0 && need > 0 && remaining > 0 {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > 0 && need > 0 && remaining == 0 {\n        result[0] = number\n   \
    \     result[1] = need\n        return result\n    }\n    if number > 0 && need\
    \ == 0 && remaining > 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == 0 && need > 0 && remaining > 0\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == 0 && need > 0 && remaining == 0 {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && need == 0 && remaining > 0 {\n        result[0] = need\n    \
    \    result[1] = remaining\n        return result\n    }\n    if number == 0 &&\
    \ need == 0 && remaining == 0 {\n        result[0] = need\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && need == 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && need == 0 &&\
    \ remaining == 0 {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > 0 && need > 0 && remaining == 0 {\n        result[0] =\
    \ number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == 0 && need > 0 && remaining > 0 {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == 0 && need > 0 &&\
    \ remaining == 0 {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == 0 && need == 0 && remaining >\
    \ 0 {\n        result[0] = need\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == 0 && need == \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxf4srrce_test.go:147:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp183xylze_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    if number < 0 {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ need < 0 {\n        fmt.Println(\"Invalid input\")\n    }\n    if remaining\
    \ < 0 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > 1000 ||\
    \ need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n     \
    \   return []int{number, number}\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if need > remaining {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ need > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n\
    \        return []int{number, number}\n    }\n    if number == remaining {\n \
    \       return []int{number, 0}\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if need > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ need > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n\
    \        return []int{number, number}\n    }\n    if number == remaining {\n \
    \       return []int{number, 0}\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if need > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number > need {\n        fmt.\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qcz4gck_test.go:131:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if remaining > 0 {\n        result\
    \ = append(result, number-need)\n    }\n    if number > need {\n        result\
    \ = append(result, need)\n    }\n    if number > 0 {\n        result = append(result,\
    \ 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpui4bry8u_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpui4bry8u_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpui4bry8u_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpui4bry8u_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpui4bry8u_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpui4bry8u_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || number < 0 {\n\
    \        return []int{0, 0}\n    }\n    if need > 1000 || need < 0 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining > 1000 || remaining < 0 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi9sfkirq_test.go:107:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || number < 0 ||\
    \ need > 1000 || need < 0 || remaining > 1000 || remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n\
    \        carrots = number\n        meals = need\n    } else {\n        carrots\
    \ = remaining\n        meals = number\n    }\n    carrots -= meals\n    meals\
    \ -= number\n    carrots += meals\n    meals += number\n    carrots += meals\n\
    \    meals += number\n    carrots += meals\n    meals += number\n    carrots +=\
    \ meals\n    meals += number\n    carrots += meals\n    meals += number\n    carrots\
    \ += meals\n    meals += number\n    carrots += meals\n    meals += number\n \
    \   carrots += meals\n    meals += number\n    carrots += meals\n    meals +=\
    \ number\n    carrots += meals\n    meals += number\n    carrots += meals\n  \
    \  meals += number\n    carrots += meals\n    meals += number\n    carrots +=\
    \ meals\n    meals += number\n    carrots += meals\n    meals += number\n    carrots\
    \ += meals\n    meals += number\n    carrots += meals\n    meals += number\n \
    \   carrots += meals\n    meals += number\n    carrots += meals\n    meals +=\
    \ number\n    carrots += meals\n    meals += number\n    carrots += meals\n  \
    \  meals += number\n    carrots += meals\n    meals += number\n    carrots +=\
    \ meals\n    meals += number\n    carrots += meals\n    meals += number\n    carrots\
    \ += meals\n    meals += number\n    carrots += meals\n    meals += number\n \
    \   carrots += meals\n    meals += number\n    carrots += meals\n    meals +=\
    \ number\n    carrots += meals\n    meals += number\n    carrots += meals\n  \
    \  meals += number\n    carrots += meals\n    meals += number\n    carrots +=\
    \ meals\n    meals += number\n    carrots += meals\n    meals += number\n    car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpac6dhwbc_test.go:110:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  if number < need {\n        carrots = number\n    } else {\n        carrots\
    \ = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n \
    \   }\n    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpumziniiu_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpumziniiu_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpumziniiu_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpumziniiu_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpumziniiu_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpumziniiu_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    if number < 0 ||\
    \ number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\
    \ {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number < remaining {\n        carrots = number\n\
    \    }\n    if number == need {\n        carrots = number\n    }\n    if number\
    \ == remaining {\n        carrots = number\n    }\n    if number > remaining {\n\
    \        carrots = number\n    }\n    if number < need {\n        carrots = number\n\
    \    }\n    if number < remaining {\n        carrots = number\n    }\n    if number\
    \ == need {\n        carrots = number\n    }\n    if number == remaining {\n \
    \       carrots = number\n    }\n    if number > remaining {\n        carrots\
    \ = number\n    }\n    if number < need {\n        carrots = number\n    }\n \
    \   if number < remaining {\n        carrots = number\n    }\n    if number ==\
    \ need {\n        carrots = number\n    }\n    if number == remaining {\n    \
    \    carrots = number\n    }\n    if number > remaining {\n        carrots = number\n\
    \    }\n    if number < need {\n        carrots = number\n    }\n    if number\
    \ < remaining {\n        carrots = number\n    }\n    if number == need {\n  \
    \      carrots = number\n    }\n    if number == remaining {\n        carrots\
    \ = number\n    }\n    if number > remaining {\n        carrots = number\n   \
    \ }\n    if number < need {\n        carrots = number\n    }\n    if number <\
    \ remaining {\n        carrots = number\n    }\n    if number == need {\n    \
    \    carrots = number\n    }\n    if number == remaining {\n        carrots =\
    \ number\n    }\n    if number > remaining {\n        carrots = number\n    }\n\
    \    if number < need {\n        carrots = number\n    }\n    if number < remaining\
    \ {\n        carrots = number\n    }\n    if number == need {\n        carrots\
    \ = number\n    }\n    if number == remaining {\n        carrots = number\n  \
    \  }\n    if number > remaining {\n        carrots = number\n    }\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpomnfkw21_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number == 0 {\n        result\
    \ = []int{0, 0}\n    } else {\n        var carrots int\n        if remaining <\
    \ need {\n            carrots = remaining\n        } else {\n            carrots\
    \ = need\n        }\n        if carrots > 0 {\n            result = []int{carrots,\
    \ carrots - 1}\n        }\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpr7om7_fq_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr7om7_fq_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=7)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpr7om7_fq_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpr7om7_fq_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpr7om7_fq_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr7om7_fq_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9uo8p527_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number == 0 {\n        result\
    \ = []int{0, 0}\n    } else {\n        if remaining < need {\n            result\
    \ = []int{0, 0}\n        } else {\n            result = []int{number, remaining\
    \ - number}\n        }\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7437ld_6_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7437ld_6_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7437ld_6_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7437ld_6_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp7437ld_6_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7437ld_6_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots - carrots + 1}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpale_p0nd_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpale_p0nd_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpale_p0nd_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpale_p0nd_test.go:62: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpale_p0nd_test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpale_p0nd_test.go:62:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8tz8ullg_test.go:122:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    need = need - carrots\n    if need > 0 {\n        result[0] = carrots\n\
    \        result[1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpv2yofs7l_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpv2yofs7l_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpv2yofs7l_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpv2yofs7l_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpv2yofs7l_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpv2yofs7l_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number == 0 {\n        result\
    \ = []int{0, 0}\n    } else {\n        var carrots int\n        if number < need\
    \ {\n            carrots = number\n        } else {\n            carrots = need\n\
    \        }\n        if carrots > remaining {\n            carrots = remaining\n\
    \        }\n        result = []int{carrots, carrots - number}\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsin1tepi_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsin1tepi_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpsin1tepi_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpsin1tepi_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpsin1tepi_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsin1tepi_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpii0pvetf_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if remaining < need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6ur3ms8_test.go:121:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbqyokuha_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, need}\n    }\n    if need == 0 && remaining > 0 {\n        return\
    \ []int{0, remaining}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        carrots := 0\n        carrots += number\n        carrots += need\n  \
    \      carrots += remaining\n        if carrots > 1000 {\n            return []int{0,\
    \ 0}\n        }\n        if carrots < 1000 {\n            return []int{0, carrots\
    \ - 1000}\n        }\n        return []int{carrots, carrots - 1000}\n    }\n \
    \   return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0v5c0rin_test.go:77: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=-979)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0v5c0rin_test.go:77:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=-979)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0v5c0rin_test.go:77: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=-979)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmp0v5c0rin_test.go:77: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=0) %!s(int=-982)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp0v5c0rin_test.go:77: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=0) %!s(int=-984)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmp0v5c0rin_test.go:77: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=-990)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    var result []int\n\
    \    var carrots int\n    if number > need {\n        carrots = number\n    }\
    \ else {\n        carrots = need\n    }\n    if carrots > remaining {\n      \
    \  carrots = remaining\n    }\n    result = []int{carrots, 0}\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpow6ha5ai_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpow6ha5ai_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpow6ha5ai_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpow6ha5ai_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpow6ha5ai_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpow6ha5ai_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code in JavaScript\
    \ (Node.js 8.9.4)\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm_tm6qxb_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n   \
    \     carrots = 1000\n    }\n    return []int{carrots, carrots - carrots + 1}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9itpgtb__test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9itpgtb__test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp9itpgtb__test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp9itpgtb__test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp9itpgtb__test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9itpgtb__test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining > 0 {\n\
    \        carrots = remaining\n        meals = number\n    }\n    if carrots >\
    \ 0 {\n        carrots = carrots + need\n        meals = meals + carrots\n   \
    \ }\n    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + carrots\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n \
    \       meals = meals + carrots\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + carrots\n    }\n    if carrots > 0\
    \ {\n        carrots = carrots - need\n        meals = meals + carrots\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + carrots\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n \
    \       meals = meals + carrots\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + carrots\n    }\n    if carrots > 0\
    \ {\n        carrots = carrots - need\n        meals = meals + carrots\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + carrots\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n \
    \       meals = meals + carrots\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + carrots\n    }\n    if carrots > 0\
    \ {\n        carrots = carrots - need\n        meals = meals + carrots\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + carrots\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n \
    \       meals = meals + carrots\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + carrots\n    }\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8l9gh5fx_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvyx4zux_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Error\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining < need {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > remaining {\n        result[0] =\
    \ need\n        result[1] = remaining\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need > number {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need && need > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = remaining\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = remaining\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > need && number > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need && number >\
    \ remaining {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need && number > remaining {\n        result[0] = remaining\n     \
    \   result[1] = need\n        return result\n    }\n    if number > need && number\
    \ > remaining {\n        result[0] = remaining\n        result[1] = number\n \
    \       return result\n    }\n    if number > need && number > remaining {\n \
    \       result[0] = remaining\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmmu9h77f_test.go:150:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7vdww468_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  if number > remaining {\n        carrots = number\n    } else {\n        carrots\
    \ = remaining\n    }\n    carrots = carrots + need\n    carrots = carrots - carrots\
    \ % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ + carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots + carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots + carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots + carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots + carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots + carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ + carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots + carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots + carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots + carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots + carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots + carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ + carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots + carrots % 10\n    carrots = car\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxqmpq5pq_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if remaining\
    \ > 0 {\n        carrots = remaining\n    }\n    if carrots > 0 {\n        result[0]\
    \ = carrots\n    }\n    if carrots > need {\n        result[1] = carrots - need\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpc35rcv4c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpc35rcv4c_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpc35rcv4c_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpc35rcv4c_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpc35rcv4c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpc35rcv4c_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ remaining}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, 0}\n    }\n    if number == need\
    \ && remaining == 0 {\n        return []int{number, 0}\n    }\n    if number ==\
    \ need && remaining > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining && need > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining && need > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvfz8u65g_test.go:124:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n\
    \    for i := 0; i < need; i++ {\n        meals += i\n    }\n    for i := 0; i\
    \ < remaining; i++ {\n        carrots += i\n    }\n    return []int{carrots, carrots\
    \ - meals}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7ofvz0k6_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=55)\
    \ %!s(int=40)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7ofvz0k6_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=42) %!s(int=14)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7ofvz0k6_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=45) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7ofvz0k6_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=-44)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp7ofvz0k6_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=27)\
    \ %!s(int=17)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7ofvz0k6_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=6) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := []int{0, 0}\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots\
    \ > need {\n        result[1] = carrots - need\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp60j1e182_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp60j1e182_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp60j1e182_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp60j1e182_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp60j1e182_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp60j1e182_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if number == 0 && need == 0 && remaining > 0 {\n        result[0] = 0\n \
    \       result[1] = remaining\n        return result\n    }\n    if number ==\
    \ 0 && need > 0 && remaining == 0 {\n        result[0] = 0\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && need == 0 && remaining\
    \ == 0 {\n        result[0] = number\n        result[1] = 0\n        return result\n\
    \    }\n    if number > 0 && need > 0 && remaining == 0 {\n        result[0] =\
    \ number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && need == 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && need > 0 &&\
    \ remaining > 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > 0 && need > 0 && remaining == 0\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > 0 && need == 0 && remaining > 0 {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > 0 && need > 0 && remaining > 0 {\n        result[0] = number\n    \
    \    result[1] = remaining\n        return result\n    }\n    if number > 0 &&\
    \ need == 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > 0 && need == 0 && remaining > 0 {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && need == 0 &&\
    \ remaining > 0 {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > 0 && need == 0 && remaining > 0 {\n        result[0] =\
    \ number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && need == 0 &&\
    \ remaining > 0 {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvwq35gk_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || number < 0 ||\
    \ need > 1000 || need < 0 || remaining > 1000 || remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n        result[0] = carrots\n     \
    \   result[1] = remaining\n    } else {\n        carrots = need\n        result[0]\
    \ = need\n        result[1] = remaining\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpv16c0jxi_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpv16c0jxi_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpv16c0jxi_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpv16c0jxi_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpv16c0jxi_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpv16c0jxi_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0f09ohkw_test.go:87:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number >\
    \ remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots > need {\n        carrots = need\n    }\n    result :=\
    \ []int{carrots, 0}\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp10pxq57f_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp10pxq57f_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp10pxq57f_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp10pxq57f_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp10pxq57f_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp10pxq57f_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    var carrots []int\n\
    \    var carrots_left int\n    if number > need {\n        carrots = append(carrots,\
    \ number-need)\n        carrots_left = number\n    } else {\n        carrots =\
    \ append(carrots, need)\n        carrots_left = need\n    }\n    if carrots_left\
    \ > remaining {\n        carrots = append(carrots, 0)\n        carrots_left =\
    \ remaining\n    }\n    return carrots\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmptdjplhz2_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmptdjplhz2_test.go:68: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmptdjplhz2_test.go:68: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=10)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmptdjplhz2_test.go:68:\
    \ expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=11) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmptdjplhz2_test.go:68: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp183xylze_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    for i := 0; i < number; i++ {\n        if carrots >= remaining\
    \ {\n            carrots -= remaining\n            meals++\n        } else {\n\
    \            carrots += need\n        }\n    }\n    return []int{meals, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaief3kg6_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=14)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaief3kg6_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=15)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpaief3kg6_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpaief3kg6_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpaief3kg6_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpaief3kg6_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=2)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpii0pvetf_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n     \
    \   result[0] = 0\n        result[1] = 0\n        return result\n    }\n    carrots\
    \ := 0\n    if number > 0 {\n        carrots = number\n    }\n    if need > 0\
    \ {\n        carrots = carrots + need\n    }\n    if remaining > 0 {\n       \
    \ carrots = carrots + remaining\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    result[0]\
    \ = carrots\n    if carrots > 0 {\n        result[1] = carrots - 1\n    }\n  \
    \  return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplcn8rtr8_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=20)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplcn8rtr8_test.go:81:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=20)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplcn8rtr8_test.go:81: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplcn8rtr8_test.go:81: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=17)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmplcn8rtr8_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=15)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplcn8rtr8_test.go:81:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=9)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number == 0 {\n        result[0] = remaining\n        result[1] = remaining\n\
    \        return result\n    }\n    if number < 0 {\n        result[0] = remaining\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ remaining {\n        result[0] = remaining\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > remaining {\n        result[0] =\
    \ remaining\n        result[1] = remaining\n        return result\n    }\n   \
    \ if number > need {\n        result[0] = number\n        result[1] = need\n \
    \       return result\n    }\n    if need > number {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > 0 &&\
    \ need > 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > 0 && need == 0 {\n        result[0] = number\n\
    \        result[1] = number\n        return result\n    }\n    if number == 0\
    \ && need > 0 {\n        result[0] = number\n        result[1] = need\n      \
    \  return result\n    }\n    if number == 0 && need == 0 {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ == 0 && need < 0 {\n        result[0] = number\n        result[1] = need\n \
    \       return result\n    }\n    if number == 0 && need < 0 {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == 0 && need > 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == 0 && need > 0 &&\
    \ remaining == 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == 0 && need > 0 && remaining < 0\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == 0 && need > 0 && remaining < 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && need > 0 && remaining > 0 && number > 0 && need > 0 {\n     \
    \   result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == 0 && need > 0 && remaining > 0 && number == 0 && need > 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == 0 && need > 0 && remaining > 0 && number == 0 && need\
    \ < 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == 0 && need > 0 && remaining > 0 && number ==\
    \ 0 && need < 0 {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number == 0 && need > 0 && remaining > 0 &&\
    \ number == 0 && need > 0 && remaining > 0 {\n        result[0] = number\n   \
    \     result[1] = need\n        return result\n    }\n    if number == 0 && need\
    \ > 0 && remaining > 0 && number == 0 && need > 0 && remaining == 0 {\n      \
    \  result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == 0 && need \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbdcezizj_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{need,\
    \ remaining}\n    }\n    if need == 0 {\n        return []int{number, remaining}\n\
    \    }\n    if remaining == 0 {\n        return []int{number, need}\n    }\n \
    \   if number > need {\n        return []int{number, need}\n    }\n    if number\
    \ > remaining {\n        return []int{number, remaining}\n    }\n    if need >\
    \ remaining {\n        return []int{need, remaining}\n    }\n    if number ==\
    \ need {\n        return []int{number, need}\n    }\n    if number == remaining\
    \ {\n        return []int{number, remaining}\n    }\n    if need == remaining\
    \ {\n        return []int{number, need}\n    }\n    if number == 0 || need ==\
    \ 0 || remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, need}\n    }\n    if number == remaining {\n\
    \        return []int{number, remaining}\n    }\n    if need == remaining {\n\
    \        return []int{number, need}\n    }\n    if number == 0 || need == 0 ||\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, need}\n    }\n    if number == remaining {\n   \
    \     return []int{number, remaining}\n    }\n    if need == remaining {\n   \
    \     return []int{number, need}\n    }\n    if number == 0 || need == 0 || remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, need}\n    }\n    if number == remaining {\n        return\
    \ []int{number, remaining}\n    }\n    if need == remaining {\n        return\
    \ []int{number, need}\n    }\n    if number == 0 || need == 0 || remaining ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, need}\n    }\n    if number == remaining {\n        return []int{number,\
    \ remaining}\n    }\n    if need == remaining {\n        return []int{number,\
    \ need}\n    }\n    if number == 0 || need == 0 || remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, need}\n\
    \    }\n    if number == remaining {\n        return []int{number, remaining}\n\
    \    }\n    if need == remaining {\n        return []int{number, need}\n    }\n\
    \    if number == 0 || need == 0 || remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5j0wcapd_test.go:128:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    if number < 0 ||\
    \ need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if remaining < need {\n     \
    \   return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == need {\n        return []int{number, 0}\n   \
    \ }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdonwwvvz_test.go:141:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2mkbiw9o_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    if number < need {\n        carrots = number\n    } else {\n        carrots\
    \ = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n \
    \   }\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj1nki55i_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvyx4zux_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number < need {\n\
    \        carrots = number\n        meals = need\n    } else {\n        carrots\
    \ = remaining\n        meals = number\n    }\n    carrots -= meals\n    carrots\
    \ += meals - 1\n    carrots += meals - 2\n    carrots += meals - 3\n    carrots\
    \ += meals - 4\n    carrots += meals - 5\n    carrots += meals - 6\n    carrots\
    \ += meals - 7\n    carrots += meals - 8\n    carrots += meals - 9\n    carrots\
    \ += meals - 10\n    carrots += meals - 11\n    carrots += meals - 12\n    carrots\
    \ += meals - 13\n    carrots += meals - 14\n    carrots += meals - 15\n    carrots\
    \ += meals - 16\n    carrots += meals - 17\n    carrots += meals - 18\n    carrots\
    \ += meals - 19\n    carrots += meals - 20\n    carrots += meals - 21\n    carrots\
    \ += meals - 22\n    carrots += meals - 23\n    carrots += meals - 24\n    carrots\
    \ += meals - 25\n    carrots += meals - 26\n    carrots += meals - 27\n    carrots\
    \ += meals - 28\n    carrots += meals - 29\n    carrots += meals - 30\n    carrots\
    \ += meals - 31\n    carrots += meals - 32\n    carrots += meals - 33\n    carrots\
    \ += meals - 34\n    carrots += meals - 35\n    carrots += meals - 36\n    carrots\
    \ += meals - 37\n    carrots += meals - 38\n    carrots += meals - 39\n    carrots\
    \ += meals - 40\n    carrots += meals - 41\n    carrots += meals - 42\n    carrots\
    \ += meals - 43\n    carrots += meals - 44\n    carrots += meals - 45\n    carrots\
    \ += meals - 46\n    carrots += meals - 47\n    car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgdkvtli3_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu46dsocc_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu46dsocc_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu46dsocc_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpu46dsocc_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpu46dsocc_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu46dsocc_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp183xylze_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number > remaining {\n    \
    \    number = remaining\n    }\n    if need > remaining {\n        need = remaining\n\
    \    }\n    if number > 0 {\n        result = append(result, number)\n    }\n\
    \    if need > 0 {\n        result = append(result, need)\n    }\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpa4a8w_kr_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpa4a8w_kr_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpa4a8w_kr_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpa4a8w_kr_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpa4a8w_kr_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpa4a8w_kr_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots = number - need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots + remaining\n    if\
    \ carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots, carrots\
    \ - carrots % 1000}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5csrid1i_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5csrid1i_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5csrid1i_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5csrid1i_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp5csrid1i_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5csrid1i_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining > 0 {\n\
    \        carrots = remaining\n        meals = 1\n    }\n    if number > need {\n\
    \        carrots = number\n        meals = 1\n    }\n    if carrots > 0 {\n  \
    \      carrots = carrots - need\n        meals = meals + 1\n    }\n    if carrots\
    \ > 0 {\n        carrots = carrots - need\n        meals = meals + 1\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + 1\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n       \
    \ meals = meals + 1\n    }\n    if carrots > 0 {\n        carrots = carrots -\
    \ need\n        meals = meals + 1\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + 1\n    }\n    if carrots > 0 {\n \
    \       carrots = carrots - need\n        meals = meals + 1\n    }\n    if carrots\
    \ > 0 {\n        carrots = carrots - need\n        meals = meals + 1\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + 1\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n       \
    \ meals = meals + 1\n    }\n    if carrots > 0 {\n        carrots = carrots -\
    \ need\n        meals = meals + 1\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots - need\n        meals = meals + 1\n    }\n    if carrots > 0 {\n \
    \       carrots = carrots - need\n        meals = meals + 1\n    }\n    if carrots\
    \ > 0 {\n        carrots = carrots - need\n        meals = meals + 1\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - need\n        meals = meals\
    \ + 1\n    }\n    if carrots > 0 {\n        carrots = carrots - need\n       \
    \ meals = meals + 1\n    }\n    if carrots > 0 {\n        carrots = carrots -\
    \ need\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8agimzlv_test.go:110:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots -= remaining\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplbc82a67_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplbc82a67_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplbc82a67_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplbc82a67_test.go:56: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmplbc82a67_test.go:56: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplbc82a67_test.go:56:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{}\n    }\n    if number == 0 && need == 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0, number}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == need && need ==\
    \ remaining {\n        return []int{number, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need && number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need && number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need && number > remaining {\n        return []int{number, 0}\n    }\n   \
    \ if number > need {\n        return []int{number, 0}\n    }\n    if number >\
    \ remaining {\n        return []int{number, 0}\n    }\n    if number == need &&\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need && number >\
    \ remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{number, 0}\n    }\n    if number > remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number == need && remaining == 0 {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need && number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need && remaining == 0 {\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexocqti5_test.go:132:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots =\
    \ carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots\
    \ = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots\
    \ = carrots + 1\n    carrots = carrots / 2\n    carrots = car\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbwly3o3o_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzg41ro27_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots\
    \ - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3kbr8mkx_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3kbr8mkx_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3kbr8mkx_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3kbr8mkx_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3kbr8mkx_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3kbr8mkx_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    carrots = number\n\
    \    meals = need\n    carrots = carrots - meals\n    carrots = carrots - remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8uazub54_test.go:86:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots - number\n  \
    \  carrots = carrots - need\n    carrots = carrots - remaining\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n\
    \        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots =\
    \ carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n  \
    \      carrots = 0\n    }\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots = carrots - number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + number\n    carrots = carrots + need\n \
    \   carrots = carrots + remaining\n    if carrots > 1000 {\n        carrots =\
    \ 1000\n    }\n    carrots = carrots - number\n    carrots = carrots - need\n\
    \    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1l9ublvm_test.go:106:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if remaining > 0 {\n        result\
    \ = append(result, need)\n        need = remaining\n    }\n    if number > 0 {\n\
    \        result = append(result, number)\n        number = number - need\n   \
    \ }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp32rblok5_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp32rblok5_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp32rblok5_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp32rblok5_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp32rblok5_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp32rblok5_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = 0\n        result[1] = 0\n        return result\n   \
    \ }\n    if number < need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number == remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number < need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number == remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number < need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp55utd8r__test.go:166:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots\
    \ > need {\n        result[1] = carrots - need\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjhfycsc1_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjhfycsc1_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjhfycsc1_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjhfycsc1_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjhfycsc1_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjhfycsc1_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrot\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc2foh049_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl1r1x4jg_test.go:119:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots\
    \ = number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots - need\n    carrots = carrots + number\n    carrots = carrots - need\n\
    \    carrots = carrots + number\n    carrots = carrots - need\n    carrots = carrots\
    \ + number\n    carrots = carrots - need\n    carrots = carrots + number\n   \
    \ carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = car\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvahfjsj9_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 {\n        result[0] = remaining\n     \
    \   result[1] = remaining\n    } else {\n        if remaining == 0 {\n       \
    \     result[0] = number\n            result[1] = need\n        } else {\n   \
    \         if number > need {\n                result[0] = number\n           \
    \     result[1] = need\n            } else {\n                result[0] = remaining\n\
    \                result[1] = remaining\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpspqr16fg_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpspqr16fg_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpspqr16fg_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpspqr16fg_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpspqr16fg_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpspqr16fg_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = remaining\n        result[1] = remaining\n    } else\
    \ {\n        result[0] = remaining\n        result[1] = need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp69l4gp7b_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp69l4gp7b_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return\n    }\n    if number == 0 {\n        result[0] = remaining\n\
    \        result[1] = remaining\n    } else {\n        result[0] = number\n   \
    \     result[1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpryqetdbf_test.go:34:9:\
    \ not enough return values\n\thave ()\n\twant ([]int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrot\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc2foh049_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || number < 0 {\n\
    \        return []int{0, 0}\n    }\n    if need > 1000 || need < 0 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining > 1000 || remaining < 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number < need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number < remaining\
    \ {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqk0gcnf_test.go:124:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2mkbiw9o_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075259
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    needEaten\
    \ := 0\n    carrots -= number\n    needEaten -= need\n    if carrots < 0 {\n \
    \       carrots = 0\n    }\n    if needEaten < 0 {\n        needEaten = 0\n  \
    \  }\n    if carrots == 0 && needEaten == 0 {\n        result[0] = 0\n       \
    \ result[1] = 0\n        return result\n    }\n    if carrots == 0 {\n       \
    \ result[0] = needEaten\n        result[1] = 0\n        return result\n    }\n\
    \    if needEaten == 0 {\n        result[0] = carrots\n        result[1] = 0\n\
    \        return result\n    }\n    if carrots > needEaten {\n        result[0]\
    \ = needEaten\n        result[1] = carrots - needEaten\n        return result\n\
    \    }\n    if carrots < needEaten {\n        result[0] = carrots\n        result[1]\
    \ = needEaten - carrots\n        return result\n    }\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiepsl643_test.go:70:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number == 0 {\n        result\
    \ = []int{0, 0}\n    } else {\n        if remaining < need {\n            result\
    \ = []int{0, 0}\n        } else {\n            result = []int{number, remaining\
    \ - number}\n        }\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7437ld_6_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7437ld_6_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7437ld_6_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7437ld_6_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp7437ld_6_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7437ld_6_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if need < 0 || need > 1000 {\n        fmt.Println(\"Invalid input\")\n  \
    \  }\n    if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if need > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n  \
    \  if number == need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n \
    \       return result\n    }\n    if need == 0 {\n        result[0] = 0\n    \
    \    result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n  \
    \      result[0] = number\n        result[1] = need\n        return result\n \
    \   }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if need > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n  \
    \  if number == need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpts2s04sq_test.go:158:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if remaining ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining == need {\n       \
    \ return []int{number, 0}\n    }\n    if remaining > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyx4iiro6_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n\
    \        carrots = number\n        meals = need\n    } else {\n        carrots\
    \ = need\n        meals = number\n    }\n    carrots -= remaining\n    meals -=\
    \ carrots\n    if carrots == 0 {\n        carrots = remaining\n        meals =\
    \ 0\n    }\n    return []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbiy1yuse_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=9)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbiy1yuse_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbiy1yuse_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbiy1yuse_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-4) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbiy1yuse_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=6)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbiy1yuse_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    if number > 1000 {\n        fmt.Println(\"Too many carrots\")\n     \
    \   return []int{0, 0}\n    }\n    if need > 1000 {\n        fmt.Println(\"Too\
    \ many carrots\")\n        return []int{0, 0}\n    }\n    if remaining > 1000\
    \ {\n        fmt.Println(\"Too many carrots\")\n        return []int{0, 0}\n \
    \   }\n    if number < need {\n        fmt.Println(\"Not enough carrots\")\n \
    \       return []int{0, 0}\n    }\n    if number == need {\n        fmt.Println(\"\
    You ate all your carrots\")\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Not enough carrots\")\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        fmt.Println(\"You ate all your\
    \ carrots\")\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        fmt.Println(\"Not enough carrots\")\n        return []int{number, 0}\n\
    \    }\n    if number == need {\n        fmt.Println(\"You ate all your carrots\"\
    )\n        return []int{number, 0}\n    }\n    if number < remaining {\n     \
    \   fmt.Println(\"Not enough carrots\")\n        return []int{number, 0}\n   \
    \ }\n    if number == remaining {\n        fmt.Println(\"You ate all your carrots\"\
    )\n        return []int{number, 0}\n    }\n    if number > need {\n        fmt.Println(\"\
    Not enough carrots\")\n        return []int{number, 0}\n    }\n    if number ==\
    \ need {\n        fmt.Println(\"You ate all your carrots\")\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        fmt.Println(\"Not enough carrots\"\
    )\n        return []int{number, 0}\n    }\n    if number == remaining {\n    \
    \    fmt.Println(\"You ate all your carrots\")\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        fmt.Println(\"Not enough carrots\")\n\
    \        return []int{number, 0}\n    }\n    if number == need {\n        fmt.Println(\"\
    You ate all your carrots\")\n        return []int{number, 0}\n    }\n    if number\
    \ < remaining {\n        fmt.Println(\"Not enough carrots\")\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        fmt.Println(\"You ate all your\
    \ carrots\")\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        fmt.Print\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzojmif6s_test.go:111:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    return []int{carrots,\
    \ carrots - carrots % 1000}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70kzoiai_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70kzoiai_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70kzoiai_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70kzoiai_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp70kzoiai_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70kzoiai_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots = number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp944qca1q_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    meals = number\n    if number > need {\n        meals = need\n\
    \    }\n    if number > remaining {\n        meals = remaining\n    }\n    carrots\
    \ = meals\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpff0s06xb_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075261
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots - carrots + need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpi4ttxcgi_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpi4ttxcgi_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpi4ttxcgi_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpi4ttxcgi_test.go:62: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpi4ttxcgi_test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpi4ttxcgi_test.go:62:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining > 0 {\n\
    \        meals = number\n        carrots = need\n    } else {\n        meals =\
    \ remaining\n        carrots = number\n    }\n    result := make([]int, 2)\n \
    \   result[0] = meals\n    result[1] = carrots\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp27tg_qbj_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp27tg_qbj_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp27tg_qbj_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp27tg_qbj_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp27tg_qbj_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp27tg_qbj_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{number, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7zlxnvie_test.go:141:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots +=\
    \ i\n    }\n    for i := 0; i < need; i++ {\n        carrots += i\n    }\n   \
    \ carrots -= need\n    result[0] = carrots\n    if carrots > remaining {\n   \
    \     result[1] = remaining\n    } else {\n        result[1] = carrots\n    }\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzi3_unk2_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=19)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzi3_unk2_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=26) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzi3_unk2_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=35) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzi3_unk2_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=45) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzi3_unk2_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzi3_unk2_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=11) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    if carrots < 0\
    \ {\n        carrots = 0\n    }\n    return []int{carrots, carrots - carrots +\
    \ number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaqrd0www_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaqrd0www_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpaqrd0www_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpaqrd0www_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpaqrd0www_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpaqrd0www_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n\
    \    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > number {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > number {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > number\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if need\
    \ > number {\n        return []int{0, 0}\n    }\n    if need > remaining {\n \
    \       return []int{0, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > number {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > number {\n        return []int{0, 0}\n    }\n    if need\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number > need {\n \
    \       return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > number {\n        return []int{0, 0}\n   \
    \ }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1pb5qwbp_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n\
    \    carrots += number\n    meals += need\n    carrots -= remaining\n    meals\
    \ -= number\n    if carrots < 0 {\n        carrots = 0\n    }\n    if meals <\
    \ 0 {\n        meals = 0\n    }\n    if carrots == 0 && meals == 0 {\n       \
    \ return []int{0, 0}\n    }\n    if carrots == 0 {\n        return []int{meals,\
    \ 0}\n    }\n    if meals == 0 {\n        return []int{0, carrots}\n    }\n  \
    \  return []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpeydhtbc7_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpeydhtbc7_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpeydhtbc7_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpeydhtbc7_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpeydhtbc7_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpeydhtbc7_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_0l2xav5_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_0l2xav5_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_0l2xav5_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_0l2xav5_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp_0l2xav5_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_0l2xav5_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    carrots -= number\n\
    \    meals += need\n    carrots -= remaining\n    meals += number\n    return\
    \ []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp2yqs7nyh_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11)\
    \ %!s(int=-15)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp2yqs7nyh_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=-13)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp2yqs7nyh_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=-11)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmp2yqs7nyh_test.go:61: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=13) %!s(int=-7)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp2yqs7nyh_test.go:61: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=9) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmp2yqs7nyh_test.go:61: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > remaining\
    \ {\n        carrots = number\n        meals = need\n    } else {\n        carrots\
    \ = remaining\n        meals = number\n    }\n    result := make([]int, 2)\n \
    \   result[0] = carrots\n    result[1] = meals\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnhe19t36_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnhe19t36_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnhe19t36_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnhe19t36_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnhe19t36_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnhe19t36_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    for i := 0; i < number; i++ {\n        carrots += eatCarrots(i,\
    \ need)\n        meals += eatMeals(carrots, remaining)\n    }\n    return []int{meals,\
    \ carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp5pavwtz_test.go:37:20: undefined: eatCarrots

    /tmp/tmpp5pavwtz_test.go:38:18: undefined: eatMeals

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, 0}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining > 0\
    \ {\n        if number >= need {\n            return []int{number, 0}\n      \
    \  }\n        if number < need {\n            return []int{0, remaining}\n   \
    \     }\n        if number < need {\n            return []int{0, 0}\n        }\n\
    \        if number < need {\n            return []int{0, 0}\n        }\n     \
    \   if number < need {\n            return []int{0, 0}\n        }\n        if\
    \ number < need {\n            return []int{0, 0}\n        }\n        if number\
    \ < need {\n            return []int{0, 0}\n        }\n        if number < need\
    \ {\n            return []int{0, 0}\n        }\n        if number < need {\n \
    \           return []int{0, 0}\n        }\n        if number < need {\n      \
    \      return []int{0, 0}\n        }\n        if number < need {\n           \
    \ return []int{0, 0}\n        }\n        if number < need {\n            return\
    \ []int{0, 0}\n        }\n        if number < need {\n            return []int{0,\
    \ 0}\n        }\n        if number < need {\n            return []int{0, 0}\n\
    \        }\n        if number < need {\n            return []int{0, 0}\n     \
    \   }\n        if number < need {\n            return []int{0, 0}\n        }\n\
    \        if number < need {\n            return []int{0, 0}\n        }\n     \
    \   if number < need {\n            return []int{0, 0}\n        }\n        if\
    \ number < need {\n            return []int{0, 0}\n        }\n        if number\
    \ < need {\n            return []int{0, 0}\n        }\n        if number < need\
    \ {\n            return []int{0, 0}\n        }\n        if number < need {\n \
    \           return []int{0, 0}\n        }\n        if number < need {\n      \
    \      return []int{0, 0}\n        }\n        if number < need {\n           \
    \ return []int{0, 0}\n        }\n        if number < need {\n            return\
    \ []int{0, 0}\n        }\n        if number < need {\n            return []int{0,\
    \ 0}\n        }\n        if number < need {\n            return []int{0, 0}\n\
    \        }\n        if number < need {\n            return []int{0, 0}\n     \
    \   }\n        if number < need {\n            return []int{0, 0}\n        }\n\
    \        if number < need {\n            return []int\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5wiozya3_test.go:135:20: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvyx4zux_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    if number > need {\n        meals = number\n        carrots\
    \ = need\n    } else {\n        meals = need\n        carrots = number\n    }\n\
    \    if carrots > remaining {\n        carrots = remaining\n    }\n    meals -=\
    \ carrots\n    carrots -= meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += meals\n    carrots += meals\n    carrots += meals\n    carrots\
    \ += meals\n    carrots += meals\n    carrots += meals\n    carrots += meals\n\
    \    carrots += \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphcn79n9a_test.go:107:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -=\
    \ need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n \
    \   carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n        carrots =\
    \ 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    if carrots == 0 {\n        carrots = 1000\n    }\n \
    \   carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -=\
    \ need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n \
    \   carrots -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu_dinzys_test.go:116:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    carrots := 0\n    carrots = number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_980k721_test.go:94:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, need}\n    }\n   \
    \ if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots += number\n    carrots += need\n    car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9x2peqh1_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075262
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots - number\n  \
    \  carrots = carrots - need\n    carrots = carrots - remaining\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots / 2\n    carrots =\
    \ carrots * 2\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = car\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn4au6jyh_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    var result []int\n    if number > 0 {\n        result\
    \ = append(result, number-need)\n    }\n    if remaining > 0 {\n        result\
    \ = append(result, remaining)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsmpb9vef_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsmpb9vef_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpsmpb9vef_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpsmpb9vef_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpsmpb9vef_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsmpb9vef_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{need, remaining}\n    }\n    if need == 0 {\n        return\
    \ []int{number, remaining}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpytx3xqds_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, 0}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && remaining > 0 {\n        if number >= need {\n\
    \            return []int{number, 0}\n        }\n        if number >= remaining\
    \ {\n            return []int{number, 0}\n        }\n        if need > remaining\
    \ {\n            return []int{0, number}\n        }\n    }\n    if number > 0\
    \ && need > 0 && remaining == 0 {\n        return []int{0, number}\n    }\n  \
    \  if number > 0 && need > 0 && remaining > 0 {\n        if number >= need {\n\
    \            return []int{number, 0}\n        }\n        if number >= remaining\
    \ {\n            return []int{number, 0}\n        }\n        if need > remaining\
    \ {\n            return []int{0, number}\n        }\n    }\n    if number > 0\
    \ && need > 0 && remaining > 0 {\n        if number >= need {\n            return\
    \ []int{number, 0}\n        }\n        if number >= remaining {\n            return\
    \ []int{number, 0}\n        }\n        if need > remaining {\n            return\
    \ []int{0, number}\n        }\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        if number >= need {\n            return []int{number, 0}\n  \
    \      }\n        if number >= remaining {\n            return []int{number, 0}\n\
    \        }\n        if need > remaining {\n            return []int{0, number}\n\
    \        }\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        if\
    \ number >= need {\n            return []int{number, 0}\n        }\n        if\
    \ number >= remaining {\n            return []int{number, 0}\n        }\n    \
    \    if need > remaining {\n            return []int{0, number}\n        }\n \
    \   }\n    if number > 0 && need > 0 && remaining > 0 {\n        if number >=\
    \ need {\n            return []int{number, 0}\n        }\n        if number >=\
    \ remaining {\n            return []int{number, 0}\n        }\n        if need\
    \ > remaining {\n            return []int{0, number}\n        }\n    }\n    if\
    \ number > 0 && need > 0 && remaining > 0 {\n        if number >= need {\n   \
    \         return []int{number, 0}\n        }\n        if number >= remaining {\n\
    \            return []int{number, 0}\n        }\n        if need > remaining {\n\
    \            return []int{0, number}\n        }\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        if number >= need {\n            return []int{number,\
    \ 0}\n        }\n        if number >= \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd2y67mxt_test.go:131:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = 0\n        result[1] = 0\n    } else {\n        result[0]\
    \ = number\n        result[1] = need\n    }\n    if remaining > 0 {\n        result[0]\
    \ = result[0] - remaining\n        result[1] = result[1] - remaining\n    }\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp8w3r2yqa_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-5)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp8w3r2yqa_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-5) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp8w3r2yqa_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp8w3r2yqa_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-3) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp8w3r2yqa_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-3)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp8w3r2yqa_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl1r1x4jg_test.go:119:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrot\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc2foh049_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if need == 0 {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if need > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgdy1lqyu_test.go:153:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwh50xo8u_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number < 0 || number > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n  \
    \  }\n    if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpplke7431_test.go:141:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{need, remaining}\n    }\n    if need == 0 {\n        return\
    \ []int{number, remaining}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n  \
    \  if number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ need}\n    }\n    if need == remaining {\n        return []int{0, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, need}\n    }\n   \
    \ if need == remaining {\n        return []int{0, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, need}\n    }\n    if need\
    \ == remaining {\n        return []int{0, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, need}\n    }\n    if need\
    \ == remaining {\n        return []int{0, 0}\n    }\n    if number > need {\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdizu4mtr_test.go:137:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{}\n    }\n    result := make([]int, 2)\n    if remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n    } else\
    \ {\n        result[0] = need\n        result[1] = 0\n    }\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1jhwghda_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1jhwghda_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1jhwghda_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1jhwghda_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1jhwghda_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1jhwghda_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots % 1000}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpr07ziao5_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr07ziao5_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpr07ziao5_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpr07ziao5_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpr07ziao5_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr07ziao5_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9eafo82x_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining && number\
    \ > need {\n        result[0] = number\n        result[1] = remaining\n      \
    \  return result\n    }\n    if need > remaining && need > number {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need && number == remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining && number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need && number > remaining && number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining && need > number {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining && number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining && need > number && need > remaining {\n        result[0] =\
    \ need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need && number == remaining && number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ && number == need && number == remaining {\n        result[0] = number\n   \
    \     result[1] = need\n        return result\n    }\n    if number > need &&\
    \ number > remaining && number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number && need > remaining && need > number && need > remaining {\n      \
    \  result[0] = \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxz63fln7_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    if number < 0 ||\
    \ number > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if need\
    \ < 0 || need > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if need >\
    \ remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number < 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    if number > 1000 {\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    if number < 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number < 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\")\n   \
    \ }\n    if number < 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n \
    \   if number > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ number < 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number < 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    if number < 1000 {\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number < 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number < 1000 {\n        fmt.Println(\"Invalid input\")\n   \
    \ }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n \
    \   if number < 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ number > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ < 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number < 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    if number > \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkgsb7ev0_test.go:126:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if remaining == 0 {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > need {\n   \
    \     result[0] = number\n        result[1] = need\n        return result\n  \
    \  }\n    if number == need {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need && number == remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number == remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number == remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number == remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number == remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number == remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number == remaining {\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50aiwqam_test.go:147:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{need, remaining}\n    }\n    if need == 0 {\n        return\
    \ []int{number, remaining}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ need}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvp28x9_2_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsbsi36q6_test.go:115:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > remaining {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw_by9bz8_test.go:168:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if remaining < need {\n        result[0] = number\n     \
    \   result[1] = remaining\n        return result\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots -= need\n    carrots += remaining\n    result[0]\
    \ = carrots\n    result[1] = carrots - need\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpcxm6r9k3_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=9)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcxm6r9k3_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=-3)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpcxm6r9k3_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpcxm6r9k3_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpcxm6r9k3_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=6)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcxm6r9k3_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwh50xo8u_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    if number < 0 ||\
    \ number > 1000 {\n        return []int{0, 0}\n    }\n    if need < 0 || need\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number < need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        carrots = number - need\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmprcw5q8vp_test.go:83: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprcw5q8vp_test.go:83:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmprcw5q8vp_test.go:83: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmprcw5q8vp_test.go:83: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmprcw5q8vp_test.go:83: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprcw5q8vp_test.go:83:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots\
    \ = carrots - number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots - number\n  \
    \  carrots = carrots - need\n    carrots = carrots - remaining\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n\
    \        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots =\
    \ carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n  \
    \      carrots = 0\n    }\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots = carrots - number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + number\n    carrots = carrots + need\n \
    \   carrots = carrots + remaining\n    if carrots > 1000 {\n        carrots =\
    \ 1000\n    }\n    carrots = carrots - number\n    carrots = carrots - need\n\
    \    carrots = carrots - remaining\n    if carrots < \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwbk6hn3f_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    for carrots < number {\n        if meals >= need {\n      \
    \      meals -= need\n            carrots += need\n        } else {\n        \
    \    carrots += remaining\n        }\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpd676jfqg_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd676jfqg_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpd676jfqg_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpd676jfqg_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpd676jfqg_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd676jfqg_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzg41ro27_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    result := []int{0, 0}\n    if number == 0\
    \ {\n        return result\n    }\n    if remaining < need {\n        return result\n\
    \    }\n    if number < need {\n        return result\n    }\n    carrots := 0\n\
    \    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    carrots +=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    result[0] = carrots\n    result[1] = remaining\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkocueg47_test.go:83: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkocueg47_test.go:83:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkocueg47_test.go:83: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkocueg47_test.go:83: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpkocueg47_test.go:83: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkocueg47_test.go:83:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining >= need\
    \ {\n        carrots = remaining\n        meals = number\n    } else {\n     \
    \   carrots = need\n        meals = remaining\n    }\n    result := make([]int,\
    \ 2)\n    result[0] = carrots\n    result[1] = meals\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpe4iej1sx_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe4iej1sx_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpe4iej1sx_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpe4iej1sx_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpe4iej1sx_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe4iej1sx_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrot\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpznmsxk56_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == need && number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need && number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need && number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need && number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need && number == remaining {\n        return []int{number, 0}\n    }\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuc73czwv_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7vdww468_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    return []int{carrots, carrots - carrots % 1000}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpit6p9lae_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpit6p9lae_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpit6p9lae_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpit6p9lae_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpit6p9lae_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpit6p9lae_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"Error\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number < need {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number < need {\n \
    \       result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp17o0iolh_test.go:169:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n        number = remaining\n      \
    \  remaining = 0\n    } else {\n        carrots = remaining\n        remaining\
    \ = number\n    }\n    if carrots == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n    } else {\n        result[0] = carrots\n        result[1] = need\n \
    \   }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpwclbr678_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwclbr678_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpwclbr678_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpwclbr678_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpwclbr678_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwclbr678_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0f09ohkw_test.go:87:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number < 0 ||\
    \ need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyh3kv5kr_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code in JavaScript\
    \ (Node.js 8.9.4)\n    // let carrots = number\n    // let need = need\n    //\
    \ let remaining = remaining\n    // let result = []\n    // while carrots > 0\
    \ && need > 0 && remaining > 0 {\n    //     carrots -= need\n    //     need\
    \ -= remaining\n    //     result.push(carrots)\n    //     remaining -= carrots\n\
    \    // }\n    // return result\n    // let carrots = number\n    // let need\
    \ = need\n    // let remaining = remaining\n    // let result = []\n    // while\
    \ carrots > 0 && need > 0 && remaining > 0 {\n    //     carrots -= need\n   \
    \ //     need -= remaining\n    //     result.push(carrots)\n    //     remaining\
    \ -= carrots\n    // }\n    // return result\n    let carrots = number\n    let\
    \ need = need\n    let remaining = remaining\n    let result = []\n    while carrots\
    \ > 0 && need > 0 && remaining > 0 {\n        carrots -= need\n        need -=\
    \ remaining\n        result.push(carrots)\n        remaining -= carrots\n    }\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyc1eergl_test.go:54:9: expected '';'', found carrots

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n   \
    \ carrots := 0\n    if remaining < need {\n        carrots = remaining\n    }\n\
    \    if carrots < need {\n        result[0] = carrots\n        result[1] = need\n\
    \    } else {\n        result[0] = need\n        result[1] = carrots\n    }\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_vlahmko_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_vlahmko_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_vlahmko_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_vlahmko_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_vlahmko_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_vlahmko_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        result[0] = 0\n       \
    \ result[1] = 0\n        return result\n    }\n    if need == 0 {\n        result[0]\
    \ = 0\n        result[1] = 0\n        return result\n    }\n    if remaining ==\
    \ 0 {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining && number\
    \ > need {\n        result[0] = number\n        result[1] = remaining\n      \
    \  return result\n    }\n    if need > remaining && need > number {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need && number == remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining && number ==\
    \ need {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need && number > remaining && number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining && need > number {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining && number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining && need > number && need > remaining {\n        result[0] =\
    \ need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need && number == remaining && number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ && number == need && number == remaining {\n        result[0] = number\n   \
    \     result[1] = need\n        return result\n    }\n    if number > need &&\
    \ number > remaining && number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpupjrqbah_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots\
    \ = number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots - need\n    carrots = carrots + number\n    carrots = carrots - need\n\
    \    carrots = carrots + number\n    carrots = carrots - need\n    carrots = carrots\
    \ + number\n    carrots = carrots - need\n    carrots = carrots + number\n   \
    \ carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = car\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvahfjsj9_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || number < 0 ||\
    \ need > 1000 || need < 0 || remaining > 1000 || remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots = number - need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots + remaining\n    if\
    \ carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots + 1\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots\
    \ + 1\n    if carrots > 1000 {\n        carrots = 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpogox8jui_test.go:114:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    carrots := 0\n    if number > remaining {\n        carrots = number\
    \ - remaining\n        result[0] = carrots\n        result[1] = remaining\n  \
    \  } else {\n        carrots = remaining\n        result[0] = remaining\n    \
    \    result[1] = 0\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpwbnj2ks6_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwbnj2ks6_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpwbnj2ks6_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpwbnj2ks6_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpwbnj2ks6_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwbnj2ks6_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    carrots\
    \ = number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    result[0] = carrots\n    result[1] = remaining\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpx4uq01do_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-11)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpx4uq01do_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-13) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpx4uq01do_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-19) %!s(int=10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpx4uq01do_test.go:62: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=-14) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpx4uq01do_test.go:62: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=-8) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpx4uq01do_test.go:62: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-2)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    carrots = number\
    \ - need\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9hnxarxh_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9hnxarxh_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp9hnxarxh_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp9hnxarxh_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp9hnxarxh_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9hnxarxh_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        result[0] = remaining\n        result[1] = remaining\n    } else\
    \ {\n        result[0] = remaining\n        result[1] = need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp69l4gp7b_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp69l4gp7b_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp69l4gp7b_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp69l4gp7b_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbvyx4zux_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    result := make([]int, 2)\n    if\
    \ number < 0 || number > 1000 {\n        fmt.Println(\"Invalid input\")\n    \
    \    return nil\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == 1 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > remaining {\n   \
    \     fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = 0\n      \
    \  return result\n    }\n    if number == remaining {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > need {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > need {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > need {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > need {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > need {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjpqbaksr_test.go:156:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \    } else {\n        result[0] = carrots\n        result[1] = number-carrots\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzdm5j92c_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzdm5j92c_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=-5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzdm5j92c_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzdm5j92c_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzdm5j92c_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzdm5j92c_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  meals := 0\n    if number > remaining {\n        carrots = number\n       \
    \ meals = need\n    } else {\n        carrots = remaining\n        meals = number\n\
    \    }\n    result := make([]int, 2)\n    result[0] = carrots\n    result[1] =\
    \ meals\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpixbrd4cl_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpixbrd4cl_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpixbrd4cl_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpixbrd4cl_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpixbrd4cl_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpixbrd4cl_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, need}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && remaining == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && remaining > 0 && need > 0 {\n\
    \        carrots := 0\n        carrots += number\n        carrots += need\n  \
    \      carrots += remaining\n        carrots %= 1000\n        carrots %= 1000\n\
    \        carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n \
    \       carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n  \
    \      carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n   \
    \     carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n    \
    \    carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n     \
    \   carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n      \
    \  carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n       \
    \ carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n        carrots\
    \ %= 1000\n        carrots %= 1000\n        carrots %= 1000\n        carrots %=\
    \ 1000\n        carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n\
    \        carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n \
    \       carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n  \
    \      carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n   \
    \     carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n    \
    \    carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n     \
    \   carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n      \
    \  carrots %= 1000\n        carrots %= 1000\n        carrots %= 1000\n       \
    \ carrots %= 1000\n        carrots %= 1000\n\nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3cr3_ce_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n       \
    \ return []int{0, need}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && remaining == 0 {\n        return\
    \ []int{number, number}\n    }\n    if number > 0 && remaining > 0 {\n       \
    \ carrots := 0\n        if number > need {\n            carrots = number - need\n\
    \        }\n        if carrots > remaining {\n            carrots = remaining\n\
    \        }\n        return []int{carrots, 0}\n    }\n    return []int{0, 0}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpl1eic7k2_test.go:77: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl1eic7k2_test.go:77:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpl1eic7k2_test.go:77: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpl1eic7k2_test.go:77: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpl1eic7k2_test.go:77: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl1eic7k2_test.go:77:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu46dsocc_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu46dsocc_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu46dsocc_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpu46dsocc_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpu46dsocc_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu46dsocc_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 && need == remaining {\n\
    \        return []int{number, 0}\n    }\n    if number == 0 && need > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number > 0 && need == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > 0 && need > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number > 0 && need == 0 {\n\
    \        return []int{0, number}\n    }\n    if number > 0 && need > 0 {\n   \
    \     result := []int{0, 0}\n        carrots := 0\n        if number > need {\n\
    \            carrots = number\n            number = need\n            need = 0\n\
    \        }\n        if number > remaining {\n            carrots = number\n  \
    \          number = remaining\n            remaining = 0\n        }\n        if\
    \ number > 0 {\n            carrots = number\n            number = 1\n       \
    \ }\n        if need > 0 {\n            carrots = need\n            need = 1\n\
    \        }\n        if carrots > 0 {\n            result[0] = carrots\n      \
    \      carrots = carrots - 1\n        }\n        if carrots > 0 {\n          \
    \  result[1] = carrots\n            carrots = carrots - 1\n        }\n       \
    \ return result\n    }\n    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpxs_an5qy_test.go:104: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxs_an5qy_test.go:104:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=7)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpxs_an5qy_test.go:104: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpxs_an5qy_test.go:104: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpxs_an5qy_test.go:104: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxs_an5qy_test.go:104:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    carrots := 0\n    if number < 0 ||\
    \ number > 1000 {\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        return nil\n    }\n    if remaining < 0 || remaining > 1000 {\n     \
    \   return nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if\
    \ number > need {\n        return nil\n    }\n    if remaining == 0 {\n      \
    \  return nil\n    }\n    if remaining > number {\n        return nil\n    }\n\
    \    if number > remaining {\n        carrots = number\n    } else {\n       \
    \ carrots = remaining\n    }\n    return []int{carrots, number - carrots}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsl4c8mpt_test.go:79: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsl4c8mpt_test.go:79: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpsl4c8mpt_test.go:79: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpsl4c8mpt_test.go:79: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpsl4c8mpt_test.go:79: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsl4c8mpt_test.go:79: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9khgly6v_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9khgly6v_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp9khgly6v_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp9khgly6v_test.go:62: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp9khgly6v_test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9khgly6v_test.go:62:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // write your code here\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr_o8nn5x_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    carrots := 0\n    result [0] = carrots\n    result [1] = remaining\n\
    \    if carrots >= need {\n        carrots -= need\n        result [0] = carrots\n\
    \    } else {\n        carrots = remaining\n        result [0] = carrots\n   \
    \     result [1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0kgqjptc_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0kgqjptc_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0kgqjptc_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0kgqjptc_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp0kgqjptc_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0kgqjptc_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 ||\
    \ remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrot\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc2foh049_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    result := []int{0, 0}\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots\
    \ > need {\n        result[1] = carrots - need\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp60j1e182_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp60j1e182_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp60j1e182_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp60j1e182_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp60j1e182_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp60j1e182_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots\
    \ += need\n    carrots -= remaining\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8a6agere_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    // Your code here\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    if carrots < 0\
    \ {\n        carrots = 0\n    }\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_lkla1ar_test.go:122:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n       \
    \ return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n    \
    \    return []int{0, 0}\n    }\n    carrots := 0\n    meals := 0\n    if number\
    \ >= need {\n        carrots = number\n        meals = need\n    } else {\n  \
    \      carrots = remaining\n        meals = number\n    }\n    result := make([]int,\
    \ 2)\n    result[0] = carrots\n    result[1] = meals\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpz0c8d2rr_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpz0c8d2rr_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpz0c8d2rr_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpz0c8d2rr_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpz0c8d2rr_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpz0c8d2rr_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10)\
    \ -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n\
    // the number of carrots that you have eaten.\n// @need : integer\n// the number\
    \ of carrots that you need to eat.\n// @remaining : integer\n// the number of\
    \ remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n\
    // * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number\
    \ int, need int, remaining int) []int {\n    if number < 0 || number > 1000 ||\
    \ need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5sg17_z_test.go:104:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
