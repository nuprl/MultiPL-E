language: go_test.go
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"int_to_mini_roman:\
    \ Invalid input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result\
    \ := \"\"\n    for _, romanIndex := range romans {\n        result += \"M\"\n\
    \        if number >= 100 && number < 1000 {\n            result += romanIndex\n\
    \            number -= 100\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'xix', got 'MMMMMMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'clii', got 'MMMMMMMMMMMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'ccli', got 'MMMCMMMMMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'cdxxvi', got 'MMMCMMDMCDMMMMMMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'd', got 'MMMCMMDMCDMCMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'i', got 'MMMMMMMMMMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'iv', got 'MMMMMMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'xliii', got 'MMMMMMMMMMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'xc', got 'MMMMMMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'xciv', got 'MMMMMMMMMMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'dxxxii', got 'MMMCMMDMCDMCMMMMMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'cm', got 'MMMCMMDMCDMCMXCMLMXLMXMMMM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmp2qx4q91e_test.go:57: expected 'cmxciv', got 'MMMCMMDMCDMCMXCMLMXLMXMMMM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp2qx4q91e_test.go:57:\
    \ expected 'm', got 'MMMMMMMMMMMMM'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"\
    L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n     \
    \   90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ep5dr9q_test.go:49:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"I\",\n        5:  \"\
    V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n        500:\
    \ \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if\
    \ !ok {\n        fmt.Println(\"int_to_mini_roman: number too large\")\n    }\n\
    \    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "int_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    int_to_mini_roman: number too large\nint_to_mini_roman: number too large\nint_to_mini_roman:\
    \ number too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number\
    \ too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too\
    \ large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    --- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp36s7eo13_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp36s7eo13_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp36s7eo13_test.go:58:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp36s7eo13_test.go:58: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp36s7eo13_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp36s7eo13_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp36s7eo13_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp36s7eo13_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp36s7eo13_test.go:58: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3us_dyxq_test.go:17:21: undefined: int_to_roman

    /tmp/tmp3us_dyxq_test.go:18:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\",\n        \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\n        \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\",\n        \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LIII\", \"LIIII\", \"LIIV\", \"LV\", \"LVI\",\n        \"LVII\",\
    \ \"LVIII\", \"LIV\", \"LVV\", \"LVVI\", \"LVVII\", \"LVVIII\", \"LVIX\", \"LX\"\
    , \"LXI\", \"LXII\",\n        \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\",\n        \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\",\n        \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\",\
    \ \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"XC\", \"CC\", \"CCC\", \"\
    CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\", \"MMM\",\n    }\n\
    \    roman_numeral_index := 0\n    roman_numeral_string := \"\"\n    for roman_numeral_index\
    \ < len(roman_numerals) {\n        if number >= roman_numerals[roman_numeral_index]\
    \ {\n            roman_numeral_string += roman_numerals[roman_numeral_index]\n\
    \            number -= roman_numerals[roman_numeral_index]\n        } else {\n\
    \            break\n        }\n    }\n    return roman_numeral_string\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3buxz6ry_test.go:30:22: invalid operation: number >= roman_numerals[roman_numeral_index]
    (mismatched types int and string)

    /tmp/tmp3buxz6ry_test.go:32:13: invalid operation: number -= roman_numerals[roman_numeral_index]
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"\
    L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n     \
    \   90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvum7_dxi_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_num := roman_num[:number%100]\n\
    \    number /= 100\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, \nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx0vt4b72_test.go:52:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input:\", number)\n    }\n    return strings.ToLower(roman)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpli8iti7o_test.go:21:9: duplicate key 100 in map literal

    /tmp/tmpli8iti7o_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_number\
    \ := roman_number[:number%100]\n    number /= 100\n    roman_number := append(roman_number,\
    \ []string{\"I\"}...)\n    roman_number := append(roman_number, []string{\"V\"\
    }...)\n    roman_number := append(roman_number, []string{\"X\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"L\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"C\"}...)\n    roman_number := append(roman_number, []string{\"D\"\
    }...)\n    roman_number := append(roman_number, []string{\"M\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"V\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"I\"}...)\n    roman_number := append(roman_number, []string{\"X\"\
    }...)\n    roman_number := append(roman_number, []string{\"C\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"D\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"M\"}...)\n    roman_number := append(roman_number, []string{\"V\"\
    }...)\n    roman_number := append(roman_number, []string{\"I\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"X\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"C\"}...)\n    roman_number := append(roman_number, []string{\"D\"\
    }...)\n    roman_number := append(roman_number, []string{\"M\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"V\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"I\"}...)\n    roman_number := append(roman_number, []string{\"X\"\
    }...)\n    roman_number := append(roman_number, []string{\"C\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"D\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"M\"}...)\n    roman_number := append(roman_number, []string{\"V\"\
    }...)\n    roman_number := append(roman_number, []string{\"I\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"X\"}...)\n    roman_number := append(roman_number,\
    \ \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ekrz8w1_test.go:48:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"I\",\n\
    \        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\"\
    ,\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\
    \n    for roman_numeral, number := range roman_numerals {\n        if number <=\
    \ number {\n            break\n        }\n    }\n    return roman_numeral\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32ds832t_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input\")\n    }\n\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9zfmh0k_test.go:21:9: duplicate key 100 in map literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9hye9kk_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7wnehwp3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\",\
    \ \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n    }\n    romanIndex := 0\n\
    \    romanIndex := number % 1000\n    romanIndex /= 1000\n    return romans[romanIndex]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2x0zince_test.go:23:16: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemtwtw91_test.go:19:1138: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"\
    L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n     \
    \   90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvum7_dxi_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n    \
    \    \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8p57m10m_test.go:31:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7t3rsz8_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := \"\"\n    roman_num := roman_num + int_to_roman(number)\n\
    \    roman_num := roman_num[0:len(roman_num)-1]\n    return roman_num\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz7r1pw0d_test.go:17:15: no new variables on left side of :=

    /tmp/tmpz7r1pw0d_test.go:17:30: undefined: int_to_roman

    /tmp/tmpz7r1pw0d_test.go:18:15: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:   \"I\",\n     \
    \   2:   \"II\",\n        3:   \"III\",\n        4:   \"IV\",\n        5:   \"\
    V\",\n        6:   \"VI\",\n        7:   \"VII\",\n        8:   \"VIII\",\n  \
    \      9:   \"IX\",\n        10:  \"X\",\n        11:  \"XI\",\n        12:  \"\
    XII\",\n        13:  \"XIII\",\n        14:  \"XIV\",\n        15:  \"XV\",\n\
    \        16:  \"XVI\",\n        17:  \"XVII\",\n        18:  \"XVIII\",\n    \
    \    19:  \"XIX\",\n        20:  \"XX\",\n        21:  \"XXI\",\n        22: \
    \ \"XXII\",\n        23:  \"XXIII\",\n        24:  \"XXIV\",\n        25:  \"\
    XXV\",\n        26:  \"XXVI\",\n        27:  \"XXVII\",\n        28:  \"XXVIII\"\
    ,\n        29:  \"XXIX\",\n        30:  \"XXX\",\n        31:  \"XXXI\",\n   \
    \     32:  \"XXXII\",\n        33:  \"XXXIII\",\n        34:  \"XXXIV\",\n   \
    \     35:  \"XXXV\",\n        36:  \"XXXVI\",\n        37:  \"XXXVII\",\n    \
    \    38:  \"XXXVIII\",\n        39:  \"XXXIX\",\n        40:  \"XL\",\n      \
    \  41:  \"L\",\n        42:  \"LX\",\n        43:  \"LXI\",\n        44:  \"LXII\"\
    ,\n        45:  \"LXIII\",\n        46:  \"LXIV\",\n        47:  \"LXV\",\n  \
    \      48:  \"LXVI\",\n        49:  \"LXVII\",\n        50:  \"LXVIII\",\n   \
    \     51:  \"LXIX\",\n        52:  \"LXX\",\n        53:  \"LXXI\",\n        54:\
    \  \"LXXII\",\n        55:  \"LXXIII\",\n        56:  \"LXXIV\",\n        57:\
    \  \"LXXV\",\n        58:  \"LXXVI\",\n        59:  \"LXXVII\",\n        60: \
    \ \"LXXVIII\",\n        61:  \"LXXIX\",\n        62:  \"LXXX\",\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp321p5h48_test.go:80:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"I\",\n\
    \        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\"\
    ,\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\
    \n    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return roman_numerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzh7vyfad_test.go:28:5: roman_numeral declared but not used

    /tmp/tmpzh7vyfad_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n    \
    \    \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp17bbr1mc_test.go:31:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    mini_roman_num\
    \ := []string{\"m\", \"c\", \"d\", \"c\", \"x\", \"l\", \"x\", \"x\", \"i\", \"\
    v\", \"i\", \"i\"}\n    mini_roman_num_len := len(mini_roman_num)\n    roman_num_len\
    \ := len(roman_num)\n\n    mini_roman_num_remainder := number % mini_roman_num_len\n\
    \    number -= mini_roman_num_remainder\n\n    mini_roman_num_remainder_pos :=\
    \ mini_roman_num_len + mini_roman_num_remainder\n    mini_roman_num_remainder_pos\
    \ %= roman_num_len\n    mini_roman_num_remainder_pos %= mini_roman_num_len\n\n\
    \    mini_roman_num_remainder_pos -= roman_num_len\n    mini_roman_num_remainder_pos\
    \ %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos -= mini_roman_num_len\n\
    \    mini_roman_num_remainder_pos %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos\
    \ -= mini_roman_num_len\n    mini_roman_num_remainder_pos %= mini_roman_num_len\n\
    \n    mini_roman_num_remainder_pos -= mini_roman_num_len\n    mini_roman_num_remainder_pos\
    \ %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos -= mini_roman_num_len\n\
    \    mini_roman_num_remainder_pos %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos\
    \ -= mini_roman_num_len\n    mini_roman_num_remainder_pos %= mini_roman_num_len\n\
    \n    mini_roman_num_remainder_pos -= mini_roman_num_len\n    mini_roman_num_remainder_pos\
    \ %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos -= mini_roman_num_len\n\
    \    mini_roman_num_remainder_pos %= mini_roman_num_len\n\n    mini_roman_num_remainder_pos\
    \ -= mini_roman_num_len\n    mini_roman_num_remainder_pos %= mini_roman_num_len\n\
    \n    mini_roman_num_remainder_pos -= mini_roman_num_len\n    mini_roman_num_remainder_pos\
    \ %= mini_roman_\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8em9km7a_test.go:57:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\"\
    , \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"XC\", \"C\", \"CI\", \"CII\"\
    , \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"\
    CXVII\", \"CXVIII\", \"CIX\",\n        \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"\
    CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CIX\",\n        \"CCX\", \"\
    CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"\
    CCXVIII\", \"CCXIX\",\n        \"CCL\", \"L\", \"L\", \"L\", \"L\", \"L\", \"\
    L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"\
    L\", \"L\", \"L\", \"L\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6qoc55xk_test.go:29:116: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    for _, romanIndex := range romans {\n        result += romanIndex\n  \
    \      if number >= romanIndex {\n            number -= romanIndex\n        }\n\
    \    }\n    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphn09q0p9_test.go:23:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmphn09q0p9_test.go:24:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmphn09q0p9_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9hye9kk_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    number -= 1 // We start counting at 1, not 0\n    for _, romanIndex :=\
    \ range romans {\n        result += romans[romanIndex]\n        number %= 100\n\
    \    }\n    return result + romans[len(romans)-1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpze6y9cd6_test.go:23:26: invalid argument: index romanIndex (variable of
    type string) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIIII\",\n        45: \"XLIIV\",\n        46: \"XLIV\"\
    ,\n        47: \"XLIVI\",\n        48: \"XLIVII\",\n        49: \"XLIVIII\",\n\
    \        50: \"XLIIX\",\n        51: \"L\",\n        52: \"LI\",\n        53:\
    \ \"LII\",\n        54: \"LIII\",\n        55: \"LIIII\",\n        56: \"LIIV\"\
    ,\n        57: \"LIV\",\n        58: \"LIVI\",\n        59: \"LIVII\",\n     \
    \   60: \"LIVIII\",\n        61: \"LIIX\",\n        62: \"M\",\n        63: \"\
    MI\",\n        64: \"MII\",\n        65: \"MIII\",\n        66: \"MIIV\",\n  \
    \      67: \"MIV\",\n        68: \"MIVI\",\n        69: \"MIV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmvwwltn4_test.go:85:13: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\"\
    , \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\"\
    , \"XVI\", \"XVII\", \"XVIII\", \"XIX\"}\n    romanIndex := 0\n    romanValue\
    \ := number\n    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n\
    \    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString\
    \ := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\
    \"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\"\n \
    \   romanIndex := 0\n    romanValue := number\n    romanString := \"\"\n    romanIndex\
    \ := 0\n    romanValue := number\n    romanString := \"\"\n    romanIndex := 0\n\
    \    romanValue := number\n    romanString := \"\"\n    romanIndex := 0\n    romanValue\
    \ := number\n    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n\
    \    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString\
    \ := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\
    \"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\"\n \
    \   romanIndex := 0\n    romanValue := number\n    romanString := \"\"\n    romanIndex\
    \ := 0\n    romanValue := number\n    romanString := \"\"\n    romanIndex := 0\n\
    \    romanValue := number\n    romanString := \"\"\n    romanIndex := 0\n    romanValue\
    \ := number\n    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n\
    \    romanString := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString\
    \ := \"\"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\
    \"\n    romanIndex := 0\n    romanValue := number\n    romanString := \"\"\n \
    \   romanIndex := 0\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptzo85izy_test.go:81:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_num := \"\"\n    roman_num := \"M\"\n    if number\
    \ >= 100 {\n        roman_num := \"CM\"\n        number -= 100\n    }\n    if\
    \ number >= 50 {\n        roman_num := roman_num + \"D\"\n        number -= 50\n\
    \    }\n    if number >= 10 {\n        roman_num := roman_num + \"C\"\n      \
    \  number -= 10\n    }\n    if number >= 5 {\n        roman_num := roman_num +\
    \ \"X\"\n        number -= 5\n    }\n    if number >= 1 {\n        roman_num :=\
    \ roman_num + \"L\"\n        number -= 1\n    }\n    if number >= 5 {\n      \
    \  roman_num := roman_num + \"V\"\n        number -= 5\n    }\n    if number >=\
    \ 10 {\n        roman_num := roman_num + \"I\"\n        number -= 10\n    }\n\
    \    if number >= 5 {\n        roman_num := roman_num + \"X\"\n        number\
    \ -= 5\n    }\n    if number >= 1 {\n        roman_num := roman_num + \"I\"\n\
    \        number -= 1\n    }\n    if number >= 1 {\n        roman_num := roman_num\
    \ + \"I\"\n        number -= 1\n    }\n    if number >= 1 {\n        roman_num\
    \ := roman_num + \"I\"\n        number -= 1\n    }\n    if number >= 1 {\n   \
    \     roman_num := roman_num + \"I\"\n        number -= 1\n    }\n    if number\
    \ >= 1 {\n        roman_num := roman_num + \"I\"\n        number -= 1\n    }\n\
    \    if number >= 1 {\n        roman_num := roman_num + \"I\"\n        number\
    \ -= 1\n    }\n    if number >= 1 {\n        roman_num := roman_num + \"I\"\n\
    \        number -= 1\n    }\n    if number >= 1 {\n        roman_num := roman_num\
    \ + \"I\"\n        number -= 1\n    }\n    if number >= 1 {\n        roman_num\
    \ := roman_num + \"I\"\n        number -= 1\n    }\n    if number >= 1 {\n   \
    \     roman_num := roman_num + \"I\"\n        number -= 1\n    }\n    if number\
    \ >= 1 {\n        roman_num := roman_num + \"I\"\n        number -= 1\n    }\n\
    \    if number >= 1 {\n        roman_num := roman_num + \"I\"\n        number\
    \ -= 1\n    }\n    if number >= 1 {\n        \nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzpnnxqlw_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n        roman_num\
    \ = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n        roman_num\
    \ = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case 5:\n        roman_num\
    \ = \"V\"\n    case 6:\n        roman_num = \"VI\"\n    case 7:\n        roman_num\
    \ = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\n    case 9:\n        roman_num\
    \ = \"IX\"\n    case 10:\n        roman_num = \"X\"\n    case 11:\n        roman_num\
    \ = \"XI\"\n    case 12:\n        roman_num = \"XII\"\n    case 13:\n        roman_num\
    \ = \"XIII\"\n    case 14:\n        roman_num = \"XIV\"\n    case 15:\n      \
    \  roman_num = \"XV\"\n    case 16:\n        roman_num = \"XVI\"\n    case 17:\n\
    \        roman_num = \"XVII\"\n    case 18:\n        roman_num = \"XVIII\"\n \
    \   case 19:\n        roman_num = \"XIX\"\n    case 20:\n        roman_num = \"\
    XX\"\n    case 21:\n        roman_num = \"XXI\"\n    case 22:\n        roman_num\
    \ = \"XXII\"\n    case 23:\n        roman_num = \"XXIII\"\n    case 24:\n    \
    \    roman_num = \"XXIV\"\n    case 25:\n        roman_num = \"XXV\"\n    case\
    \ 26:\n        roman_num = \"XXVI\"\n    case 27:\n        roman_num = \"XXVII\"\
    \n    case 28:\n        roman_num = \"XXVIII\"\n    case 29:\n        roman_num\
    \ = \"XXIX\"\n    case 30:\n        roman_num = \"XXX\"\n    case 31:\n      \
    \  roman_num = \"XXXI\"\n    case 32:\n        roman_num = \"XXXII\"\n    case\
    \ 33:\n        roman_num = \"XXXIII\"\n    case 34:\n        roman_num = \"XXXIV\"\
    \n    case 35:\n        roman_num = \"XXXV\"\n    case 36:\n        roman_num\
    \ = \"XXXVI\"\n    case 37:\n        roman_num = \"XXXVII\"\n    case 38:\n  \
    \      roman_num = \"XXXVIII\"\n    case 39:\n        roman_num = \"XXXIX\"\n\
    \    case 40:\n        roman_num = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptvr6zmos_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n\n    roman_number := number /\
    \ 100\n    roman_number %= 100\n\n    return roman_numerals[roman_number]\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpa6d423zi_test.go:58: expected\
    \ 'clii', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpa6d423zi_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpa6d423zi_test.go:58:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpa6d423zi_test.go:58: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpa6d423zi_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpa6d423zi_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpa6d423zi_test.go:58:\
    \ expected 'dxxxii', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpa6d423zi_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpa6d423zi_test.go:58: expected 'm', got 'X'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIV\",\n        45: \"XLV\",\n        46: \"XLVI\",\n\
    \        47: \"XLVII\",\n        48: \"XLVIII\",\n        49: \"XLIX\",\n    \
    \    50: \"L\",\n        51: \"LI\",\n        52: \"LII\",\n        53: \"LIII\"\
    ,\n        54: \"LIV\",\n        55: \"LV\",\n        56: \"LVI\",\n        57:\
    \ \"LVII\",\n        58: \"LVIII\",\n        59: \"LIX\",\n        60: \"M\",\n\
    \        61: \"MI\",\n        62: \"MII\",\n        63: \"MIII\",\n        64:\
    \ \"MIIX\",\n        65: \"M\",\n        66: \"MI\",\n        67: \"MII\",\n \
    \       68: \"MIII\",\n        69: \"MIIX\",\n        70: \"MM\",\n        71:\
    \ \"MMM\",\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp49f2x0v9_test.go:89:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        2:\
    \ \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n      \
    \  6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\",\n\
    \        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13: \"\
    XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n   \
    \     17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n        20:\
    \ \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIV\",\n        45: \"XLV\",\n        46: \"XLVI\",\n\
    \        47: \"XLVII\",\n        48: \"XLVIII\",\n        49: \"XLIX\",\n    \
    \    50: \"L\",\n        51: \"LI\",\n        52: \"LII\",\n        53: \"LIII\"\
    ,\n        54: \"LIV\",\n        55: \"LV\",\n        56: \"LVI\",\n        57:\
    \ \"LVII\",\n        58: \"LVIII\",\n        59: \"LIX\",\n        60: \"M\",\n\
    \        61: \"MI\",\n        62: \"MII\",\n        63: \"MIII\",\n        64:\
    \ \"MIIV\",\n        65: \"MIV\",\n        66: \"MIVI\",\n        67: \"MIVII\"\
    ,\n        68: \"MIVIII\",\n        69: \"MIIX\",\n        70: \"MM\",\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpildhvi2i_test.go:88:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qsernqt_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n    }\n    roman_number := 0\n\
    \    for i := 0; i < len(romans); i++ {\n        if number >= romans[i] {\n  \
    \          roman_number += romans[i].Length()\n            number -= romans[i]\n\
    \        }\n    }\n    return string(romans[roman_number])\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfxd04a_h_test.go:24:22: invalid operation: number >= romans[i] (mismatched
    types int and string)

    /tmp/tmpfxd04a_h_test.go:25:39: romans[i].Length undefined (type string has no
    field or method Length)

    /tmp/tmpfxd04a_h_test.go:26:13: invalid operation: number -= romans[i] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_num := roman_num[:len(roman_num)-number%len(roman_num)]\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(roman_num, roman_num...)\n    roman_num\
    \ := append(roman_num, roman_num...)\n    roman_num := append(roman_num, roman_num...)\n\
    \    roman_num := append(roman_num, roman_num...)\n    roman_num := append(roman_num,\
    \ roman_num...)\n    roman_num := append(\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqbcxtuky_test.go:51:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_number\
    \ := roman_number[:number%100]\n    number /= 100\n    roman_number := append(roman_number,\
    \ roman_number[:number%10]...)\n    number /= 10\n    roman_number := append(roman_number,\
    \ roman_number[:number]...)\n    return string(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbuu7oy6_test.go:17:18: no new variables on left side of :=

    /tmp/tmphbuu7oy6_test.go:19:18: no new variables on left side of :=

    /tmp/tmphbuu7oy6_test.go:21:18: no new variables on left side of :=

    /tmp/tmphbuu7oy6_test.go:22:19: cannot convert roman_number (variable of type
    []string) to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 {\n        return \"\"\n    }\n    if number < 1000\
    \ {\n        return fmt.Sprintf(\"%c\", number)\n    }\n    number -= 1000\n \
    \   if number < 900 {\n        return fmt.Sprintf(\"%c%c\", number/100, number%100)\n\
    \    }\n    number -= 900\n    if number < 500 {\n        return fmt.Sprintf(\"\
    %c%c%c\", number/1000, number%1000, number/100)\n    }\n    number -= 500\n  \
    \  if number < 400 {\n        return fmt.Sprintf(\"%c%c%c%c\", number/1000, number%1000,\
    \ number/100, number%100)\n    }\n    number -= 400\n    if number < 100 {\n \
    \       return fmt.Sprintf(\"%c%c%c%c%c\", number/1000, number%1000, number/100,\
    \ number%100, number/10)\n    }\n    number -= 100\n    if number < 50 {\n   \
    \     return fmt.Sprintf(\"%c%c%c%c%c%c\", number/1000, number%1000, number/100,\
    \ number%100, number/10, number%10)\n    }\n    number -= 50\n    if number <\
    \ 10 {\n        return fmt.Sprintf(\"%c%c%c%c%c%c%c\", number/1000, number%1000,\
    \ number/100, number%100, number/10, number%10, number%1)\n    }\n    number -=\
    \ 10\n    return fmt.Sprintf(\"%c%c%c%c%c%c%c%c\", number/1000, number%1000, number/100,\
    \ number%100, number/10, number%10, number%1, number%0)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kk_qa36_test.go:47:133: invalid operation: division by zero

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_num := \"\"\n    switch number {\n    case 1:\n \
    \       roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_hhitgf1_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:   \"I\",\n      \
    \  2:   \"II\",\n        3:   \"III\",\n        4:   \"IV\",\n        5:   \"\
    V\",\n        6:   \"VI\",\n        7:   \"VII\",\n        8:   \"VIII\",\n  \
    \      9:   \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\"\
    ,\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16:\
    \ \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\"\
    ,\n        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50:\
    \ \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n \
    \       90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    romanNumerals\
    \ := map[int]string{\n        1:   \"I\",\n        2:   \"II\",\n        3:  \
    \ \"III\",\n        4:   \"IV\",\n        5:   \"V\",\n        6:   \"VI\",\n\
    \        7:   \"VII\",\n        8:   \"VIII\",\n        9:   \"IX\",\n       \
    \ 10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13: \"XIII\"\
    ,\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n        17:\
    \ \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n        20: \"XX\"\
    ,\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"L\",\n        60:\
    \ \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n        90: \"XC\",\n\
    \        100: \"C\",\n        1000: \"C\",\n    }\n    romanNumerals := map[int]string{\n\
    \        1:   \"I\",\n        2:   \"II\",\n        3:   \"III\",\n        4:\
    \   \"IV\",\n        5:   \"V\",\n        6:   \"VI\",\n        7:   \"VII\",\n\
    \        8:   \"VIII\",\n        9:   \"IX\",\n        10: \"X\",\n        11:\
    \ \"XI\",\n        12: \"XII\",\n        13\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps4_zbnqz_test.go:91:11: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n    result := \"\"\n    for _, romanNum := range romans {\n        if\
    \ number >= romanNum {\n            result += romans[romanNum]\n            number\
    \ -= romanNum\n        }\n    }\n    if number > 0 {\n        result += romans[number]\n\
    \    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2q50tp_h_test.go:21:9: duplicate key 100 in map literal

    /tmp/tmp2q50tp_h_test.go:33:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmp2q50tp_h_test.go:34:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmp2q50tp_h_test.go:35:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7wnehwp3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n    for\
    \ romanNumeral, numeral := range romanNumerals {\n        if number >= romanNumerals[numeral]\
    \ {\n            break\n        }\n    }\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu_r92pi6_test.go:26:9: romanNumeral declared but not used

    /tmp/tmpu_r92pi6_test.go:27:22: invalid operation: number >= romanNumerals[numeral]
    (mismatched types int and string)

    /tmp/tmpu_r92pi6_test.go:27:36: cannot use numeral (variable of type string) as
    type int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"i\",\n      \
    \  5:  \"ii\",\n        10: \"iii\",\n        50: \"iv\",\n        100: \"v\"\
    ,\n        500: \"vi\",\n        1000: \"vii\",\n        5000: \"viii\",\n   \
    \     10000: \"ix\",\n        50000: \"x\",\n        100000: \"xi\",\n       \
    \ 500000: \"xii\",\n        1000000: \"xiii\",\n        5000000: \"xiv\",\n  \
    \      10000000: \"xv\",\n        50000000: \"xv\",\n        100000000: \"xv\"\
    ,\n        500000000: \"xv\",\n        1000000000: \"xv\",\n        5000000000:\
    \ \"xv\",\n        10000000000: \"xv\",\n        50000000000: \"xv\",\n      \
    \  100000000000: \"xv\",\n        500000000000: \"xv\",\n        1000000000000:\
    \ \"xv\",\n        5000000000000: \"xv\",\n        10000000000000: \"xv\",\n \
    \       50000000000000: \"xv\",\n        100000000000000: \"xv\",\n        500000000000000:\
    \ \"xv\",\n        1000000000000000: \"xv\",\n        5000000000000000: \"xv\"\
    ,\n        1000000000000000000: \"xv\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyavfopdk_test.go:52:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    i := 0\n    for ; i < len(romans); i++ {\n        if number >= romans[i]\
    \ {\n            result += romans[i]\n            number -= romans[i]\n      \
    \  }\n    }\n    if number > 0 {\n        result += romans[i]\n    }\n    return\
    \ result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpailbp4gw_test.go:23:22: invalid operation: number >= romans[i] (mismatched
    types int and string)

    /tmp/tmpailbp4gw_test.go:25:13: invalid operation: number -= romans[i] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXI\",\n        40: \"XXII\",\n        50:\
    \ \"XXIII\",\n        60: \"XXIV\",\n        70: \"XXV\",\n        80: \"XXVI\"\
    ,\n        90: \"XXVII\",\n        100: \"XXVIII\",\n        1000: \"XXIX\",\n\
    \    }\n\n    roman_numeral := \"\"\n    for key, value := range roman_numerals\
    \ {\n        if number >= key {\n            roman_numeral += value\n        \
    \    number -= key\n        }\n    }\n\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5y1evcgp_test.go:56:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"LX\"\
    , \"L\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"\
    CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9lvxtuz6_test.go:19:1123: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qsernqt_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n\n    roman_number := roman_numerals[number]\n\
    \    if number < 1000 {\n        return roman_number\n    }\n\n    roman_number\
    \ += string(number % 10)\n    number /= 10\n\n    for number > 0 {\n        roman_number\
    \ += string(number % 10)\n        number /= 10\n    }\n\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp4_p2mked_test.go:31:21: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    /tmp/tmp4_p2mked_test.go:35:25: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\"\n\
    \    roman_num := roman_num[:number%100]\n    number /= 100\n    for _, r := range\
    \ roman_num {\n        if number >= 100 {\n            result += r\n         \
    \   number -= 100\n        } else {\n            result += r + strconv.Itoa(number)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp08bc7cte_test.go:18:15: no new variables on left side of :=

    /tmp/tmp08bc7cte_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XL\",\n        40: \"L\",\n        50: \"\
    M\",\n        60: \"M\",\n        70: \"MM\",\n        80: \"MMM\",\n        90:\
    \ \"MMMM\",\n        100: \"MMMM\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9yxos3pj_test.go:47:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if !ok\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp6uwjepcf_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp6uwjepcf_test.go:58: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp6uwjepcf_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n    \
    \    \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lu1acz__test.go:31:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CXL\"\
    , \"CL\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\",\n        \"LVI\"\
    , \"LVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp96kex9y7_test.go:31:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n    for\
    \ romanNumeral, number := range romanNumerals {\n        if number <= number {\n\
    \            break\n        }\n    }\n    if romanNumeral == \"\" {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7hi47r5__test.go:26:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIIII\",\n        45: \"XLIIV\",\n        46: \"XLIV\"\
    ,\n        47: \"XLIVI\",\n        48: \"XLIVII\",\n        49: \"XLIVIII\",\n\
    \        50: \"XLIIX\",\n        51: \"L\",\n        52: \"LI\",\n        53:\
    \ \"LII\",\n        54: \"LIII\",\n        55: \"LIIII\",\n        56: \"LIIV\"\
    ,\n        57: \"LIV\",\n        58: \"LIVI\",\n        59: \"LIVII\",\n     \
    \   60: \"LIVIII\",\n        61: \"LIIX\",\n        62: \"M\",\n        63: \"\
    MI\",\n        64: \"MII\",\n        65: \"MIII\",\n        66: \"MIIV\",\n  \
    \      67: \"MIV\",\n        68: \"MIVI\",\n        69: \"MIV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmvwwltn4_test.go:85:13: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n    \
    \    \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdmtz26vh_test.go:31:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyp_tjsf5_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        30: \"XL\",\n        40: \"L\",\n        50: \"M\",\n \
    \       60: \"M\",\n        70: \"MM\",\n        80: \"MMM\",\n        90: \"\
    MMMM\",\n        100: \"MMMM\",\n    }\n\n    roman_numeral_string := \"\"\n \
    \   for roman_numeral, mini_roman := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            roman_numeral_string += mini_roman\n       \
    \     number -= roman_numeral\n        }\n    }\n\n    return roman_numeral_string\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpz6mazolz_test.go:84: expected 'xix', got 'XVIIII'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'clii', got 'XVIIMMMMXVIVIVIIIIIIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpz6mazolz_test.go:84: expected 'ccli', got 'IIXIIIXIXVIIXIXVIMMMMMMIVVIIII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'cdxxvi', got 'XIXXIVXVIXXMMMMMMMXVXVIIXIIIVIIVIIILMVXIIIIIIIIV'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'd', got 'MIIIVIIIXIIXIXMVXIXIIIXIVXVIIIXXVIIIMMMMMMIVIXVXXIVIIXXLVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpz6mazolz_test.go:84: expected 'iv', got 'III'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpz6mazolz_test.go:84: expected 'xliii', got 'VIXIIXIVVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'xc', got 'IIIXVIIXVIIIXIIXVVIIXIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpz6mazolz_test.go:84: expected 'xciv', got 'VXIIIIIIXXIXIIXVVIIXIXI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'dxxxii', got 'XMMMMIIIXVXVIIXXLXVIXIVXVIIIXLMMMMMIVXIXIIIIVIMIVVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'cm', got 'VXIVMXVXLMIVVIIXXIIXIIXXXIXMMMMIIIXVIXVIIIVIIXMMMLMMMMMMIIVIIIXIIIXVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'cmxciv', got 'IIIXIIXIIIXVIXIXIVXVMMMMIXVIIXVIIIXXMMMMMMIIVIIVIIIXIXIVLVIMMMMIXXVXLM'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpz6mazolz_test.go:84:\
    \ expected 'm', got 'IIVIIIIIIIVXIXLVIXIIIMMMX"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n    for\
    \ romanNumeral, numeral := range romanNumerals {\n        if number >= romanNumerals[numeral]\
    \ {\n            break\n        }\n    }\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu_r92pi6_test.go:26:9: romanNumeral declared but not used

    /tmp/tmpu_r92pi6_test.go:27:22: invalid operation: number >= romanNumerals[numeral]
    (mismatched types int and string)

    /tmp/tmpu_r92pi6_test.go:27:36: cannot use numeral (variable of type string) as
    type int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"I\",\n\
    \        2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\"\
    ,\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"\
    IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n       \
    \ 13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\"\
    ,\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n     \
    \   20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIIII\",\n        45: \"XLIIV\",\n        46: \"XLIV\"\
    ,\n        47: \"XLIVI\",\n        48: \"XLIVII\",\n        49: \"XLIVIII\",\n\
    \        50: \"XLIIX\",\n        51: \"L\",\n        52: \"LI\",\n        53:\
    \ \"LII\",\n        54: \"LIII\",\n        55: \"LIIII\",\n        56: \"LIIV\"\
    ,\n        57: \"LIV\",\n        58: \"LIVI\",\n        59: \"LIVII\",\n     \
    \   60: \"LIVIII\",\n        61: \"LIIX\",\n        62: \"M\",\n        63: \"\
    MI\",\n        64: \"MII\",\n        65: \"MIII\",\n        66: \"MIIV\",\n  \
    \      \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz4lv578z_test.go:87:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"\
    LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"LXII\", \"LXIII\"\
    , \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"\
    CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CVIV\"\
    , \"CVV\", \"CVVI\", \"CVVII\", \"CVVIII\", \"CVIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"CXIII\", \"CXIV\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"\
    CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"\
    CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\"\
    , \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIIII\",\
    \ \"LIIIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LVIIII\", \"LVIIIII\"\
    , \"LVIV\", \"LVV\", \"LVVI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzzhzq8z9_test.go:17:1138: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9hye9kk_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n\n    roman, ok := romans[number]\n    if !ok\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n\n    return roman\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp9rdrer0n_test.go:60: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp9rdrer0n_test.go:60: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp9rdrer0n_test.go:60:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp9rdrer0n_test.go:60: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp9rdrer0n_test.go:60: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp9rdrer0n_test.go:60: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp9rdrer0n_test.go:60:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp9rdrer0n_test.go:60:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp9rdrer0n_test.go:60: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\"\
    , \"VII\", \"VIII\", \"IX\"}\n    result := \"\"\n    for _, romanIndex := range\
    \ romans {\n        result += \"M\"\n        if number >= romanIndex {\n     \
    \       number -= romanIndex\n            result += romans[romanIndex]\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ae4mit0_test.go:20:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmp9ae4mit0_test.go:21:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmp9ae4mit0_test.go:22:30: invalid argument: index romanIndex (variable of
    type string) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n    }\n    result := \"\"\n    for _,\
    \ romanIndex := range romans {\n        result += \"M\"\n        if number >=\
    \ romanIndex {\n            number -= romanIndex\n            result += romans[romanIndex]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaee7k7su_test.go:22:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpaee7k7su_test.go:23:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmpaee7k7su_test.go:24:30: invalid argument: index romanIndex (variable of
    type string) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if !ok\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp6uwjepcf_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp6uwjepcf_test.go:58: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp6uwjepcf_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n    \
    \    \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdmtz26vh_test.go:31:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"L\",\n\
    \        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n        90:\
    \ \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    roman_number\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_number)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8knbfyey_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    mini_roman_numerals :=\
    \ map[string]int{\n        \"I\":  1,\n        \"V\":  5,\n        \"X\":  10,\n\
    \        \"L\":  50,\n        \"C\":  100,\n        \"D\":  500,\n        \"M\"\
    :  1000,\n    }\n    roman_number := roman_numerals[number]\n    mini_roman_number\
    \ := mini_roman_numerals[roman_number]\n    return string(mini_roman_numerals[number])\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo4v4vuoz_test.go:35:5: mini_roman_number declared but not used

    /tmp/tmpo4v4vuoz_test.go:36:39: cannot use number (variable of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9hye9kk_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIIII\",\n        45: \"XLIIV\",\n        46: \"XLIV\"\
    ,\n        47: \"XLIVI\",\n        48: \"XLIVII\",\n        49: \"XLIVIII\",\n\
    \        50: \"XLIIX\",\n        51: \"L\",\n        52: \"LI\",\n        53:\
    \ \"LII\",\n        54: \"LIII\",\n        55: \"LIIII\",\n        56: \"LIIV\"\
    ,\n        57: \"LIV\",\n        58: \"LIVI\",\n        59: \"LIVII\",\n     \
    \   60: \"LIVIII\",\n        61: \"LIIX\",\n        62: \"LX\",\n        63: \"\
    LXI\",\n        64: \"LXII\",\n        65: \"LXIII\",\n        66: \"LXIV\",\n\
    \        67: \"LXV\",\n        68: \"LXV\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_gc7oytr_test.go:84:13: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    index := 0\n    for number > 0 {\n        result += romans[index]\n  \
    \      number -= (number % 10)\n        index++\n    }\n    return result\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out\
    \ of range [13] with length 13 [recovered]\n\tpanic: runtime error: index out\
    \ of range [13] with length 13\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc0001d6030})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc0001d6030})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.int_to_mini_roman(0xc0001d24a0?)\n\t/tmp/tmpadjudaql_test.go:23\
    \ +0x29a\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0x0?)\n\t/tmp/tmpadjudaql_test.go:37\
    \ +0x46\ntesting.tRunner(0xc000199040, 0x528fb0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIV\",\n        45: \"XLV\",\n        46: \"XLVI\",\n\
    \        47: \"XLVII\",\n        48: \"XLVIII\",\n        49: \"XLIX\",\n    \
    \    50: \"L\",\n        51: \"LI\",\n        52: \"LII\",\n        53: \"LIII\"\
    ,\n        54: \"LIV\",\n        55: \"LV\",\n        56: \"LVI\",\n        57:\
    \ \"LVII\",\n        58: \"LVIII\",\n        59: \"LIX\",\n        60: \"M\",\n\
    \        61: \"MI\",\n        62: \"MII\",\n        63: \"MIII\",\n        64:\
    \ \"MIV\",\n        65: \"MV\",\n        66: \"MVI\",\n        67: \"MVII\",\n\
    \        68: \"MVIII\",\n        69: \"MIX\",\n        70: \"MM\",\n        71:\
    \ \"MMM\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbl1dsskl_test.go:87:13: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    return roman_number[0:len(roman_number)-1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn7wodks0_test.go:17:21: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"I\",\n        5:  \"\
    V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n        500:\
    \ \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if\
    \ !ok {\n        fmt.Println(\"Invalid input:\", number)\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input: 19\nInvalid input: 152\nInvalid input: 251\nInvalid input:\
    \ 426\nInvalid input: 4\nInvalid input: 43\nInvalid input: 90\nInvalid input:\
    \ 94\nInvalid input: 532\nInvalid input: 900\nInvalid input: 994\n--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpfm54hjf__test.go:58:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpfm54hjf__test.go:58: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpfm54hjf__test.go:58: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpfm54hjf__test.go:58: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpfm54hjf__test.go:58: expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5\
    \ (0.00s)\n        tmpfm54hjf__test.go:58: expected 'i', got 'I'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpfm54hjf__test.go:58: expected\
    \ 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n    \
    \    tmpfm54hjf__test.go:58: expected 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpfm54hjf__test.go:58: expected 'xc', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpfm54hjf__test.go:58: expected\
    \ 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n \
    \       tmpfm54hjf__test.go:58: expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpfm54hjf__test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpfm54hjf__test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpfm54hjf__test.go:58: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkoyguox3_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input:\", number)\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtu6ui9w_test.go:21:9: duplicate key 100 in map literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"i\",\n      \
    \  5:  \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"ix\"\
    ,\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    roman_numeral :=\
    \ roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2s0hzxqb_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"I\",\n        5:  \"\
    V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n        500:\
    \ \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if\
    \ !ok {\n        fmt.Println(\"int_to_mini_roman: number too large\")\n      \
    \  return \"\"\n    }\n    return strings.ToLower(roman)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4agqdxwc_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7t3rsz8_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsInverse := map[string]int{\n\
    \        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n\
    \        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    romanNumeral\
    \ := \"\"\n    for romanNumeral, number := range romanNumerals {\n        if number\
    \ >= number {\n            break\n        }\n    }\n    if romanNumeral == \"\"\
    \ {\n        fmt.Println(\"Roman numeral not found\")\n    }\n    romanNumeralInverse\
    \ := \"\"\n    for romanNumeralInverse, number := range romanNumeralsInverse {\n\
    \        if number >= number {\n            break\n        }\n    }\n    if romanNumeralInverse\
    \ == \"\" {\n        fmt.Println(\"Roman numeral inverse not found\")\n    }\n\
    \    romanNumeralInverse += romanNumeral\n    romanNumeralInverse += romanNumerals[number]\n\
    \    return romanNumeralInverse\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppbam9hbz_test.go:35:9: romanNumeral declared but not used

    /tmp/tmppbam9hbz_test.go:44:9: romanNumeralInverse declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"I\",\n        5:  \"\
    V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500:\
    \ \"D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for roman_number,\
    \ number >= 1000 {\n        roman_number += romans[number%1000]\n        number\
    \ /= 1000\n    }\n    roman_number += romans[number]\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3bhvwtu_test.go:26:9: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"int_to_mini_roman:\
    \ number must be between 1 and 1000\")\n    }\n    roman_num := \"\"\n    roman_num\
    \ := roman_num + int_to_roman(number)\n    return strings.ToLower(roman_num)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptd0v5kjb_test.go:20:15: no new variables on left side of :=

    /tmp/tmptd0v5kjb_test.go:20:30: undefined: int_to_roman

    /tmp/tmptd0v5kjb_test.go:21:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for roman_number,\
    \ number := range romans {\n        if number <= number {\n            break\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s%s\", romans[number], number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpry3qx7ld_test.go:25:5: roman_number declared but not used

    /tmp/tmpry3qx7ld_test.go:26:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := []string{\"I\", \"II\", \"III\", \"IV\", \"V\"\
    , \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIIII\"\
    , \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LI\", \"LI\"\
    , \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\"\
    , \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\", \"LI\"\
    , \"LI\", \"LI\", \"LI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiocdjcf1_test.go:16:1201: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CX\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdt3p8h83_test.go:17:1149: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for roman_number,\
    \ number := range romans {\n        if number >= number {\n            break\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s%s\", romans[number], number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8i38kl4_test.go:25:5: roman_number declared but not used

    /tmp/tmpi8i38kl4_test.go:26:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    result := \"\"\n    for num, _ := range\
    \ romans {\n        if number >= num {\n            result += romans[num]\n  \
    \          number -= num\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbh_7t3tb_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n        roman_num\
    \ = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n        roman_num\
    \ = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case 5:\n        roman_num\
    \ = \"V\"\n    case 6:\n        roman_num = \"VI\"\n    case 7:\n        roman_num\
    \ = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\n    case 9:\n        roman_num\
    \ = \"IX\"\n    case 10:\n        roman_num = \"X\"\n    case 11:\n        roman_num\
    \ = \"XI\"\n    case 12:\n        roman_num = \"XII\"\n    case 13:\n        roman_num\
    \ = \"XIII\"\n    case 14:\n        roman_num = \"XIV\"\n    case 15:\n      \
    \  roman_num = \"XV\"\n    case 16:\n        roman_num = \"XVI\"\n    case 17:\n\
    \        roman_num = \"XVII\"\n    case 18:\n        roman_num = \"XVIII\"\n \
    \   case 19:\n        roman_num = \"XIX\"\n    case 20:\n        roman_num = \"\
    XX\"\n    case 21:\n        roman_num = \"XXI\"\n    case 22:\n        roman_num\
    \ = \"XXII\"\n    case 23:\n        roman_num = \"XXIII\"\n    case 24:\n    \
    \    roman_num = \"XXIV\"\n    case 25:\n        roman_num = \"XXV\"\n    case\
    \ 26:\n        roman_num = \"XXVI\"\n    case 27:\n        roman_num = \"XXVII\"\
    \n    case 28:\n        roman_num = \"XXVIII\"\n    case 29:\n        roman_num\
    \ = \"XXIX\"\n    case 30:\n        roman_num = \"XXX\"\n    case 31:\n      \
    \  roman_num = \"XXXI\"\n    case 32:\n        roman_num = \"XXXII\"\n    case\
    \ 33:\n        roman_num = \"XXXIII\"\n    case 34:\n        roman_num = \"XXXIV\"\
    \n    case 35:\n        roman_num = \"XXXV\"\n    case 36:\n        roman_num\
    \ = \"XXXVI\"\n    case 37:\n        roman_num = \"XXXVII\"\n    case 38:\n  \
    \      roman_num = \"XXXVIII\"\n    case 39:\n        roman_num = \"XXXIX\"\n\
    \    case 40:\n        roman_num = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptvr6zmos_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\",\n        \"CVII\",\
    \ \"CVIII\", \"C\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvazyx9ha_test.go:31:26: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for roman_number,\
    \ number < 1000, number += 1000 {\n        if number >= 1000 {\n            roman_number\
    \ += romans[number / 1000]\n            number %= 1000\n        }\n        roman_number\
    \ += romans[number]\n    }\n    return strings.ToLower(roman_number)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp32zpisi7_test.go:26:9: expected boolean or range expression, found assignment
    (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXI\",\n        40: \"XXII\",\n        50:\
    \ \"XXIII\",\n        60: \"XXIV\",\n        70: \"XXV\",\n        80: \"XXVI\"\
    ,\n        90: \"XXVII\",\n        100: \"XXVIII\",\n        1000: \"XXIX\",\n\
    \    }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps8cal_u8_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumerals := map[int]string{\n\
    \        1:  \"I\",\n        5:  \"V\",\n        10: \"X\",\n        50: \"L\"\
    ,\n        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n   \
    \ romanNumerals := map[int]string{\n        1:  \"I\",\n        5:  \"V\",\n \
    \       10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"D\"\
    ,\n        1000: \"M\",\n    }\n    romanNumerals := map[int]string{\n       \
    \ 1:  \"I\",\n        5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n   \
    \     100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumerals\
    \ := map[int]string{\n        1:  \"I\",\n        5:  \"V\",\n        10: \"X\"\
    ,\n        50: \"L\",\n        100: \"C\",\n        500: \"D\",\n        1000:\
    \ \"M\",\n    }\n    romanNumerals := map[int]string{\n        1:  \"I\",\n  \
    \      5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\"\
    ,\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumerals := map[int]string{\n\
    \        1:  \"I\",\n        5:  \"V\",\n        10: \"X\",\n        50: \"L\"\
    ,\n        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n   \
    \ romanNumerals := map[int]string{\n        1:  \"I\",\n        5:  \"V\",\n \
    \       10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"D\"\
    ,\n        1000: \"M\",\n    }\n    romanNumerals := map[int]string{\n       \
    \ 1:  \"I\",\n        5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n   \
    \     100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumerals\
    \ := map[int]string{\n        1:  \"I\",\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi1rtwo_8_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return \"\"\n    }\n    romans := []string{\n        \"I\"\
    , \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"\
    XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\"\
    , \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\"\
    ,\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\"\
    , \"LVI\", \"LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"\
    LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"\
    LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\"\
    , \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n\
    \        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\"\
    , \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\"\
    , \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2jlbybki_test.go:34:52: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n    roman_number := \"\"\n    for _, roman_rep := range romans {\n   \
    \     if number >= roman_rep {\n            roman_number = roman_rep\n       \
    \     break\n        }\n    }\n    return strings.ToLower(roman_number)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_czdqcfp_test.go:21:9: duplicate key 100 in map literal

    /tmp/tmp_czdqcfp_test.go:33:22: invalid operation: number >= roman_rep (mismatched
    types int and string)

    /tmp/tmp_czdqcfp_test.go:38:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if !ok\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp6uwjepcf_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp6uwjepcf_test.go:58: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp6uwjepcf_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp6uwjepcf_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp6uwjepcf_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp6uwjepcf_test.go:58: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"\
    L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n     \
    \   90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\n    roman_number\
    \ := 0\n    for number > 0 {\n        roman_number += number % 10\n        number\
    \ /= 10\n    }\n\n    return roman_numerals[roman_number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'xix', got 'X'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp9ikhb61d_test.go:83: expected\
    \ 'clii', got 'VIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmp9ikhb61d_test.go:83: expected 'ccli', got 'VIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'cdxxvi', got 'XII'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp9ikhb61d_test.go:83:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp9ikhb61d_test.go:83: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'iv', got 'IV'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp9ikhb61d_test.go:83: expected\
    \ 'xliii', got 'VII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmp9ikhb61d_test.go:83: expected 'xc', got 'IX'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'xciv', got 'XIII'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp9ikhb61d_test.go:83:\
    \ expected 'dxxxii', got 'X'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'cm', got 'IX'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp9ikhb61d_test.go:83:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp9ikhb61d_test.go:83: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"i\",\n      \
    \  5:  \"ii\",\n        10: \"iii\",\n        50: \"iv\",\n        100: \"v\"\
    ,\n        500: \"vi\",\n        1000: \"vii\",\n    }\n    mini_roman_numerals\
    \ := map[string]int{\n        \"i\":  1,\n        \"ii\": 2,\n        \"iii\"\
    : 3,\n        \"iv\": 4,\n        \"v\": 5,\n        \"vi\": 6,\n        \"vii\"\
    : 7,\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    i\": \"i\",\n        \"ii\": \"ii\",\n        \"iii\": \"iii\",\n        \"iv\"\
    : \"iv\",\n        \"v\": \"v\",\n        \"vi\": \"vi\",\n        \"vii\": \"\
    vii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n        \"\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpptt1oaz__test.go:89:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n\n    romanNumeral := \"\"\n    for\
    \ romanNumeral, number := range romanNumerals {\n        if number >= number {\n\
    \            break\n        }\n    }\n\n    if romanNumeral == \"\" {\n      \
    \  fmt.Println(\"Error: No roman numeral for number\", number)\n    }\n\n    return\
    \ romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4q_c3onm_test.go:27:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n\n    if number < 1 {\n     \
    \   return fmt.Sprintf(\"%v\", number)\n    }\n\n    if number == 1 {\n      \
    \  return roman_numeral\n    }\n\n    roman_numerals = roman_numerals[:number]\n\
    \    roman_numerals = append(roman_numerals, roman_numerals[number-1])\n\n   \
    \ return strings.Join(roman_numerals, \"\")\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptb4gdw8j_test.go:27:9: roman_numeral declared but not used

    /tmp/tmptb4gdw8j_test.go:41:22: invalid operation: cannot slice roman_numerals
    (variable of type map[int]string)

    /tmp/tmptb4gdw8j_test.go:42:29: first argument to append must be a slice; have
    roman_numerals (variable of type map[int]string)

    /tmp/tmptb4gdw8j_test.go:44:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7t3rsz8_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyp_tjsf5_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXI\",\n        40: \"XXII\",\n        50:\
    \ \"XXIII\",\n        60: \"XXIV\",\n        70: \"XXV\",\n        80: \"XXVI\"\
    ,\n        90: \"XXVII\",\n        100: \"XXVIII\",\n        1000: \"XXIX\",\n\
    \    }\n    return roman_numerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'xix', got 'XIX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgf_k4dzc_test.go:76:\
    \ expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmpgf_k4dzc_test.go:76: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgf_k4dzc_test.go:76:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpgf_k4dzc_test.go:76: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'iv', got 'IV'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgf_k4dzc_test.go:76: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpgf_k4dzc_test.go:76: expected 'xc', got 'XXVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgf_k4dzc_test.go:76:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgf_k4dzc_test.go:76:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpgf_k4dzc_test.go:76: expected 'm', got 'XXIX'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIIII\",\n        45: \"XLIIV\",\n        46: \"XLIV\"\
    ,\n        47: \"XLIVI\",\n        48: \"XLIVII\",\n        49: \"XLIVIII\",\n\
    \        50: \"XLIIX\",\n        51: \"L\",\n        52: \"LI\",\n        53:\
    \ \"LII\",\n        54: \"LIII\",\n        55: \"LIIII\",\n        56: \"LIIV\"\
    ,\n        57: \"LIV\",\n        58: \"LIVI\",\n        59: \"LIVII\",\n     \
    \   60: \"LIVIII\",\n        61: \"LIIX\",\n        62: \"M\",\n        63: \"\
    MI\",\n        64: \"MII\",\n        65: \"MIII\",\n        66: \"MIIV\",\n  \
    \      67: \"MIV\",\n        68: \"MIVI\",\n        69: \"MIV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmvwwltn4_test.go:85:13: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"int_to_mini_roman:\
    \ Invalid input\")\n        return \"\"\n    }\n\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\
    \n    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number >= number {\n            break\n        }\n    }\n\n  \
    \  return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphocq5tp7_test.go:54:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"\
    LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"LXII\", \"LXIII\"\
    , \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"\
    CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\"\
    , \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \"\
    CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\",\
    \ \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\"\
    , \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \"\
    CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXX\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv8uo32i__test.go:17:1147: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_num := \"\"\n    switch number {\n    case 1:\n \
    \       roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_hhitgf1_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:   \"I\",\n     \
    \   5:   \"V\",\n        10:  \"X\",\n        50:  \"L\",\n        100:  \"C\"\
    ,\n        500:  \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpznlz9l3t_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7t3rsz8_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n    }\n    romans := romans[:number]\n    romans := append(romans,\
    \ \"I\")\n    romans := append(romans, \"II\")\n    romans := append(romans, \"\
    III\")\n    romans := append(romans, \"IV\")\n    romans := append(romans, \"\
    V\")\n    romans := append(romans, \"VI\")\n    romans := append(romans, \"VII\"\
    )\n    romans := append(romans, \"VIII\")\n    romans := append(romans, \"IX\"\
    )\n    romans := append(romans, \"X\")\n    romans := append(romans, \"XI\")\n\
    \    romans := append(romans, \"XII\")\n    romans := append(romans, \"XIII\"\
    )\n    romans := append(romans, \"XIV\")\n    romans := append(romans, \"XV\"\
    )\n    romans := append(romans, \"XVI\")\n    romans := append(romans, \"XVII\"\
    )\n    romans := append(romans, \"XVIII\")\n    romans := append(romans, \"XIX\"\
    )\n    romans := append(romans, \"XX\")\n    romans := append(romans, \"XXI\"\
    )\n    romans := append(romans, \"XXII\")\n    romans := append(romans, \"XXIII\"\
    )\n    romans := append(romans, \"XXIV\")\n    romans := append(romans, \"XXV\"\
    )\n    romans := append(romans, \"XXVI\")\n    romans := append(romans, \"XXVII\"\
    )\n    romans := append(romans, \"XXVII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgmb_fbtj_test.go:50:30: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:   \"I\",\n     \
    \   2:   \"II\",\n        3:   \"III\",\n        4:   \"IV\",\n        5:   \"\
    V\",\n        6:   \"VI\",\n        7:   \"VII\",\n        8:   \"VIII\",\n  \
    \      9:   \"IX\",\n        10:  \"X\",\n        11:  \"XI\",\n        12:  \"\
    XII\",\n        13:  \"XIII\",\n        14:  \"XIV\",\n        15:  \"XV\",\n\
    \        16:  \"XVI\",\n        17:  \"XVII\",\n        18:  \"XVIII\",\n    \
    \    19:  \"XIX\",\n        20:  \"XX\",\n        21:  \"XXI\",\n        22: \
    \ \"XXII\",\n        23:  \"XXIII\",\n        24:  \"XXIV\",\n        25:  \"\
    XXV\",\n        26:  \"XXVI\",\n        27:  \"XXVII\",\n        28:  \"XXVIII\"\
    ,\n        29:  \"XXIX\",\n        30:  \"XXX\",\n        31:  \"XXXI\",\n   \
    \     32:  \"XXXII\",\n        33:  \"XXXIII\",\n        34:  \"XXXIV\",\n   \
    \     35:  \"XXXV\",\n        36:  \"XXXVI\",\n        37:  \"XXXVII\",\n    \
    \    38:  \"XXXVIII\",\n        39:  \"XXXIX\",\n        40:  \"XL\",\n      \
    \  41:  \"L\",\n        42:  \"LX\",\n        43:  \"LXI\",\n        44:  \"LXII\"\
    ,\n        45:  \"LXIII\",\n        46:  \"LXIV\",\n        47:  \"LXV\",\n  \
    \      48:  \"LXVI\",\n        49:  \"LXVII\",\n        50:  \"LXVIII\",\n   \
    \     51:  \"LXIX\",\n        52:  \"LXX\",\n        53:  \"LXXI\",\n        54:\
    \  \"LXXII\",\n        55:  \"LXXIII\",\n        56:  \"LXXIV\",\n        57:\
    \  \"LXXV\",\n        58:  \"LXXVI\",\n        59:  \"LXXVII\",\n        60: \
    \ \"LXXVIII\",\n        61:  \"LXXIX\",\n        62:  \"LXXX\",\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp321p5h48_test.go:80:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"LXII\", \"LXIII\"\
    , \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"\
    CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\"\
    , \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"\
    CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXV\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5z_wo2ik_test.go:19:1125: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:   \"I\",\n      \
    \  2:   \"II\",\n        3:   \"III\",\n        4:   \"IV\",\n        5:   \"\
    V\",\n        6:   \"VI\",\n        7:   \"VII\",\n        8:   \"VIII\",\n  \
    \      9:   \"IX\",\n        10:  \"X\",\n        11:  \"XI\",\n        12:  \"\
    XII\",\n        13:  \"XIII\",\n        14:  \"XIV\",\n        15:  \"XV\",\n\
    \        16:  \"XVI\",\n        17:  \"XVII\",\n        18:  \"XVIII\",\n    \
    \    19:  \"XIX\",\n        20:  \"XX\",\n        21:  \"XXI\",\n        22: \
    \ \"XXII\",\n        23:  \"XXIII\",\n        24:  \"XXIV\",\n        25:  \"\
    XXV\",\n        26:  \"XXVI\",\n        27:  \"XXVII\",\n        28:  \"XXVIII\"\
    ,\n        29:  \"XXIX\",\n        30:  \"XXX\",\n        31:  \"XXXI\",\n   \
    \     32:  \"XXXII\",\n        33:  \"XXXIII\",\n        34:  \"XXXIV\",\n   \
    \     35:  \"XXXV\",\n        36:  \"XXXVI\",\n        37:  \"XXXVII\",\n    \
    \    38:  \"XXXVIII\",\n        39:  \"XXXIX\",\n        40:  \"XL\",\n      \
    \  41:  \"L\",\n        42:  \"LX\",\n        43:  \"LX\",\n        44:  \"LXX\"\
    ,\n        45:  \"LXXX\",\n        46:  \"LXXXX\",\n        47:  \"LXXXXX\",\n\
    \        48:  \"LXXXXXX\",\n        49:  \"LXXXXXXX\",\n        50:  \"LXXXXXXXX\"\
    ,\n        51:  \"LXXXXXXXXX\",\n        52:  \"LXXXXXXXXXX\",\n        53:  \"\
    LXXXXXXXXXXX\",\n        54:  \"LXXXXXXXXXXXX\",\n        55:  \"LXXXXXXXXXXXXX\"\
    ,\n        56:  \"LXXXXXXXXXXXXXX\",\n        57:  \"LXXXXXXXXXXXXXXX\",\n   \
    \     58:  \"LXXXXXXXXXXXXXXXX\",\n        59:  \"LXXXXXXXXXXXXXXXXX\",\n    \
    \    60:  \"LXXXXXXXXXXXXXXXXXX\",\n        61:  \"LXXXXXXXXXXXXXXXXXXX\",\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbbb0meg1_test.go:78:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"i\",\n       \
    \ 5:  \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100: \"\
    iv\",\n        500: \"ivv\",\n        1000: \"v\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp03olavzz_test.go:55: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp03olavzz_test.go:55: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp03olavzz_test.go:55:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp03olavzz_test.go:55: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp03olavzz_test.go:55: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp03olavzz_test.go:55: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp03olavzz_test.go:55:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp03olavzz_test.go:55:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp03olavzz_test.go:55: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    mini_roman_numerals :=\
    \ map[string]int{\n        \"I\":  1,\n        \"V\":  5,\n        \"X\":  10,\n\
    \        \"L\":  50,\n        \"C\":  100,\n        \"D\":  500,\n        \"M\"\
    :  1000,\n    }\n    roman_number := roman_numerals[number]\n    mini_roman :=\
    \ mini_roman_numerals[roman_number]\n    return string(mini_roman)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp4bxq6bop_test.go:36:12: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    i := number - 1\n    roman_number +=\
    \ int_to_roman(i)\n    for i--; i>0; i-- {\n        roman_number += int_to_roman(i)\n\
    \    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeymypnvq_test.go:18:21: undefined: int_to_roman

    /tmp/tmpeymypnvq_test.go:20:25: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        30: \"XXI\",\n        40: \"XXII\",\n        50: \"XXIII\"\
    ,\n        60: \"XXIV\",\n        70: \"XXV\",\n        80: \"XXVI\",\n      \
    \  90: \"XXVII\",\n        100: \"XXVIII\",\n        1000: \"XXIX\",\n    }\n\
    \    roman_number := roman_numerals[number]\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp588di8lx_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral_string :=\
    \ \"\"\n    for roman_numeral, numeral_string := range roman_numerals {\n    \
    \    if number >= roman_numeral {\n            roman_numeral_string = numeral_string\n\
    \            break\n        }\n    }\n    return strings.ToLower(roman_numeral_string)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp612og6m6_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1: \"I\",\n        5: \"V\"\
    ,\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500: \"\
    D\",\n        1000: \"M\",\n    }\n    result := \"\"\n    for number > 0 {\n\
    \        roman, ok := romans[number]\n        if ok {\n            result += roman\n\
    \            number -= roman\n        } else {\n            result += fmt.Sprintf(\"\
    %d\", number)\n            break\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0hdvhd3_test.go:30:13: invalid operation: number -= roman (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return strings.ToLower(roman)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp57pmuzf4_test.go:21:9: duplicate key 100 in map literal

    /tmp/tmp57pmuzf4_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n        roman_num\
    \ = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n        roman_num\
    \ = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case 5:\n        roman_num\
    \ = \"V\"\n    case 6:\n        roman_num = \"VI\"\n    case 7:\n        roman_num\
    \ = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\n    case 9:\n        roman_num\
    \ = \"IX\"\n    case 10:\n        roman_num = \"X\"\n    case 11:\n        roman_num\
    \ = \"XI\"\n    case 12:\n        roman_num = \"XII\"\n    case 13:\n        roman_num\
    \ = \"XIII\"\n    case 14:\n        roman_num = \"XIV\"\n    case 15:\n      \
    \  roman_num = \"XV\"\n    case 16:\n        roman_num = \"XVI\"\n    case 17:\n\
    \        roman_num = \"XVII\"\n    case 18:\n        roman_num = \"XVIII\"\n \
    \   case 19:\n        roman_num = \"XIX\"\n    case 20:\n        roman_num = \"\
    XX\"\n    case 21:\n        roman_num = \"XXI\"\n    case 22:\n        roman_num\
    \ = \"XXII\"\n    case 23:\n        roman_num = \"XXIII\"\n    case 24:\n    \
    \    roman_num = \"XXIV\"\n    case 25:\n        roman_num = \"XXV\"\n    case\
    \ 26:\n        roman_num = \"XXVI\"\n    case 27:\n        roman_num = \"XXVII\"\
    \n    case 28:\n        roman_num = \"XXVIII\"\n    case 29:\n        roman_num\
    \ = \"XXIX\"\n    case 30:\n        roman_num = \"XXX\"\n    case 31:\n      \
    \  roman_num = \"XXXI\"\n    case 32:\n        roman_num = \"XXXII\"\n    case\
    \ 33:\n        roman_num = \"XXXIII\"\n    case 34:\n        roman_num = \"XXXIV\"\
    \n    case 35:\n        roman_num = \"XXXV\"\n    case 36:\n        roman_num\
    \ = \"XXXVI\"\n    case 37:\n        roman_num = \"XXXVII\"\n    case 38:\n  \
    \      roman_num = \"XXXVIII\"\n    case 39:\n        roman_num = \"XXXIX\"\n\
    \    case 40:\n        roman_num = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptvr6zmos_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    mini_roman_numerals :=\
    \ map[string]int{\n        \"I\":  1,\n        \"V\":  5,\n        \"X\":  10,\n\
    \        \"L\":  50,\n        \"C\":  100,\n        \"D\":  500,\n        \"M\"\
    :  1000,\n    }\n    roman_number := roman_numerals[number]\n    mini_roman_number\
    \ := mini_roman_numerals[roman_number]\n    return string(mini_roman_numerals[number])\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo4v4vuoz_test.go:35:5: mini_roman_number declared but not used

    /tmp/tmpo4v4vuoz_test.go:36:39: cannot use number (variable of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1:  \"I\",\n      \
    \  2:  \"II\",\n        3:  \"III\",\n        4:  \"IV\",\n        5:  \"V\",\n\
    \        6:  \"VI\",\n        7:  \"VII\",\n        8:  \"VIII\",\n        9:\
    \  \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n  \
    \      13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"\
    XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n\
    \        20: \"XX\",\n        30: \"XXI\",\n        40: \"XXII\",\n        50:\
    \ \"XXIII\",\n        60: \"XXIV\",\n        70: \"XXV\",\n        80: \"XXVI\"\
    ,\n        90: \"XXVII\",\n        100: \"XXVIII\",\n        1000: \"XXIX\",\n\
    \    }\n\n    roman_number := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number <= number {\n            roman_number += roman_numeral\n\
    \        }\n    }\n\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4lcotzl_test.go:51:13: invalid operation: roman_number += roman_numeral
    (mismatched types string and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n    }\n    result := \"\"\n    for _,\
    \ romanIndex := range romans {\n        result += romanIndex\n        if number\
    \ >= romanIndex {\n            number -= romanIndex\n        }\n    }\n    return\
    \ strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnhp1nqum_test.go:22:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpnhp1nqum_test.go:23:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmpnhp1nqum_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIV\",\n        45: \"XLV\",\n        46: \"XLVI\",\n\
    \        47: \"XLVII\",\n        48: \"XLVIII\",\n        49: \"XLIX\",\n    \
    \    50: \"L\",\n        51: \"LI\",\n        52: \"LII\",\n        53: \"LIII\"\
    ,\n        54: \"LIV\",\n        55: \"LV\",\n        56: \"LVI\",\n        57:\
    \ \"LVII\",\n        58: \"LVIII\",\n        59: \"LIX\",\n        60: \"M\",\n\
    \        61: \"MI\",\n        62: \"MII\",\n        63: \"MIII\",\n        64:\
    \ \"MIIV\",\n        65: \"MIV\",\n        66: \"MIVI\",\n        67: \"MIVII\"\
    ,\n        68: \"MIVIII\",\n        69: \"MIIX\",\n        70: \"MM\",\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwipb326h_test.go:88:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n    }\n    roman_number := 0\n    for\
    \ _, roman_letter := range romans {\n        if number >= roman_number {\n   \
    \         roman_number += roman_letter\n        } else {\n            return fmt.Sprintf(\"\
    %c\", roman_letter)\n        }\n    }\n    return fmt.Sprintf(\"%c\", romans[len(romans)-1])\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr6_5b622_test.go:22:13: invalid operation: roman_number += roman_letter
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:   \"I\",\n      \
    \  5:   \"V\",\n        10:  \"X\",\n        50:  \"L\",\n        100:  \"C\"\
    ,\n        500:  \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0g5a3vz6_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\",\n    \
    \    \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\",\n        \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\",\
    \ \"LXXXI\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\",\n        \"CXI\"\
    , \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\",\n        \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\",\n        \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCX\", \"CCXI\", \"CCXII\",\n        \"CCXIII\"\
    , \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"CCH\"\
    ,\n        \"SCH\", \"SCHI\", \"SCHXI\", \"SCHXII\", \"SCHXIII\", \"SCHXIV\",\
    \ \"SCHXV\", \"SCHXVI\",\n        \"SCHXVII\", \"SCHXVIII\", \"SCHXIX\", \"SCHXX\"\
    , \"SCHXXI\", \"SCHXXII\", \"SCHXXIII\",\n        \"SCHXXIV\", \"SCHXX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4i583ssv_test.go:31:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n     \
    \   roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n    case\
    \ 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number = \"IV\"\
    \n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9zdtd42_test.go:98:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\",\n        \"CXIII\", \"CXIV\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9mi2kfw9_test.go:31:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"\
    LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\"\
    , \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"\
    CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\"\
    , \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"\
    CXL\", \"CL\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\",\
    \ \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\"\
    , \"LXVI\", \"LXVII\", \"L\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25hf3d9j_test.go:16:1152: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsInverse := map[string]int{\n\
    \        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n\
    \        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    romanNumeralInverse := romanNumeralsInverse[romanNumeral]\n\
    \    romanNumeralString := fmt.Sprintf(\"%c\", romanNumeralInverse)\n    return\
    \ strings.ToLower(romanNumeralString)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21bpa65__test.go:37:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"I\",\n\
    \        2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\"\
    ,\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"\
    IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n       \
    \ 13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\"\
    ,\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n     \
    \   20: \"XX\",\n        30: \"XL\",\n        40: \"L\",\n        50: \"M\",\n\
    \        60: \"M\",\n        70: \"MM\",\n        80: \"MMM\",\n        90: \"\
    MMMM\",\n    }\n    roman_numeral := \"\"\n    for roman_numeral, number := range\
    \ roman_numerals {\n        if number == number {\n            return roman_numeral\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6yyqnr2w_test.go:48:5: roman_numeral declared but not used

    /tmp/tmp6yyqnr2w_test.go:51:20: cannot use roman_numeral (variable of type int)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsInverse := map[string]int{\n\
    \        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n\
    \        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    romanNumeral\
    \ := \"\"\n    for romanNumeral, number := range romanNumerals {\n        if number\
    \ >= number {\n            break\n        }\n    }\n    if romanNumeral == \"\"\
    \ {\n        fmt.Println(\"No roman numeral for \", number)\n    }\n    return\
    \ romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpea9ekv51_test.go:25:5: romanNumeralsInverse declared but not used

    /tmp/tmpea9ekv51_test.go:35:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"L\",\n\
    \        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n        90:\
    \ \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6sfz33od_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"I\",\n        5:  \"\
    V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n        500:\
    \ \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n    if\
    \ !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return strings.ToLower(roman)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpunmk7fyg_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"I\",\n\
    \        2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\"\
    ,\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"\
    IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n       \
    \ 13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\"\
    ,\n        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n     \
    \   20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n        50: \"L\"\
    ,\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"LXXX\",\n        90:\
    \ \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgiq44f3d_test.go:51:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    roman_num := \"\"\n    switch number {\n    case 1:\n \
    \       roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXI\"\n    case\
    \ 32:\n        roman_num = \"XXII\"\n    case 33:\n        roman_num = \"XXIII\"\
    \n    case 34:\n        roman_num = \"XXIV\"\n    case 35:\n        roman_num\
    \ = \"XXV\"\n    case 36:\n        roman_num = \"XXVI\"\n    case 37:\n      \
    \  roman_num = \"XXVII\"\n    case 38:\n        roman_num = \"XXVIII\"\n    case\
    \ 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmpox348n_test.go:99:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 2: \"II\",\n        3: \"III\",\n        4: \"IV\",\n        5: \"V\",\n   \
    \     6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\",\n        9: \"IX\"\
    ,\n        10: \"X\",\n        11: \"XI\",\n        12: \"XII\",\n        13:\
    \ \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n        16: \"XVI\",\n\
    \        17: \"XVII\",\n        18: \"XVIII\",\n        19: \"XIX\",\n       \
    \ 20: \"XX\",\n        21: \"XXI\",\n        22: \"XXII\",\n        23: \"XXIII\"\
    ,\n        24: \"XXIV\",\n        25: \"XXV\",\n        26: \"XXVI\",\n      \
    \  27: \"XXVII\",\n        28: \"XXVIII\",\n        29: \"XXIX\",\n        30:\
    \ \"XXX\",\n        31: \"XXXI\",\n        32: \"XXXII\",\n        33: \"XXXIII\"\
    ,\n        34: \"XXXIV\",\n        35: \"XXXV\",\n        36: \"XXXVI\",\n   \
    \     37: \"XXXVII\",\n        38: \"XXXVIII\",\n        39: \"XXXIX\",\n    \
    \    40: \"XL\",\n        41: \"XLI\",\n        42: \"XLII\",\n        43: \"\
    XLIII\",\n        44: \"XLIV\",\n        45: \"XLV\",\n        46: \"XLVI\",\n\
    \        47: \"XLVII\",\n        48: \"XLVIII\",\n        49: \"XLIX\",\n    \
    \    50: \"L\",\n        51: \"LI\",\n        52: \"LII\",\n        53: \"LIII\"\
    ,\n        54: \"LIV\",\n        55: \"LV\",\n        56: \"LVI\",\n        57:\
    \ \"LVII\",\n        58: \"LVIII\",\n        59: \"LIX\",\n        60: \"M\",\n\
    \        61: \"MI\",\n        62: \"MII\",\n        63: \"MIII\",\n        64:\
    \ \"MIIV\",\n        65: \"MIV\",\n        66: \"MIVI\",\n        67: \"MIVII\"\
    ,\n        68: \"MIVIII\",\n        69: \"MIIX\",\n        70: \"MM\",\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwipb326h_test.go:88:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    return roman_number[0:len(roman_number)-1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn7wodks0_test.go:17:21: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n  \
    \      500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw7t3rsz8_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzo6ds1x_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    for _, romanIndex := range romans {\n        if number >= romanIndex {\n\
    \            result += romanIndex\n            number -= romanIndex\n        }\n\
    \    }\n    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpay32khxb_test.go:22:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpay32khxb_test.go:24:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmpay32khxb_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_num := roman_num[:len(roman_num)-number%len(roman_num)]\n\
    \    roman_num := append(roman_num, roman_num...)\n    return roman_num[number%len(roman_num)]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8fl7f09e_test.go:17:15: no new variables on left side of :=

    /tmp/tmp8fl7f09e_test.go:18:15: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_num := []string{\"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\"}\n    mini_roman_num := []string{\"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"}\n    mini_roman_num_len\
    \ := len(mini_roman_num)\n\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        fmt.Println(\"Number:\", number)\n        fmt.Println(\"\
    Roman:\", roman_num)\n        fmt.Println(\"MiniRoman:\", mini_roman_num)\n  \
    \      fmt.Println(\"MiniRomanLen:\", mini_roman_num_len)\n    }\n\n    roman_num_len\
    \ := len(roman_num)\n    mini_roman_num_len := len(mini_roman_num)\n\n    roman_num_pos\
    \ := number - 1\n    mini_roman_num_pos := number - 1\n\n    mini_roman_num_pos\
    \ %= mini_roman_num_len\n    roman_num_pos %= roman_num_len\n\n    mini_roman_num\
    \ := mini_roman_num[mini_roman_num_pos]\n    roman_num := roman_num[roman_num_pos]\n\
    \n    return mini_roman_num + roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsor1q6a8_test.go:29:24: no new variables on left side of :=

    /tmp/tmpsor1q6a8_test.go:37:20: no new variables on left side of :=

    /tmp/tmpsor1q6a8_test.go:37:23: cannot use mini_roman_num[mini_roman_num_pos]
    (variable of type string) as type []string in assignment

    /tmp/tmpsor1q6a8_test.go:38:15: no new variables on left side of :=

    /tmp/tmpsor1q6a8_test.go:38:18: cannot use roman_num[roman_num_pos] (variable
    of type string) as type []string in assignment

    /tmp/tmpsor1q6a8_test.go:40:12: invalid operation: operator + not defined on mini_roman_num
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zfw69y0_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n       \
    \ 5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n   \
    \     500: \"D\",\n        1000: \"M\",\n    }\n    result := \"\"\n    for roman_numeral,\
    \ numeral_string := range roman_numerals {\n        if number >= roman_numeral\
    \ {\n            result += numeral_string\n            number -= roman_numeral\n\
    \        }\n    }\n    if number > 0 {\n        result += int_to_mini_roman(number)\n\
    \    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'xix', got 'IVXIII'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'clii', got 'IVXLIVXLIVXIIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'ccli', got 'IVXLCVXLIIVXIII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'cdxxvi', got 'VXLCIIVXLCIVXLXIVIVIV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'd', got 'VXLCIIVXLCIVXLCII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmprgzbk6es_test.go:64: expected 'iv', got 'IIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'xliii', got 'IVXVXIIVIIIII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'xc', got 'IVXLXIVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'xciv', got 'IVXLVXIIVIV'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'dxxxii', got 'IVXLCIVXLCXLCIVXIVVXIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'cm', got 'IVXLCDCIVXLIVXLII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmprgzbk6es_test.go:64:\
    \ expected 'cmxciv', got 'LCDIVXLCIVXVXLILIVXVXIIVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmprgzbk6es_test.go:64: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"I\",\n       \
    \ 5:  \"V\",\n        10: \"X\",\n        50:  \"L\",\n        100: \"C\",\n \
    \       500: \"D\",\n        1000: \"M\",\n    }\n\n    romanNumeral := romanNumerals[number]\n\
    \    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps8dz46r6_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        1:  \"i\",\n        5:  \"\
    vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"ix\",\n   \
    \     500: \"ixi\",\n        1000: \"ixii\",\n    }\n    result := \"\"\n    for\
    \ _, romanNum := range romans {\n        if number >= romanNum {\n           \
    \ result += romans[romanNum]\n            number -= romanNum\n        }\n    }\n\
    \    if number > 0 {\n        result += romans[number]\n    }\n    return result\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3niqxscr_test.go:27:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmp3niqxscr_test.go:28:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmp3niqxscr_test.go:29:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsInverse := map[string]int{\n\
    \        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n\
    \        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    romanNumeralInverse := romanNumeralsInverse[romanNumeral]\n\
    \    romanNumeralString := fmt.Sprintf(\"%c\", romanNumeralInverse)\n    return\
    \ strings.ToLower(romanNumeralString)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21bpa65__test.go:37:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := map[int]string{\n        100: \"M\",\n        900: \"\
    CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n      \
    \  90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n\
    \        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n\
    \    }\n    result := \"\"\n    for numDigits := 0; number >= 1000; numDigits++\
    \ {\n        number /= 1000\n    }\n    for numDigits > 0; numDigits-- {\n   \
    \     result += romans[number%1000]\n        number /= 1000\n    }\n    return\
    \ result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz5l3cq3u_test.go:35:24: expected boolean or range expression, found simple
    statement (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romanNumerals := map[int]string{\n        1:  \"i\",\n       \
    \ 5:  \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100: \"\
    viiiii\",\n        500: \"viiiiii\",\n        1000: \"viiiiiii\",\n    }\n   \
    \ romanNumeral := romanNumerals[number]\n    if romanNumeral == \"\" {\n     \
    \   fmt.Println(\"Invalid input\")\n    }\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6gt81x3y_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075613
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n\
    // >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number int)\
    \ string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\", \"\
    XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n    }\n    roman_number := 0\n    roman_number += number/100\n\
    \    roman_number %= 100\n    roman_number += number%100/10\n    roman_number\
    \ %= 10\n    roman_number += number%10\n    return romans[roman_number]\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'xix', got 'XI'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpddwu6uzs_test.go:57: expected\
    \ 'clii', got 'IX'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmpddwu6uzs_test.go:57: expected 'ccli', got 'IX'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'cdxxvi', got 'XIII'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpddwu6uzs_test.go:57:\
    \ expected 'd', got 'VI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpddwu6uzs_test.go:57: expected 'i', got 'II'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'iv', got 'V'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpddwu6uzs_test.go:57: expected\
    \ 'xliii', got 'VIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmpddwu6uzs_test.go:57: expected 'xc', got 'X'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'xciv', got 'XIV'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpddwu6uzs_test.go:57:\
    \ expected 'dxxxii', got 'XI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'cm', got 'X'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpddwu6uzs_test.go:57:\
    \ expected 'cmxciv', got 'XIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpddwu6uzs_test.go:57: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075613
