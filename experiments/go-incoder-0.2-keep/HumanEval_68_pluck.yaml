name: HumanEval_68_pluck
language: go_test.go
prompt: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"\
  Given an array representing a branch of a tree that has non-negative integer nodes\n\
  // your task is to pluck one of the nodes and return it.\n// The plucked node should\
  \ be the node with the smallest even value.\n// If multiple nodes with the same\
  \ smallest even value are found return the node that has smallest index.\n// The\
  \ plucked node should be returned in a list, [ smalest_value, its index ],\n// If\
  \ there are no even values or the given array is empty, return [].\n// Example 1:\n\
  // Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value,\
  \ and 2 has the smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2,\
  \ 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\
  \ \n// Example 3:\n// Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0,\
  \ 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but \
  \ there are two zeros,\n// so we will choose the first zero, which has the smallest\
  \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
  func pluck(arr []int) []int {\n"
tests: "func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
  \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
  \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0,\
  \ 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
  \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
  \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n \
    \   for _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n\
    \                min = v\n                index = index\n            }\n     \
    \   } else {\n            if min == v {\n                index = index\n     \
    \       }\n        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n", "    var result []int\n    var smallestValue\
    \ int\n    var smallestIndex int\n    var index int\n    for _, value := range\
    \ arr {\n        if smallestValue == 0 || value < smallestValue {\n          \
    \  smallestValue = value\n            smallestIndex = index\n        }\n     \
    \   index++\n    }\n    if smallestValue == 0 {\n        return result\n    }\n\
    \    for _, value := range arr {\n        if value == smallestValue {\n      \
    \      result = append(result, smallestValue)\n            result = append(result,\
    \ smallestIndex)\n        }\n    }\n    return result\n}\n", "    // Write your\
    \ code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    ", "    m := make(map[int]int)\n\
    \    for _, v := range arr {\n        m[v] = m[v] + 1\n    }\n    result := make([]int,\
    \ 0, len(m))\n    for _, v := range m {\n        if v%2 == 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    if len(result) == 0 {\n        return\
    \ nil\n    }\n    if len(result) == 1 {\n        return result[0]\n    }\n   \
    \ return result\n}\n", "    arr2 := make([]int, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n\
    \    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8\
    \ := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int,\
    \ len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n\
    \    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15\
    \ := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int,\
    \ len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n\
    \    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22\
    \ := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int,\
    \ len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n\
    \    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29\
    \ := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int,\
    \ len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n\
    \    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36\
    \ := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int,\
    \ len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n\
    \    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43\
    \ := make([]int, len(arr))\n    arr", "    sort.Ints(arr)\n    smalest_value :=\
    \ arr[0]\n    smalest_index := 0\n    for _, v := range arr {\n        if v%2\
    \ == 0 {\n            if v < smalest_value {\n                smalest_value =\
    \ v\n                smalest_index = sort.SearchInts(arr, v)\n            }\n\
    \        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n", "   \
    \ result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if min > v {\n             \
    \   min = v\n                index = index\n            }\n        } else {\n\
    \            if min == v {\n                index = index\n            }\n   \
    \     }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n", "    m := make(map[int]int)\n    for _, v :=\
    \ range arr {\n        m[v] = m[min(v, m[v])]\n    }\n    result := make([]int,\
    \ 0, len(m))\n    for _, v := range m {\n        result = append(result, v)\n\
    \    }\n    return result\n}\n", "    result := make([]int, 0)\n    index := 0\n\
    \    min := arr[0]\n    for _, v := range arr {\n        if v%2 == 0 {\n     \
    \       if min > v {\n                min = v\n                index = index +\
    \ 1\n            }\n        } else {\n            if min == v {\n            \
    \    index = index + 1\n            }\n        }\n    }\n    result = append(result,\
    \ min)\n    result = append(result, index)\n    return result\n}\n", "    result\
    \ := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for _, val := range\
    \ arr {\n        if val < min {\n            min = val\n            index = -1\n\
    \        }\n        if val == min {\n            index = index + 1\n        }\n\
    \    }\n    if index == -1 {\n        return nil\n    }\n    result = append(result,\
    \ min)\n    result = append(result, index)\n    return result\n}\n", "    var\
    \ result []int\n    var minVal int\n    var minIndex int\n    for _, v := range\
    \ arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal {\n \
    \               minVal = v\n                minIndex = -1\n            }\n   \
    \     } else {\n            if minVal == 0 || v > minVal {\n                minVal\
    \ = v\n                minIndex = -1\n            }\n        }\n    }\n    if\
    \ minVal == 0 {\n        return []\n    }\n    result = append(result, minVal)\n\
    \    if minIndex == -1 {\n        return result\n    }\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] == minVal {\n            result = append(result, i)\n\
    \        }\n    }\n    return result\n}\n", "    m := make(map[int]int)\n    for\
    \ _, v := range arr {\n        m[v] = m[min(m[v], len(m))]\n    }\n    result\
    \ := make([]int, 0, len(m))\n    for _, v := range m {\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n", "    result := make([]int, 0)\n    min :=\
    \ arr[0]\n    index := 0\n    for _, value := range arr {\n        if value%2\
    \ == 0 {\n            if value < min {\n                min = value\n        \
    \        index = index\n            }\n        } else {\n            if min >\
    \ value {\n                min = value\n                index = index\n      \
    \      }\n        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n", "    m := make(map[int]int)\n    for _, v :=\
    \ range arr {\n        m[v] = m[v] + 1\n    }\n    arr2 := make([]int, 0, len(m))\n\
    \    for _, v := range m {\n        if v%2 == 0 {\n            arr2 = append(arr2,\
    \ v)\n        }\n    }\n    if len(arr2) == 0 {\n        return []\n    }\n  \
    \  arr3 = make([]int, 0, len(arr2))\n    for _, v := range arr2 {\n        arr3\
    \ = append(arr3, v)\n    }\n    return arr3\n}\n", "    sort.Ints(arr)\n    index\
    \ := 0\n    smalest := arr[0]\n    for _, v := range arr {\n        if v%2 ==\
    \ 0 {\n            if smalest == v {\n                index = index + 1\n    \
    \        } else {\n                smalest = v\n                index = index\n\
    \            }\n        }\n    }\n    return []int{smalest, index}\n}\n", "  \
    \  // write your code here\n    arr := make([]int, len(arr))\n    arr[0] = arr[0]\n\
    \    arr[1] = arr[1]\n    arr[2] = arr[2]\n    arr[3] = arr[3]\n    arr[4] = arr[4]\n\
    \    arr[5] = arr[5]\n    arr[6] = arr[6]\n    arr[7] = arr[7]\n    arr[8] = arr[8]\n\
    \    arr[9] = arr[9]\n    arr[10] = arr[10]\n    arr[0] = arr[0]\n    arr[1] =\
    \ arr[1]\n    arr[2] = arr[2]\n    arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5]\
    \ = arr[5]\n    arr[6] = arr[6]\n    arr[7] = arr[7]\n    arr[8] = arr[8]\n  \
    \  arr[9] = arr[9]\n    arr[10] = arr[10]\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n\
    \    arr[2] = arr[2]\n    arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5] = arr[5]\n\
    \    arr[6] = arr[6]\n    arr[7] = arr[7]\n    arr[8] = arr[8]\n    arr[9] = arr[9]\n\
    \    arr[10] = arr[10]\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n    arr[2] =\
    \ arr[2]\n    arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5] = arr[5]\n    arr[6]\
    \ = arr[6]\n    arr[7] = arr[7]\n    arr[8] = arr[8]\n    arr[9] = arr[9]\n  \
    \  arr[10] = arr[10]\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n    arr[2] = arr[2]\n\
    \    arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5] = arr[5]\n    arr[6] = arr[6]\n\
    \    arr[7] = arr[7]\n    arr[8] = arr[8]\n    arr[9] = arr[9]\n    arr[10] =\
    \ arr[10]\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n    arr[2] = arr[2]\n   \
    \ arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5] = arr[5]\n    arr[6] = arr[6]\n\
    \    arr[7] = arr[7]\n    arr[8] = arr[8]\n    arr[9] = arr[9]\n    arr[10] =\
    \ arr[10]\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n    arr[2] = arr[2]\n   \
    \ arr[3] = arr[3]\n    arr[4", "    // write your code here\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    ", "    result := make([]int, 0)\n    min := arr[0]\n \
    \   index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n         \
    \   if min > v {\n                min = v\n                index = index + 1\n\
    \            }\n        } else {\n            if min == v {\n                index\
    \ = index + 1\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n", "    sort.Ints(arr)\n\
    \    var result []int\n    var index int\n    for _, v := range arr {\n      \
    \  if v%2 == 0 {\n            result = append(result, v)\n            index =\
    \ len(result)\n        }\n    }\n    if index == 0 {\n        return []\n    }\n\
    \    return append(result[:index], result[index:]...)\n}\n", "    result := make([]int,\
    \ 0)\n    min := arr[0]\n    index := 0\n    for _, v := range arr {\n       \
    \ if v%2 == 0 {\n            if min > v {\n                min = v\n         \
    \       index = index\n            }\n        } else {\n            if min > v\
    \ {\n                min = v\n                index = index\n            }\n \
    \       }\n    }\n    result = append(result, min, index)\n    return result\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
