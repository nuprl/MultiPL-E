language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1OrbitSun, planet1Orbit)\n    planet2SunDistance := getDistance(planet2OrbitSun,\
    \ planet2Orbit)\n    \n    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = planet1OrbitSun,\
    \ planet2OrbitSun\n    \n    planet1OrbitSun, planet2OrbitSun = plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzb0vdsu7_test.go:66:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt2odp11j_test.go:81:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    planet1Sun := getSun(planet1)\n    planet2Sun := getSun(planet2)\n    planet1OrbitSun\
    \ := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun := getOrbit(planet2, planet2Sun)\n\
    \    planet1OrbitSunOrbitSun := getOrbit(planet1, planet1Sun, planet2Sun)\n  \
    \  planet2OrbitSunOrbitSun := getOrbit(planet2, planet2Sun, planet1Sun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet2OrbitSunOrbitSunOrbitSunOrbitSun := getOrbit(planet2, planet2Sun,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSunOrbitSun)\n    planet2OrbitSunOrbitSunOrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun, planet1OrbitSun,\
    \ planet2OrbitSunOrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbitSunOrbitSunOrbitSun\
    \ := getOrbit(planet1, planet1Sun, planet2Sun, planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwmh4nyi6_test.go:36:113: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplmqj0r2y_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqoqlkodt_test.go:46:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{planet1, planet2}\n    planet2Planets := []string{planet2,\
    \ planet1}\n    planet1PlanetsSet := make(map[string]bool)\n    planet2PlanetsSet\
    \ := make(map[string]bool)\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet2] = true\n    planet2PlanetsSet[planet1]\
    \ = true\n    planet1PlanetsSet[planet2] = true\n    planet2PlanetsSet[planet1]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[planet2]\
    \ = true\n    planet1PlanetsSet[planet1] = true\n    planet2PlanetsSet[plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7x4zr50r_test.go:57:27: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe7vvhcrb_test.go:58:47: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planet2Planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(planet1Planets,\
    \ planet1)\n    planet2Planets = append(planet2Planets, planet2)\n    planet1Planets\
    \ = append(planet1Planets, planet1)\n    planet2Planets = append(planet2Planets,\
    \ planet2)\n    planet1Planets = append(planet1Planets, planet1)\n    planet2Planets\
    \ = append(planet2Planets, planet2)\n    planet1Planets = append(planet1Planets,\
    \ planet1)\n    planet2Planets = append(planet2Planets, planet2)\n    planet1Planets\
    \ = append(planet1Planets, planet1)\n    planet2Planets = append(planet2Planets,\
    \ planet2)\n    planet1Planets = append(planet1Planets, planet1)\n    planet2Planets\
    \ = append(planet2Planets, planet2)\n    planet1Planets = append(planet1Planets,\
    \ planet1)\n    planet2Planets = append(planet2Planets, planet2)\n    planet1Planets\
    \ = append(planet1Planets, planet1)\n    planet2Planets = append(planet2Planets,\
    \ planet2)\n    planet1Planets = append(planet1Planets, planet1)\n    planet2Planets\
    \ = append(planet2Planets, planet2)\n    planet1Planets = append(planet1Planets,\
    \ planet1)\n    planet2Planets = append(planet2Planets, planet2)\n    planet1Planets\
    \ = append(planet1Planets, planet1)\n    planet2Planets = append(planet2Planets,\
    \ planet2)\n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpybyi5ajn_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp92__2l1q_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n        return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return nil\n    }\n  \
    \  planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet2Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n        return nil\n    }\n    planet1SunDistance,\
    \ err := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet2SunDistance, err := getDistance(planet2Orbit,\
    \ planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n        return nil\n\
    \    }\n    if planet1SunDistance < planet2SunDistance {\n        planet1Orbit,\
    \ planet2Orbit, planet1Sun, planet2Sun = planet2Orbit, planet1Orbit, planet2Sun,\
    \ planet1Sun\n    }\n    planet1Orbit, planet2Orbit, planet1Sun, planet2Sun =\
    \ planet2Orbit, planet1Orbit, planet2Sun, planet1Sun\n    planet1Orbit, planet2Orbit,\
    \ planet1Sun, planet2Sun = planet2Orbit, planet1Orbit, planet2Sun, planet1Sun\n\
    \    planet1Orbit, planet2Orbit, planet1Sun, planet2Sun = planet2Orbit, planet1Orbit,\
    \ planet2Sun, planet1Sun\n    planet1Orbit, planet2Orbit, planet1Sun, planet2Sun\
    \ = planet2Orbit, planet1Orbit, planet2Sun, planet1Sun\n    planet1Orbit, planet2Orbit,\
    \ planet1Sun, planet2Sun = planet2Orbit, planet1Orbit, planet2Sun, planet1Sun\n\
    \    planet1Orbit, planet2Orbit, planet1Sun, planet2Sun = plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprp2pzr12_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 == \"\
    Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\"\
    \ || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\"\
    \ || planet1 == \"Neptune\" {\n        planet1 = \"Mercury\"\n    }\n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planet2 = \"Mercury\"\n    }\n \
    \   \n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 ==\
    \ \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"\
    Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\"\
    \ || planet1 == \"Neptune\" {\n        planet1 = \"Mercury\"\n    }\n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planet2 = \"Mercury\"\n    }\n \
    \   \n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 ==\
    \ \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"\
    Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\"\
    \ || planet1 == \"Neptune\" {\n        planet1 = \"Mercury\"\n    }\n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planet2 = \"Mercury\"\n    }\n \
    \   \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppvfy0wmt_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqoqlkodt_test.go:46:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getPlanetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1OrbitSun, err := getPlanetOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ := getPlanetOrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance, err := getPlanetSunDistance(planet1OrbitSun,\
    \ planet2OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ planet2SunDistance, err := getPlanetSunDistance(planet1OrbitSun, planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance, err := getPlanetsBetween(planet1Orbit,\
    \ planet2Orbit, planet1SunDistance, planet2SunDistance)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ planet1SunDistance, planet2SunDistance, err := getPlanetsBetween(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ planet1SunDistance, planet2SunDistance, err := getPlanetsBetween(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ planet1SunDistance, planet2SunDistance, err := getPlanetsBetween(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpce9ewx_m_test.go:67:113: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpawqwa7l7_test.go:37:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(),\
    \ planet2.ToUpper()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn42scde__test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n  \
    \  planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2kpqfn3b_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n\
    \    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit :=\
    \ planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp76vxakc2_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0rncgbli_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSun, planet2OrbitSun\
    \ = sortByProximity(planet1OrbitSun, planet2Orbit\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp766_9z3q_test.go:36:85: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1Orbit(planet1), planet2Orbit(planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]string), planet2Orbit.([]string)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl_d0c3qb_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSunOrbit := orbit(planet1, planet1Sun, planet2OrbitSun)\n   \
    \ planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1OrbitSun)\n    planet1OrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun)\n    planet2OrbitSunOrbitSun\
    \ := orbit(planet2, planet2Sun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1OrbitSun,\
    \ planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSunOrbitSun := orbit(planet2,\
    \ planet2Sun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbitSunOrbitSunOrbitSun := orbit(planet1, planet1Sun,\
    \ planet2OrbitSun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet2OrbitSunOrbitSunOrbitSunOrbit\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbjcjo9fi_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_l01g8we_test.go:22:13: no new variables on left side of :=

    /tmp/tmp_l01g8we_test.go:23:13: no new variables on left side of :=

    /tmp/tmp_l01g8we_test.go:28:34: undefined: orbit

    /tmp/tmp_l01g8we_test.go:30:34: undefined: sortByProximity

    /tmp/tmp_l01g8we_test.go:32:12: cannot use planet1Orbit (variable of type string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    \n    planet1Orbit := planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8w18su47_test.go:48:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqxrt34va_test.go:55:46: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawrgr39_test.go:35:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2b1ay6dk_test.go:24:35: undefined: getOrbits

    /tmp/tmp2b1ay6dk_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius\
    \ := getOrbit(planet1)\n    planet2Orbit, planet2OrbitRadius := getOrbit(planet2)\n\
    \    \n    planet1SunRadius := getSunRadius(planet1)\n    planet2SunRadius :=\
    \ getSunRadius(planet2)\n    \n    planet1SunDistance := getSunDistance(planet1,\
    \ planet2)\n    planet2SunDistance := getSunDistance(planet2, planet1)\n    \n\
    \    planet1OrbitDistance := getOrbitDistance(planet1, planet2)\n    planet2OrbitDistance\
    \ := getOrbitDistance(planet2, planet1)\n    \n    planet1OrbitRadius := getOrbitRadius(planet1)\n\
    \    planet2OrbitRadius := getOrbitRadius(planet2)\n    \n    planet1OrbitDistance\
    \ := getOrbitDistance(planet1, planet2)\n    planet2OrbitDistance := getOrbitDistance(planet2,\
    \ planet1)\n    \n    planet1OrbitRadius := getOrbitRadius(planet1)\n    planet2OrbitRadius\
    \ := getOrbitRadius(planet2)\n    \n    planet1OrbitDistance := getOrbitDistance(planet1,\
    \ planet2)\n    planet2OrbitDistance := getOrbitDistance(planet2, planet1)\n \
    \   \n    planet1OrbitRadius := getOrbitRadius(planet1)\n    planet2OrbitRadius\
    \ := getOrbitRadius(planet2)\n    \n    planet1OrbitDistance := getOrbitDistance(planet1,\
    \ planet2)\n    planet2OrbitDistance := getOrbitDistance(planet2, planet1)\n \
    \   \n    planet1OrbitRadius := getOrbitRadius(planet1)\n    planet2OrbitRadius\
    \ := getOrbitRadius(planet2)\n    \n    planet1OrbitDistance := getOrbitDistance(planet1,\
    \ planet2)\n    planet2OrbitDistance := getOrbitDistance(planet2, planet1)\n \
    \   \n    planet1OrbitRadius := get\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpux5_v0hr_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk11_7ol9_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, planet1 := range planet1Orbit {\n        for _, planet2\
    \ := range planet2Orbit {\n            if planet1.distance < planet2.distance\
    \ {\n                planet1.distance += planet2.distance\n                planet1.planets\
    \ = append(planet1.planets, planet2)\n                planet2.planets = append(planet2.planets,\
    \ planet1)\n                \n                planet1.distance -= planet2.distance\n\
    \                planet2.distance -= planet1.distance\n                \n    \
    \            planet1.planets = append(planet1.planets, planet2)\n            \
    \    planet2.planets = append(planet2.planets, planet1)\n                \n  \
    \              planet1.distance += planet2.distance\n                planet2.distance\
    \ += planet1.distance\n                \n                planet1.planets = append(planet1.planets,\
    \ planet2)\n                planet2.planets = append(planet2.planets, planet1)\n\
    \                \n                planet1.distance -= planet2.distance\n    \
    \            planet2.distance -= planet1.distance\n                \n        \
    \        planet1.planets = append(planet1.planets, planet2)\n                planet2.planets\
    \ = append(planet2.planets, planet1)\n                \n                planet1.distance\
    \ += planet2.distance\n                planet2.distance += planet1.distance\n\
    \                \n                planet1.planets = append(planet1.planets, planet2)\n\
    \                planet2.planets = append(planet2.planets, planet1)\n        \
    \        \n                planet1.distance -= planet2.distance\n            \
    \    planet2.distance -= planet1.distance\n                \n                planet1.planets\
    \ = append(planet1.planets, planet2)\n                planet2.planets = append(planet2.planets,\
    \ planet1)\n                \n                planet1.distance += planet2.distance\n\
    \                planet2.distance += planet1.distance\n                \n    \
    \            planet1.planets = append(planet1.planets, planet2)\n            \
    \    planet2.planets = append(planet2.\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6jvznnxx_test.go:72:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    \n    planet1Sun := getSunOrbit(planet1)\n    planet2Sun := getSunOrbit(planet2)\n\
    \    \n    planet1Distance := getDistance(planet1Orbit, planet1Sun)\n    planet2Distance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1Proximity := getProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2Proximity := getProximity(planet2Orbit, planet2Sun)\n\
    \    \n    planet1ProximitySorted := getProximitySorted(planet1Proximity)\n  \
    \  planet2ProximitySorted := getProximitySorted(planet2Proximity)\n    \n    planet1ProximitySortedByDistance\
    \ := getProximitySortedByDistance(planet1ProximitySorted)\n    planet2ProximitySortedByDistance\
    \ := getProximitySortedByDistance(planet2ProximitySorted)\n    \n    planet1ProximitySortedByDistanceAndPlanet1\
    \ := getProximitySortedByDistanceAndPlanet1(planet1ProximitySortedByDistance)\n\
    \    planet2ProximitySortedByDistanceAndPlanet1 := getProximitySortedByDistanceAndPlanet1(planet2ProximitySortedByDistance)\n\
    \    \n    planet1ProximitySortedByDistanceAndPlanet2 := getProximitySortedByDistanceAndPlanet2(planet1ProximitySortedByDistance)\n\
    \    planet2ProximitySortedByDistanceAndPlanet2 := getProximitySortedByDistanceAndPlanet2(planet2ProximitySortedByDistance)\n\
    \    \n    planet1ProximitySortedByDistanceAndPlanet1AndPlanet2 := getProximitySortedByDistanceAndPlanet1AndPlanet2(planet1ProximitySortedByDistance)\n\
    \    planet2ProximitySortedByDistanceAndPlanet1AndPlanet2 := getProximitySortedByDistanceAndPlanet1AndPlanet2(planet2ProximitySortedByDistance)\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4mus5cxa_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdes_qt2p_test.go:36:97: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1OrbitSun := getOrbits(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := getOrbits(planet2, planet2Sun)\n    planet1SunOrbitSun\
    \ := getOrbits(planet1Sun, planet2Sun)\n    planet2SunOrbitSun := getOrbits(planet2Sun,\
    \ planet1Sun)\n    planet1OrbitSunOrbitSun := getOrbits(planet1Sun, planet1Sun)\n\
    \    planet2OrbitSunOrbitSun := getOrbits(planet2Sun, planet2Sun)\n    planet1OrbitSunOrbitSun\
    \ := getOrbits(planet1Sun, planet1Sun)\n    planet2OrbitSunOrbitSun := getOrbits(planet2Sun,\
    \ planet2Sun)\n    planet1OrbitSunOrbitSun := getOrbits(planet1Sun, planet1Sun)\n\
    \    planet2OrbitSunOrbitSun := getOrbits(planet2Sun, planet2Sun)\n    planet1OrbitSunOrbitSun\
    \ := getOrbits(planet1Sun, planet1Sun)\n    planet2OrbitSunOrbitSun := getOrbits(planet2Sun,\
    \ planet2Sun)\n    planet1OrbitSunOrbitSun := getOrbits(planet1Sun, planet1Sun)\n\
    \    planet2OrbitSunOrbitSun := getOrbits(planet2Sun, planet2Sun)\n    planet1OrbitSunOrbitSun\
    \ := getOrbits(planet1Sun, planet1Sun)\n    planet2OrbitSunOrbitSun := getOrbits(planet2Sun,\
    \ planet2Sun)\n    planet1OrbitSunOrbitSun := getOrbits(planet1Sun, planet1Sun)\n\
    \    planet2OrbitSunOrbitSun := getOrbits(planet2Sun, \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbwt_g520_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    \n    planet1Sun := getSunOrbit(planet1)\n    planet2Sun := getSunOrbit(planet2)\n\
    \    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1OrbitDistance :=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n    \n   \
    \ planet1OrbitDistance *= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ *= getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance /=\
    \ getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n    \n   \
    \ planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance /=\
    \ getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n    \n   \
    \ planet1OrbitDistance /= getDistance(planet1\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4b492g1u_test.go:55:48: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n\
    \    planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp77nwrp88_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1Orbit(planet1, planet2), planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n\
    \    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2), append(planet2Orbit,\
    \ planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet1), append(planet2Orbit,\
    \ plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpez6gcdtr_test.go:36:90: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n\
    \    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit :=\
    \ planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp76vxakc2_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(),\
    \ planet2.ToUpper()\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.ToUpper(), planet2Orbit.ToUpper()\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n   \
    \ \n    planet1Orbit, planet2Orbit = planet1Orbit[1], planet2Orbit[1]\n    \n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[2], planet2Orbit[2]\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit[3], planet2Orbit[3]\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[4], planet2Orbit[4]\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[5], planet2Orbit[5]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[6],\
    \ planet2Orbit[6]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[7], planet2Orbit[7]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[8], planet2Orbit[8]\n   \
    \ \n    planet1Orbit, planet2Orbit = planet1Orbit[9], planet2Orbit[9]\n    \n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[10], planet2Orbit[10]\n    \n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[11], planet2Orbit[11]\n    \n  \
    \  planet1Orbit, planet2Orbit = planet1Orbit[12], planet2Orbit[12]\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit[13], planet2Orbit[13]\n    \n    planet1Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu6k7e9yx_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius,\
    \ planet1OrbitDistance := getOrbit(planet1)\n    planet2Orbit, planet2OrbitRadius,\
    \ planet2OrbitDistance := getOrbit(planet2)\n    \n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1, planet2 = planet2, planet1\n    }\n\
    \    \n    planet1OrbitRadius += planet2OrbitRadius\n    \n    planet1OrbitRadius\
    \ /= 2\n    \n    planet1OrbitDistance += planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= 2\n    \n    planet1OrbitRadius /= 2\n    \n    planet1OrbitDistance /= 2\n\
    \    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n  \
    \  \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n\
    \    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /=\
    \ 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n\
    \    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n  \
    \  \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n\
    \    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /=\
    \ 2\n    \n    planet1OrbitDistance /= 2\n    \n    planet1OrbitDistance /= 2\n\
    \    \n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0g8agg7e_test.go:97:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm9t0bu1l_test.go:45:46: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw8hb44kc_test.go:37:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-2]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-2]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-2]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp99lt80hb_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n\
    \    planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp77nwrp88_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.insert(planet2Orbit)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.insert(planet2Orbit)\n\
    \    planet1Orbit.sort()\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk240pz8z_test.go:22:21: undefined: planet1Orbit

    /tmp/tmpk240pz8z_test.go:23:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074432
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1Orbit(planet1), planet2Orbit(planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet2Orbit...)\n    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n\
    \    \n    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd30qisfp_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1SunDistance\n\
    \    planet2OrbitDistance *= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphgqbdzvk_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getPlanetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity, err := getPlanetProximity(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunProximity,\
    \ err := getPlanetProximity(planet2Sun, planet2Orbit)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfpb8pgt4_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkvsf6k4z_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit =\
    \ planet2Orbit, planet1Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwfyoy_pf_test.go:62:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 == planet2\
    \ {\n        return nil\n    }\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9_691ior_test.go:100:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSunOrbit := orbit(planet1, planet1Sun, planet2OrbitSun)\n   \
    \ planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1OrbitSun)\n    planet1OrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun)\n    planet2OrbitSunOrbitSun\
    \ := orbit(planet2, planet2Sun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbit\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1OrbitSun,\
    \ planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2,\
    \ planet2Sun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun := orbit(planet1,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSun,\
    \ planet2OrbitSun, planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphn45ohd2_test.go:36:158: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    \n    planet1Sun := getSun()\n    planet2Sun := getSun()\n    \n    planet1OrbitSun\
    \ := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun := getOrbit(planet2, planet2Sun)\n\
    \    \n    planet1OrbitSun := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := getOrbit(planet2, planet2Sun)\n    \n    planet1OrbitSun := getOrbit(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := getOrbit(planet2, planet2Sun)\n    \n  \
    \  planet1OrbitSun := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun := getOrbit(planet2,\
    \ planet2Sun)\n    \n    planet1OrbitSun := getOrbit(planet1, planet1Sun)\n  \
    \  planet2OrbitSun := getOrbit(planet2, planet2Sun)\n    \n    planet1OrbitSun\
    \ := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun := getOrbit(planet2, planet2Sun)\n\
    \    \n    planet1OrbitSun := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := getOrbit(planet2, planet2Sun)\n    \n    planet1OrbitSun := getOrbit(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := getOrbit(planet2, planet2Sun)\n    \n  \
    \  planet1OrbitSun := getOrbit(planet1, planet1Sun)\n    planet2OrbitSun := getOrbit(planet2,\
    \ planet2Sun)\n    \n    planet1OrbitSun := getOrbit(planet1, planet1Sun)\n  \
    \  planet2OrbitSun := getOrbit(planet2, planet2Sun\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp99ogcxs0_test.go:56:52: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit := orbit(planet1)\n    planet2Orbit\
    \ := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n\
    \    \n    planet1OrbitSun := planet1Orbit.Intersection(planet1Sun)\n    planet2OrbitSun\
    \ := planet2Orbit.Intersection(planet2Sun)\n    \n    planet1OrbitSunSorted :=\
    \ planet1OrbitSun.OrderByDistance(planet2OrbitSun)\n    \n    return planet1OrbitSunSorted\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_2b7epwj_test.go:23:21: undefined: orbit

    /tmp/tmp_2b7epwj_test.go:24:21: undefined: orbit

    /tmp/tmp_2b7epwj_test.go:26:19: undefined: sun

    /tmp/tmp_2b7epwj_test.go:27:19: undefined: sun

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = strings.ToLower(planet1), strings.ToLower(planet2)\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5cv36lq7_test.go:50:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpokoioc5p_test.go:23:13: no new variables on left side of :=

    /tmp/tmpokoioc5p_test.go:24:13: no new variables on left side of :=

    /tmp/tmpokoioc5p_test.go:25:35: undefined: orbit

    /tmp/tmpokoioc5p_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n\
    \    planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp77nwrp88_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    \n    planet1Orbit := planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit, planet1Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpizyi0exa_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1OrbitSun := getOrbits(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := getOrbits(planet2, planet2Sun)\n    planet1OrbitSunSun\
    \ := getOrbits(planet1, planet1SunSun)\n    planet2OrbitSunSun := getOrbits(planet2,\
    \ planet2SunSun)\n    planet1OrbitSunSunSun := getOrbits(planet1, planet1SunSunSun)\n\
    \    planet2OrbitSunSunSun := getOrbits(planet2, planet2SunSunSun)\n    planet1OrbitSunSunSunSun\
    \ := getOrbits(planet1, planet1SunSunSunSun)\n    planet2OrbitSunSunSunSun :=\
    \ getOrbits(planet2, planet2SunSunSunSun)\n    planet1OrbitSunSunSunSunSun :=\
    \ getOrbits(planet1, planet1SunSunSunSunSun)\n    planet2OrbitSunSunSunSunSun\
    \ := getOrbits(planet2, planet2SunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSun\
    \ := getOrbits(planet1, planet1SunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSun\
    \ := getOrbits(planet2, planet2SunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSun\
    \ := getOrbits(planet1, planet1SunSunSunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSunSun\
    \ := getOrbits(planet2, planet2SunSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSun\
    \ := getOrbits(planet1, planet1SunSunSunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSunSunSun\
    \ := getOrbits(planet2, planet2SunSunSunSunSunSunSunSun)\n    \nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt1km47h6_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj6rb2wua_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = strings.ToLower(planet1), strings.ToLower(planet2)\n\
    \    planet1, planet2 = strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n\
    \    if planet1 == \"\" || planet2 == \"\" {\n        return []\n    }\n    planet1,\
    \ planet2 = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2\
    \ = strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc664co0j_test.go:25:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = strings.ToLower(planet1), strings.ToLower(planet2)\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = strings.TrimSpace(planet1),\
    \ strings.TrimSpace(planet2)\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSpace(planet1),\
    \ strings.TrimSpace(planet2)\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSpace(planet1),\
    \ strings.TrimSpace(planet2)\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    planet1, planet2 = strings.TrimSpace(planet1),\
    \ strings.TrimSpace(planet2)\n    planet1, planet2 = strings.TrimSuffix(planet1,\
    \ \" \"), strings.TrimSuffix(planet2, \" \")\n    planet1, planet2 = strings.TrimPrefix(planet1,\
    \ \" \"), strings.TrimPrefix(planet2, \" \")\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_oq4gful_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe7vvhcrb_test.go:58:47: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1OrbitDistance\n    planet2SunDistance\
    \ += planet2OrbitDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_jgc3p3w_test.go:85:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(),\
    \ planet2.ToUpper()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn42scde__test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplkhy9qb7_test.go:42:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.insert(planet2Orbit)\n\
    \    planet1Orbit.deleteDuplicates()\n    planet2Orbit.insert(planet1Orbit)\n\
    \    planet2Orbit.deleteDuplicates()\n    return planet1Orbit\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq_4tsxxf_test.go:22:21: undefined: planet1Orbit

    /tmp/tmpq_4tsxxf_test.go:23:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = strings.ToLower(planet1),\
    \ strings.ToLower(planet2)\n    planet1, planet2 = strings.TrimSpace(planet1),\
    \ strings.TrimSpace(planet2)\n    planet1, planet2 = strings.ToUpper(planet1),\
    \ strings.ToUpper(planet2)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet1, \"V\", \"Venus\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"E\", \"Earth\", -1), strings.Replace(planet1,\
    \ \"M\", \"Mars\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"J\"\
    , \"Jupiter\", -1), strings.Replace(planet1, \"S\", \"Saturn\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"U\", \"Uranus\", -1), strings.Replace(planet1,\
    \ \"N\", \"Neptune\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet1, \"V\", \"Venus\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"E\", \"Earth\", -1), strings.Replace(planet1,\
    \ \"M\", \"Mars\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"J\"\
    , \"Jupiter\", -1), strings.Replace(planet1, \"S\", \"Saturn\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"U\", \"Uranus\", -1), strings.Replace(planet1,\
    \ \"N\", \"Neptune\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet1, \"V\", \"Venus\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"E\", \"Earth\", -1), strings.Replace(planet1,\
    \ \"M\", \"Mars\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"J\"\
    , \"Jupiter\", -1), strings.Replace(planet1, \"S\", \"Saturn\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"U\", \"Uranus\", -1), strings.Replace(planet1,\
    \ \"N\", \"Neptune\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet1, \"V\", \"Venus\", -1)\n    planet1,\
    \ planet2 = strings.\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdanccnal_test.go:40:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planet2Planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1PlanetsIndex := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}\n\
    \    planet2PlanetsIndex := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}\n    planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\
    \ = planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet2)]\n    planet2PlanetsIndex[planet1PlanetsIndex.FindIndex(planet2)]\
    \ = planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\n    planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\
    \ = planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet2)]\n    planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet2)]\
    \ = planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet1)]\n    planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\
    \ = planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet2)]\n    planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet2)]\
    \ = planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet1)]\n    planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\
    \ = planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet2)]\n    planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet2)]\
    \ = planet2PlanetsIndex[planet2PlanetsIndex.FindIndex(planet1)]\n    planet1PlanetsIndex[planet1PlanetsIndex.FindIndex(planet1)]\
    \ = planet1PlanetsIndex[planet1PlanetsIndex.Find\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdvzz61av_test.go:34:111: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1,\
    \ \" \")\n    planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"-\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"-\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"-\", \" \", -1)\n    planet1 := strings.Replace(planet1, \"+\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"+\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"/\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"/\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"\\\\\", \" \", -1)\n    planet2 :=\
    \ strings.Replace(planet2, \"\\\\\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"*\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"*\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"?\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"?\", \" \", -1)\n    planet1 := strings.Replace(planet1, \":\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \":\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"<\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"<\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \">\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \">\", \" \", -1)\n    planet1 := strings.Replace(planet1, \"&\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"&\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"=\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"=\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"!\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"!\", \" \", -1)\n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5jprx9g2_test.go:55:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun := sun(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1OrbitSunSun, planet2OrbitSunSun := sun(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunSunSun, planet2OrbitSunSunSun :=\
    \ sun(planet1OrbitSunSunSun, planet2OrbitSunSunSun)\n    \n    planet1OrbitSunSunSunSun,\
    \ planet2OrbitSunSunSunSun := sun(planet1OrbitSunSunSunSun, planet2OrbitSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSunSun, planet2OrbitSunSunSunSunSun := sun(planet1OrbitSunSunSunSunSun,\
    \ planet2OrbitSunSunSunSunSun)\n    \n    planet1OrbitSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSun)\n   \
    \ \n    planet1OrbitSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSun :=\
    \ sun(planet1OrbitSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSunSunSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSunSunSunSunSunSun\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk3ci2nfh_test.go:43:209: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074433
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planet2Planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Orbits, planet2Orbits := orbits(planet1, planet2)\n\
    \    planet1Orbits = append(planet1Orbits, planet2)\n    planet2Orbits = append(planet2Orbits,\
    \ planet1)\n    planet1Orbits = append(planet1Orbits, planet1)\n    planet2Orbits\
    \ = append(planet2Orbits, planet2)\n    planet1Orbits = append(planet1Orbits,\
    \ planet1)\n    planet2Orbits = append(planet2Orbits, planet2)\n    planet1Orbits\
    \ = append(planet1Orbits, planet1)\n    planet2Orbits = append(planet2Orbits,\
    \ planet2)\n    planet1Orbits = append(planet1Orbits, planet1)\n    planet2Orbits\
    \ = append(planet2Orbits, planet2)\n    planet1Orbits = append(planet1Orbits,\
    \ planet1)\n    planet2Orbits = append(planet2Orbits, planet2)\n    planet1Orbits\
    \ = append(planet1Orbits, planet1)\n    planet2Orbits = append(planet2Orbits,\
    \ planet2)\n    planet1Orbits = append(planet1Orbits, planet1)\n    planet2Orbits\
    \ = append(planet2Orbits, planet2)\n    planet1Orbits = append(planet1Orbits,\
    \ planet1)\n    planet2Orbits = append(planet2Orbits, planet2)\n    planet1Orbits\
    \ = append(planet1Orbits, planet1)\n    planet2Orbits = append(planet2Orbits,\
    \ planet2)\n    planet1Orbits = append(planet1Orbits, planet1)\n    planet2Orbits\
    \ = append(planet2Orbits, planet2)\n    planet1Orbits = append(planet1Orbits,\
    \ planet1)\n    planet2Orbits = append(planet2Orbits, planet2)\n    planet1Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6886tsvh_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    result := []interface{}{}\n\
    \    for _, planet1OrbitItem := range planet1Orbit {\n        for _, planet2OrbitItem\
    \ := range planet2Orbit {\n            if planet1OrbitItem < planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            } else\
    \ {\n                planet2OrbitItem = planet2OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem < planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            } else\
    \ {\n                planet2OrbitItem = planet2OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem < planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            } else\
    \ {\n                planet2OrbitItem = planet2OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem < planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            } else\
    \ {\n                planet2OrbitItem = planet2OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpta8wkzkb_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        return\
    \ nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n\
    \        return nil\n    }\n    planet1Sun, err := getSun(planet1)\n    if err\
    \ != nil {\n        return nil\n    }\n    planet2Sun, err := getSun(planet2)\n\
    \    if err != nil {\n        return nil\n    }\n    planet1SunDistance := getDistance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ip0svc9_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    result := make([]interface{},\
    \ 0)\n    for _, planet := range planet1Orbit {\n        for _, planet2 := range\
    \ planet2Orbit {\n            if planetOrbit(planet, planet2) {\n            \
    \    planet1.sort()\n                planet2.sort()\n                if planet1\
    \ == planet2 {\n                    result = append(result, planet)\n        \
    \        } else {\n                    result = append(result, planet)\n     \
    \               result = append(result, planet2)\n                }\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zv4vmw_test.go:22:21: undefined: planet1Orbit

    /tmp/tmpe0zv4vmw_test.go:23:21: undefined: planet2Orbit

    /tmp/tmpe0zv4vmw_test.go:29:16: undefined: planetOrbit

    /tmp/tmpe0zv4vmw_test.go:30:25: planet1.sort undefined (type string has no field
    or method sort)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1SunDistance\
    \ := distance(planet1Sun, planet1Orbit)\n    planet2SunDistance := distance(planet2Sun,\
    \ planet2Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxz1hetwi_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    planet1OrbitDistance := planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet1Orbit)\n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet2OrbitDistance += planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance\
    \ /= 2\n    planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7lbdzoiz_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit,\
    \ planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet2Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_o0gajwx_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjawrgr39_test.go:35:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius\
    \ := getOrbit(planet1)\n    planet2Orbit, planet2OrbitRadius := getOrbit(planet2)\n\
    \    \n    planet1SunRadius := getSunRadius(planet1)\n    planet2SunRadius :=\
    \ getSunRadius(planet2)\n    \n    planet1Distance := getDistance(planet1Orbit,\
    \ planet1OrbitRadius)\n    planet2Distance := getDistance(planet2Orbit, planet2OrbitRadius)\n\
    \    \n    planet1Distance += planet1SunRadius\n    planet2Distance += planet2SunRadius\n\
    \    \n    planet1Distance /= 2\n    planet2Distance /= 2\n    \n    planet1Distance\
    \ += planet1OrbitRadius\n    planet2Distance += planet2OrbitRadius\n    \n   \
    \ planet1Distance /= 2\n    planet2Distance /= 2\n    \n    planet1Distance +=\
    \ planet1OrbitRadius\n    planet2Distance += planet2OrbitRadius\n    \n    planet1Distance\
    \ /= 2\n    planet2Distance /= 2\n    \n    planet1Distance += planet1OrbitRadius\n\
    \    planet2Distance += planet2OrbitRadius\n    \n    planet1Distance /= 2\n \
    \   planet2Distance /= 2\n    \n    planet1Distance += planet1OrbitRadius\n  \
    \  planet2Distance += planet2OrbitRadius\n    \n    planet1Distance /= 2\n   \
    \ planet2Distance /= 2\n    \n    planet1Distance += planet1OrbitRadius\n    planet2Distance\
    \ += planet2OrbitRadius\n    \n    planet1Distance /= 2\n    planet2Distance /=\
    \ 2\n    \n    planet1Distance += planet1OrbitRadius\n    planet2Distance += planet2OrbitRadius\n\
    \    \n    planet1Distance /= 2\n    planet2Distance /= 2\n    \n    planet1Distance\
    \ += planet1OrbitRadius\n    planet2Distance += planet2OrbitRadius\n    \n   \
    \ planet1Distance /= 2\n    planet2Distance /= \nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgu07ka0y_test.go:81:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit\
    \ := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    result := []interface{}{}\n    for _, planet1 := range planet1Orbit {\n \
    \       for _, planet2 := range planet2Orbit {\n            if planet1 == planet2\
    \ {\n                continue\n            }\n            distance := planet1Orbit.distance(planet2)\n\
    \            if distance < planet1Orbit.sunDistance {\n                result\
    \ = append(result, planet1)\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6hc9wjo8_test.go:23:21: undefined: planet1Orbit

    /tmp/tmp6hc9wjo8_test.go:24:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    \n    planet1Sun, planet2Sun := sun(planet1,\
    \ planet2)\n    \n    planet1SunOrbit, planet2SunOrbit := orbit(planet1Sun, planet2Sun)\n\
    \    \n    planet1SunOrbitSun, planet2SunOrbitSun := sun(planet1SunOrbit, planet2SunOrbit)\n\
    \    \n    planet1SunOrbitSunOrbit, planet2SunOrbitSunOrbit := orbit(planet1SunOrbitSun,\
    \ planet2SunOrbitSun)\n    \n    planet1SunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSun\
    \ := sun(planet1SunOrbitSunOrbit, planet2SunOrbitSunOrbit)\n    \n    planet1SunOrbitSunOrbitSunOrbit,\
    \ planet2SunOrbitSunOrbitSunOrbit := orbit(planet1SunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSun)\n\
    \    \n    planet1SunOrbitSunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSunOrbitSun\
    \ := sun(planet1SunOrbitSunOrbitSunOrbit, planet2SunOrbitSunOrbitSunOrbit)\n \
    \   \n    planet1SunOrbitSunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1SunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSun)\n    \n   \
    \ planet1SunOrbitSunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSunOrbitSun := sun(planet1SunOrbitSunOrbitSunOrbit,\
    \ planet2SunOrbitSunOrbitSunOrbit)\n    \n    planet1SunOrbitSunOrbitSunOrbitSun,\
    \ planet2SunOrbitSunOrbitSunOrbitSun := orbit(planet1SunOrbitSunOrbitSun, planet2SunOrbitSunOrbitSun)\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdn_6zgs5_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqoqlkodt_test.go:46:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ := getOrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet1SunDistance, err := getDistance(planet1OrbitSun, planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance,\
    \ planet2SunDistance := getOrbitSunDistance(planet1OrbitSun, planet2OrbitSun,\
    \ planet1SunDistance, planet2SunDistance)\n    planet1OrbitSun, planet2OrbitSun,\
    \ planet1SunDistance, planet2SunDistance := getOrbitSunDistance(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance := getOrbitSunDistance(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance := getOrbitSunDistance(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance := getOrbitSunDistance(planet1OrbitSun,\
    \ planet2OrbitSun, planet1SunDistance, planet2SunDistance)\n    planet1OrbitSun,\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmped88eoko_test.go:51:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    result := []interface{}{}\n\
    \    \n    for _, planet := range planet1Orbit {\n        if planet == planet2\
    \ {\n            result = append(result, planet)\n        }\n    }\n    \n   \
    \ for _, planet := range planet2Orbit {\n        if planet == planet1 {\n    \
    \        result = append(result, planet)\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04m_6ljv_test.go:22:21: undefined: orbit

    /tmp/tmp04m_6ljv_test.go:23:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2Sun, err := getSun(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitDistance := getDistance(planet1Orbit, planet1Orbit)\n\
    \    planet2OrbitDistance := getDistance(planet2Orbit, planet2Orbit)\n    \n \
    \   planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance +=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm5vlv7kf_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    \n\
    \    planet1SunDistance := distance(planet1Sun, planet1Orbit)\n    planet2SunDistance\
    \ := distance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance := distance(planet1Orbit,\
    \ planet1Orbit)\n    planet2OrbitDistance := distance(planet2Orbit, planet2Orbit)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqytsxocs_test.go:69:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe6whfbf3_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    result := []interface{}{}\n\
    \    for _, planet1 := range planet1Orbit {\n        for _, planet2 := range planet2Orbit\
    \ {\n            if planet1.distance < planet2.distance {\n                planet1.distance\
    \ += 1\n            } else {\n                planet2.distance += 1\n        \
    \    }\n            if planet1.distance < planet2.distance {\n               \
    \ planet1.distance += 1\n            } else {\n                planet2.distance\
    \ += 1\n            }\n            if planet1.distance < planet2.distance {\n\
    \                planet1.distance += 1\n            } else {\n               \
    \ planet2.distance += 1\n            }\n            if planet1.distance < planet2.distance\
    \ {\n                planet1.distance += 1\n            } else {\n           \
    \     planet2.distance += 1\n            }\n            if planet1.distance <\
    \ planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpika6gepn_test.go:100:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074434
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(),\
    \ planet2.ToUpper()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn42scde__test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit\
    \ := getOrbit(planet2)\n    planet1Sun := getSun(planet1)\n    planet2Sun := getSun(planet2)\n\
    \    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n\
    \    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit,\
    \ planet2Orbit)\n    planet2SunDistance += getDistance(planet2Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp__cvvs6p_test.go:46:48: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    \n    planet1Planets := []string{planet1, planet2}\n\
    \    planet2Planets := []string{planet2, planet1}\n    \n    planet1Planets =\
    \ append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiev2zbwe_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius,\
    \ planet1OrbitRadians, planet1OrbitDistance, planet1OrbitDistance := getOrbit(planet1)\n\
    \    planet2Orbit, planet2OrbitRadius, planet2OrbitRadians, planet2OrbitDistance,\
    \ planet2OrbitDistance := getOrbit(planet2)\n    \n    planet1Sun, planet1SunRadius,\
    \ planet1SunRadians, planet1SunDistance, planet1SunDistance := getSun(planet1)\n\
    \    planet2Sun, planet2SunRadius, planet2SunRadians, planet2SunDistance, planet2SunDistance\
    \ := getSun(planet2)\n    \n    planet1OrbitDistance := planet1OrbitDistance -\
    \ planet1OrbitRadius\n    planet2OrbitDistance := planet2OrbitDistance - planet2OrbitRadius\n\
    \    \n    planet1SunDistance := planet1SunDistance - planet1SunRadius\n    planet2SunDistance\
    \ := planet2SunDistance - planet2SunRadius\n    \n    planet1OrbitRadians := planet1OrbitRadians\
    \ - planet1OrbitRadians\n    planet2OrbitRadians := planet2OrbitRadians - planet2OrbitRadians\n\
    \    \n    planet1OrbitRadians := planet1OrbitRadians * math.Cos(planet1OrbitRadians)\n\
    \    planet2OrbitRadians := planet2OrbitRadians * math.Cos(planet2OrbitRadians)\n\
    \    \n    planet1OrbitRadians /= math.Sqrt(math.Pow(planet1OrbitDistance, 2)\
    \ + math.Pow(planet1OrbitRadius, 2))\n    planet2OrbitRadians /= math.Sqrt(math.Pow(planet2OrbitDistance,\
    \ 2) + math.Pow(planet2OrbitRadius, 2))\n    \n    planet1OrbitDistance /= math.Sqrt(math.Pow(planet1OrbitRadians,\
    \ 2) + math.Pow(planet1OrbitDistance, 2))\n    planet2OrbitDistance /= math.S\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkmcr4xfx_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    result := []interface{}{}\n\
    \    \n    for _, planet1 := range planet1Orbit {\n        for _, planet2 := range\
    \ planet2Orbit {\n            if planet1 == planet2 {\n                continue\n\
    \            }\n            \n            distance := distance(planet1, planet2)\n\
    \            \n            if distance < planet1Orbit.distance {\n           \
    \     planet1Orbit.distance = distance\n                planet1Orbit.planet =\
    \ planet1\n            }\n            \n            if distance < planet2Orbit.distance\
    \ {\n                planet2Orbit.distance = distance\n                planet2Orbit.planet\
    \ = planet2\n            }\n        }\n    }\n    \n    for _, planet1 := range\
    \ planet1Orbit {\n        for _, planet2 := range planet2Orbit {\n           \
    \ if planet1 == planet2 {\n                continue\n            }\n         \
    \   \n            distance := distance(planet1, planet2)\n            \n     \
    \       if distance < planet1Orbit.distance {\n                planet1Orbit.distance\
    \ = distance\n                planet1Orbit.planet = planet1\n            }\n \
    \           \n            if distance < planet2Orbit.distance {\n            \
    \    planet2Orbit.distance = distance\n                planet2Orbit.planet = planet2\n\
    \            }\n        }\n    }\n    \n    for _, planet1 := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet1 ==\
    \ planet2 {\n                continue\n            }\n            \n         \
    \   distance := distance(planet1, planet2)\n            \n            if distance\
    \ < planet1Orbit.distance {\n                planet1Orbit.distance = distance\n\
    \                planet1Orbit.planet = planet1\n            }\n            \n\
    \            if distance < planet2Orbit.distance {\n                planet2Orbit.distance\
    \ = distance\n                planet2Orbit.planet = planet2\n            }\n \
    \       }\n    }\n    \n    for _, planet1 := range planet1Orbit {\n        for\
    \ _, planet2 := range planet2Orbit {\n            if planet1 == planet2 {\n  \
    \              continue\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc3g9vd9t_test.go:94:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5kiztub_test.go:22:35: undefined: orbit

    /tmp/tmpq5kiztub_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 == planet2\
    \ {\n        return nil\n    }\n    \n    planet1Orbit := planet1\n    planet2Orbit\
    \ := planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplb1bw1tl_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz8h36mjk_test.go:36:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getPlanetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity := getPlanetProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getPlanetProximity(planet2Orbit, planet2Sun)\n   \
    \ \n    planet1Proximity, err := getPlanetProximity(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity, err\
    \ := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n   \
    \     fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8d8bdqev_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqoqlkodt_test.go:46:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    planet1Orbit, planet2Orbit\
    \ = removePlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3cfccd2_test.go:22:35: undefined: getOrbits

    /tmp/tmpx3cfccd2_test.go:23:34: undefined: sortPlanets

    /tmp/tmpx3cfccd2_test.go:24:34: undefined: removePlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := get\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplp7qtbjh_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := planet1OrbitSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet2OrbitSunSun.([]interface{})\n    planet1OrbitSunSun, planet2OrbitSunSun\
    \ := planet1OrbitSunSun.([]interface{})\n    planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpashs55rf_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.sort()\n \
    \   planet2Orbit.sort()\n    result := make([]interface{}, 0)\n    for _, planet\
    \ := range planet1Orbit {\n        for _, planet2 := range planet2Orbit {\n  \
    \          if planet1 == planet {\n                if planet2 == planet2 {\n \
    \                   result = append(result, planet2)\n                }\n    \
    \        }\n            if planet2 == planet {\n                if planet1 ==\
    \ planet2 {\n                    result = append(result, planet1)\n          \
    \      }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_qrv2ya_test.go:22:21: undefined: planet1Orbit

    /tmp/tmpv_qrv2ya_test.go:23:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 == planet2\
    \ {\n        return nil\n    }\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return nil\n    }\n  \
    \  \n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n       \
    \ fmt.Println(err)\n        return nil\n    }\n    \n    planet1Sun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n        return nil\n    }\n  \
    \  \n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n\
    \    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    if planet1OrbitDistance < planet2OrbitDistance {\n        planet1OrbitDistance\
    \ = planet2OrbitDistance\n    }\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ *= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance *= planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance /= planet2Orbit.Distance(\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphdecv6t5_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planet2Planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1PlanetsIndex := map[string]int{planet1: 0}\n    planet2PlanetsIndex\
    \ := map[string]int{planet2: 0}\n    planet1PlanetsOrbit := map[string][]string{}\n\
    \    planet2PlanetsOrbit := map[string][]string{}\n    planet1PlanetsOrbitIndex\
    \ := map[string][]int{}\n    planet2PlanetsOrbitIndex := map[string][]int{}\n\
    \    planet1PlanetsOrbitIndex2 := map[string][]int{}\n    planet2PlanetsOrbitIndex2\
    \ := map[string][]int{}\n    planet1PlanetsOrbitIndex3 := map[string][]int{}\n\
    \    planet2PlanetsOrbitIndex3 := map[string][]int{}\n    planet1PlanetsOrbitIndex4\
    \ := map[string][]int{}\n    planet2PlanetsOrbitIndex4 := map[string][]int{}\n\
    \    planet1PlanetsOrbitIndex5 := map[string][]int{}\n    planet2PlanetsOrbitIndex5\
    \ := map[string][]int{}\n    planet1PlanetsOrbitIndex6 := map[string][]int{}\n\
    \    planet2PlanetsOrbitIndex6 := map[string][]int{}\n    planet1PlanetsOrbitIndex7\
    \ := map[string][]int{}\n    planet2PlanetsOrbitIndex7 := map[string][]int{}\n\
    \    planet1PlanetsOrbitIndex8 := map[string][]int{}\n    planet2PlanetsOrbitIndex8\
    \ := map[string][]int{}\n    planet1PlanetsOrbitIndex9 := map[string][]int{}\n\
    \    planet2PlanetsOrbitIndex9 := map[string][]int{}\n    planet1PlanetsOrbitIndex10\
    \ := map[string][]int{}\n    planet2Plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgm0r59ez_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance, err :=\
    \ getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunDistance, err := getDistance(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ = planet1SunDistance * planet1Orbit.Radius\n    planet2SunDistance = planet2SunDistance\
    \ * planet2Orbit.Radius\n    planet1SunDistance = planet1SunDistance / planet1Orbit.Radius\n\
    \    planet2SunDistance = planet2SunDistance / planet2Orbit.Radius\n    planet1SunDistance\
    \ = planet1SunDistance * planet1Orbit.Radius\n    planet2SunDistance = planet2SunDistance\
    \ * planet2Orbit.Radius\n    planet1SunDistance = planet1SunDistance / planet1Orbit.Radius\n\
    \    planet2SunDistance = planet2SunDistance / planet2Orbit.Radius\n    planet1SunDistance\
    \ = planet1SunDistance * planet1Orbit.Radius\n    planet2SunDistance = planet2SunDistance\
    \ * planet2Orbit.Radius\n    planet1SunDistance = planet1SunDistance / planet1Orbit.Radius\n\
    \    planet2SunDistance = planet2SunDistance / planet2Orbit.Radius\n    planet1SunDistance\
    \ = planet1SunDistance * planet1Orbit.Radius\n    planet2SunDistance = planet2SunDistance\
    \ * planet2Orbit.Radius\n    planet1SunDistance = planet1Sun\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpne6kqbrb_test.go:64:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5u0o_khx_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    \n    planet1Planets := []string{planet1, planet2}\n\
    \    planet2Planets := []string{planet2, planet1}\n    \n    planet1Planets =\
    \ append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    \n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    \n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    \n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiev2zbwe_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius\
    \ := getOrbit(planet1)\n    planet2Orbit, planet2OrbitRadius := getOrbit(planet2)\n\
    \    \n    planet1Sun, planet1SunRadius := getSun(planet1)\n    planet2Sun, planet2SunRadius\
    \ := getSun(planet2)\n    \n    planet1Distance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2Distance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1Proximity\
    \ := getProximity(planet1OrbitRadius, planet1SunRadius, planet2OrbitRadius, planet2SunRadius)\n\
    \    planet2Proximity := getProximity(planet2OrbitRadius, planet2SunRadius, planet1OrbitRadius,\
    \ planet1SunRadius)\n    \n    planet1ProximityList := []interface{}{}\n    planet2ProximityList\
    \ := []interface{}{}\n    \n    if planet1Proximity < planet2Proximity {\n   \
    \     planet1ProximityList = append(planet1ProximityList, planet1)\n        planet1ProximityList\
    \ = append(planet1ProximityList, planet2)\n    } else {\n        planet2ProximityList\
    \ = append(planet2ProximityList, planet1)\n        planet2ProximityList = append(planet2ProximityList,\
    \ planet2)\n    }\n    \n    planet1ProximityList = sortByProximity(planet1ProximityList)\n\
    \    planet2ProximityList = sortByProximity(planet2ProximityList)\n    \n    return\
    \ planet1ProximityList\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdgrutzht_test.go:22:13: no new variables on left side of :=

    /tmp/tmpdgrutzht_test.go:23:13: no new variables on left side of :=

    /tmp/tmpdgrutzht_test.go:25:41: undefined: getOrbit

    /tmp/tmpdgrutzht_test.go:26:41: undefined: getOrbit

    /tmp/tmpdgrutzht_test.go:28:37: undefined: getSun

    /tmp/tmpdgrutzht_test.go:29:37: undefined: getSun

    /tmp/tmpdgrutzht_test.go:31:24: undefined: getDistance

    /tmp/tmpdgrutzht_test.go:32:24: undefined: getDistance

    /tmp/tmpdgrutzht_test.go:34:25: undefined: getProximity

    /tmp/tmpdgrutzht_test.go:35:25: undefined: getProximity

    /tmp/tmpdgrutzht_test.go:35:25: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprv3e6zbf_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{planet1, planet2}\n    planet2Planets := []string{planet2,\
    \ planet1}\n    planet1PlanetsSorted := []string{}\n    planet2PlanetsSorted :=\
    \ []string{}\n    planet1PlanetsSortedByDistance := []string{}\n    planet2PlanetsSortedByDistance\
    \ := []string{}\n    planet1PlanetsSortedByDistanceByPlanet1 := []string{}\n \
    \   planet2PlanetsSortedByDistanceByPlanet1 := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2\
    \ := []string{}\n    planet2PlanetsSortedByDistanceByPlanet2 := []string{}\n \
    \   planet1PlanetsSortedByDistanceByPlanet1ByPlanet2 := []string{}\n    planet2PlanetsSortedByDistanceByPlanet1ByPlanet2\
    \ := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2ByPlanet1 := []string{}\n\
    \    planet2PlanetsSortedByDistanceByPlanet2ByPlanet1 := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2\
    \ := []string{}\n    planet2PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2\
    \ := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet1\
    \ := []string{}\n    planet2PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet1\
    \ := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet1ByPlanet2\
    \ := []string{}\n    planet2PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet1ByPlanet2\
    \ := []string{}\n    planet1PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet1ByPlanet2ByPlanet1\
    \ := []string{}\n    planet2PlanetsSortedByDistanceByPlanet2ByPlanet1ByPlanet2ByPlanet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa5okqa9g_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n\
    \    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsx4nnvag_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{planet1, planet2}\n    planet2Planets := []string{planet2,\
    \ planet1}\n    planet1PlanetsPlanets := []string{planet1, planet2}\n    planet2PlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanets := []string{planet1,\
    \ planet2}\n    planet2PlanetsPlanetsPlanets := []string{planet2, planet1}\n \
    \   planet1PlanetsPlanetsPlanetsPlanets := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet2, planet1}\n    planet1PlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanetsPlanets\
    \ := []string{planet1, planet2}\n    planet2PlanetsPlanetsPlanetsPlan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcaqauflo_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    if planet1SunDistance < planet2SunDistance {\n        planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    }\n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Sun),\
    \ planet2Orbit.Orbit(planet2Sun)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Orbit.Orbit(planet2Orbit)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Orbit.Orbit(planet2Orbit)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Orbit.Orbit(planet2Orbit)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Orbit.Orbit(planet2Orbit)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Orbit.Orbit(planet2Orbit)\n    planet1Orbit, planet2Orbit = planet1Orbit.Orbit(planet1Orbit),\
    \ planet2Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo7r8vuns_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2,\
    \ planet2Sun)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n\
    \    planet2OrbitSun := orbit(planet2, planet2Sun)\n    planet1OrbitSun := orbit(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2,\
    \ planet2Sun)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n\
    \    planet2OrbitSun := orbit(planet2, planet2Sun)\n    planet1OrbitSun := orbit(planet1,\
    \ planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSun := orbit(planet1, planet1Sun)\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx7msshfo_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planets := []string{planet1, planet2}\n    planet2Planets := []string{planet2,\
    \ planet1}\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(planet1Planets,\
    \ planet2)\n    planet2Planets = append(planet2Planets, planet1)\n    planet1Planets\
    \ = append(planet1Planets, planet2)\n    planet2Planets = append(planet2Planets,\
    \ planet1)\n    planet1Planets = append(planet1Planets, planet2)\n    planet2Planets\
    \ = append(planet2Planets, planet1)\n    planet1Planets = append(\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppfpb2ljf_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    \n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, planet1OrbitElement := range planet1Orbit {\n        for\
    \ _, planet2OrbitElement := range planet2Orbit {\n            if planet1OrbitElement\
    \ < planet2OrbitElement {\n                planet1OrbitElement = planet1OrbitElement\
    \ + 1\n            } else {\n                planet2OrbitElement = planet2OrbitElement\
    \ + 1\n            }\n            \n            if planet1OrbitElement == planet2OrbitElement\
    \ {\n                result = append(result, planet1OrbitElement)\n          \
    \  }\n        }\n    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bjrog0u_test.go:22:13: no new variables on left side of :=

    /tmp/tmp_bjrog0u_test.go:22:16: undefined: strings

    /tmp/tmp_bjrog0u_test.go:23:13: no new variables on left side of :=

    /tmp/tmp_bjrog0u_test.go:23:16: undefined: strings

    /tmp/tmp_bjrog0u_test.go:25:21: undefined: orbit

    /tmp/tmp_bjrog0u_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi6o6oh2v_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1Distance\
    \ := distance(planet1Orbit, planet1Sun)\n    planet2Distance := distance(planet2Orbit,\
    \ planet2Sun)\n    planet1Distance += planet1Distance\n    planet2Distance +=\
    \ planet2Distance\n    planet1Distance /= 2\n    planet2Distance /= 2\n    planet1Distance\
    \ += planet2Distance\n    planet2Distance += planet1Distance\n    planet1Distance\
    \ /= 2\n    planet2Distance /= 2\n    planet1Distance += planet2Distance\n   \
    \ planet2Distance += planet1Distance\n    planet1Distance /= 2\n    planet2Distance\
    \ /= 2\n    planet1Distance += planet2Distance\n    planet2Distance += planet1Distance\n\
    \    planet1Distance /= 2\n    planet2Distance /= 2\n    planet1Distance += planet2Distance\n\
    \    planet2Distance += planet1Distance\n    planet1Distance /= 2\n    planet2Distance\
    \ /= 2\n    planet1Distance += planet2Distance\n    planet2Distance += planet1Distance\n\
    \    planet1Distance /= 2\n    planet2Distance /= 2\n    planet1Distance += planet2Distance\n\
    \    planet2Distance += planet1Distance\n    planet1Distance /= 2\n    planet2Distance\
    \ /= 2\n    planet1Distance += planet2Distance\n    planet2Distance += planet1Distance\n\
    \    planet1Distance /= 2\n    planet2Distance /= 2\n    planet1Distance += planet2Distance\n\
    \    planet2Distance += planet1Distance\n    planet1Distance /= 2\n    planet2Distance\
    \ /= 2\n    planet1Distance += planet2Distance\n    planet2Distance += planet1Distance\n\
    \    planet1Distance /= 2\n    planet2Distance /= 2\n    planet1Distance += planet2Distance\n\
    \    planet2Distance += planet1Distance\n    planet1Distance /= 2\n    planet2Distance\
    \ /= 2\n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_3ip3mmy_test.go:73:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := sun(planet1, planet2)\n    planet1SunProximity := planet1Orbit\
    \ - planet1Sun\n    planet2SunProximity := planet2Orbit - planet2Sun\n    planet1SunProximity\
    \ = planet1SunProximity / planet1Orbit\n    planet2SunProximity = planet2SunProximity\
    \ / planet2Orbit\n    planet1SunProximity = planet1SunProximity * planet1Orbit\n\
    \    planet2SunProximity = planet2SunProximity * planet2Orbit\n    planet1SunProximity\
    \ = planet1SunProximity / planet1Orbit\n    planet2SunProximity = planet2SunProximity\
    \ / planet2Orbit\n    planet1SunProximity = planet1SunProximity * planet1Orbit\n\
    \    planet2SunProximity = planet2SunProximity * planet2Orbit\n    planet1SunProximity\
    \ = planet1SunProximity / planet1Orbit\n    planet2SunProximity = planet2SunProximity\
    \ / planet2Orbit\n    planet1SunProximity = planet1SunProximity * planet1Orbit\n\
    \    planet2SunProximity = planet2SunProximity * planet2Orbit\n    planet1SunProximity\
    \ = planet1SunProximity / planet1Orbit\n    planet2SunProximity = planet2SunProximity\
    \ / planet2Orbit\n    planet1SunProximity = planet1SunProximity * planet1Orbit\n\
    \    planet2SunProximity = planet2SunProximity * planet2Orbit\n    planet1SunProximity\
    \ = planet1SunProximity / planet1Orbit\n    planet2SunProximity = planet2SunProximity\
    \ / planet2Orbit\n    planet1SunProximity = planet1SunProxim\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2c9mxrur_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2Sun, err := getSun(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity\
    \ := getProximity(planet1Orbit, planet1Sun)\n    planet2SunProximity := getProximity(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1Proximity := getProximity(planet1Orbit, planet1Orbit)\n\
    \    planet2Proximity := getProximity(planet2Orbit, planet2Orbit)\n    \n    planet1ProximitySorted\
    \ := getProximitySorted(planet1Proximity)\n    planet2ProximitySorted := getProximitySorted(planet2Proximity)\n\
    \    \n    planet1ProximitySortedSun := getProximitySortedSun(planet1ProximitySorted)\n\
    \    planet2ProximitySortedSun := getProximitySortedSun(planet2ProximitySorted)\n\
    \    \n    planet1ProximitySortedSunProximity := getProximitySortedSunProximity(planet1ProximitySortedSun)\n\
    \    planet2ProximitySortedSunProximity := getProximitySortedSunProximity(planet2ProximitySortedSun)\n\
    \    \n    planet1ProximitySortedSunProximitySorted := getProximitySortedSunProximitySorted(planet1ProximitySortedSunProximity)\n\
    \    planet2ProximitySortedSunProximitySorted := getProximitySortedSunProximitySorted(planet2ProximitySortedSunProximity)\n\
    \    \n    planet1ProximitySortedSunProx\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkdit7vhg_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    \n\
    \    planet1SunOrbit := orbit(planet1Sun)\n    planet2SunOrbit := orbit(planet2Sun)\n\
    \    \n    planet1SunSun := sun(planet1Sun)\n    planet2SunSun := sun(planet2Sun)\n\
    \    \n    planet1SunSunOrbit := orbit(planet1SunSun)\n    planet2SunSunOrbit\
    \ := orbit(planet2SunSun)\n    \n    planet1SunSunSun := sun(planet1SunSun)\n\
    \    planet2SunSunSun := sun(planet2SunSun)\n    \n    planet1SunSunSunOrbit :=\
    \ orbit(planet1SunSunSun)\n    planet2SunSunSunOrbit := orbit(planet2SunSunSun)\n\
    \    \n    planet1SunSunSunSun := sun(planet1SunSunSun)\n    planet2SunSunSunSun\
    \ := sun(planet2SunSunSun)\n    \n    planet1SunSunSunSunOrbit := orbit(planet1SunSunSunSun)\n\
    \    planet2SunSunSunOrbit := orbit(planet2SunSunSunSun)\n    \n    planet1SunSunSunSun\
    \ := sun(planet1SunSunSunSun)\n    planet2SunSunSunSun := sun(planet2SunSunSunSun)\n\
    \    \n    planet1SunSunSunSunOrbit := orbit(planet1SunSunSunSunSun)\n    planet2SunSunSunSunOrbit\
    \ := orbit(planet2SunSunSunSun)\n    \n    planet1SunSunSunSun := sun(planet1SunSunSunSun)\n\
    \    planet2SunSunSunSun := sun(planet2SunSunSunSun)\n    \n    planet1SunSunSunSunOrbit\
    \ := orbit(planet1SunSunSunSunSun)\n    planet2SunSunSunSunOrbit := orbit(planet2SunSunSunSun)\n\
    \    \n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6yyfp9ep_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.insert(planet2Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet1Orbit)\n\
    \    planet1Orbit.insert(planet1Orbit)\n    planet1Orbit.insert(planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9udzxdh5_test.go:56:31: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity := getSunProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2SunProximity := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    planet1OrbitProximity := getOrbitProximity(planet1Orbit, planet1Sun)\n  \
    \  planet2OrbitProximity := getOrbitProximity(planet2Orbit, planet2Sun)\n    planet1ProximityList\
    \ := getProximityList(planet1OrbitProximity)\n    planet2ProximityList := getProximityList(planet2OrbitProximity)\n\
    \    planet1ProximityListSorted := sortProximityList(planet1ProximityList)\n \
    \   planet2ProximityListSorted := sortProximityList(planet2ProximityList)\n  \
    \  planet1ProximityListSortedBySun := sortProximityListBySun(planet1ProximityListSorted)\n\
    \    planet2ProximityListSortedBySun := sortProximityListBySun(planet2ProximityListSorted)\n\
    \    planet1ProximityListSortedByOrbit := sortProximityListByOrbit(planet1ProximityListSortedBySun)\n\
    \    planet2ProximityListSortedByOrbit := sortProximityListByOrbit(planet2ProximityListSortedBySun)\n\
    \    planet1ProximityListSortedByProximityList := sortProximityListByProximityList(planet1ProximityListSortedByOrbit)\n\
    \    planet2ProximityListSortedByProximityList := sortProximityListByProximityList(planet2ProximityListSortedByOrbit)\n\
    \    planet1ProximityListSortedByProximityListSorted := sortProximityListByProximityListSorted(planet1ProximityListSortedByProximityList)\n\
    \    planet2ProximityListSorted\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2lf0oiyw_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity := getSunProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2SunProximity := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    planet1Proximity := getProximity(planet1Orbit, planet1Sun)\n    planet2Proximity\
    \ := getProximity(planet2Orbit, planet2Sun)\n    planet1ProximitySorted := getProximitySorted(planet1Proximity)\n\
    \    planet2ProximitySorted := getProximitySorted(planet2Proximity)\n    planet1ProximitySortedSorted\
    \ := getProximitySortedSorted(planet1ProximitySorted)\n    planet2ProximitySortedSorted\
    \ := getProximitySortedSorted(planet2ProximitySorted)\n    planet1ProximitySortedSortedSorted\
    \ := getProximitySortedSortedSorted(planet1ProximitySortedSorted)\n    planet2ProximitySortedSortedSorted\
    \ := getProximitySortedSortedSorted(planet2ProximitySortedSorted)\n    planet1ProximitySortedSortedSortedSorted\
    \ := getProximitySortedSortedSortedSorted(planet1ProximitySortedSortedSorted)\n\
    \    planet2ProximitySortedSortedSortedSorted := getProximitySortedSortedSortedSorted(planet2ProximitySortedSortedSorted)\n\
    \    planet1ProximitySortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSorted(planet1ProximitySortedSortedSortedSorted)\n\
    \    planet2ProximitySortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSorted(planet2ProximitySortedSortedSortedSorted)\n\
    \    planet1ProximitySortedSortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSortedSorted(planet1ProximitySortedSortedSortedSorted\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvt08y66p_test.go:40:150: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    \n\
    \    planet1SunDistance := distance(planet1Sun, planet1Orbit)\n    planet2SunDistance\
    \ := distance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance := distance(planet1Orbit,\
    \ planet1Sun)\n    planet2OrbitDistance := distance(planet2Orbit, planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposoe41uh_test.go:69:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1Orbit(planet1)\n    planet2Orbit := planet2Orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.intersect(planet2Orbit)\n\
    \    return planet1Orbit.slice()\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfoeyd_kp_test.go:22:21: undefined: planet1Orbit

    /tmp/tmpfoeyd_kp_test.go:23:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    result := []interface{}{}\n\
    \    \n    for _, planet := range planet1Orbit {\n        if planet == planet2\
    \ {\n            result = append(result, planet)\n        }\n    }\n    \n   \
    \ for _, planet := range planet2Orbit {\n        if planet == planet1 {\n    \
    \        result = append(result, planet)\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04m_6ljv_test.go:22:21: undefined: orbit

    /tmp/tmp04m_6ljv_test.go:23:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074435
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1OrbitSun\
    \ := orbit(planet1, planet1Sun)\n    planet2OrbitSun := orbit(planet2, planet2Sun)\n\
    \    planet1OrbitSunAndPlanet2Orbit := orbit(planet1, planet1Sun, planet2OrbitSun)\n\
    \    planet2OrbitSunAndPlanet1Orbit := orbit(planet2, planet2OrbitSun, planet1OrbitSun)\n\
    \    planet1OrbitSunAndPlanet2OrbitAndPlanet1Orbit := orbit(planet1, planet1Sun,\
    \ planet2OrbitSun, planet1OrbitSun)\n    planet2OrbitSunAndPlanet1OrbitAndPlanet2Orbit\
    \ := orbit(planet2, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunAndPlanet2OrbitAndPlanet1OrbitAndPlanet2Orbit\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet1OrbitSunAndPlanet2OrbitAndPlanet1OrbitAndPlanet2OrbitAndPlanet1Orbit\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun)\n    planet1OrbitSunAndPlanet2OrbitAndPlanet1OrbitAndPlanet2OrbitAndPlanet1OrbitAndPlanet2Orbit\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunAndPlanet2OrbitAndPlanet1OrbitAndPlanet2OrbitAndPlanet1OrbitAndPlanet2OrbitAndPlanet1Orbit\
    \ := orbit(planet1, \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1v82cq01_test.go:36:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    planet1Orbit.intersect(planet2Orbit)\n\
    \    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegycdbql_test.go:22:21: undefined: getOrbit

    /tmp/tmpegycdbql_test.go:23:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1Sun, planet2Sun := orbit(planet1,\
    \ planet2)\n    planet1SunOrbit, planet2SunOrbit := orbit(planet1, planet2)\n\
    \    planet1SunOrbitSun, planet2SunOrbitSun := orbit(planet1, planet2)\n    planet1OrbitSunSun,\
    \ planet2OrbitSunSun := orbit(planet1, planet2)\n    planet1OrbitSunOrbit, planet2OrbitSunOrbit\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSun, planet2OrbitSunOrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSunOrbitSun\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpno8xsvbq_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    planet1Orbit.intersect(planet2Orbit)\n\
    \    \n    return planet1Orbit.slice()\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzh5w9zo8_test.go:22:21: undefined: orbit

    /tmp/tmpzh5w9zo8_test.go:23:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSun\
    \ := getOrbit(planet1)\n    planet2OrbitSun := getOrbit(planet2)\n    planet1SunSun\
    \ := getSun()\n    planet2SunSun := getSun()\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun := getOrbit(planet1)\n\
    \    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5mw08nu8_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnrjs4uig_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    \n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    \n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getProximity(planet2Orbit, planet2Sun)\n    \n   \
    \ planet1Proximity := getProximity(planet1Orbit, planet1Orbit)\n    planet2Proximity\
    \ := getProximity(planet2Orbit, planet2Orbit)\n    \n    planet1ProximitySorted\
    \ := getProximitySorted(planet1Proximity)\n    planet2ProximitySorted := getProximitySorted(planet2Proximity)\n\
    \    \n    planet1ProximitySortedSorted := getProximitySortedSorted(planet1ProximitySorted)\n\
    \    planet2ProximitySortedSorted := getProximitySortedSorted(planet2ProximitySorted)\n\
    \    \n    planet1ProximitySortedSortedSorted := getProximitySortedSortedSorted(planet1ProximitySortedSorted)\n\
    \    planet2ProximitySortedSortedSorted := getProximitySortedSortedSorted(planet2ProximitySortedSorted)\n\
    \    \n    planet1ProximitySortedSortedSortedSorted := getProximitySortedSortedSortedSorted(planet1ProximitySortedSortedSorted)\n\
    \    planet2ProximitySortedSortedSortedSorted := getProximitySortedSortedSortedSorted(planet2ProximitySortedSortedSorted)\n\
    \    \n    planet1ProximitySortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSorted(planet1ProximitySortedSortedSortedSorted)\n\
    \    planet2ProximitySortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSorted(planet2ProximitySortedSortedSortedSorted)\n\
    \    \n    planet1ProximitySortedSortedSortedSortedSortedSorted := getProximitySortedSortedSortedSortedSorted\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmv0aitti_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    // Your code here\n    planet1 := planet1\n    planet2 := planet2\n \
    \   planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\n    planet1OrbitSunDistance := planet1\n\
    \    planet2OrbitSunDistance := planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9qum9vc5_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Planet, err := planetToPlanet(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Planet, err := planetToPlanet(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet, err\
    \ = planetToPlanet(planet1)\n    if err != nil {\n        fmt.Println(err)\n \
    \   }\n    planet2Planet, err = planetToPlanet(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1Planet, err = planetToPlanet(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Planet, err\
    \ = planetToPlanet(planet2)\n    if err != nil {\n        fmt.Println(err)\n \
    \   }\n    planet1Planet, err = planetToPlanet(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Planet, err = planetToPlanet(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet, err\
    \ = planetToPlanet(planet1)\n    if err != nil {\n        fmt.Println(err)\n \
    \   }\n    planet2Planet, err = planetToPlanet(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1Planet, err = planetToPlanet(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Planet, err\
    \ = planetToPlanet(planet2)\n    if err != nil {\n        fmt.Println(err)\n \
    \   }\n    planet1Planet, err = planetToPlanet(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Planet, err = planetToPlanet(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet, err\
    \ = planetToPlanet(planet1)\n    if err != nil {\n        fmt.Println(err)\n \
    \   }\n    planet2Planet, err = planetToPlanet(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1Planet, err = planetToPlanet(\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm5rdc5e8_test.go:87:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := planet1OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun :=\
    \ planet2OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun.([]interface{})\n\
    \    planet1OrbitSun, planet2OrbitSun := planet2OrbitSun.([]interface{})\n   \
    \ planet1OrbitSun, planet2OrbitSun := planet1OrbitSun.([]interface{})\n    planet1OrbitSun,\
    \ planet2OrbitSun := planet2OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun\
    \ := planet1OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun :=\
    \ planet2OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun.([]interface{})\n\
    \    planet1OrbitSun, planet2OrbitSun := planet2OrbitSun.([]interface{})\n   \
    \ planet1OrbitSun, planet2OrbitSun := planet1OrbitSun.([]interface{})\n    planet1OrbitSun,\
    \ planet2OrbitSun := planet2OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun\
    \ := planet1OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun :=\
    \ planet2OrbitSun.([]interface{})\n    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun.([]interface{})\n\
    \    planet1OrbitSun, planet2OrbitSun := planet2OrbitSun.([]interface{})\n   \
    \ planet1OrbitSun, planet2OrbitSun := plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzrvjoqjy_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n\
    \    planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2qddh58e_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = strings.ToLower(planet1),\
    \ strings.ToLower(planet2)\n    planet1, planet2 = strings.Trim(planet1, \" \"\
    ), strings.Trim(planet2, \" \")\n    planet1, planet2 = strings.ToUpper(planet1),\
    \ strings.ToUpper(planet2)\n    planet1, planet2 = strings.Replace(planet1, \"\
    \ \", \"\"), strings.Replace(planet2, \" \", \"\")\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"-\", \"\"), strings.Replace(planet2, \"-\", \"\")\n    planet1, planet2 =\
    \ strings.Replace(planet1, \"/\", \"\"), strings.Replace(planet2, \"/\", \"\"\
    )\n    planet1, planet2 = strings.Replace(planet1, \"\\\\\", \"\"), strings.Replace(planet2,\
    \ \"\\\\\", \"\")\n    planet1, planet2 = strings.Replace(planet1, \"'\", \"\"\
    ), strings.Replace(planet2, \"'\", \"\")\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"-\", \"\"), strings.Replace(planet2, \"-\", \"\")\n    planet1, planet2 =\
    \ strings.Replace(planet1, \"\\\\\", \"\"), strings.Replace(planet2, \"\\\\\"\
    , \"\")\n    planet1, planet2 = strings.Replace(planet1, \"'\", \"\"), strings.Replace(planet2,\
    \ \"'\", \"\")\n    planet1, planet2 = strings.Replace(planet1, \"/\", \"\"),\
    \ strings.Replace(planet2, \"/\", \"\")\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"\\\\\", \"\"), strings.Replace(planet2, \"\\\\\", \"\")\n    planet1, planet2\
    \ = strings.Replace(planet1, \"-\", \"\"), strings.Replace(planet2, \"-\", \"\"\
    )\n    planet1, planet2 = strings.Replace(planet1, \"\\\\\", \"\"), strings.Replace(planet2,\
    \ \"\\\\\", \"\")\n    planet1, planet2 = strings.Replace(planet1, \"'\", \"\"\
    ), strings.Replace(planet2, \"'\", \"\")\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"/\", \"\"), strings.Replace(planet2, \"/\", \"\")\n    planet1, planet2 =\
    \ strings.Replace(planet1, \"\\\\\", \"\"), strings.Replace(planet2, \"\\\\\"\
    , \"\")\n    planet1, planet2 = strings.Replace(planet1, \"-\", \"\"), strings.Replace(planet2,\
    \ \"-\", \"\")\n    planet1, planet2 = strings.Replace(planet1, \"\\\\\", \"\"\
    ), strings.Replace(planet2, \"\\\\\", \"\")\n    planet1, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpka3ynme__test.go:43:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    result := make([]interface{},\
    \ 0)\n    for _, planet1OrbitItem := range planet1Orbit {\n        for _, planet2OrbitItem\
    \ := range planet2Orbit {\n            if planet1OrbitItem == planet2OrbitItem\
    \ {\n                continue\n            }\n            if planet1OrbitItem\
    \ < planet2OrbitItem {\n                planet1OrbitItem = planet1OrbitItem +\
    \ 1\n            } else {\n                planet2OrbitItem = planet2OrbitItem\
    \ + 1\n            }\n            if planet1OrbitItem == planet2OrbitItem {\n\
    \                planet1OrbitItem = planet1OrbitItem + 1\n            }\n    \
    \        if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem == planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem == planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem == planet2OrbitItem\
    \ {\n                planet1OrbitItem = planet1OrbitItem + 1\n            }\n\
    \            if planet1OrbitItem < planet2OrbitItem {\n                planet1OrbitItem\
    \ = planet1OrbitItem + 1\n            } else {\n                planet2OrbitItem\
    \ = planet2OrbitItem + 1\n            }\n            if planet1OrbitItem == \n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ow1sdjx_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1\n\
    \    planet2OrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n   \
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3vz1f4jk_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopcvle5m_test.go:22:35: undefined: getOrbits

    /tmp/tmpopcvle5m_test.go:23:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1Planet, planet2Planet\
    \ := planet1, planet2\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Planet, planet2Planet = planet1Planet[:len(planet1Planet)-1],\
    \ planet2Planet[:len(planet2Planet)-1]\n    planet1Plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfm7yh65v_test.go:36:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdykrr83g_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1Orbit(planet1), planet2Orbit(planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n\
    \    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit,\
    \ \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n \
    \   planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"\
    Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"Sun\")\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n \
    \   planet2Orbit = append(planet2Orbit, \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet1Orbit...)\n    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit,\
    \ \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n \
    \   planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"\
    Sun\")\n    \n    planet1Orbit = \nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkz_48o8a_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := planet1Orbit(planet1), planet2Orbit(planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n\
    \    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit,\
    \ \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n \
    \   planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2isyc7kn_test.go:55:34: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitOrbit\
    \ := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n    planet1OrbitOrbitOrbit\
    \ := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1OrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_12spkwi_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps40fvcad_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortPlanets(planet1Orbit, planet2Orbit)\n    planet1Orbit, planet2Orbit\
    \ = removeDuplicates(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5l8fp8tf_test.go:22:35: undefined: getOrbits

    /tmp/tmp5l8fp8tf_test.go:23:34: undefined: sortPlanets

    /tmp/tmp5l8fp8tf_test.go:24:34: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4tlwqur_test.go:81:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n\
    \    planet1Sun := sun(planet1)\n    planet2Sun := sun(planet2)\n    planet1SunOrbit\
    \ := orbit(planet1Sun)\n    planet2SunOrbit := orbit(planet2Sun)\n    planet1SunOrbitDistance\
    \ := distance(planet1Orbit, planet1SunOrbit)\n    planet2SunOrbitDistance := distance(planet2Orbit,\
    \ planet2SunOrbit)\n    planet1SunOrbitDistance < planet2SunOrbitDistance ? planet1Orbit\
    \ : planet2Orbit\n    planet1OrbitDistance := distance(planet1Orbit, planet2Orbit)\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet2Orbit : planet1Orbit\n\
    \    planet1OrbitDistance < planet2OrbitDistance ? planet1Orbit : planet2Orbit\n\
    \    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphi2nisnd_test.go:30:55: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmkcgx2_test.go:22:35: undefined: getOrbits

    /tmp/tmphmmkcgx2_test.go:23:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074430
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprwya63_o_test.go:64:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit :=\
    \ planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n\
    \    planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp77nwrp88_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074431
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprv3e6zbf_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := planet1\n    planet2 := planet2\n    \n    if planet1 == \"\
    Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\"\
    \ || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\"\
    \ || planet1 == \"Neptune\" {\n        return nil\n    }\n    if planet2 == \"\
    Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\"\
    \ || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\" {\n        return nil\n    }\n    \n    planet1 :=\
    \ planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 :=\
    \ planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1\
    \ := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n    planet2\
    \ := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n    \n   \
    \ planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n \
    \   planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := \nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijp2xl9m_test.go:85:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = strings.ToLower(planet1),\
    \ strings.ToLower(planet2)\n    planet1, planet2 = strings.Trim(planet1, \" \"\
    ), strings.Trim(planet2, \" \")\n    planet1, planet2 = strings.ToUpper(planet1),\
    \ strings.ToUpper(planet2)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet2, \"M\", \"Mercury\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"V\", \"Venus\", -1), strings.Replace(planet2,\
    \ \"V\", \"Venus\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"E\"\
    , \"Earth\", -1), strings.Replace(planet2, \"E\", \"Earth\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"M\", \"Mars\", -1), strings.Replace(planet2,\
    \ \"M\", \"Mars\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"J\"\
    , \"Jupiter\", -1), strings.Replace(planet2, \"J\", \"Jupiter\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"S\", \"Saturn\", -1), strings.Replace(planet2,\
    \ \"S\", \"Saturn\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"U\"\
    , \"Uranus\", -1), strings.Replace(planet2, \"U\", \"Uranus\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"N\", \"Neptune\", -1), strings.Replace(planet2,\
    \ \"N\", \"Neptune\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"\
    M\", \"Mercury\", -1), strings.Replace(planet2, \"M\", \"Mercury\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"V\", \"Venus\", -1), strings.Replace(planet2,\
    \ \"V\", \"Venus\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"E\"\
    , \"Earth\", -1), strings.Replace(planet2, \"E\", \"Earth\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"M\", \"Mars\", -1), strings.Replace(planet2,\
    \ \"M\", \"Mars\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"J\"\
    , \"Jupiter\", -1), strings.Replace(planet2, \"J\", \"Jupiter\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8tugf2_9_test.go:39:49: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprv3e6zbf_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074436
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1.ToLower(),\
    \ planet2.ToLower()\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9s3kzg6s_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074429
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nfunc bf(planet1 string, planet2 string) []interface{}\
    \ {\n    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    \n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9hnr9a9v_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
