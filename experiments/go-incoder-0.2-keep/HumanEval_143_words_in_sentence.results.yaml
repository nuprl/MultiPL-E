language: go_test.go
name: HumanEval_143_words_in_sentence
results:
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            result += word\n        }\n\
    \    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n \
    \ candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfm1tce8t_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += word\n          \
    \  }\n        } else {\n            if isPrime(length) && isPrime(length-1) {\n\
    \                result += word\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplwijoby3_test.go:23:14: undefined: strings

    /tmp/tmplwijoby3_test.go:31:16: undefined: isPrime

    /tmp/tmplwijoby3_test.go:35:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        } else {\n            result += \"\\n\"\
    \ + word + \"\\n\"\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqcmefplc_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bfwxsp0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += \" \" + word\n  \
    \          }\n            continue\n        }\n        if length == 4 {\n    \
    \        if isPrime(length) {\n                result += \" \" + word\n      \
    \      }\n            continue\n        }\n        if length == 5 || length ==\
    \ 6 || length == 7 || length == 8 {\n            if isPrime(length) {\n      \
    \          result += \" \" + word\n            }\n            continue\n     \
    \   }\n        if length == 9 || length == 10 || length == 11 || length == 12\
    \ {\n            if isPrime(length) {\n                result += \" \" + word\n\
    \            }\n            continue\n        }\n        if length == 13 || length\
    \ == 14 || length == 15 || length == 16 {\n            if isPrime(length) {\n\
    \                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 17 || length == 18 || length == 19 || length\
    \ == 20 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 21\
    \ || length == 22 || length == 23 || length == 24 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 25 || length == 26 || length == 27 || length\
    \ == 28 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 29\
    \ || length == 30 || length == 31 || length == 32 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 33 || length == 34 || length == 35 || length\
    \ == 36 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 37\
    \ || length == 38 || length == 39 || length == 40  {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 41 || length == 42 || length == 43 || length\
    \ == 44 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 45\
    \ || length == 46 || length == 47 || length == 48 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 49 || length == 50 || length == 51 || length\
    \ == 52 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 53\
    \ || length == 54\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate :=\
    \ words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpea1nttwp_test.go:115:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\\"\" + word + \"\\\"\"\n        } else {\n            result\
    \ += \"\\\"\" + word + \"\\\" \" + word\n        }\n    }\n    return result\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3e1_w_7x_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        if isPrime(word) {\n           \
    \ result = result + \" \" + word\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppv64iib3_test.go:24:14: undefined: strings

    /tmp/tmppv64iib3_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   fmt.Println(length)\n            fmt.Println(word)\n        }\n        if\
    \ length == 2 {\n            result += word\n        }\n    }\n    return result\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy130slsl_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bfwxsp0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 1 {\n           \
    \ continue\n        }\n        if length == 2 && word[1] == 's' {\n          \
    \  continue\n        }\n        if length == 3 && word[1] == 's' && word[2] ==\
    \ 'w' {\n            continue\n        }\n        if length == 4 && word[1] ==\
    \ 's' && word[2] == 'w' && word[3] == 'm' {\n            continue\n        }\n\
    \        if length == 5 && word[1] == 's' && word[2] == 'w' && word[3] == 'm'\
    \ && word[4] == 'i' {\n            continue\n        }\n        if length == 6\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' {\n            continue\n        }\n        if length == 7 && word[1]\
    \ == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n'\
    \ && word[6] == 'g' {\n            continue\n        }\n        if length == 8\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' && word[6] == 'g' && word[7] == 'o' {\n            continue\n       \
    \ }\n        if length == 9 && word[1] == 's' && word[2] == 'w' && word[3] ==\
    \ 'm' && word[4] == 'i' && word[5] == 'n' && word[6] == 'g' && word[7] == 'o'\
    \ && word[8] == 'm' {\n            continue\n        }\n        if length == 10\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' && word[6] == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i'\
    \ {\n            continue\n        }\n        if length == 11 && word[1] == 's'\
    \ && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n' && word[6]\
    \ == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i' && word[10] ==\
    \ 'e' {\n            continue\n        }\n        if length == 12 && word[1] ==\
    \ 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n'\
    \ && word[6] == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i' && word[10]\
    \ == 'e' && word[11] == 's' {\n            continue\n        }\n        if length\
    \ == 13 && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i'\
    \ && word[5] == '\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate :=\
    \ words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgs2z03lx_test.go:63:111: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   length--\n        }\n        if length == 2 {\n            result = result\
    \ + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88jm3yo8_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bfwxsp0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   fmt.Println(length)\n            fmt.Println(word)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphyupc9h2_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        primes := make([]int, length)\n        for i\
    \ := 0; i < length; i++ {\n            primes[i] = true\n        }\n        for\
    \ i := 2; i < length; i++ {\n            if primes[i] {\n                for j\
    \ := 0; j < i; j++ {\n                    if primes[j] {\n                   \
    \     primes[j] = false\n                        break\n                    }\n\
    \                }\n            }\n        }\n        for _, prime := range primes\
    \ {\n            if prime {\n                result += \" \" + word\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxl_w74d2_test.go:23:14: undefined: strings

    /tmp/tmpxl_w74d2_test.go:32:25: cannot use true (untyped bool constant) as int
    value in assignment

    /tmp/tmpxl_w74d2_test.go:35:16: non-boolean condition in if statement

    /tmp/tmpxl_w74d2_test.go:37:24: non-boolean condition in if statement

    /tmp/tmpxl_w74d2_test.go:38:37: cannot use false (untyped bool constant) as int
    value in assignment

    /tmp/tmpxl_w74d2_test.go:45:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        primes := make([]bool, length+1)\n        primes[0]\
    \ = true\n        for i := 1; i < length; i++ {\n            if primes[i] {\n\
    \                primes[i+1] = true\n                for j := 2; i*j <= length;\
    \ j++ {\n                    primes[i*j] = false\n                }\n        \
    \    }\n        }\n        for i := 2; i < length; i++ {\n            if primes[i]\
    \ {\n                result += \" \" + word\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ixpndm3_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        primes := make([]int, length/2)\n        for\
    \ i := 0; i < length/2; i++ {\n            primes[i] = true\n        }\n     \
    \   for i := 2; i < length; i++ {\n            if primes[i] {\n              \
    \  for j := 0; j < i; j++ {\n                    if primes[j] {\n            \
    \            primes[j] = false\n                        primes[i*j] = true\n \
    \                       break\n                    }\n                }\n    \
    \        }\n        }\n        for _, prime := range primes {\n            if\
    \ prime {\n                result += \" \" + word\n            }\n        }\n\
    \    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n \
    \ candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp89dt9tio_test.go:23:14: undefined: strings

    /tmp/tmp89dt9tio_test.go:32:25: cannot use true (untyped bool constant) as int
    value in assignment

    /tmp/tmp89dt9tio_test.go:35:16: non-boolean condition in if statement

    /tmp/tmp89dt9tio_test.go:37:24: non-boolean condition in if statement

    /tmp/tmp89dt9tio_test.go:38:37: cannot use false (untyped bool constant) as int
    value in assignment

    /tmp/tmp89dt9tio_test.go:39:39: cannot use true (untyped bool constant) as int
    value in assignment

    /tmp/tmp89dt9tio_test.go:46:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 1 {\n           \
    \ continue\n        }\n        if length == 2 && word[0] != \"a\" && word[1] !=\
    \ \"a\" {\n            continue\n        }\n        if length == 3 && word[0]\
    \ != \"a\" && word[1] != \"a\" && word[2] != \"a\" {\n            continue\n \
    \       }\n        if length == 4 && word[0] != \"a\" && word[1] != \"a\" && word[2]\
    \ != \"a\" && word[3] != \"a\" {\n            continue\n        }\n        if\
    \ length == 5 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" {\n            continue\n        }\n        if\
    \ length == 6 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" && word[5] != \"a\" {\n            continue\n \
    \       }\n        if length == 7 && word[0] != \"a\" && word[1] != \"a\" && word[2]\
    \ != \"a\" && word[3] != \"a\" && word[4] != \"a\" && word[5] != \"a\" && word[6]\
    \ != \"a\" {\n            continue\n        }\n        if length == 8 && word[0]\
    \ != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4]\
    \ != \"a\" && word[5] != \"a\" && word[6] != \"a\" && word[7] != \"a\" {\n   \
    \         continue\n        }\n        if length == 9 && word[0] != \"a\" && word[1]\
    \ != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4] != \"a\" && word[5]\
    \ != \"a\" && word[6] != \"a\" && word[7] != \"a\" && word[8] != \"a\" {\n   \
    \         continue\n        }\n        if length == 10 && word[0] != \"a\" &&\
    \ word[1] != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4] != \"a\"\
    \ && word[5] != \"a\" && word[6] != \"a\" && word[7] != \"a\" && word[8] != \"\
    a\" && word[9] != \"a\" {\n            continue\n        }\n        if length\
    \ == 11 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" && word[5] != \"a\" && word[6] != \"a\" && word[7]\
    \ != \"a\" && word[8] != \"a\" && word[9] != \"a\" && word[10] != \"a\" {\n  \
    \          continue\n        }\n        if length == 12 && word[0] != \"a\" &&\
    \ word[1] != \"a\" && word[2] != \"a\" && word[3] \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp96muruwf_test.go:61:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%2 != 0 {\n            length--\n        }\n      \
    \  if length%2 != 0 {\n            length--\n        }\n        if length%2 !=\
    \ 0 {\n            length--\n        }\n        if length%2 != 0 {\n         \
    \   length--\n        }\n        if length%2 != 0 {\n            length--\n  \
    \      }\n        if length%\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgjrx5teg_test.go:139:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"(\" + word + \")\"\n        } else {\n            result += \"\
    (\" + word + \")\" + \" \"\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn33s00zv_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 != 0 {\n            continue\n        }\n        result += \"\\\"\"\
    \ + word + \"\\\"\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyrloxdxb_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073572
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        result += \"\\n\" + word\n    }\n    return result\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn_ly5mkb_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073572
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        if isPrime(word) {\n           \
    \ result += \" \" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkdbz_n4l_test.go:24:14: undefined: strings

    /tmp/tmpkdbz_n4l_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073572
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        } else {\n            result += \"\\n\"\
    \ + word[:length/2] + \" \" + word[length/2:]\n        }\n    }\n    return result\n\
    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspqdgr8y_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073572
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bfwxsp0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"(\" + word + \")\"\n        } else {\n            result += \"\
    (\" + word + \") \"\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptt70k583_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        result += \"\\\"\" + word + \"\\\" \" + length\n\
    \    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n \
    \ candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp36y6owoy_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length == 2 {\n            if isPrime(length) {\n                result += \"\
    \ \" + word\n            }\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqvcvnnen_test.go:24:14: undefined: strings

    /tmp/tmpqvcvnnen_test.go:29:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\\"\" + word + \"\\\"\"\n        } else {\n            result\
    \ += \"\\\"\" + word + \"\\\" \"\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxahl913_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"is\"\n        } else {\n            result += \"is not\"\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsp1iuw0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        primes := make([]bool, length+1)\n        primes[0]\
    \ = true\n        for i := 1; i < length; i++ {\n            if primes[i] {\n\
    \                for j := 2; i*j <= length; j++ {\n                    if i*j\
    \ == length {\n                        primes[j] = true\n                    \
    \    break\n                    }\n                    if primes[i*j] {\n    \
    \                    break\n                    }\n                }\n       \
    \     }\n        }\n        if primes[length] {\n            result += \" \" +\
    \ word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3489d8qo_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 ||\
    \ length == 4 || length == 5 || length == 6 || length == 7 || length == 8 || length\
    \ == 9 {\n            result += word\n            continue\n        }\n      \
    \  if length == 2 && isPrime(length) {\n            result += word\n         \
    \   continue\n        }\n        if length == 3 && isPrime(length) {\n       \
    \     result += word\n            continue\n        }\n        if length == 4\
    \ && isPrime(length) {\n            result += word\n            continue\n   \
    \     }\n        if length == 5 && isPrime(length) {\n            result += word\n\
    \            continue\n        }\n        if length == 6 && isPrime(length) {\n\
    \            result += word\n            continue\n        }\n        if length\
    \ == 7 && isPrime(length) {\n            result += word\n            continue\n\
    \        }\n        if length == 8 && isPrime(length) {\n            result +=\
    \ word\n            continue\n        }\n        if length == 9 && isPrime(length)\
    \ {\n            result += word\n            continue\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv5xg90sl_test.go:23:14: undefined: strings

    /tmp/tmpv5xg90sl_test.go:34:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:38:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:42:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:46:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:50:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:54:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:58:27: undefined: isPrime

    /tmp/tmpv5xg90sl_test.go:62:27: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 == 0 {\n            result += \"\\\"\" + word + \"\\\"\"\n        }\
    \ else {\n            result += \"\\\"\" + word + \"\\\" \"\n        }\n    }\n\
    \    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ly4o1lj_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length == 2 {\n            result += word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgxn2_o7g_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        if isPrime(word) {\n           \
    \ result += \" \" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkdbz_n4l_test.go:24:14: undefined: strings

    /tmp/tmpkdbz_n4l_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073572
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        result += \"\\\"\" + word + \"\\\" \" + length\
    \ + \"\\n\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttnjr39d_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"\\\"\" + word + \"\\\" \" + word\n    }\n    return\
    \ result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3r0ooct_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += word\n          \
    \  }\n            continue\n        }\n        if length == 4 || length == 5 ||\
    \ length == 6 || length == 7 || length == 8 || length == 9 {\n            if isPrime(length)\
    \ {\n                result += word\n            }\n            continue\n   \
    \     }\n        if length == 10 || length == 15 || length == 20 || length ==\
    \ 25 || length == 30 || length == 35 {\n            if isPrime(length) {\n   \
    \             result += word\n            }\n            continue\n        }\n\
    \        if length == 50 || length == 100 {\n            if isPrime(length) {\n\
    \                result += word\n            }\n            continue\n       \
    \ }\n        fmt.Println(\"error\")\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwd87fwp_test.go:23:14: undefined: strings

    /tmp/tmpxwd87fwp_test.go:31:16: undefined: isPrime

    /tmp/tmpxwd87fwp_test.go:37:16: undefined: isPrime

    /tmp/tmpxwd87fwp_test.go:43:16: undefined: isPrime

    /tmp/tmpxwd87fwp_test.go:49:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4iddi_lj_test.go:148:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 1 {\n         \
    \   continue\n        }\n        if length == 2 {\n            if word == \"a\"\
    \ || word == \"e\" || word == \"i\" || word == \"o\" || word == \"u\" {\n    \
    \            continue\n            }\n        }\n        if length == 3 {\n  \
    \          if word == \"a\" || word == \"e\" || word == \"i\" || word == \"o\"\
    \ || word == \"u\" || word == \"y\" {\n                continue\n            }\n\
    \        }\n        if length == 4 {\n            if word == \"a\" || word ==\
    \ \"e\" || word == \"i\" || word == \"o\" || word == \"u\" || word == \"y\" ||\
    \ word == \"s\" {\n                continue\n            }\n        }\n      \
    \  if length == 5 || length == 6 {\n            if word == \"a\" || word == \"\
    e\" || word == \"i\" || word == \"o\" || word == \"u\" || word == \"y\" || word\
    \ == \"s\" || word == \"d\" || word == \"f\" || word == \"g\" || word == \"h\"\
    \ || word == \"j\" || word == \"k\" || word == \"l\" || word == \"m\" || word\
    \ == \"n\" || word == \"p\" || word == \"q\" || word == \"r\" || word == \"s\"\
    \ || word == \"t\" || word == \"v\" || word == \"w\" || word == \"x\" || word\
    \ == \"y\" || word == \"z\" {\n                continue\n            }\n     \
    \   }\n        if length == 7 || length == 8 {\n            if word == \"a\" ||\
    \ word == \"e\" || word == \"i\" || word == \"o\" || word == \"u\" || word ==\
    \ \"y\" || word == \"s\" || word == \"d\" || word == \"f\" || word == \"g\" ||\
    \ word == \"h\" || word == \"j\" || word == \"k\" || word == \"l\" || word ==\
    \ \"m\" || word == \"n\" || word == \"p\" || word == \"q\" || word == \"r\" ||\
    \ word == \"s\" || word == \"t\" || word == \"v\" || word == \"w\" || word ==\
    \ \"x\" || word == \"y\" || word == \"z\" || word == \"a\" || word == \"e\" ||\
    \ word == \"i\" || word == \"o\" || word == \"u\" {\n                continue\n\
    \            }\n        }\n        if length == 9 || length == 10 {\n        \
    \    if word == \"a\" || word == \"e\" || word == \"i\" || word == \"o\" || word\
    \ == \"u\" || word == \"y\" || word == \"s\" || word == \"d\" || word == \"f\"\
    \ || word == \"g\" || word == \"h\" || word == \"j\" || word == \"k\" || word\
    \ == \"l\" || word == \"m\" || word == \"n\" || word == \"p\" || word == \"q\"\
    \ || word == \"r\" || word == \"s\" || word == \"t\" || word == \"v\" || word\
    \ \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl52qxolb_test.go:57:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\\"\" + word + \"\\\"\"\n        } else if length%2 == 1 {\n\
    \            result += \"\\\"\" + word + \"\\\" \" + word\n        }\n    }\n\
    \    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate\
    \ := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a\
    \ test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"\
    ), expected: \"go for\" },\n     { actual: candidate(\"there is no place available\
    \ here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I\
    \ am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go\
    \ for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected:\
    \ \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5d6pjn40_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += \" \" + word\n  \
    \          }\n            continue\n        }\n        if length == 4 || length\
    \ == 5 || length == 6 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 7 || length == 8 || length == 9 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 10 || length == 15 || length == 20 || length\
    \ == 25 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 13\
    \ || length == 16 || length == 17 || length == 18 || length == 19 {\n        \
    \    if isPrime(length) {\n                result += \" \" + word\n          \
    \  }\n            continue\n        }\n        if length == 14 || length == 21\
    \ || length == 24 || length == 27 || length == 28 || length == 29 || length ==\
    \ 30 {\n            if isPrime(length) {\n                result += \" \" + word\n\
    \            }\n            continue\n        }\n        if length == 15 || length\
    \ == 22 || length == 25 || length == 29 || length == 30 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 16 || length == 23 || length == 26 || length\
    \ == 29 || length == 30 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 17 || length == 24 || length == 27 || length == 30 {\n           \
    \ if isPrime(length) {\n                result += \" \" + word\n            }\n\
    \            continue\n        }\n        if length == 18 || length == 25 || length\
    \ == 28 || length == 30 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 19 || length == 26 || length == 29 || length == 30 {\n           \
    \ if isPrime(length) {\n                result += \" \" + word\n            }\n\
    \            continue\n        }\n        if length == 20 || length == 27 || length\
    \ == 30 {\n            if isPrime(length) {\n                result += \" \" +\
    \ word\n            }\n            continue\n        }\n        if length == 21\
    \ || length == 28 || length == 30 {\n            if isPrime(length) {\n      \
    \          result += \" \" + word\n            }\n            continue\n     \
    \   }\n        if length == 22 || length == 29 || length == 30 \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu5yrpc4r_test.go:109:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps6_la53v_test.go:278:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 != 0 {\n            continue\n        }\n        result += \"\\n\"\
    \ + word\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6xja9d0x_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%2 == 0 {\n         \
    \   length--\n        }\n        if length%2 == 0 {\n            length--\n  \
    \      }\n        if length%2 == 0 {\n            length--\n        }\n      \
    \  if length%2 == 0 {\n            length--\n        }\n        if length%2 ==\
    \ 0 {\n            length--\n        }\n        if length%\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_b4w0q1n_test.go:148:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 1 {\n           \
    \ continue\n        }\n        if length == 2 && word[1] == 's' {\n          \
    \  continue\n        }\n        if length == 3 && word[1] == 's' && word[2] ==\
    \ 'w' {\n            continue\n        }\n        if length == 4 && word[1] ==\
    \ 's' && word[2] == 'w' && word[3] == 'm' {\n            continue\n        }\n\
    \        if length == 5 && word[1] == 's' && word[2] == 'w' && word[3] == 'm'\
    \ && word[4] == 'i' {\n            continue\n        }\n        if length == 6\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' {\n            continue\n        }\n        if length == 7 && word[1]\
    \ == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n'\
    \ && word[6] == 'g' {\n            continue\n        }\n        if length == 8\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' && word[6] == 'g' && word[7] == 'o' {\n            continue\n       \
    \ }\n        if length == 9 && word[1] == 's' && word[2] == 'w' && word[3] ==\
    \ 'm' && word[4] == 'i' && word[5] == 'n' && word[6] == 'g' && word[7] == 'o'\
    \ && word[8] == 'm' {\n            continue\n        }\n        if length == 10\
    \ && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5]\
    \ == 'n' && word[6] == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i'\
    \ {\n            continue\n        }\n        if length == 11 && word[1] == 's'\
    \ && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n' && word[6]\
    \ == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i' && word[10] ==\
    \ 'n' {\n            continue\n        }\n        if length == 12 && word[1] ==\
    \ 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i' && word[5] == 'n'\
    \ && word[6] == 'g' && word[7] == 'o' && word[8] == 'm' && word[9] == 'i' && word[10]\
    \ == 'n' && word[11] == 'g' {\n            continue\n        }\n        if length\
    \ == 13 && word[1] == 's' && word[2] == 'w' && word[3] == 'm' && word[4] == 'i'\
    \ && word[5]\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3mf8j5yd_test.go:64:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 1 {\n           \
    \ continue\n        }\n        if length == 2 && word[0] != \"a\" && word[1] !=\
    \ \"a\" {\n            continue\n        }\n        if length == 3 && word[0]\
    \ != \"a\" && word[1] != \"a\" && word[2] != \"a\" {\n            continue\n \
    \       }\n        if length == 4 && word[0] != \"a\" && word[1] != \"a\" && word[2]\
    \ != \"a\" && word[3] != \"a\" {\n            continue\n        }\n        if\
    \ length == 5 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" {\n            continue\n        }\n        if\
    \ length == 6 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" && word[5] != \"a\" {\n            continue\n \
    \       }\n        if length == 7 && word[0] != \"a\" && word[1] != \"a\" && word[2]\
    \ != \"a\" && word[3] != \"a\" && word[4] != \"a\" && word[5] != \"a\" && word[6]\
    \ != \"a\" {\n            continue\n        }\n        if length == 8 && word[0]\
    \ != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4]\
    \ != \"a\" && word[5] != \"a\" && word[6] != \"a\" && word[7] != \"a\" {\n   \
    \         continue\n        }\n        if length == 9 && word[0] != \"a\" && word[1]\
    \ != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4] != \"a\" && word[5]\
    \ != \"a\" && word[6] != \"a\" && word[7] != \"a\" && word[8] != \"a\" {\n   \
    \         continue\n        }\n        if length == 10 && word[0] != \"a\" &&\
    \ word[1] != \"a\" && word[2] != \"a\" && word[3] != \"a\" && word[4] != \"a\"\
    \ && word[5] != \"a\" && word[6] != \"a\" && word[7] != \"a\" && word[8] != \"\
    a\" && word[9] != \"a\" {\n            continue\n        }\n        if length\
    \ == 11 && word[0] != \"a\" && word[1] != \"a\" && word[2] != \"a\" && word[3]\
    \ != \"a\" && word[4] != \"a\" && word[5] != \"a\" && word[6] != \"a\" && word[7]\
    \ != \"a\" && word[8] != \"a\" && word[9] != \"a\" && word[10] != \"a\" {\n  \
    \          continue\n        }\n        if length == 12 && word[0] != \"a\" &&\
    \ word[1] != \"a\" && word[2] != \"a\" && word[3] \nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp96muruwf_test.go:61:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 != 0 {\n            continue\n        }\n        result += \"\\n\"\
    \ + word\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6xja9d0x_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 != 0 {\n         \
    \   continue\n        }\n        for i := 2; i < length; i += 2 {\n          \
    \  if length%i == 0 {\n                result += word\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp30qlwrh__test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 == 0 {\n            result += \"is\"\n        } else if length%2 ==\
    \ 1 {\n            result += \"are\"\n        } else {\n            result +=\
    \ \"is\"\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphi_qokwl_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073574
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += \" \" + word\n  \
    \          }\n            continue\n        }\n        if length == 4 || length\
    \ == 5 || length == 6 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 7 || length == 8 || length == 9 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 10 || length == 15 || length == 20 {\n      \
    \      if isPrime(length) {\n                result += \" \" + word\n        \
    \    }\n            continue\n        }\n        if length == 13 || length ==\
    \ 17 || length == 19 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 14 || length == 18 || length == 20 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 16 || length == 18 || length == 20 {\n      \
    \      if isPrime(length) {\n                result += \" \" + word\n        \
    \    }\n            continue\n        }\n        if length == 17 || length ==\
    \ 19 || length == 20 {\n            if isPrime(length) {\n                result\
    \ += \" \" + word\n            }\n            continue\n        }\n        if\
    \ length == 18 || length == 20 {\n            if isPrime(length) {\n         \
    \       result += \" \" + word\n            }\n            continue\n        }\n\
    \        if length == 19 || length == 20 {\n            if isPrime(length) {\n\
    \                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 20 {\n            if isPrime(length) {\n    \
    \            result += \" \" + word\n            }\n            continue\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp1uuuvp0_test.go:23:14: undefined: strings

    /tmp/tmpp1uuuvp0_test.go:31:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:37:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:43:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:49:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:55:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:61:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:67:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:73:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:79:16: undefined: isPrime

    /tmp/tmpp1uuuvp0_test.go:79:16: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result = result + \" \" + word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3iqcweo_test.go:23:14: undefined: strings

    /tmp/tmph3iqcweo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0la4x8l_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    // write\
    \ your code here\n    words := strings.Split(sentence, \" \")\n    result := \"\
    \"\n    for _, word := range words {\n        length := len(word)\n        if\
    \ length%2 != 0 {\n            continue\n        }\n        result += \"\\n\"\
    \ + word\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6xja9d0x_test.go:24:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        result += \"is\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefmef_gf_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"is\"\n            continue\n        }\n        result += \"is\
    \ not\"\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnkmuesy6_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073574
- exit_code: 1
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            if isPrime(length) {\n                result += \" \" + word\n  \
    \          }\n            continue\n        }\n        if length == 4 {\n    \
    \        if isPrime(length) {\n                result += \" \" + word\n      \
    \      }\n            continue\n        }\n        if length == 5 || length ==\
    \ 6 || length == 7 || length == 8 || length == 9 {\n            if isPrime(length)\
    \ {\n                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 10 || length == 11 || length == 12 || length\
    \ == 13 || length == 14 || length == 15 {\n            if isPrime(length) {\n\
    \                result += \" \" + word\n            }\n            continue\n\
    \        }\n        if length == 16 || length == 17 || length == 18 || length\
    \ == 19 || length == 20 || length == 21 || length == 22 || length == 23 || length\
    \ == 24 || length == 25 || length == 26 || length == 27 || length == 28 || length\
    \ == 29 || length == 30 || length == 31 || length == 32 || length == 33 || length\
    \ == 34 || length == 35 || length == 36 || length == 37 || length == 38 || length\
    \ == 39 || length == 40 || length == 41 || length == 42 || length == 43 || length\
    \ == 44 || length == 45 || length == 46 || length == 47 || length == 48 || length\
    \ == 49 || length == 50 || length == 51 || length == 52 || length == 53 || length\
    \ == 54 || length == 55 || length == 56 || length == 57 || length == 58 || length\
    \ == 59 || length == 60 || length == 61 || length == 62 || length == 63 || length\
    \ == 64 || length == 65 || length == 66 || length == 67 || length == 68 || length\
    \ == 69 || length == 70 || length == 71 || length == 72 || length == 73 || length\
    \ == 74 || length == 75 || length == 76 || length == 77 || length == 78 || length\
    \ == 79 || length == 80 || length == 81 || length == 82 || length == 83 || length\
    \ == 84 || length == 85 || length == 86 || length == 87 || length == 88 || length\
    \ == 89 || length == 90 || length == 91 || length == 92 || length == 93 || length\
    \ == 94 || length == 95 || length == 96 || length == 97 || length == 98 {\n  \
    \          if isPrime(length) {\n                result += \" \" + word\n    \
    \        }\n            continue\n        }\n        if length == 99 || length\
    \ == 100 {\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected:\
    \ \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"\
    go for\" },\n     { actual: candidate(\"there is no place available here\"), expected:\
    \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
    \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"\
    go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     {\
    \ actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpilz44dc8_test.go:62:6: expected ''('', found TestWords_In_Sentence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073573
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length == 0 {\n           \
    \ continue\n        }\n        if length == 1 || length == 2 || length == 3 {\n\
    \            result += word\n            continue\n        }\n        if length\
    \ == 4 {\n            result += word\n            continue\n        }\n      \
    \  if length == 5 || length == 6 || length == 7 || length == 8 || length == 9\
    \ {\n            result += word\n            continue\n        }\n        if length\
    \ == 10 || length == 15 || length == 20 || length == 25 || length == 30 || length\
    \ == 35 {\n            result += word\n            continue\n        }\n     \
    \   if length == 50 || length == 100 {\n            result += word\n         \
    \   continue\n        }\n        fmt.Println(\"length\", length, \"is too big\"\
    )\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n\
    \  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5uw2pi8h_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073574
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        if isPrime(word) {\n            result += \" \" + word\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T)\
    \ {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for\
    \ swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no\
    \ place available here\"), expected: \"there is no place\" },\n     { actual:\
    \ candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual:\
    \ candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"\
    here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"\
    is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwzyeut7_test.go:23:14: undefined: strings

    /tmp/tmpkwzyeut7_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
- exit_code: 2
  program: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a string representing a sentence,\n// the sentence contains\
    \ some words separated by a space,\n// and you have to return a string that contains\
    \ the words from the original sentence,\n// whose lengths are prime numbers,\n\
    // the order of the words in the new string should be the same as the original\
    \ one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"\
    is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output:\
    \ \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains\
    \ only letters\nfunc words_in_sentence(sentence string) string {\n    words :=\
    \ strings.Split(sentence, \" \")\n    result := \"\"\n    for _, word := range\
    \ words {\n        length := len(word)\n        if length%2 == 0 {\n         \
    \   result += \"\\n\" + word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t\
    \ *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual:\
    \ candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual:\
    \ candidate(\"there is no place available here\"), expected: \"there is no place\"\
    \ },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\"\
    \ },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n  \
    \   { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"\
    here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bfwxsp0_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073571
